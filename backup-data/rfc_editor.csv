reference,text
RFC9260,"



RFC 9260
Stream Control Transmission Protocol
June 2022


Stewart, et al.
Standards Track
[Page]


Status:Proposed StandardObsoletes:4460, 4960, 6096, 7053, 8540More info:Datatracker | IPR | Info page


Stream:
Internet Engineering Task Force (IETF)
RFC:
9260
Obsoletes:

4460, 4960, 6096, 7053, 8540 
Category:
Standards Track
Published:

June 2022

ISSN:
2070-1721
Authors:


R. Stewart
Netflix, Inc.


M. Tüxen
Münster Univ. of Appl. Sciences


K. Nielsen
Kamstrup A/S




RFC 9260
Stream Control Transmission Protocol

Abstract
This document describes the Stream Control Transmission Protocol (SCTP) and obsoletes RFC 4960.  It incorporates the specification of the chunk flags registry from RFC 6096 and the
specification of the I bit of DATA chunks from RFC 7053.
Therefore, RFCs 6096 and 7053 are also obsoleted by this document.
In addition, RFCs 4460 and 8540, which describe errata for SCTP, are obsoleted by this document.¶
SCTP was originally designed to transport Public Switched Telephone
Network (PSTN) signaling messages over IP networks.
It is also suited to be used for other applications, for example, WebRTC.¶
SCTP is a reliable transport protocol operating on top of a
connectionless packet network, such as IP.
It offers the following services to its users:¶


acknowledged error-free, non-duplicated transfer of user data,¶


data fragmentation to conform to discovered Path Maximum Transmission Unit (PMTU) size,¶


sequenced delivery of user messages within multiple streams, with
an option for order-of-arrival delivery of individual user messages,¶


optional bundling of multiple user messages into a single SCTP packet, and¶


network-level fault tolerance through supporting of multi-homing
at either or both ends of an association.¶


The design of SCTP includes appropriate congestion avoidance behavior
and resistance to flooding and masquerade attacks.¶




Status of This Memo


            This is an Internet Standards Track document.¶

            This document is a product of the Internet Engineering Task Force
            (IETF).  It represents the consensus of the IETF community.  It has
            received public review and has been approved for publication by
            the Internet Engineering Steering Group (IESG).  Further
            information on Internet Standards is available in Section 2 of 
            RFC 7841.¶

            Information about the current status of this document, any
            errata, and how to provide feedback on it may be obtained at
            https://www.rfc-editor.org/info/rfc9260.¶





Copyright Notice


            Copyright (c) 2022 IETF Trust and the persons identified as the
            document authors. All rights reserved.¶

            This document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (https://trustee.ietf.org/license-info) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document. Code Components extracted from this
            document must include Revised BSD License text as described in
            Section 4.e of the Trust Legal Provisions and are provided without
            warranty as described in the Revised BSD License.¶

            This document may contain material from IETF Documents or IETF
            Contributions published or made publicly available before November
            10, 2008. The person(s) controlling the copyright in some of this
            material may not have granted the IETF Trust the right to allow
            modifications of such material outside the IETF Standards Process.
            Without obtaining an adequate license from the person(s)
            controlling the copyright in such materials, this document may not
            be modified outside the IETF Standards Process, and derivative
            works of it may not be created outside the IETF Standards Process,
            except to format it for publication as an RFC or to translate it
            into languages other than English.¶




▲
Table of Contents



1.  Introduction


1.1.  Motivation


1.2.  Architectural View of SCTP


1.3.  Key Terms


1.4.  Abbreviations


1.5.  Functional View of SCTP


1.5.1.  Association Startup and Takedown


1.5.2.  Sequenced Delivery within Streams


1.5.3.  User Data Fragmentation


1.5.4.  Acknowledgement and Congestion Avoidance


1.5.5.  Chunk Bundling


1.5.6.  Packet Validation


1.5.7.  Path Management




1.6.  Serial Number Arithmetic


1.7.  Changes from RFC 4960




2.  Conventions


3.  SCTP Packet Format


3.1.  SCTP Common Header Field Descriptions


3.2.  Chunk Field Descriptions


3.2.1.  Optional/Variable-Length Parameter Format


3.2.2.  Reporting of Unrecognized Parameters




3.3.  SCTP Chunk Definitions


3.3.1.  Payload Data (DATA) (0)


3.3.2.  Initiation (INIT) (1)


3.3.2.1.  Optional or Variable-Length Parameters in INIT chunks




3.3.3.  Initiation Acknowledgement (INIT ACK) (2)


3.3.3.1.  Optional or Variable-Length Parameters in INIT ACK Chunks




3.3.4.  Selective Acknowledgement (SACK) (3)


3.3.5.  Heartbeat Request (HEARTBEAT) (4)


3.3.6.  Heartbeat Acknowledgement (HEARTBEAT ACK) (5)


3.3.7.  Abort Association (ABORT) (6)


3.3.8.  Shutdown Association (SHUTDOWN) (7)


3.3.9.  Shutdown Acknowledgement (SHUTDOWN ACK) (8)


3.3.10. Operation Error (ERROR) (9)


3.3.10.1.  Invalid Stream Identifier (1)


3.3.10.2.  Missing Mandatory Parameter (2)


3.3.10.3.  Stale Cookie (3)


3.3.10.4.  Out of Resource (4)


3.3.10.5.  Unresolvable Address (5)


3.3.10.6.  Unrecognized Chunk Type (6)


3.3.10.7.  Invalid Mandatory Parameter (7)


3.3.10.8.  Unrecognized Parameters (8)


3.3.10.9.  No User Data (9)


3.3.10.10. Cookie Received While Shutting Down (10)


3.3.10.11. Restart of an Association with New Addresses (11)


3.3.10.12. User-Initiated Abort (12)


3.3.10.13. Protocol Violation (13)




3.3.11. Cookie Echo (COOKIE ECHO) (10)


3.3.12. Cookie Acknowledgement (COOKIE ACK) (11)


3.3.13. Shutdown Complete (SHUTDOWN COMPLETE) (14)






4.  SCTP Association State Diagram


5.  Association Initialization


5.1.  Normal Establishment of an Association


5.1.1.  Handle Stream Parameters


5.1.2.  Handle Address Parameters


5.1.3.  Generating State Cookie


5.1.4.  State Cookie Processing


5.1.5.  State Cookie Authentication


5.1.6.  An Example of Normal Association Establishment




5.2.  Handle Duplicate or Unexpected INIT, INIT ACK, COOKIE ECHO, and COOKIE ACK Chunks


5.2.1.  INIT Chunk Received in COOKIE-WAIT or COOKIE-ECHOED State (Item B)


5.2.2.  Unexpected INIT Chunk in States Other than CLOSED, COOKIE-ECHOED, COOKIE-WAIT, and SHUTDOWN-ACK-SENT


5.2.3.  Unexpected INIT ACK Chunk


5.2.4.  Handle a COOKIE ECHO Chunk When a TCB Exists


5.2.4.1.  An Example of an Association Restart




5.2.5.  Handle Duplicate COOKIE ACK Chunk


5.2.6.  Handle Stale Cookie Error




5.3.  Other Initialization Issues


5.3.1.  Selection of Tag Value




5.4.  Path Verification




6.  User Data Transfer


6.1.  Transmission of DATA Chunks


6.2.  Acknowledgement on Reception of DATA Chunks


6.2.1.  Processing a Received SACK Chunk




6.3.  Management of Retransmission Timer


6.3.1.  RTO Calculation


6.3.2.  Retransmission Timer Rules


6.3.3.  Handle T3-rtx Expiration




6.4.  Multi-Homed SCTP Endpoints


6.4.1.  Failover from an Inactive Destination Address




6.5.  Stream Identifier and Stream Sequence Number


6.6.  Ordered and Unordered Delivery


6.7.  Report Gaps in Received DATA TSNs


6.8.  CRC32c Checksum Calculation


6.9.  Fragmentation and Reassembly


6.10. Bundling




7.  Congestion Control


7.1.  SCTP Differences from TCP Congestion Control


7.2.  SCTP Slow-Start and Congestion Avoidance


7.2.1.  Slow-Start


7.2.2.  Congestion Avoidance


7.2.3.  Congestion Control


7.2.4.  Fast Retransmit on Gap Reports


7.2.5.  Reinitialization


7.2.5.1.  Change of Differentiated Services Code Points


7.2.5.2.  Change of Routes






7.3.  PMTU Discovery




8.  Fault Management


8.1.  Endpoint Failure Detection


8.2.  Path Failure Detection


8.3.  Path Heartbeat


8.4.  Handle ""Out of the Blue"" Packets


8.5.  Verification Tag


8.5.1.  Exceptions in Verification Tag Rules






9.  Termination of Association


9.1.  Abort of an Association


9.2.  Shutdown of an Association




10. ICMP Handling


11. Interface with Upper Layer


11.1.  ULP-to-SCTP


11.1.1.  Initialize


11.1.2.  Associate


11.1.3.  Shutdown


11.1.4.  Abort


11.1.5.  Send


11.1.6.  Set Primary


11.1.7.  Receive


11.1.8.  Status


11.1.9.  Change Heartbeat


11.1.10. Request Heartbeat


11.1.11. Get SRTT Report


11.1.12. Set Failure Threshold


11.1.13. Set Protocol Parameters


11.1.14. Receive Unsent Message


11.1.15. Receive Unacknowledged Message


11.1.16. Destroy SCTP Instance




11.2.  SCTP-to-ULP


11.2.1.  DATA ARRIVE Notification


11.2.2.  SEND FAILURE Notification


11.2.3.  NETWORK STATUS CHANGE Notification


11.2.4.  COMMUNICATION UP Notification


11.2.5.  COMMUNICATION LOST Notification


11.2.6.  COMMUNICATION ERROR Notification


11.2.7.  RESTART Notification


11.2.8.  SHUTDOWN COMPLETE Notification






12. Security Considerations


12.1.  Security Objectives


12.2.  SCTP Responses to Potential Threats


12.2.1.  Countering Insider Attacks


12.2.2.  Protecting against Data Corruption in the Network


12.2.3.  Protecting Confidentiality


12.2.4.  Protecting against Blind Denial-of-Service Attacks


12.2.4.1.  Flooding


12.2.4.2.  Blind Masquerade


12.2.4.3.  Improper Monopolization of Services






12.3.  SCTP Interactions with Firewalls


12.4.  Protection of Non-SCTP-capable Hosts




13. Network Management Considerations


14. Recommended Transmission Control Block (TCB) Parameters


14.1.  Parameters Necessary for the SCTP Instance


14.2.  Parameters Necessary per Association (i.e., the TCB)


14.3.  Per Transport Address Data


14.4.  General Parameters Needed




15. IANA Considerations


15.1.  IETF-Defined Chunk Extension


15.2.  IETF-Defined Chunk Flags Registration


15.3.  IETF-Defined Chunk Parameter Extension


15.4.  IETF-Defined Additional Error Causes


15.5.  Payload Protocol Identifiers


15.6.  Port Numbers Registry




16. Suggested SCTP Protocol Parameter Values


17. References


17.1.  Normative References


17.2.  Informative References




Appendix A.  CRC32c Checksum Calculation


Acknowledgements


Authors' Addresses







1. Introduction

This section explains the reasoning behind the development of the
Stream Control Transmission Protocol (SCTP), the services it offers,
and the basic concepts needed to understand the detailed description
of the protocol.¶
This document obsoletes [RFC4960].
In addition to that, it incorporates the specification of the chunk flags
registry from [RFC6096] and the specification of the I bit of
DATA chunks from [RFC7053].
Therefore, [RFC6096] and [RFC7053] are also
obsoleted by this document.¶


1.1. Motivation

TCP [RFC0793] has performed immense service as the primary
means of reliable data transfer in IP networks.
However, an increasing number of recent applications have found TCP too
limiting and have incorporated their own reliable data transfer protocol
on top of UDP [RFC0768].
The limitations that users have wished to bypass include the following:¶


TCP provides both reliable data transfer and strict
order-of-transmission delivery of data.
Some applications need reliable transfer without sequence maintenance,
while others would be satisfied with partial ordering of the data.
In both of these cases, the head-of-line blocking offered by TCP causes
unnecessary delay.¶


The stream-oriented nature of TCP is often an inconvenience.
Applications add their own record marking to delineate their
messages and make explicit use of the push facility to
ensure that a complete message is transferred in a reasonable
time.¶


The limited scope of TCP sockets complicates the task of providing
highly available data transfer capability using multi-homed hosts.¶


TCP is relatively vulnerable to denial-of-service attacks, such
as SYN attacks.¶


Transport of PSTN signaling across the IP network is an application
for which all of these limitations of TCP are relevant.
While this application directly motivated the development of SCTP, other
applications might find SCTP a good match to their requirements.
One example of this is the use of data channels in the WebRTC infrastructure.¶



1.2. Architectural View of SCTP

SCTP is viewed as a layer between the SCTP user application (""SCTP
user"" for short) and a connectionless packet network service, such as
IP.
The remainder of this document assumes SCTP runs on top of IP.
The basic service offered by SCTP is the reliable transfer of user
messages between peer SCTP users.
It performs this service within the context of an association between
two SCTP endpoints.
Section 11 of this document sketches the API that exists
at the boundary between SCTP and the SCTP upper layers.¶
SCTP is connection oriented in nature, but the SCTP association is a
broader concept than the TCP connection.
SCTP provides the means for each SCTP endpoint (Section 1.3)
to provide the other endpoint (during association startup) with a list of
transport addresses (i.e., multiple IP addresses in combination with an SCTP
port) through which that endpoint can be reached and from which it will
originate SCTP packets.
The association spans transfers over all of the possible source/destination
combinations that can be generated from each endpoint's lists.¶



 _____________                                      _____________
|  SCTP User  |                                    |  SCTP User  |
| Application |                                    | Application |
|-------------|                                    |-------------|
|    SCTP     |                                    |    SCTP     |
|  Transport  |                                    |  Transport  |
|   Service   |                                    |   Service   |
|-------------|                                    |-------------|
|             |One or more    ----      One or more|             |
| IP Network  |IP address      \/        IP address| IP Network  |
|   Service   |appearances     /\       appearances|   Service   |
|_____________|               ----                 |_____________|

  SCTP Node A |<-------- Network transport ------->| SCTP Node B



Figure 1:
An SCTP Association


In addition to encapsulating SCTP packets in IPv4 or IPv6, it is also possible
to encapsulate SCTP packets in UDP as specified in [RFC6951]
or encapsulate them in DTLS as specified in [RFC8261].¶




1.3. Key Terms

Some of the language used to describe SCTP has been introduced in the
previous sections. This section provides a consolidated list of the
key terms and their definitions.¶

Active Destination Transport Address:
A transport address on a peer endpoint that a transmitting endpoint considers
available for receiving user messages.¶


Association Maximum DATA Chunk Size (AMDCS):
The smallest Path Maximum DATA Chunk Size (PMDCS) of all destination
addresses.¶


Bundling of Chunks:
An optional multiplexing operation, whereby more than one chunk can
be carried in the same SCTP packet.¶


Bundling of User Messages:
An optional multiplexing operation, whereby more than one user message can
be carried in the same SCTP packet. Each user message occupies its own DATA chunk.¶


Chunk:
A unit of information within an SCTP packet, consisting of a chunk header
and chunk-specific content.¶


Congestion Window (cwnd):
An SCTP variable that limits outstanding data, in number of bytes,
that a sender can send to a particular destination transport address before
receiving an acknowledgement.¶


Control Chunk:
A chunk not being used for transmitting user data, i.e., every chunk that
is not a DATA chunk.¶


Cumulative TSN Ack Point:
The Transmission Sequence Number (TSN) of the last DATA chunk acknowledged via
the Cumulative TSN Ack field of a SACK chunk.¶


Flightsize:
The number of bytes of outstanding data to a particular destination transport
address at any given time.¶


Idle Destination Address:
An address that has not had user messages sent to it within some length
of time, normally the 'HB.interval' or greater.¶


Inactive Destination Transport Address:
An address that is considered inactive due to errors and unavailable to
transport user messages.¶


Message (or User Message):
Data submitted to SCTP by the Upper-Layer Protocol (ULP).¶


Network Byte Order:
Most significant byte first, a.k.a., big endian.¶


Ordered Message:
A user message that is delivered in order with respect to all previous user
messages sent within the stream on which the message was sent.¶


Outstanding Data (or Data Outstanding or Data In Flight):
The total size of the DATA chunks associated with outstanding TSNs.
A retransmitted DATA chunk is counted once in outstanding data.
A DATA chunk that is classified as lost but that has not yet been
retransmitted is not in outstanding data.¶


Outstanding TSN (at an SCTP Endpoint):
A TSN (and the associated DATA chunk) that has been sent by the endpoint
but for which it has not yet received an acknowledgement.¶


""Out of the Blue"" (OOTB) Packet:
A correctly formed packet, for which the receiver cannot identify the
association it belongs to. See Section 8.4.¶


Path:
The route taken by the SCTP packets sent by one SCTP endpoint to a specific
destination transport address of its peer SCTP endpoint.
Sending to different destination transport addresses does not necessarily
guarantee getting separate paths.
Within this specification, a path is identified by the destination transport
address, since the routing is assumed to be stable.
This includes, in particular, the source address being selected when sending
packets to the destination address.¶


Path Maximum DATA Chunk Size (PMDCS):
The maximum size (including the DATA chunk header) of a DATA chunk that fits
into an SCTP packet not exceeding the PMTU of a particular destination address.¶


Path Maximum Transmission Unit (PMTU):
The maximum size (including the SCTP common header and all chunks including
their paddings) of an SCTP packet that can be sent to a particular
destination address without using IP-level fragmentation.¶


Primary Path:
The destination and source address that will be put into
a packet outbound to the peer endpoint by default.
The definition includes the source address since an implementation MAY wish
to specify both destination and source address to better control the return
path taken by reply chunks and on which interface the packet is transmitted
when the data sender is multi-homed.¶


Receiver Window (rwnd):
An SCTP variable a data sender uses to store the most recently calculated
receiver window of its peer, in number of bytes.
This gives the sender an indication of the space available in the receiver's
inbound buffer.¶


SCTP Association:
A protocol relationship between SCTP endpoints, composed of the two SCTP
endpoints and protocol state information, including Verification Tags and the
currently active set of Transmission Sequence Numbers (TSNs), etc.
An association can be uniquely identified by the transport addresses used by the
endpoints in the association.
Two SCTP endpoints MUST NOT have more than one SCTP association between
them at any given time.¶


SCTP Endpoint:
The logical sender/receiver of SCTP packets.
On a multi-homed host, an SCTP endpoint is represented to its peers as
a combination of a set of eligible destination transport addresses
to which SCTP packets can be sent and a set of eligible source
transport addresses from which SCTP packets can be received.
All transport addresses used by an SCTP endpoint MUST use the same
port number but can use multiple IP addresses.
A transport address used by an SCTP endpoint MUST NOT be used by another SCTP
endpoint.
In other words, a transport address is unique to an SCTP endpoint.¶


SCTP Packet (or Packet):
The unit of data delivery across the interface between SCTP and the
connectionless packet network (e.g., IP).
An SCTP packet includes the common SCTP header, possible SCTP control chunks,
and user data encapsulated within SCTP DATA chunks.¶


SCTP User Application (or SCTP User):
The logical higher-layer application entity that uses the services of SCTP,
also called the Upper-Layer Protocol (ULP).¶


Slow-Start Threshold (ssthresh):
An SCTP variable.
This is the threshold that the endpoint will use to determine whether to
perform slow-start or congestion avoidance on a particular destination
transport address. Ssthresh is in number of bytes.¶


State Cookie:
A container of all information needed to establish an association.¶


Stream:

A unidirectional logical channel established from one to
another associated SCTP endpoint, within which all user messages
are delivered in sequence, except for those submitted to the
unordered delivery service.¶
Note: The relationship between stream numbers in opposite directions
is strictly a matter of how the applications use them. It is the
responsibility of the SCTP user to create and manage these
correlations if they are so desired.¶


Stream Sequence Number:
A 16-bit sequence number used internally by SCTP to ensure sequenced delivery
of the user messages within a given stream.
One Stream Sequence Number is attached to each ordered user message.¶


Tie-Tags:
Two 32-bit random numbers that together make a 64-bit nonce.
These tags are used within a State Cookie and TCB so that a newly restarting
association can be linked to the original association within the endpoint
that did not restart and yet not reveal the true Verification Tags of an
existing association.¶


Transmission Control Block (TCB):
An internal data structure created by an SCTP endpoint for each of its
existing SCTP associations to other SCTP endpoints.
TCB contains all the status and operational information for the endpoint
to maintain and manage the corresponding association.¶


Transmission Sequence Number (TSN):
A 32-bit sequence number used internally by SCTP.
One TSN is attached to each chunk containing user data to permit the
receiving SCTP endpoint to acknowledge its receipt and detect duplicate
deliveries.¶


Transport Address:
A transport address is typically defined by a network-layer address,
a transport-layer protocol, and a transport-layer port number.
In the case of SCTP running over IP, a transport address is defined by
the combination of an IP address and an SCTP port number (where SCTP is the
transport protocol).¶


Unordered Message:
Unordered messages are ""unordered"" with respect to any other message;
this includes both other unordered messages as well as other ordered messages.
An unordered message might be delivered prior to or later than ordered messages
sent on the same stream.¶


User Message:
The unit of data delivery across the interface between SCTP and its user.¶


Verification Tag:
A 32-bit unsigned integer that is randomly generated.
The Verification Tag provides a key that allows a receiver to verify that the
SCTP packet belongs to the current association and is not an old or stale
packet from a previous association.¶







1.4. Abbreviations


MAC
Message Authentication Code [RFC2104]¶


RTO
Retransmission Timeout¶


RTT
Round-Trip Time¶


RTTVAR
Round-Trip Time Variation¶


SCTP
Stream Control Transmission Protocol¶


SRTT
Smoothed RTT¶


TCB
Transmission Control Block¶


TLV
Type-Length-Value coding format¶


TSN
Transmission Sequence Number¶


ULP
Upper-Layer Protocol¶






1.5. Functional View of SCTP

The SCTP transport service can be decomposed into a number of functions.
These are depicted in Figure 2 and explained
in the remainder of this section.¶



                SCTP User Application

-----------------------------------------------------
 _____________                  ____________________
|             |                | Sequenced Delivery |
| Association |                |   within Streams   |
|             |                |____________________|
|   Startup   |
|             |         ____________________________
|     and     |        |  User Data Fragmentation   |
|             |        |____________________________|
|  Takedown   |
|             |         ____________________________
|             |        |      Acknowledgement       |
|             |        |            and             |
|             |        |    Congestion Avoidance    |
|             |        |____________________________|
|             |
|             |         ____________________________
|             |        |       Chunk Bundling       |
|             |        |____________________________|
|             |
|             |     ________________________________
|             |    |       Packet Validation        |
|             |    |________________________________|
|             |
|             |     ________________________________
|             |    |        Path Management         |
|_____________|    |________________________________|



Figure 2:
Functional View of the SCTP Transport Service




1.5.1. Association Startup and Takedown

An association is initiated by a request from the SCTP user (see the
description of the ASSOCIATE (or SEND) primitive in Section 11).¶
A cookie mechanism, similar to one described by Karn and Simpson in
[RFC2522], is employed during the initialization to provide
protection against synchronization attacks.
The cookie mechanism uses a four-way handshake, the last two legs of which
are allowed to carry user data for fast setup.
The startup sequence is described in Section 5
of this document.¶
SCTP provides for graceful close (i.e., shutdown) of an active
association on request from the SCTP user.
See the description of the SHUTDOWN primitive in Section 11.
SCTP also allows ungraceful close (i.e., abort), either on request from the
user (ABORT primitive) or as a result of an error condition detected within
the SCTP layer.
Section 9 describes both the graceful and the
ungraceful close procedures.¶
SCTP does not support a half-open state (like TCP) wherein one side
continues sending data while the other end is closed.
When either endpoint performs a shutdown, the association on each peer will
stop accepting new data from its user and only deliver data in queue at
the time of the graceful close (see Section 9).¶



1.5.2. Sequenced Delivery within Streams

The term ""stream"" is used in SCTP to refer to a sequence of user
messages that are to be delivered to the upper-layer protocol in
order with respect to other messages within the same stream.
This is in contrast to its usage in TCP, where it refers to a sequence of
bytes (in this document, a byte is assumed to be 8 bits).¶
At association startup time, the SCTP user can specify the number of
streams to be supported by the association.
This number is negotiated with the remote end
(see Section 5.1.1).
User messages are associated with stream numbers (SEND, RECEIVE primitives;
Section 11).
Internally, SCTP assigns a Stream Sequence Number to each message passed to
it by the SCTP user.
On the receiving side, SCTP ensures that messages are delivered to the SCTP
user in sequence within a given stream.
However, while one stream might be blocked waiting for the next in-sequence
user message, delivery from other streams might proceed.¶
SCTP provides a mechanism for bypassing the sequenced delivery
service.
User messages sent using this mechanism are delivered to the SCTP user as
soon as they are received.¶



1.5.3. User Data Fragmentation

When needed, SCTP fragments user messages to ensure that the size of the SCTP
packet passed to the lower layer does not exceed the PMTU.
Once a user message has been fragmented, this fragmentation cannot be changed
anymore.
On receipt, fragments are reassembled into complete messages before
being passed to the SCTP user.¶



1.5.4. Acknowledgement and Congestion Avoidance

SCTP assigns a Transmission Sequence Number (TSN) to each user data
fragment or unfragmented message.
The TSN is independent of any Stream Sequence Number assigned at the
stream level.
The receiving end acknowledges all TSNs received, even if there are gaps in the
sequence.
If a user data fragment or unfragmented message needs to be retransmitted,
the TSN assigned to it is used.
In this way, reliable delivery is kept functionally separate from sequenced
stream delivery.¶
The acknowledgement and congestion avoidance function is responsible
for packet retransmission when timely acknowledgement has not been
received.
Packet retransmission is conditioned by congestion avoidance procedures
similar to those used for TCP. See Sections 6 and
7 for detailed descriptions of the
protocol procedures associated with this function.¶



1.5.5. Chunk Bundling

As described in Section 3, the SCTP packet
as delivered to the lower layer consists of a common header followed by one
or more chunks.
Each chunk contains either user data or SCTP control information.
An SCTP implementation supporting bundling on the sender side might
delay the sending of user messages to allow the corresponding DATA
chunks to be bundled.¶
The SCTP user has the option to request that an SCTP implementation does not
delay the sending of a user message just for this purpose.
However, even if the SCTP user has chosen this option, the SCTP implementation
might delay the sending due to other reasons (for example, due to congestion
control or flow control) and might also bundle multiple DATA chunks, if
possible.¶



1.5.6. Packet Validation

A mandatory Verification Tag field and a 32-bit checksum field (see
Appendix A for a description of the 32-bit Cyclic Redundancy Check (CRC32c) checksum)
are included in the SCTP common header.
The Verification Tag value is chosen by each end of the association during
association startup.
Packets received without the expected Verification Tag value are discarded,
as a protection against blind masquerade attacks and against stale SCTP
packets from a previous association.
The CRC32c checksum is set by the sender of each SCTP packet to
provide additional protection against data corruption in the network.
The receiver of an SCTP packet with an invalid CRC32c checksum silently
discards the packet.¶



1.5.7. Path Management

The sending SCTP user is able to manipulate the set of transport
addresses used as destinations for SCTP packets through the
primitives described in Section 11.
The SCTP path management function monitors reachability through heartbeats
when other packet traffic is inadequate to provide this information and advises
the SCTP user when reachability of any transport address of the peer endpoint
changes.
The path management function chooses the destination transport address
for each outgoing SCTP packet based on the SCTP user's instructions and the
currently perceived reachability status of the eligible destination set.
The path management function is also responsible for reporting the eligible
set of local transport addresses to the peer endpoint during association startup
and for reporting the transport addresses returned from the peer endpoint to the
SCTP user.¶
At association startup, a primary path is defined for each SCTP
endpoint and is used to send SCTP packets normally.¶
On the receiving end, the path management is responsible for
verifying the existence of a valid SCTP association to which the
inbound SCTP packet belongs before passing it for further processing.¶
Note: Path Management and Packet Validation are done at the same
time; although described separately above, in reality, they cannot
be performed as separate items.¶




1.6. Serial Number Arithmetic

It is essential to remember that the actual Transmission Sequence
Number space is finite, though very large.
This space ranges from 0 to 232 - 1.
Since the space is finite, all arithmetic dealing with Transmission Sequence
Numbers MUST be performed modulo 232.
This unsigned arithmetic preserves the relationship of sequence numbers as
they cycle from 232 - 1 to 0 again.
There are some subtleties to computer modulo arithmetic, so great care has to
be taken in programming the comparison of such values.
When referring to TSNs, the symbol ""<="" means
""less than or equal"" (modulo 232).¶
Comparisons and arithmetic on TSNs in this document SHOULD use Serial
Number Arithmetic, as defined in [RFC1982],
where SERIAL_BITS = 32.¶
An endpoint SHOULD NOT transmit a DATA chunk with a TSN that is more
than 231 - 1 above the beginning TSN of its current send window.
Doing so will cause problems in comparing TSNs.¶
Transmission Sequence Numbers wrap around when they reach 232 - 1.
That is, the next TSN a DATA chunk MUST use after transmitting TSN =
232 - 1 is TSN = 0.¶
Any arithmetic done on Stream Sequence Numbers SHOULD use Serial
Number Arithmetic, as defined in [RFC1982], where SERIAL_BITS = 16.
All other arithmetic and comparisons in this document use normal
arithmetic.¶



1.7. Changes from RFC 4960

SCTP was originally defined in [RFC4960], which this document
obsoletes.
Readers interested in the details of the various changes that this document
incorporates are asked to consult [RFC8540].¶
In addition to these and further editorial changes, the following changes
have been incorporated in this document:¶


Update references.¶


Improve the language related to requirements levels.¶


Allow the ASSOCIATE primitive to take multiple remote addresses;
       also refer to the socket API specification.¶


Refer to the Packetization Layer Path MTU Discovery (PLPMTUD) specification for path MTU discovery.¶


Move the description of ICMP handling from the Appendix to the main
       text.¶


Remove the Appendix describing Explicit Congestion Notification (ECN) handling from the document.¶


Describe the packet size handling more precisely by introducing PMTU,
       PMDCS, and AMDCS.¶


Add the definition of control chunk.¶


Improve the description of the handling of INIT and INIT ACK chunks with
       invalid mandatory parameters.¶


Allow using L > 1 for Appropriate Byte Counting (ABC) during
       slow start.¶


Explicitly describe the reinitialization of the congestion controller on
       route changes.¶


Improve the terminology to make it clear that this specification does not
       describe a full mesh architecture.¶


Improve the description of sequence number generation
       (Transmission Sequence Number and Stream Sequence Number).¶


Improve the description of reneging.¶


Don't require the change of the Cumulative TSN Ack anymore for increasing
       the congestion window.
       This improves the consistency with the handling in congestion
       avoidance.¶


Improve the description of the State Cookie.¶


Fix the API for retrieving messages in case of association failures.¶






2. Conventions

The key words ""MUST"", ""MUST NOT"", ""REQUIRED"", ""SHALL"", ""SHALL NOT"",
""SHOULD"", ""SHOULD NOT"", ""RECOMMENDED"", ""NOT RECOMMENDED"", ""MAY"", and
""OPTIONAL"" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when,
and only when, they appear in all capitals, as shown here.¶




3. SCTP Packet Format

An SCTP packet is composed of a common header and chunks.
A chunk contains either control information or user data.¶
The SCTP packet format is shown below:¶

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         Common Header                         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           Chunk #1                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           Chunk #n                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
¶

INIT, INIT ACK, and SHUTDOWN COMPLETE chunks MUST NOT be bundled
with any other chunk into an SCTP packet.
All other chunks MAY be bundled to form an SCTP packet that does not exceed
the PMTU.
See Section 6.10 for more details on chunk bundling.¶
If a user data message does not fit into one SCTP packet, it can be
fragmented into multiple chunks using the procedure defined in
Section 6.9.¶
All integer fields in an SCTP packet MUST be transmitted in network
byte order, unless otherwise stated.¶



3.1. SCTP Common Header Field Descriptions


 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|      Source Port Number       |    Destination Port Number    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       Verification Tag                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           Checksum                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
¶


Source Port Number: 16 bits (unsigned integer)
This is the SCTP sender's port number.
It can be used by the receiver in combination with the source IP address,
the SCTP Destination Port Number, and possibly the destination IP address to
identify the association to which this packet belongs.
The Source Port Number 0 MUST NOT be used.¶


Destination Port Number: 16 bits (unsigned integer)
This is the SCTP port number to which this packet is destined.
The receiving host will use this port number to de-multiplex the
SCTP packet to the correct receiving endpoint/application.
The Destination Port Number 0 MUST NOT be used.¶


Verification Tag: 32 bits (unsigned integer)

The receiver of an SCTP packet uses the Verification Tag to validate
the sender of this packet.
On transmit, the value of the Verification Tag MUST be set to the value of
the Initiate Tag received from the peer endpoint during the association
initialization, with the following exceptions:¶

A packet containing an INIT chunk MUST have a zero Verification Tag.¶

A packet containing a SHUTDOWN COMPLETE chunk with the T bit set MUST have
the Verification Tag copied from the packet with the SHUTDOWN ACK chunk.¶

A packet containing an ABORT chunk MAY have the Verification Tag copied
from the packet that caused the ABORT chunk to be sent.
For details, see Sections 8.4 and
8.5.¶




Checksum: 32 bits (unsigned integer)
This field contains the checksum of the SCTP packet.
Its calculation is discussed in
Section 6.8.
SCTP uses the CRC32c algorithm as described in Appendix A for
calculating the checksum.¶








3.2. Chunk Field Descriptions

The figure below illustrates the field format for the chunks to be
transmitted in the SCTP packet.
Each chunk is formatted with a Chunk Type field, a Chunk Flags field,
a Chunk Length field, and a Chunk Value field.¶

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Chunk Type   |  Chunk Flags  |         Chunk Length          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
\                                                               \
/                          Chunk Value                          /
\                                                               \
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
¶


Chunk Type: 8 bits (unsigned integer)

This field identifies the type of information contained in the Chunk Value
field. It takes a value from 0 to 254.
The value of 255 is reserved for future use as an extension field.¶
The values of Chunk Types defined in this document are as follows:¶


Table 1:
Chunk Types



ID Value
Chunk Type




0         
Payload Data (DATA)                                      


1         
Initiation (INIT)                                        


2         
Initiation Acknowledgement (INIT ACK)                    


3         
Selective Acknowledgement (SACK)                         


4         
Heartbeat Request (HEARTBEAT)                            


5         
Heartbeat Acknowledgement (HEARTBEAT ACK)                


6         
Abort (ABORT)                                            


7         
Shutdown (SHUTDOWN)                                      


8         
Shutdown Acknowledgement (SHUTDOWN ACK)                  


9         
Operation Error (ERROR)                                  


10        
State Cookie (COOKIE ECHO)                               


11        
Cookie Acknowledgement (COOKIE ACK)                      


12        
Reserved for Explicit Congestion Notification Echo (ECNE)


13        
Reserved for Congestion Window Reduced (CWR)             


14        
Shutdown Complete (SHUTDOWN COMPLETE)                    


15 to 62  
Unassigned                                                


63        
Reserved for IETF-defined Chunk Extensions               


64 to 126 
Unassigned                                                


127       
Reserved for IETF-defined Chunk Extensions               


128 to 190
Unassigned                                                


191       
Reserved for IETF-defined Chunk Extensions               


192 to 254
Unassigned                                                


255       
Reserved for IETF-defined Chunk Extensions               



Note: The ECNE and CWR chunk types are reserved for future use of Explicit
Congestion Notification (ECN).¶
Chunk Types are encoded such that the highest-order 2 bits specify the action
that is taken if the processing endpoint does not recognize the Chunk Type.¶


Table 2:
Processing of Unknown Chunks



00

Stop processing this SCTP packet and
                   discard the unrecognized chunk and all further chunks.¶



01

Stop processing this SCTP packet, discard the unrecognized
                   chunk and all further chunks, and report the unrecognized
                   chunk in an ERROR chunk using the 'Unrecognized Chunk Type'
                   error cause.¶



10

Skip this chunk and continue processing.¶



11

Skip this chunk and continue processing, but report it in
                   an ERROR chunk using the 'Unrecognized Chunk Type' error
                   cause.¶






Chunk Flags: 8 bits

The usage of these bits depends on the Chunk Type, as given by the Chunk Type
field.
Unless otherwise specified, they are set to 0 on transmit and are ignored
on receipt.¶


Chunk Length: 16 bits (unsigned integer)

This value represents the size of the chunk in bytes, including the Chunk Type,
Chunk Flags, Chunk Length, and Chunk Value fields.
Therefore, if the Chunk Value field is zero-length, the Length field will be
set to 4.
The Chunk Length field does not count any chunk padding.
However, it does include any padding of variable-length parameters other than
the last parameter in the chunk.¶
Note: A robust implementation is expected to accept the chunk whether or not
the final padding has been included in the Chunk Length.¶


Chunk Value: variable length

The Chunk Value field contains the actual information to be transferred in the
chunk.
The usage and format of this field is dependent on the Chunk Type.¶



The total length of a chunk (including Type, Length, and Value fields) MUST
be a multiple of 4 bytes.
If the length of the chunk is not a multiple of 4 bytes, the sender MUST pad
the chunk with all zero bytes, and this padding is not included in the
Chunk Length field.
The sender MUST NOT pad with more than 3 bytes.
The receiver MUST ignore the padding bytes.¶
SCTP-defined chunks are described in detail in
Section 3.3.
The guidelines for IETF-defined chunk extensions can be found in
Section 15.1 of this document.¶



3.2.1. Optional/Variable-Length Parameter Format

Chunk values of SCTP control chunks consist of a chunk-type-specific
header of required fields, followed by zero or more parameters.
The optional and variable-length parameters contained in a chunk are
defined in a Type-Length-Value format, as shown below.¶

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|        Parameter Type         |       Parameter Length        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
\                                                               \
/                        Parameter Value                        /
\                                                               \
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
¶


Parameter Type: 16 bits (unsigned integer)

The Type field is a 16-bit identifier of the type of parameter.
It takes a value of 0 to 65534.¶
The value of 65535 is reserved for IETF-defined extensions.
Values other than those defined in specific SCTP chunk descriptions are
reserved for use by IETF.¶


Parameter Length: 16 bits (unsigned integer)
The Parameter Length field contains the size of the parameter in
bytes, including the Parameter Type, Parameter Length, and Parameter Value
fields. Thus, a parameter with a zero-length Parameter Value field would have a
Parameter Length field of 4.
The Parameter Length does not include any padding bytes.¶


Parameter Value: variable length

The Parameter Value field contains the actual information to be transferred in
the parameter.¶



The total length of a parameter (including Parameter Type, Parameter Length,
and Parameter Value fields) MUST be a multiple of 4 bytes.
If the length of the parameter is not a multiple of 4 bytes, the sender pads the
parameter at the end (i.e., after the Parameter Value field) with all zero
bytes.
The length of the padding is not included in the Parameter Length field.
A sender MUST NOT pad with more than 3 bytes.
The receiver MUST ignore the padding bytes.¶
The Parameter Types are encoded such that the highest-order 2 bits specify the
action that is taken if the processing endpoint does not recognize the
Parameter Type.¶


Table 3:
Processing of Unknown Parameters



00

Stop processing this parameter and do not process any
                   further parameters within this chunk.¶



01

Stop processing this parameter, do not process any
                   further parameters within this chunk, and report the
                   unrecognized parameter, as described in
                   Section 3.2.2.¶



10

Skip this parameter and continue processing.¶



11

Skip this parameter and continue processing, but report
                   the unrecognized parameter, as described in
                   Section 3.2.2.¶




Please note that, when an INIT or INIT ACK chunk is received, in all
four cases, an INIT ACK or COOKIE ECHO chunk is sent in response, respectively.
In the 00 or 01 case, the processing of the parameters after the unknown
parameter is canceled, but no processing already done is rolled back.¶
The actual SCTP parameters are defined in the specific SCTP chunk sections.
The rules for IETF-defined parameter extensions are defined in
Section 15.3.
Parameter types MUST be unique across all chunks.
For example, the parameter type '5' is used to represent an IPv4 address
(see Section 3.3.2.1.1).
The value '5' then is reserved across all chunks to represent an IPv4 address
and MUST NOT be reused with a different meaning in any other chunk.¶





3.2.2. Reporting of Unrecognized Parameters

If the receiver of an INIT chunk detects unrecognized parameters and
has to report them according to Section 3.2.1,
it MUST put the ""Unrecognized Parameter"" parameter(s) in the INIT ACK chunk
sent in response to the INIT chunk.
Note that, if the receiver of the INIT chunk is not going to establish an
association (e.g., due to lack of resources), an ""Unrecognized Parameters""
error cause would not be included with any ABORT chunk being sent to the sender
of the INIT chunk.¶
If the receiver of any other chunk (e.g., INIT ACK) detects unrecognized
parameters and has to report them according to
Section 3.2.1, it SHOULD bundle the ERROR chunk
containing the ""Unrecognized Parameters"" error cause with the chunk sent
in response (e.g., COOKIE ECHO).
If the receiver of an INIT ACK chunk cannot bundle the COOKIE ECHO chunk with
the ERROR chunk, the ERROR chunk MAY be sent separately but not before the
COOKIE ACK chunk has been received.¶
Any time a COOKIE ECHO chunk is sent in a packet, it MUST be the first
chunk.¶







3.3. SCTP Chunk Definitions

This section defines the format of the different SCTP chunk types.¶



3.3.1. Payload Data (DATA) (0)

The following format MUST be used for the DATA chunk:¶

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Type = 0    |  Res  |I|U|B|E|            Length             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                              TSN                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|      Stream Identifier S      |   Stream Sequence Number n    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                  Payload Protocol Identifier                  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
\                                                               \
/                 User Data (seq n of Stream S)                 /
\                                                               \
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
¶


Res: 4 bits
All set to 0 on transmit and ignored on receipt.¶


I bit: 1 bit
The (I)mmediate bit MAY be set by the sender whenever the sender of a DATA
chunk can benefit from the corresponding SACK chunk being sent back without delay.
See Section 4 of [RFC7053] for a discussion of the benefits.¶


U bit: 1 bit

The (U)nordered bit, if set to 1, indicates that this is an unordered
DATA chunk, and there is no Stream Sequence Number assigned to this DATA chunk.
Therefore, the receiver MUST ignore the Stream Sequence Number field.¶
After reassembly (if necessary), unordered DATA chunks MUST be dispatched to
the upper layer by the receiver without any attempt to reorder.¶
If an unordered user message is fragmented, each fragment of the message MUST
have its U bit set to 1.¶


B bit: 1 bit
The (B)eginning fragment bit, if set, indicates the first fragment of a
user message.¶


E bit: 1 bit
The (E)nding fragment bit, if set, indicates the last fragment of
a user message.¶


Length: 16 bits (unsigned integer)

This field indicates the length of the DATA chunk in bytes from
the beginning of the type field to the end of the User Data field
excluding any padding.
A DATA chunk with one byte of user data will have the Length field set to 17
(indicating 17 bytes).¶
A DATA chunk with a User Data field of length L will have the Length field set
to (16 + L) (indicating 16 + L bytes) where L MUST be greater than 0.¶


TSN: 32 bits (unsigned integer)
This value represents the TSN for this DATA chunk.
The valid range of TSN is from 0 to 4294967295 (232 - 1).
TSN wraps back to 0 after reaching 4294967295.¶


Stream Identifier S: 16 bits (unsigned integer)
Identifies the stream to which the following user data belongs.¶


Stream Sequence Number n: 16 bits (unsigned integer)

This value represents the Stream Sequence Number of the following user data
within the stream S.
Valid range is 0 to 65535.¶
When a user message is fragmented by SCTP for transport, the same
Stream Sequence Number MUST be carried in each of the fragments of the message.¶


Payload Protocol Identifier: 32 bits (unsigned integer)

This value represents an application (or upper layer) specified protocol
identifier.
This value is passed to SCTP by its upper layer and sent to its peer.
This identifier is not used by SCTP but can be used by certain network entities,
as well as by the peer application, to identify the type of information being
carried in this DATA chunk.
This field MUST be sent even in fragmented DATA chunks (to make sure it is
available for agents in the middle of the network).
Note that this field is not touched by an SCTP implementation;
the upper layer is responsible for the host to network byte order conversion of
this field.¶
The value 0 indicates that no application identifier is specified by the upper
layer for this payload data.¶


User Data: variable length
This is the payload user data.
The implementation MUST pad the end of the data to a 4-byte boundary with
all zero bytes.
Any padding MUST NOT be included in the Length field.
A sender MUST never add more than 3 bytes of padding.¶



An unfragmented user message MUST have both the B and E bits set to 1.
Setting both B and E bits to 0 indicates a middle fragment of a multi-fragment
user message, as summarized in the following table:¶



Table 4:
Fragment Description Flags



B
E
Description




1
0
First piece of a fragmented user message


0
0
Middle piece of a fragmented user message


0
1
Last piece of a fragmented user message


1
1
Unfragmented message




When a user message is fragmented into multiple chunks, the TSNs are
used by the receiver to reassemble the message. This means that the
TSNs for each fragment of a fragmented user message MUST be strictly
sequential.¶
The TSNs of DATA chunks sent SHOULD be strictly sequential.¶
Note: The extension described in [RFC8260] can be used
to mitigate the head of line blocking when transferring large user messages.¶





3.3.2. Initiation (INIT) (1)

This chunk is used to initiate an SCTP association between two endpoints.
The format of the INIT chunk is shown below:¶

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Type = 1    |  Chunk Flags  |      Chunk Length             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         Initiate Tag                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          Advertised Receiver Window Credit (a_rwnd)           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Number of Outbound Streams   |   Number of Inbound Streams   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Initial TSN                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
\                                                               \
/              Optional/Variable-Length Parameters              /
\                                                               \
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
¶

The following parameters are specified for the INIT chunk.
Unless otherwise noted, each parameter MUST only be included once in the
INIT chunk.¶


Table 5:
Fixed-Length Parameters of INIT Chunks



Fixed-Length Parameter
Status




Initiate Tag
Mandatory


Advertised Receiver Window Credit
Mandatory


Number of Outbound Streams
Mandatory


Number of Inbound Streams
Mandatory


Initial TSN
Mandatory





Table 6:
Variable-Length Parameters of INIT Chunks



Variable-Length Parameter
Status
Type Value




IPv4 Address (Note 1)
Optional
5


IPv6 Address (Note 1)
Optional
6


Cookie Preservative
Optional
9


Reserved for ECN Capable (Note 2)
Optional
32768 (0x8000)


Host Name Address (Note 3)
Deprecated
11


Supported Address Types (Note 4)
Optional
12



Note 1:
The INIT chunks can contain multiple addresses that can be IPv4 and/or IPv6
in any combination.¶
Note 2:
The ECN Capable field is reserved for future use of Explicit Congestion
Notification.¶
Note 3:
An INIT chunk MUST NOT contain the Host Name Address parameter.
The receiver of an INIT chunk containing a Host Name Address parameter MUST
send an ABORT chunk and MAY include an ""Unresolvable Address"" error cause.¶
Note 4:
This parameter, when present, specifies all the address types the sending
endpoint can support.
The absence of this parameter indicates that the sending endpoint can support
any address type.¶
If an INIT chunk is received with all mandatory parameters that are
specified for the INIT chunk, then the receiver SHOULD process the INIT chunk
and send back an INIT ACK.
The receiver of the INIT chunk MAY bundle an ERROR chunk with the COOKIE ACK
chunk later.
However, restrictive implementations MAY send back an ABORT chunk in response
to the INIT chunk.¶
The Chunk Flags field in INIT chunks is reserved, and all bits in it SHOULD
be set to 0 by the sender and ignored by the receiver.¶

Initiate Tag: 32 bits (unsigned integer)

The receiver of the INIT chunk (the responding end) records the value of the
Initiate Tag parameter.
This value MUST be placed into the Verification Tag field of every SCTP packet
that the receiver of the INIT chunk transmits within this association.¶
The Initiate Tag is allowed to have any value except 0.
See Section 5.3.1 for more on the selection of
the tag value.¶
If the value of the Initiate Tag in a received INIT chunk is found to be 0,
the receiver MUST silently discard the packet.¶


Advertised Receiver Window Credit (a_rwnd): 32 bits (unsigned integer)

This value represents the dedicated buffer space, in number of bytes,
the sender of the INIT chunk has reserved in association with this window.¶
The Advertised Receiver Window Credit MUST NOT be smaller than 1500.¶
A receiver of an INIT chunk with the a_rwnd value set to a value smaller than
1500 MUST discard the packet, SHOULD send a packet in response containing
an ABORT chunk and using the Initiate Tag as the Verification Tag, and MUST NOT
change the state of any existing association.¶
During the life of the association, this buffer space SHOULD NOT be reduced
(i.e., dedicated buffers ought not to be taken away from this association);
however, an endpoint MAY change the value of a_rwnd it sends in SACK chunks.¶


Number of Outbound Streams (OS): 16 bits (unsigned integer)

Defines the number of outbound streams the sender of this INIT chunk wishes
to create in this association.
The value of 0 MUST NOT be used.¶
A receiver of an INIT chunk with the OS value set to 0 MUST discard the
packet, SHOULD send a packet in response containing an ABORT chunk and using
the Initiate Tag as the Verification Tag, and MUST NOT change the state of any
existing association.¶


Number of Inbound Streams (MIS): 16 bits (unsigned integer)

Defines the maximum number of streams the sender of this INIT chunk allows
the peer end to create in this association.
The value 0 MUST NOT be used.¶
Note: There is no negotiation of the actual number of streams; instead, the
two endpoints will use the min(requested, offered).
See Section 5.1.1 for details.¶
A receiver of an INIT chunk with the MIS value set to 0 MUST discard the
packet, SHOULD send a packet in response containing an ABORT chunk and using
the Initiate Tag as the Verification Tag, and MUST NOT change the state of any
existing association.¶


Initial TSN (I-TSN): 32 bits (unsigned integer)
Defines the TSN that the sender of the INIT chunk will use initially.
The valid range is from 0 to 4294967295 and the Initial TSN SHOULD be set to a
random value in that range.
The methods described in [RFC4086] can be used for the
Initial TSN randomization.¶






3.3.2.1. Optional or Variable-Length Parameters in INIT chunks

The following parameters follow the Type-Length-Value format as defined in
Section 3.2.1.
Any Type-Length-Value fields MUST be placed after the fixed-length fields.
(The fixed-length fields are defined in the previous section.)¶



3.3.2.1.1. IPv4 Address (5)


 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           Type = 5            |          Length = 8           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         IPv4 Address                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
¶


IPv4 Address: 32 bits (unsigned integer)
Contains an IPv4 address of the sending endpoint.
It is binary encoded.¶








3.3.2.1.2. IPv6 Address (6)


 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           Type = 6            |          Length = 20          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
|                         IPv6 Address                          |
|                                                               |
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
¶


IPv6 Address: 128 bits (unsigned integer)

Contains an IPv6 [RFC8200] address of the sending endpoint.
It is binary encoded.¶
A sender MUST NOT use an IPv4-mapped IPv6 address [RFC4291]
but SHOULD instead use an IPv4 Address parameter for an IPv4 address.¶



Combined with the Source Port Number in the SCTP common header, the value
passed in an IPv4 or IPv6 Address parameter indicates a transport address the
sender of the INIT chunk will support for the association being initiated.
That is, during the life time of this association, this IP address can appear
in the source address field of an IP datagram sent from the sender of the INIT
chunk and can be used as a destination address of an IP datagram sent from the
receiver of the INIT chunk.¶
More than one IP Address parameter can be included in an INIT chunk when the
sender of the INIT chunk is multi-homed.
Moreover, a multi-homed endpoint might have access to different types of network;
thus, more than one address type can be present in one INIT chunk, i.e.,
IPv4 and IPv6 addresses are allowed in the same INIT chunk.¶
If the INIT chunk contains at least one IP Address parameter, then the
source address of the IP datagram containing the INIT chunk and any additional
address(es) provided within the INIT can be used as destinations by the endpoint
receiving the INIT chunk.
If the INIT chunk does not contain any IP Address parameters, the endpoint
receiving the INIT chunk MUST use the source address associated with the
received IP datagram as its sole destination address for the association.¶
Note that not using any IP Address parameters in the INIT and INIT ACK chunk
is a way to make an association more likely to work in combination with Network
Address Translation (NAT).¶




3.3.2.1.3. Cookie Preservative (9)

The sender of the INIT chunk uses this parameter to suggest to the
receiver of the INIT chunk a longer life span for the State Cookie.¶

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           Type = 9            |          Length = 8           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         Suggested Cookie Life-Span Increment (msec.)          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
¶


Suggested Cookie Life-Span Increment: 32 bits (unsigned integer)

This parameter indicates to the receiver how much increment in milliseconds
the sender wishes the receiver to add to its default cookie life span.¶
This optional parameter MAY be added to the INIT chunk by the sender when
it reattempts establishing an association with a peer to which its previous
attempt of establishing the association failed due to a stale cookie operation
error.
The receiver MAY choose to ignore the suggested cookie life span increase for
its own security reasons.¶







3.3.2.1.4. Host Name Address (11)

The sender of an INIT chunk or INIT ACK chunk MUST NOT include this parameter.
The usage of the Host Name Address parameter is deprecated.
The receiver of an INIT chunk or an INIT ACK containing a Host Name Address
parameter MUST send an ABORT chunk and MAY include an ""Unresolvable Address""
error cause.¶

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           Type = 11           |            Length             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
/                           Host Name                           /
\                                                               \
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
¶


Host Name: variable length

This field contains a host name in ""host name syntax"" per Section 2.1 of [RFC1123].
The method for resolving the host name is out of scope of SCTP.¶
At least one null terminator is included in the Host Name string and MUST be
included in the length.¶







3.3.2.1.5. Supported Address Types (12)

The sender of the INIT chunk uses this parameter to list all the address types
it can support.¶

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           Type = 12           |            Length             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|        Address Type #1        |        Address Type #2        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                            ......                             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-++-+-+-+-+-+-+-+-+-+-+-+-+-+-++-+-+-+
¶


Address Type: 16 bits (unsigned integer)
This is filled with the type value of the corresponding address
TLV (e.g., 5 for indicating IPv4, and 6 for indicating IPv6).
The value indicating the Host Name Address parameter MUST NOT be used
when sending this parameter and MUST be ignored when receiving this
parameter.¶











3.3.3. Initiation Acknowledgement (INIT ACK) (2)

The INIT ACK chunk is used to acknowledge the initiation of an SCTP
association.
The format of the INIT ACK chunk is shown below:¶

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Type = 2    |  Chunk Flags  |         Chunk Length          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         Initiate Tag                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|               Advertised Receiver Window Credit               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Number of Outbound Streams   |   Number of Inbound Streams   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Initial TSN                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
\                                                               \
/              Optional/Variable-Length Parameters              /
\                                                               \
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
¶

The parameter part of INIT ACK is formatted similarly to the INIT chunk.
The following parameters are specified for the INIT ACK chunk:¶


Table 7:
Fixed-Length Parameters of INIT ACK Chunks



Fixed-Length Parameter
Status




Initiate Tag
Mandatory


Advertised Receiver Window Credit
Mandatory


Number of Outbound Streams
Mandatory


Number of Inbound Streams
Mandatory


Initial TSN
Mandatory



It uses two extra variable parameters: the State Cookie and the Unrecognized
Parameter.¶


Table 8:
Variable-Length Parameters of INIT ACK Chunks



Variable-Length Parameter
Status
Type Value




State Cookie
Mandatory
7


IPv4 Address (Note 1)
Optional
5


IPv6 Address (Note 1)
Optional
6


Unrecognized Parameter
Optional
8


Reserved for ECN Capable (Note 2)
Optional
32768 (0x8000)


Host Name Address (Note 3)
Deprecated
11



Note 1:
The INIT ACK chunks can contain any number of IP Address parameters that
can be IPv4 and/or IPv6 in any combination.¶
Note 2:
The ECN Capable field is reserved for future use of Explicit Congestion
Notification.¶
Note 3:
An INIT ACK chunk MUST NOT contain the Host Name Address parameter.
The receiver of INIT ACK chunks containing a Host Name Address parameter
MUST send an ABORT chunk and MAY include an ""Unresolvable Address"" error cause.¶
The Chunk Flags field in INIT ACK chunks is reserved, and all bits in it
SHOULD be set to 0 by the sender and ignored by the receiver.¶

Initiate Tag: 32 bits (unsigned integer)

The receiver of the INIT ACK chunk records the value of the Initiate Tag
parameter.
This value MUST be placed into the Verification Tag field of every SCTP packet
that the receiver of the INIT ACK chunk transmits within this association.¶
The Initiate Tag MUST NOT take the value 0.
See Section 5.3.1 for more on the selection of
the Initiate Tag value.¶
If an endpoint in the COOKIE-WAIT state receives an INIT ACK chunk with the
Initiate Tag set to 0, it MUST destroy the TCB and SHOULD send an ABORT chunk
with the T bit set.
If such an INIT ACK chunk is received in any state other than CLOSED or
COOKIE-WAIT, it SHOULD be discarded silently
(see Section 5.2.3).¶


Advertised Receiver Window Credit (a_rwnd): 32 bits (unsigned integer)

This value represents the dedicated buffer space, in number of bytes, the
sender of the INIT ACK chunk has reserved in association with this window.¶
The Advertised Receiver Window Credit MUST NOT be smaller than 1500.¶
A receiver of an INIT ACK chunk with the a_rwnd value set to a value smaller
than 1500 MUST discard the packet, SHOULD send a packet in response
containing an ABORT chunk and using the Initiate Tag as the Verification Tag,
and MUST NOT change the state of any existing association.¶
During the life of the association, this buffer space SHOULD NOT be reduced
(i.e., dedicated buffers ought not to be taken away from this association);
however, an endpoint MAY change the value of a_rwnd it sends in SACK chunks.¶


Number of Outbound Streams (OS): 16 bits (unsigned integer)

Defines the number of outbound streams the sender of this INIT ACK chunk
wishes to create in this association.
The value of 0 MUST NOT be used, and the value MUST NOT be greater than the
MIS value sent in the INIT chunk.¶
If an endpoint in the COOKIE-WAIT state receives an INIT ACK chunk with the
OS value set to 0, it MUST destroy the TCB and SHOULD send an ABORT chunk.
If such an INIT ACK chunk is received in any state other than CLOSED or
COOKIE-WAIT, it SHOULD be discarded silently
(see Section 5.2.3).¶


Number of Inbound Streams (MIS): 16 bits (unsigned integer)

Defines the maximum number of streams the sender of this INIT ACK chunk
allows the peer end to create in this association.
The value 0 MUST NOT be used.¶
Note:
There is no negotiation of the actual number of streams, but instead the two
endpoints will use the min(requested, offered).
See Section 5.1.1 for details.¶
If an endpoint in the COOKIE-WAIT state receives an INIT ACK chunk with the
MIS value set to 0, it MUST destroy the TCB and SHOULD send an ABORT chunk.
If such an INIT ACK chunk is received in any state other than CLOSED or
COOKIE-WAIT, it SHOULD be discarded silently
(see Section 5.2.3).¶


Initial TSN (I-TSN): 32 bits (unsigned integer)
Defines the TSN that the sender of the INIT ACK chunk will use initially.
The valid range is from 0 to 4294967295 and the Initial TSN SHOULD be set to a
random value in that range.
The methods described in [RFC4086] can be used for the
Initial TSN randomization.¶



Implementation Note:
An implementation MUST be prepared to receive an INIT ACK chunk that is quite
large (more than 1500 bytes) due to the variable size of the State Cookie and
the variable address list.
For example, if a responder to the INIT chunk has 1000 IPv4 addresses it wishes
to send, it would need at least 8,000 bytes to encode this in the
INIT ACK chunk.¶
If an INIT ACK chunk is received with all mandatory parameters that are
specified for the INIT ACK chunk, then the receiver SHOULD process the
INIT ACK chunk and send back a COOKIE ECHO chunk.
The receiver of the INIT ACK chunk MAY bundle an ERROR chunk with the
COOKIE ECHO chunk.
However, restrictive implementations MAY send back an ABORT chunk in
response to the INIT ACK chunk.¶
In combination with the Source Port Number carried in the SCTP common header,
each IP Address parameter in the INIT ACK chunk indicates to the receiver of
the INIT ACK chunk a valid transport address supported by the sender of the
INIT ACK chunk for the life time of the association being initiated.¶
If the INIT ACK chunk contains at least one IP Address parameter, then the
source address of the IP datagram containing the INIT ACK chunk and any
additional address(es) provided within the INIT ACK chunk MAY be used as
destinations by the receiver of the INIT ACK chunk.
If the INIT ACK chunk does not contain any IP Address parameters, the receiver
of the INIT ACK chunk MUST use the source address associated with the received
IP datagram as its sole destination address for the association.¶
The State Cookie and Unrecognized Parameters use the Type-Length-Value format
as defined in Section 3.2.1 and are described below.
The other fields are defined in the same way as their counterparts in the
INIT chunk.¶



3.3.3.1. Optional or Variable-Length Parameters in INIT ACK Chunks

The State Cookie and Unrecognized Parameters use the Type-Length-Value format,
as defined in Section 3.2.1, and are described below.
The IPv4 Address parameter is described in Section 3.3.2.1.1, and
the IPv6 Address parameter is described in Section 3.3.2.1.2.
The Host Name Address parameter is described in Section 3.3.2.1.4
and MUST NOT be included in an INIT ACK chunk.
Any Type-Length-Value fields MUST be placed after the fixed-length fields.
(The fixed-length fields are defined in the previous section.)¶


3.3.3.1.1. State Cookie (7)


 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           Type = 7            |            Length             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
/                            Cookie                             /
\                                                               \
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
¶


Cookie: variable length
This parameter value MUST contain all the necessary state and parameter
information required for the sender of this INIT ACK chunk to create the
association, along with a Message Authentication Code (MAC).
See Section 5.1.3 for details on
State Cookie definition.¶






3.3.3.1.2. Unrecognized Parameter (8)

This parameter is returned to the originator of the INIT chunk when the INIT
chunk contains an unrecognized parameter that has a type that indicates it
SHOULD be reported to the sender.¶

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           Type = 8            |            Length             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
/                    Unrecognized Parameter                     /
\                                                               \
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
¶


Unrecognized Parameter: variable length
The Parameter Value field will contain an unrecognized parameter copied from
the INIT chunk complete with Parameter Type, Length, and Value fields.¶











3.3.4. Selective Acknowledgement (SACK) (3)

This chunk is sent to the peer endpoint to acknowledge received DATA chunks
and to inform the peer endpoint of gaps in the received subsequences of DATA
chunks as represented by their TSNs.¶
The SACK chunk MUST contain the Cumulative TSN Ack, Advertised Receiver
Window Credit (a_rwnd), Number of Gap Ack Blocks, and Number of Duplicate TSNs
fields.¶
By definition, the value of the Cumulative TSN Ack parameter is the
last TSN received before a break in the sequence of received TSNs
occurs;
the next TSN value following this one has not yet been received at the endpoint
sending the SACK chunk.
This parameter therefore acknowledges receipt of all TSNs less than or equal to
its value.¶
The handling of a_rwnd by the receiver of the SACK chunk is discussed in
detail in Section 6.2.1.¶
The SACK chunk also contains zero or more Gap Ack Blocks.
Each Gap Ack Block acknowledges a subsequence of TSNs received following a break
in the sequence of received TSNs.
The Gap Ack Blocks SHOULD be isolated.
This means that the TSN just before each Gap Ack Block and the TSN just after
each Gap Ack Block have not been received.
By definition, all TSNs acknowledged by Gap Ack Blocks are greater than the
value of the Cumulative TSN Ack.¶

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Type = 3    |  Chunk Flags  |         Chunk Length          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      Cumulative TSN Ack                       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          Advertised Receiver Window Credit (a_rwnd)           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Number of Gap Ack Blocks = N  |  Number of Duplicate TSNs = M |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    Gap Ack Block #1 Start     |     Gap Ack Block #1 End      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
/                                                               /
\                              ...                              \
/                                                               /
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    Gap Ack Block #N Start     |     Gap Ack Block #N End      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Duplicate TSN 1                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
/                                                               /
\                              ...                              \
/                                                               /
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Duplicate TSN M                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
¶


Chunk Flags: 8 bits
All set to 0 on transmit and ignored on receipt.¶


Cumulative TSN Ack: 32 bits (unsigned integer)
The largest TSN, such that all TSNs smaller than or equal to it have been
received and the next one has not been received.
In the case where no DATA chunk has been received, this value is set to the
peer's Initial TSN minus one.¶


Advertised Receiver Window Credit (a_rwnd): 32 bits (unsigned integer)
This field indicates the updated receive buffer space in bytes of the sender
of this SACK chunk; see Section 6.2.1 for details.¶


Number of Gap Ack Blocks: 16 bits (unsigned integer)
Indicates the number of Gap Ack Blocks included in this SACK chunk.¶


Number of Duplicate TSNs: 16 bit
This field contains the number of duplicate TSNs the endpoint has received.
Each duplicate TSN is listed following the Gap Ack Block list.¶


Gap Ack Blocks:
These fields contain the Gap Ack Blocks.
They are repeated for each Gap Ack Block up to the number of Gap Ack Blocks
defined in the Number of Gap Ack Blocks field.
All DATA chunks with TSNs greater than or equal to (Cumulative TSN Ack +
Gap Ack Block Start) and less than or equal to (Cumulative TSN Ack +
Gap Ack Block End) of each Gap Ack Block are assumed to have been received
correctly.¶


Gap Ack Block Start: 16 bits (unsigned integer)
Indicates the Start offset TSN for this Gap Ack Block.
To calculate the actual TSN number, the Cumulative TSN Ack is added to
this offset number.
This calculated TSN identifies the lowest TSN in this Gap Ack Block that has
been received.¶


Gap Ack Block End: 16 bits (unsigned integer)

Indicates the End offset TSN for this Gap Ack Block.
To calculate the actual TSN number, the Cumulative TSN Ack is added to this
offset number.
This calculated TSN identifies the highest TSN in this Gap Ack Block that has
been received.¶
For example, assume that the receiver has the following DATA chunks newly
arrived at the time when it decides to send a Selective ACK:¶

------------
| TSN = 17 |
------------
|          | <- still missing
------------
| TSN = 15 |
------------
| TSN = 14 |
------------
|          | <- still missing
------------
| TSN = 12 |
------------
| TSN = 11 |
------------
| TSN = 10 |
------------
¶

Then, the parameter part of the SACK chunk MUST be constructed as follows
(assuming the new a_rwnd is set to 4660 by the sender):¶

+-------------------+-------------------+
|        Cumulative TSN Ack = 12        |
+-------------------+-------------------+
|             a_rwnd = 4660             |
+-------------------+-------------------+
| num of block = 2  |  num of dup = 0   |
+-------------------+-------------------+
|block #1 start = 2 | block #1 end = 3  |
+-------------------+-------------------+
|block #2 start = 5 | block #2 end = 5  |
+-------------------+-------------------+
¶



Duplicate TSN: 32 bits (unsigned integer)

Indicates the number of times a TSN was received in duplicate since the last
SACK chunk was sent.
Every time a receiver gets a duplicate TSN (before sending the SACK chunk), it
adds it to the list of duplicates.
The duplicate count is reinitialized to zero after sending each SACK chunk.¶
For example, if a receiver were to get the TSN 19 three times, it
would list 19 twice in the outbound SACK chunk.
After sending the SACK chunk, if it received yet one more TSN 19, it would list
19 as a duplicate once in the next outgoing SACK chunk.¶








3.3.5. Heartbeat Request (HEARTBEAT) (4)

An endpoint SHOULD send a HEARTBEAT (HB) chunk to its peer endpoint to probe
the reachability of a particular destination transport address defined in the
present association.¶
The parameter field contains the Heartbeat Information, which is a
variable-length opaque data structure understood only by the sender.¶

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Type = 4    |  Chunk Flags  |       Heartbeat Length        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
\                                                               \
/          Heartbeat Information TLV (Variable-Length)          /
\                                                               \
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
¶


Chunk Flags: 8 bits
Set to 0 on transmit and ignored on receipt.¶


Heartbeat Length: 16 bits (unsigned integer)
Set to the size of the chunk in bytes, including the chunk header and the
Heartbeat Information field.¶


Heartbeat Information: variable length

Defined as a variable-length parameter using the format described
in Section 3.2.1, that is:¶


Table 9:
Variable-Length Parameters of HEARTBEAT Chunks



Variable Parameters
Status
Type Value




Heartbeat Info
Mandatory
1




 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    Heartbeat Info Type = 1    |        HB Info Length         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
/                Sender-Specific Heartbeat Info                 /
\                                                               \
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
¶

The Sender-Specific Heartbeat Info field SHOULD include
information about the sender's current time when this HEARTBEAT
chunk is sent and the destination transport address to which this
HEARTBEAT chunk is sent (see Section 8.3).
This information is simply reflected back by the receiver in the HEARTBEAT ACK
chunk (see Section 3.3.6).
Note also that the HEARTBEAT chunk is both for reachability checking and for
path verification (see Section 5.4).
When a HEARTBEAT chunk is being used for path verification purposes, it MUST
include a random nonce of length 64 bits or longer ([RFC4086]
provides some information on randomness guidelines).¶








3.3.6. Heartbeat Acknowledgement (HEARTBEAT ACK) (5)

An endpoint MUST send this chunk to its peer endpoint as a response
to a HEARTBEAT chunk (see Section 8.3).
A packet containing the HEARTBEAT ACK chunk is always sent to the source
IP address of the IP datagram containing the HEARTBEAT chunk to which this
HEARTBEAT ACK chunk is responding.¶
The parameter field contains a variable-length opaque data structure.¶

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Type = 5    |  Chunk Flags  |     Heartbeat Ack Length      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
\                                                               \
/          Heartbeat Information TLV (Variable-Length)          /
\                                                               \
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
¶


Chunk Flags: 8 bits
Set to 0 on transmit and ignored on receipt.¶


Heartbeat Ack Length: 16 bits (unsigned integer)
Set to the size of the chunk in bytes, including the chunk header and the
Heartbeat Information field.¶


Heartbeat Information: variable length

This field MUST contain the Heartbeat Info parameter (as defined in
Section 3.3.5) of the Heartbeat Request to which this
Heartbeat Acknowledgement is responding.¶


Table 10:
Variable-Length Parameters of HEARTBEAT ACK Chunks



Variable Parameters
Status
Type Value




Heartbeat Info
Mandatory
1











3.3.7. Abort Association (ABORT) (6)

The ABORT chunk is sent to the peer of an association to close the
association.
The ABORT chunk MAY contain error causes to inform the receiver about the
reason of the abort.
DATA chunks MUST NOT be bundled with ABORT chunks.
Control chunks (except for INIT, INIT ACK, and SHUTDOWN COMPLETE) MAY be
bundled with an ABORT chunk, but they MUST be placed before the ABORT chunk
in the SCTP packet; otherwise, they will be ignored by the receiver.¶
If an endpoint receives an ABORT chunk with a format error or no TCB is
found, it MUST silently discard it.
Moreover, under any circumstances, an endpoint that receives an ABORT chunk
MUST NOT respond to that ABORT chunk by sending an ABORT chunk of its own.¶

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Type = 6    |  Reserved   |T|            Length             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
\                                                               \
/                   zero or more Error Causes                   /
\                                                               \
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
¶


Chunk Flags: 8 bits


Reserved: 7 bits
Set to 0 on transmit and ignored on receipt.¶


T bit: 1 bit
The T bit is set to 0 if the sender filled in the Verification Tag
expected by the peer.
If the Verification Tag is reflected, the T bit MUST be set to 1.
Reflecting means that the sent Verification Tag is the same as the received one.¶





Length: 16 bits (unsigned integer)
Set to the size of the chunk in bytes, including the chunk header and all the
Error Cause fields present.¶



See Section 3.3.10 for Error Cause definitions.¶
Note: Special rules apply to this chunk for verification;
please see Section 8.5.1 for
details.¶





3.3.8. Shutdown Association (SHUTDOWN) (7)

An endpoint in an association MUST use this chunk to initiate a graceful
close of the association with its peer.
This chunk has the following format.¶

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Type = 7    |  Chunk Flags  |          Length = 8           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      Cumulative TSN Ack                       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
¶


Chunk Flags: 8 bits
Set to 0 on transmit and ignored on receipt.¶


Length: 16 bits (unsigned integer)
Indicates the length of the parameter. Set to 8.¶


Cumulative TSN Ack: 32 bits (unsigned integer)
The largest TSN, such that all TSNs smaller than or equal to it have been
received and the next one has not been received.¶



Note: Since the SHUTDOWN chunk does not contain Gap Ack Blocks,
it cannot be used to acknowledge TSNs received out of order.
In a SACK chunk, lack of Gap Ack Blocks that were previously included indicates
that the data receiver reneged on the associated DATA chunks.¶
Since the SHUTDOWN chunk does not contain Gap Ack Blocks, the receiver of
the SHUTDOWN chunk MUST NOT interpret the lack of a Gap Ack Block as a renege.
(See Section 6.2 for
information on reneging.)¶
The sender of the SHUTDOWN chunk MAY bundle a SACK chunk to indicate any
gaps in the received TSNs.¶





3.3.9. Shutdown Acknowledgement (SHUTDOWN ACK) (8)

This chunk MUST be used to acknowledge the receipt of the SHUTDOWN chunk at
the completion of the shutdown process;
see Section 9.2 for details.¶
The SHUTDOWN ACK chunk has no parameters.¶

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Type = 8    |  Chunk Flags  |          Length = 4           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
¶


Chunk Flags: 8 bits
Set to 0 on transmit and ignored on receipt.¶








3.3.10. Operation Error (ERROR) (9)

An endpoint sends this chunk to its peer endpoint to notify it of
certain error conditions.
It contains one or more error causes.
An Operation Error is not considered fatal in and of itself, but the
corresponding error cause MAY be used with an ABORT chunk to report a fatal
condition.
An ERROR chunk has the following format:¶

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Type = 9    |  Chunk Flags  |            Length             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
\                                                               \
/                   one or more Error Causes                    /
\                                                               \
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
¶


Chunk Flags: 8 bits
Set to 0 on transmit and ignored on receipt.¶


Length: 16 bits (unsigned integer)
Set to the size of the chunk in bytes, including the chunk header and all the
Error Cause fields present.¶



Error causes are defined as variable-length parameters using the
format described in Section 3.2.1, that is:¶

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          Cause Code           |         Cause Length          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
/                  Cause-Specific Information                   /
\                                                               \
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
¶


Cause Code: 16 bits (unsigned integer)

Defines the type of error conditions being reported.¶


Table 11:
Cause Code



Value
Cause Code




 1
Invalid Stream Identifier


 2
Missing Mandatory Parameter


 3
Stale Cookie


 4
Out of Resource


 5
Unresolvable Address


 6
Unrecognized Chunk Type


 7
Invalid Mandatory Parameter


 8
Unrecognized Parameters


 9
No User Data


10
Cookie Received While Shutting Down


11
Restart of an Association with New Addresses


12
User-Initiated Abort


13
Protocol Violation





Cause Length: 16 bits (unsigned integer)
Set to the size of the parameter in bytes, including the Cause Code,
Cause Length, and Cause-Specific Information fields.¶


Cause-Specific Information: variable length
This field carries the details of the error condition.¶



Sections 3.3.10.1 -
3.3.10.13 define error causes for SCTP.
Guidelines for the IETF to define new error cause values are discussed in
Section 15.4.¶



3.3.10.1. Invalid Stream Identifier (1)

Indicates that the endpoint received a DATA chunk sent using a nonexistent
stream.¶

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|        Cause Code = 1         |       Cause Length = 8        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|       Stream Identifier       |          (Reserved)           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
¶


Stream Identifier: 16 bits (unsigned integer)
Contains the Stream Identifier of the DATA chunk received in error.¶


Reserved: 16 bits
This field is reserved.
It is set to all 0's on transmit and ignored on receipt.¶








3.3.10.2. Missing Mandatory Parameter (2)

Indicates that one or more mandatory TLV
parameters are missing in a received INIT or INIT ACK chunk.¶

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|        Cause Code = 2         |   Cause Length = 8 + N * 2    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                 Number of missing params = N                  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     Missing Param Type #1     |     Missing Param Type #2     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    Missing Param Type #N-1    |     Missing Param Type #N     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
¶


Number of Missing params: 32 bits (unsigned integer)
This field contains the number of parameters contained in the Cause-Specific
Information field.¶


Missing Param Type: 16 bits (unsigned integer)
Each field will contain the missing mandatory parameter number.¶








3.3.10.3. Stale Cookie (3)

Indicates the receipt of a valid State Cookie that has expired.¶

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|        Cause Code = 3         |       Cause Length = 8        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                 Measure of Staleness (usec.)                  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
¶


Measure of Staleness: 32 bits (unsigned integer)

This field contains the difference, rounded up in microseconds, between the
current time and the time the State Cookie expired.¶
The sender of this error cause MAY choose to report how long past
expiration the State Cookie is by including a non-zero value in
the Measure of Staleness field.
If the sender does not wish to provide the Measure of Staleness, it SHOULD set
this field to the value of zero.¶








3.3.10.4. Out of Resource (4)

Indicates that the sender is out of resource.
This is usually sent in combination with or within an ABORT chunk.¶

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|        Cause Code = 4         |       Cause Length = 4        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
¶






3.3.10.5. Unresolvable Address (5)

Indicates that the sender is not able to resolve the specified address
parameter (e.g., type of address is not supported by the sender).
This is usually sent in combination with or within an ABORT chunk.¶

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|        Cause Code = 5         |         Cause Length          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
/                     Unresolvable Address                      /
\                                                               \
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
¶


Unresolvable Address: variable length
The Unresolvable Address field contains the complete Type, Length, and Value
of the address parameter (or Host Name parameter) that contains the
unresolvable address or host name.¶








3.3.10.6. Unrecognized Chunk Type (6)

This error cause is returned to the originator of the chunk if the receiver
does not understand the chunk and the upper bits of the 'Chunk Type' are set
to 01 or 11.¶

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|        Cause Code = 6         |         Cause Length          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
/                      Unrecognized Chunk                       /
\                                                               \
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
¶


Unrecognized Chunk: variable length
The Unrecognized Chunk field contains the unrecognized chunk from the
SCTP packet complete with Chunk Type, Chunk Flags, and Chunk Length.¶








3.3.10.7. Invalid Mandatory Parameter (7)

This error cause is returned to the originator of an INIT or INIT ACK chunk
when one of the mandatory parameters is set to an invalid value.¶

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|        Cause Code = 7         |       Cause Length = 4        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
¶






3.3.10.8. Unrecognized Parameters (8)

This error cause is returned to the originator of the INIT ACK chunk if the
receiver does not recognize one or more Optional TLV parameters in the
INIT ACK chunk.¶

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|        Cause Code = 8         |         Cause Length          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
/                    Unrecognized Parameters                    /
\                                                               \
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
¶


Unrecognized Parameters: variable length
The Unrecognized Parameters field contains the unrecognized parameters copied
from the INIT ACK chunk complete with TLV.
This error cause is normally contained in an ERROR chunk bundled with
the COOKIE ECHO chunk when responding to the INIT ACK chunk, when the
sender of the COOKIE ECHO chunk wishes to report unrecognized parameters.¶








3.3.10.9. No User Data (9)

This error cause is returned to the originator of a DATA chunk if a
received DATA chunk has no user data.¶

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|        Cause Code = 9         |       Cause Length = 8        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                              TSN                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
¶


TSN: 32 bits (unsigned integer)
This parameter contains the TSN of the DATA chunk received with no User
Data field.¶



This cause code is normally returned in an ABORT chunk
(see Section 6.2).¶





3.3.10.10. Cookie Received While Shutting Down (10)

A COOKIE ECHO chunk was received while the endpoint was in the
SHUTDOWN-ACK-SENT state.
This error is usually returned in an ERROR chunk bundled with the
retransmitted SHUTDOWN ACK chunk.¶

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|        Cause Code = 10        |       Cause Length = 4        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
¶






3.3.10.11. Restart of an Association with New Addresses (11)

An INIT chunk was received on an existing association.
But the INIT chunk added addresses to the association that were previously
not part of the association.
The new addresses are listed in the error cause.
This error cause is normally sent as part of an ABORT chunk refusing the
INIT chunk
(see Section 5.2).¶

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|        Cause Code = 11        |         Cause Length          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
/                       New Address TLVs                        /
\                                                               \
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
¶

Note: Each New Address TLV is an exact copy of the TLV that was found
in the INIT chunk that was new, including the Parameter Type and the
Parameter Length.¶





3.3.10.12. User-Initiated Abort (12)

This error cause MAY be included in ABORT chunks that are sent
because of an upper-layer request.
The upper layer can specify an Upper Layer Abort Reason that is transported by
SCTP transparently and MAY be delivered to the upper-layer protocol at the peer.¶

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|        Cause Code = 12        |         Cause Length          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
/                   Upper Layer Abort Reason                    /
\                                                               \
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
¶






3.3.10.13. Protocol Violation (13)

This error cause MAY be included in ABORT chunks that are sent
because an SCTP endpoint detects a protocol violation of the peer
that is not covered by the error causes described in Sections
3.3.10.1 -
3.3.10.12.
An implementation MAY provide additional information specifying what kind of
protocol violation has been detected.¶

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         Cause Code = 13         |        Cause Length         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
/                    Additional Information                     /
\                                                               \
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
¶








3.3.11. Cookie Echo (COOKIE ECHO) (10)

This chunk is used only during the initialization of an association.
It is sent by the initiator of an association to its peer to complete
the initialization process.
This chunk MUST precede any DATA chunk sent within the association but MAY be
bundled with one or more DATA chunks in the same packet.¶

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Type = 10   |  Chunk Flags  |            Length             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
/                            Cookie                             /
\                                                               \
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
¶


Chunk Flags: 8 bits
Set to 0 on transmit and ignored on receipt.¶


Length: 16 bits (unsigned integer)
Set to the size of the chunk in bytes, including the 4 bytes of the
chunk header and the size of the cookie.¶


Cookie: variable size

This field MUST contain the exact cookie received in the State Cookie parameter
from the previous INIT ACK chunk.¶
An implementation SHOULD make the cookie as small as possible to ensure
interoperability.¶
Note: A Cookie Echo does not contain a State Cookie parameter;
instead, the data within the State Cookie's Parameter Value becomes the data
within the Cookie Echo's Chunk Value.
This allows an implementation to change only the first 2 bytes of the
State Cookie parameter to become a COOKIE ECHO chunk.¶








3.3.12. Cookie Acknowledgement (COOKIE ACK) (11)

This chunk is used only during the initialization of an association.
It is used to acknowledge the receipt of a COOKIE ECHO chunk.
This chunk MUST precede any DATA or SACK chunk sent within the
association but MAY be bundled with one or more DATA chunks or SACK
chunk's in the same SCTP packet.¶

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Type = 11   |  Chunk Flags  |          Length = 4           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
¶


Chunk Flags: 8 bits
Set to 0 on transmit and ignored on receipt.¶








3.3.13. Shutdown Complete (SHUTDOWN COMPLETE) (14)

This chunk MUST be used to acknowledge the receipt of the SHUTDOWN ACK chunk
at the completion of the shutdown process;
see Section 9.2 for details.¶
The SHUTDOWN COMPLETE chunk has no parameters.¶

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Type = 14   |  Reserved   |T|          Length = 4           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
¶


Chunk Flags: 8 bits


Reserved: 7 bits
Set to 0 on transmit and ignored on receipt.¶


T bit: 1 bit
The T bit is set to 0 if the sender filled in the Verification Tag
expected by the peer.
If the Verification Tag is reflected, the T bit MUST be set to 1.
Reflecting means that the sent Verification Tag is the same as the
received one.¶






Note: Special rules apply to this chunk for verification; please see
Section 8.5.1 for details.¶









4. SCTP Association State Diagram

During the life time of an SCTP association, the SCTP endpoint's
association progresses from one state to another in response to
various events.
The events that might potentially advance an association's state include:¶


SCTP user primitive calls, e.g., [ASSOCIATE], [SHUTDOWN], or [ABORT],¶


reception of INIT, COOKIE ECHO, ABORT, SHUTDOWN, etc., and control chunks, or¶


some timeout events.¶


The state diagram in the figures below illustrates state changes, together
with the causing events and resulting actions.
Note that some of the error conditions are not shown in the state diagram.
Full descriptions of all special cases are found in the text.¶
Note: Chunk names are given in all capital letters, while parameter
names have the first letter capitalized, e.g., COOKIE ECHO chunk type
vs. State Cookie parameter.
If more than one event/message can occur that causes a state transition, it
is labeled (A) or (B).¶



                        -----          -------- (from any state)
                      /       \      /receive ABORT      [ABORT]
        receive INIT |         |    |--------------  or ----------
---------------------|         v    v    delete TCB     send ABORT
generate State Cookie \    +---------+                  delete TCB
        send INIT ACK   ---|  CLOSED |
                           +---------+
                             /      \
                            /        \  [ASSOCIATE]
                           |          |-----------------
                           |          | create TCB
                           |          | send INIT
          receive valid    |          | start T1-init timer
          COOKIE  ECHO     |          v
      (1) -----------------|    +-----------+
          create TCB       |    |COOKIE-WAIT| (2)
          send COOKIE ACK  |    +-----------+
                           |          |
                           |          | receive INIT ACK
                           |          |-------------------
                           |          | send COOKIE ECHO
                           |          | stop T1-init timer
                           |          | start T1-cookie timer
                           |          v
                           |   +-------------+
                           |   |COOKIE-ECHOED| (3)
                           |   +-------------+
                           |          |
                           |          | receive COOKIE ACK
                           |          |-------------------
                           |          | stop T1-cookie timer
                           v          v
                         +---------------+
                         |  ESTABLISHED  |
                         +---------------+
                                 |
                                 |
                        /--------+--------\
    [SHUTDOWN]         /                   \
    -------------------|                   |
    check outstanding  |                   |
    DATA chunks        |                   |
                       v                   |
              +----------------+           |
              |SHUTDOWN-PENDING|           | receive SHUTDOWN
              +----------------+           |------------------
                                           | check outstanding
                       |                   | DATA chunks
No more outstanding    |                   |
-----------------------|                   |
send SHUTDOWN          |                   |
start T2-shutdown timer|                   |
                       v                   v
                +-------------+   +-----------------+
            (4) |SHUTDOWN-SENT|   |SHUTDOWN-RECEIVED| (5,6)
                +-------------+   +-----------------+
                       |  \                |
receive SHUTDOWN ACK   |   \               |
-----------------------|    \              |
stop T2-shutdown timer |     \             |
send SHUTDOWN COMPLETE |      \            |
delete TCB             |       \           |
                       |        \          | No more outstanding
                       |         \         |--------------------
                       |          \        | send SHUTDOWN ACK
receive SHUTDOWN      -|-          \       | start T2-shutdown timer
--------------------/  | \----------\      |
send SHUTDOWN ACK      |             \     |
start T2-shutdown timer|              \    |
                       |               \   |
                       |                |  |
                       |                v  v
                       |          +-----------------+
                       |          |SHUTDOWN-ACK-SENT| (7)
                       |          +-----------------+
                       |                   | (A)
                       |                   |receive SHUTDOWN COMPLETE
                       |                   |-------------------------
                       |                   | stop T2-shutdown timer
                       |                   | delete TCB
                       |                   |
                       |                   | (B)
                       |                   | receive SHUTDOWN ACK
                       |                   |-----------------------
                       |                   | stop T2-shutdown timer
                       |                   | send SHUTDOWN COMPLETE
                       |                   | delete TCB
                       |                   |
                       \    +---------+    /
                        \-->| CLOSED  |<--/
                            +---------+


Figure 3:
State Transition Diagram of SCTP


The following applies:¶

1)

If the State Cookie in the received COOKIE ECHO chunk is invalid (i.e.,
failed to pass the integrity check), the receiver MUST silently discard
the packet.
Or, if the received State Cookie is expired (see
Section 5.1.5), the receiver MUST send back
an ERROR chunk.
In either case, the receiver stays in the CLOSED state.¶


2)

If the T1-init timer expires, the endpoint MUST
retransmit the INIT chunk and restart the T1-init timer.
The endpoint stays in the COOKIE-WAIT state.
This MUST be repeated up to 'Max.Init.Retransmits' times.
After that, the endpoint MUST abort the initialization process and report the
error to the SCTP user.¶


3)

If the T1-cookie timer expires, the endpoint MUST
retransmit COOKIE ECHO chunk and restart the T1-cookie timer.
The endpoint stays in the COOKIE-ECHOED state.
This MUST be repeated up to 'Max.Init.Retransmits' times.
After that, the endpoint MUST abort the initialization process and report the
error to the SCTP user.¶


4)

In the SHUTDOWN-SENT state, the endpoint MUST acknowledge any
received DATA chunks without delay.¶


5)

In the SHUTDOWN-RECEIVED state, the endpoint MUST NOT accept any
new send requests from its SCTP user.¶


6)

In the SHUTDOWN-RECEIVED state, the endpoint MUST transmit or retransmit
data and leave this state when all data in queue is transmitted.¶


7)

In the SHUTDOWN-ACK-SENT state, the endpoint MUST NOT accept any new send
requests from its SCTP user.¶



The CLOSED state is used to indicate that an association is not created
(i.e., does not exist).¶





5. Association Initialization

Before the first data transmission can take place from one SCTP
endpoint (""A"") to another SCTP endpoint (""Z""), the two endpoints MUST
complete an initialization process in order to set up an SCTP
association between them.¶
The SCTP user at an endpoint can use the ASSOCIATE primitive to
initialize an SCTP association to another SCTP endpoint.¶
Implementation Note: From an SCTP user's point of view, an
association might be implicitly opened, without an ASSOCIATE primitive
(see Section 11.1.2) being invoked, by the initiating
endpoint's sending of the first user data to the destination endpoint.
The initiating SCTP will assume default values for all mandatory and
optional parameters for the INIT/INIT ACK chunk.¶
Once the association is established, unidirectional streams are open
for data transfer on both ends
(see Section 5.1.1).¶



5.1. Normal Establishment of an Association

The initialization process consists of the following steps (assuming that
SCTP endpoint ""A"" tries to set up an association with SCTP endpoint ""Z"" and
""Z"" accepts the new association):¶

A)

""A"" first builds a TCB and sends an INIT chunk to ""Z"".
In the INIT chunk, ""A"" MUST provide its Verification Tag (Tag_A) in the
Initiate Tag field.
Tag_A SHOULD be a random number in the range of 1 to 4294967295
(see Section 5.3.1 for Tag value selection).
After sending the INIT chunk, ""A"" starts the T1-init timer and enters the
COOKIE-WAIT state.¶


B)

""Z"" responds immediately with an INIT ACK chunk.
The destination IP address of the INIT ACK chunk MUST be set to the source
IP address of the INIT chunk to which this INIT ACK chunk is responding.
In the response, besides filling in other parameters, ""Z"" MUST set the
Verification Tag field to Tag_A and also provide its own
Verification Tag (Tag_Z) in the Initiate Tag field.¶
Moreover, ""Z"" MUST generate and send along with the INIT ACK chunk a 
State Cookie.
See Section 5.1.3 for State Cookie generation.¶
After sending an INIT ACK chunk with the State Cookie parameter,
""Z"" MUST NOT allocate any resources or keep any states for the new
association.
Otherwise, ""Z"" will be vulnerable to resource attacks.¶


C)

Upon reception of the INIT ACK chunk from ""Z"", ""A"" stops the T1-init
timer and leaves the COOKIE-WAIT state.
""A"" then sends the State Cookie received in the INIT ACK chunk in a
COOKIE ECHO chunk, starts the T1-cookie timer, and enters the COOKIE-ECHOED
state.¶
The COOKIE ECHO chunk MAY be bundled with any pending outbound DATA
chunks, but it MUST be the first chunk in the packet and, until the COOKIE ACK
chunk is returned, the sender MUST NOT send any other packets to the peer.¶


D)

Upon reception of the COOKIE ECHO chunk, endpoint ""Z"" replies
with a COOKIE ACK chunk after building a TCB and moving to the
ESTABLISHED state.
A COOKIE ACK chunk MAY be bundled with any pending DATA chunks
(and/or SACK chunks), but the COOKIE ACK chunk MUST be the first chunk in
the packet.¶
Implementation Note: An implementation can choose to send the
COMMUNICATION UP notification to the SCTP user upon reception of a
valid COOKIE ECHO chunk.¶


E)

Upon reception of the COOKIE ACK chunk, endpoint ""A"" moves from the
COOKIE-ECHOED state to the ESTABLISHED state, stopping the T1-cookie timer.
It can also notify its ULP about the successful establishment of the
association with a COMMUNICATION UP notification
(see Section 11).¶



An INIT or INIT ACK chunk MUST NOT be bundled with any other chunk.
They MUST be the only chunks present in the SCTP packets that carry them.¶
An endpoint MUST send the INIT ACK chunk to the IP address from which it
received the INIT chunk.¶
The T1-init timer and T1-cookie timer SHOULD follow the same rules
given in Section 6.3.
If the application provided multiple IP addresses of the peer, there SHOULD
be a T1-init and T1-cookie timer for each address of the peer. Retransmissions
of INIT chunks and COOKIE ECHO chunks SHOULD use all addresses of the peer
similar to retransmissions of DATA chunks.¶
If an endpoint receives an INIT, INIT ACK, or COOKIE ECHO chunk but decides
not to establish the new association due to missing mandatory parameters in the
received INIT or INIT ACK chunk, invalid parameter values, or lack of local
resources, it SHOULD respond with an ABORT chunk.
It SHOULD also specify the cause of abort, such as the type of the missing
mandatory parameters, etc., by including an error cause in the ABORT chunk.
The Verification Tag field in the common header of the outbound SCTP packet
containing the ABORT chunk MUST be set to the Initiate Tag value of the
received INIT or INIT ACK chunk this ABORT chunk is responding to.¶
Note that a COOKIE ECHO chunk that does not pass the integrity check
is not considered an 'invalid mandatory parameter' and requires special
handling; see Section 5.1.5.¶
After the reception of the first DATA chunk in an association, the
endpoint MUST immediately respond with a SACK chunk to acknowledge the DATA
chunk.
Subsequent acknowledgements SHOULD be done as described in
Section 6.2.¶
When the TCB is created, each endpoint MUST set its internal
Cumulative TSN Ack Point to the value of its transmitted Initial TSN
minus one.¶
Implementation Note: The IP addresses and SCTP port are generally
used as the key to find the TCB within an SCTP instance.¶



5.1.1. Handle Stream Parameters

In the INIT and INIT ACK chunks, the sender of the chunk MUST
indicate the number of outbound streams (OS) it wishes to have in
the association, as well as the maximum inbound streams (MIS) it
will accept from the other endpoint.¶
After receiving the stream configuration information from the other
side, each endpoint MUST perform the following check:
If the peer's MIS is less than the endpoint's OS, meaning that the peer is
incapable of supporting all the outbound streams the endpoint wants
to configure, the endpoint MUST use MIS outbound streams and MAY
report any shortage to the upper layer.
The upper layer can then choose to abort the association if the resource
shortage is unacceptable.¶
After the association is initialized, the valid outbound stream identifier
range for either endpoint MUST be 0 to min(local OS, remote MIS) - 1.¶





5.1.2. Handle Address Parameters

During the association initialization, an endpoint uses the
following rules to discover and collect the destination transport address(es)
of its peer.¶

A)

If there are no address parameters present in the received INIT or
INIT ACK chunk, the endpoint MUST take the source IP address from
which the chunk arrives and record it, in combination with the
SCTP Source Port Number, as the only destination transport address
for this peer.¶


B)

If there is a Host Name Address parameter present in the received INIT or
INIT ACK chunk, the endpoint MUST immediately send an ABORT chunk and MAY
include an ""Unresolvable Address"" error cause to its peer.
The ABORT chunk SHOULD be sent to the source IP address from which the last peer
packet was received.¶


C)

If there are only IPv4/IPv6 addresses present in the received INIT or
INIT ACK chunk, the receiver MUST derive and record all the transport addresses
from the received chunk AND the source IP address that sent the INIT or
INIT ACK chunk.
The transport addresses are derived by the combination of SCTP Source Port Number
(from the common header) and the IP Address parameter(s) carried in the INIT
or INIT ACK chunk and the source IP address of the IP datagram.
The receiver SHOULD use only these transport addresses as destination
transport addresses when sending subsequent packets to its peer.¶


D)

An INIT or INIT ACK chunk MUST be treated as belonging to an already
established association (or one in the process of being established) if the
use of any of the valid address parameters contained within the chunk would
identify an existing TCB.¶



Implementation Note: In some cases (e.g., when the implementation does not
control the source IP address that is used for transmitting), an endpoint
might need to include in its INIT or INIT ACK chunk all possible IP addresses
from which packets to the peer could be transmitted.¶
After all transport addresses are derived from the INIT or INIT ACK chunk
using the above rules, the endpoint selects one of the transport addresses
as the initial primary path.¶
The packet containing the INIT ACK chunk MUST be sent to the source address
of the packet containing the INIT chunk.¶
The sender of INIT chunks MAY include a 'Supported Address Types' parameter
in the INIT chunk to indicate what types of addresses are acceptable.¶
Implementation Note: In the case that the receiver of an INIT ACK chunk
fails to resolve the address parameter due to an unsupported type, it
can abort the initiation process and then attempt a reinitiation by
using a 'Supported Address Types' parameter in the new INIT chunk to indicate
what types of address it prefers.¶
If an SCTP endpoint that only supports either IPv4 or
IPv6 receives IPv4 and IPv6 addresses in an INIT or INIT ACK chunk from its
peer, it MUST use all the addresses belonging to the supported address family.
The other addresses MAY be ignored.
The endpoint SHOULD NOT respond with any kind of error indication.¶
If an SCTP endpoint lists in the 'Supported Address
Types' parameter either IPv4 or IPv6 but uses the other family for sending
the packet containing the INIT chunk, or if it also lists addresses of the
other family in the INIT chunk, then the address family that is not listed
in the 'Supported Address Types' parameter SHOULD also be considered as
supported by the receiver of the INIT chunk.
The receiver of the INIT chunk SHOULD NOT respond with any kind of error
indication.¶





5.1.3. Generating State Cookie

When sending an INIT ACK chunk as a response to an INIT chunk, the sender
of the INIT ACK chunk creates a State Cookie and sends it in the State Cookie
parameter of the INIT ACK chunk.
Inside this State Cookie, the sender MUST include a MAC
(see [RFC2104] for an example) to provide integrity protection
on the State Cookie.
The State Cookie SHOULD also contain a timestamp on when the
State Cookie is created and the lifespan of the State Cookie, along with all
the information necessary for it to establish the association, including
the port numbers and the Verification Tags.¶
The method used to generate the MAC is strictly a private matter for the
receiver of the INIT chunk.
The use of a MAC is mandatory to prevent denial-of-service attacks.
MAC algorithms can have different performances depending on the platform.
Choosing a high-performance MAC algorithm increases the resistance against
cookie flooding attacks.
A MAC with acceptable security properties SHOULD be used.
The secret key SHOULD be random ([RFC4086] provides some
information on randomness guidelines).
The secret keys need to have an appropriate size.
The secret key SHOULD be changed reasonably frequently (e.g., hourly), and the
timestamp in the State Cookie MAY be used to determine which key is used to
verify the MAC.¶
If the State Cookie is not encrypted, it MUST NOT contain information
that is not being envisioned to be shared.¶
An implementation SHOULD make the cookie as small as possible to
ensure interoperability.¶





5.1.4. State Cookie Processing

When an endpoint (in the COOKIE-WAIT state) receives an INIT ACK
chunk with a State Cookie parameter, it MUST immediately send a
COOKIE ECHO chunk to its peer with the received State Cookie.
The sender MAY also add any pending DATA chunks to the packet after the
COOKIE ECHO chunk.¶
The endpoint MUST also start the T1-cookie timer after sending the
COOKIE ECHO chunk.
If the timer expires, the endpoint MUST retransmit the COOKIE ECHO chunk and
restart the T1-cookie timer.
This is repeated until either a COOKIE ACK chunk is received or
'Max.Init.Retransmits' (see Section 16) is reached,
causing the peer endpoint to be marked unreachable (and thus the association
enters the CLOSED state).¶





5.1.5. State Cookie Authentication

When an endpoint receives a COOKIE ECHO chunk from another endpoint
with which it has no association, it takes the following actions:¶

1)

Compute a MAC using the information carried in the State Cookie and
the secret key.
The timestamp in the State Cookie MAY be used to determine which secret key to
use.
If secrets are kept only for a limited amount of time and the secret key to use
is not available anymore, the packet containing the COOKIE ECHO chunk MUST be
silently discarded.
[RFC2104] can be used as a guideline for generating the MAC.¶


2)

Authenticate the State Cookie as one that it previously generated
by comparing the computed MAC against the one carried in the State Cookie.
If this comparison fails, the SCTP packet, including the COOKIE ECHO chunk and
any DATA chunks, MUST be silently discarded.¶


3)

Compare the port numbers and the Verification Tag contained within the
COOKIE ECHO chunk to the actual port numbers and the Verification Tag within
the SCTP common header of the received packet.
If these values do not match, the packet MUST be silently discarded.¶


4)

Compare the creation timestamp in the State Cookie to the current local
time.
If the elapsed time is longer than the lifespan carried in the State Cookie,
then the packet, including the COOKIE ECHO chunk and any attached DATA chunks,
SHOULD be discarded, and the endpoint MUST transmit an ERROR chunk with a
""Stale Cookie"" error cause to the peer endpoint.¶


5)

If the State Cookie is valid, create an association to the sender
of the COOKIE ECHO chunk with the information in the State Cookie
carried in the COOKIE ECHO chunk and enter the ESTABLISHED state.¶


6)

Send a COOKIE ACK chunk to the peer acknowledging receipt of the
COOKIE ECHO chunk.
The COOKIE ACK chunk MAY be bundled with an outbound DATA chunk or SACK chunk;
however, the COOKIE ACK chunk MUST be the first chunk in the SCTP packet.¶


7)

Immediately acknowledge any DATA chunk bundled with the COOKIE ECHO chunk
with a SACK chunk (subsequent DATA chunk acknowledgement SHOULD follow the rules
defined in Section 6.2).
As mentioned in step 6, if the SACK chunk is bundled with the COOKIE ACK chunk,
the COOKIE ACK chunk MUST appear first in the SCTP packet.¶



If a COOKIE ECHO chunk is received from an endpoint with which the receiver
of the COOKIE ECHO chunk has an existing association, the procedures in
Section 5.2 SHOULD be
followed.¶





5.1.6. An Example of Normal Association Establishment

In the following example, ""A"" initiates the association and then sends a
user message to ""Z""; then, ""Z"" sends two user messages to ""A"" later
(assuming no bundling or fragmentation occurs):¶



Endpoint A                                          Endpoint Z
{app sets association with Z}
(build TCB)
INIT [I-Tag=Tag_A
      & other info]  ------\
(Start T1-init timer)       \
(Enter COOKIE-WAIT state)    \---> (compose Cookie_Z)
                                /-- INIT ACK [Veri Tag=Tag_A,
                               /             I-Tag=Tag_Z,
(Cancel T1-init timer) <------/              Cookie_Z, & other info]

COOKIE ECHO [Cookie_Z] ------\
(Start T1-cookie timer)       \
(Enter COOKIE-ECHOED state)    \---> (build TCB, enter ESTABLISHED
                                      state)
                               /---- COOKIE ACK
                              /
(Cancel T1-cookie timer, <---/
 enter ESTABLISHED state)
{app sends 1st user data; strm 0}
DATA [TSN=init TSN_A
    Strm=0,Seq=0 & user data]--\
(Start T3-rtx timer)            \
                                 \->
                               /----- SACK [TSN Ack=init TSN_A,
                                            Block=0]
(Cancel T3-rtx timer) <------/
                                      ...
                                     {app sends 2 messages;strm 0}
                               /---- DATA
                              /        [TSN=init TSN_Z,
                          <--/          Strm=0,Seq=0 & user data 1]
SACK [TSN Ack=init TSN_Z,      /---- DATA
      Block=0]     --------\  /        [TSN=init TSN_Z +1,
                            \/          Strm=0,Seq=1 & user data 2]
                     <------/\
                              \
                               \------>


Figure 4:
A Setup Example


If the T1-init timer expires at ""A"" after the INIT or COOKIE ECHO chunks
are sent, the same INIT or COOKIE ECHO chunk with the same Initiate Tag
(i.e., Tag_A) or State Cookie is retransmitted and the timer is restarted.
This is repeated 'Max.Init.Retransmits' times before ""A"" considers ""Z""
unreachable and reports the failure to its upper layer (and thus the
association enters the CLOSED state).¶
When retransmitting the INIT chunk, the endpoint MUST follow the rules
defined in Section 6.3 to determine
the proper timer value.¶







5.2. Handle Duplicate or Unexpected INIT, INIT ACK, COOKIE ECHO, and COOKIE ACK Chunks

During the life time of an association (in one of the possible states),
an endpoint can receive from its peer endpoint one of the setup chunks (INIT,
INIT ACK, COOKIE ECHO, or COOKIE ACK).
The receiver treats such a setup chunk as a duplicate and process it
as described in this section.¶
Note: An endpoint will not receive the chunk unless the chunk was sent to
an SCTP transport address and is from an SCTP transport address associated
with this endpoint.
Therefore, the endpoint processes such a chunk as part of its current
association.¶
The following scenarios can cause duplicated or unexpected chunks:¶

A)

the peer has crashed without being detected, restarted itself, and
sent a new INIT chunk trying to restore the association,¶


B)

both sides are trying to initialize the association at about the same
time,¶


C)

the chunk is from a stale packet that was used to establish the present
association or a past association that is no longer in existence,¶


D)

the chunk is a false packet generated by an attacker, or¶


E)

the peer never received the COOKIE ACK chunk and is retransmitting its
COOKIE ECHO chunk.¶



The rules in the following sections are applied in order to identify
and correctly handle these cases.¶


5.2.1. INIT Chunk Received in COOKIE-WAIT or COOKIE-ECHOED State (Item B)

This usually indicates an initialization collision, i.e., each endpoint
is attempting, at about the same time, to establish an association with the
other endpoint.¶
Upon receipt of an INIT chunk in the COOKIE-WAIT state, an endpoint MUST
respond with an INIT ACK chunk using the same parameters it sent in its
original INIT chunk (including its Initiate Tag, unchanged).
When responding, the following rules MUST be applied:¶

1)

The packet containing the INIT ACK chunk MUST only be sent to an address
passed by the upper layer in the request to initialize the association.¶


2)

The packet containing the INIT ACK chunk MUST only be sent to an address
reported in the incoming INIT chunk.¶


3)

The packet containing the INIT ACK chunk SHOULD be sent to the source
address of the received packet containing the INIT chunk.¶



Upon receipt of an INIT chunk in the COOKIE-ECHOED state, an endpoint MUST
respond with an INIT ACK chunk using the same parameters it sent in its
original INIT chunk (including its Initiate Tag, unchanged), provided
that no new address has been added to the forming association.
If the INIT chunk indicates that a new address has been added to the
association, then the entire INIT chunk MUST be discarded, and the state of
the existing association SHOULD NOT be changed.
An ABORT chunk SHOULD be sent in a response that MAY include the
""Restart of an Association with New Addresses"" error cause.
The error SHOULD list the addresses that were added to the restarting
association.¶
When responding in either state (COOKIE-WAIT or COOKIE-ECHOED) with
an INIT ACK chunk, the original parameters are combined with those from the
newly received INIT chunk.
The endpoint MUST also generate a State Cookie with the INIT ACK chunk.
The endpoint uses the parameters sent in its INIT chunk to calculate the
State Cookie.¶
After that, the endpoint MUST NOT change its state, the T1-init timer
MUST be left running, and the corresponding TCB MUST NOT be destroyed.
The normal procedures for handling State Cookies when a
TCB exists will resolve the duplicate INIT chunks to a single association.¶
For an endpoint that is in the COOKIE-ECHOED state, it MUST populate
its Tie-Tags within both the association TCB and inside the State Cookie (see
Section 5.2.2
for a description of the Tie-Tags).¶




5.2.2. Unexpected INIT Chunk in States Other than CLOSED, COOKIE-ECHOED, COOKIE-WAIT, and SHUTDOWN-ACK-SENT

Unless otherwise stated, upon receipt of an unexpected INIT chunk for this
association, the endpoint MUST generate an INIT ACK chunk with a State Cookie.
Before responding, the endpoint MUST check to see if the unexpected INIT chunk
adds new addresses to the association.
If new addresses are added to the association, the endpoint MUST respond with
an ABORT chunk, copying the 'Initiate Tag' of the unexpected INIT chunk into the
'Verification Tag' of the outbound packet carrying the ABORT chunk.
In the ABORT chunk, the error cause MAY be set to ""Restart of an
Association with New Addresses"".
The error SHOULD list the addresses that were added to the restarting
association.
If no new addresses are added, when responding to the INIT chunk in the outbound
INIT ACK chunk, the endpoint MUST copy its current Tie-Tags to a reserved place
within the State Cookie and the association's TCB.
We refer to these locations inside the cookie as the Peer's-Tie-Tag and
the Local-Tie-Tag.
We will refer to the copy within an association's TCB as the Local Tag and
Peer's Tag.
The outbound SCTP packet containing this INIT ACK chunk MUST carry a
Verification Tag value equal to the Initiate Tag found in the unexpected
INIT chunk.
And the INIT ACK chunk MUST contain a new Initiate Tag
(randomly generated; see Section 5.3.1).
Other parameters for the endpoint SHOULD be copied from the existing
parameters of the association (e.g., number of outbound streams) into the
INIT ACK chunk and cookie.¶
After sending the INIT ACK or ABORT chunk, the endpoint MUST take no
further actions,
i.e., the existing association, including its current state, and the
corresponding TCB MUST NOT be changed.¶
Only when a TCB exists and the association is not in a COOKIE-WAIT
or SHUTDOWN-ACK-SENT state are the Tie-Tags populated with a random value
other than 0.
For a normal association INIT chunk (i.e., the endpoint is in the CLOSED state),
the Tie-Tags MUST be set to 0 (indicating that no previous TCB existed).¶





5.2.3. Unexpected INIT ACK Chunk

If an INIT ACK chunk is received by an endpoint in any state other than the
COOKIE-WAIT or CLOSED state, the endpoint SHOULD discard the INIT ACK chunk.
An unexpected INIT ACK chunk usually indicates the processing of an old or
duplicated INIT chunk.¶





5.2.4. Handle a COOKIE ECHO Chunk When a TCB Exists

When a COOKIE ECHO chunk is received by an endpoint in any state for an
existing association (i.e., not in the CLOSED state), the following rules
are applied:¶

1)

Compute a MAC as described in step 1 of
Section 5.1.5.¶


2)

Authenticate the State Cookie as described in step 2 of
Section 5.1.5
(this is case C or D above).¶


3)

Compare the timestamp in the State Cookie to the current time.
If the State Cookie is older than the lifespan carried in the State Cookie
and the Verification Tags contained in the State Cookie do not match the
current association's Verification Tags, the packet, including the COOKIE ECHO
chunk and any DATA chunks, SHOULD be discarded.
The endpoint also MUST transmit an ERROR chunk with a ""Stale Cookie"" error cause
to the peer endpoint (this is case C or D in
Section 5.2).¶
If both Verification Tags in the State Cookie match the Verification Tags of
the current association, consider the State Cookie valid (this is case E in
Section 5.2), even if the
lifespan is exceeded.¶


4)

If the State Cookie proves to be valid, unpack the TCB into a
temporary TCB.¶


5)

Refer to Table 12 to determine the
correct action to be taken.¶






Table 12:
Handling of a COOKIE ECHO Chunk When a TCB Exists



Local Tag
Peer's Tag
Local-Tie-Tag
Peer's-Tie-Tag
Action




X
X
M
M
(A)


M
X
A
A
(B)


M
0
A
A
(B)


X
M
0
0
(C)


M
M
A
A
(D)




Legend:¶

X -
Tag does not match the existing TCB.¶


M -
Tag matches the existing TCB.¶


0 -
Tag unknown (Peer's Tag not known yet / No Tie-Tag in cookie).¶


A -
All cases, i.e., M, X, or 0.¶



For any case not shown in Table 12,
the cookie SHOULD be silently discarded.¶
Action:¶

A)

In this case, the peer might have restarted. When the endpoint
recognizes this potential 'restart', the existing session is
treated the same as if it received an ABORT chunk followed by a new
COOKIE ECHO chunk with the following exceptions:¶


Any SCTP DATA chunks MAY be retained (this is an implementation-specific
option).¶


A RESTART notification SHOULD be sent to the ULP instead of a
COMMUNICATION LOST notification.¶


All the congestion control parameters (e.g., cwnd, ssthresh)
related to this peer MUST be reset to their initial values
(see Section 6.2.1).¶
After this, the endpoint enters the ESTABLISHED state.¶
If the endpoint is in the SHUTDOWN-ACK-SENT state and recognizes that the peer
has restarted (Action A), it MUST NOT set up a new association but instead
resend the SHUTDOWN ACK chunk and send an ERROR chunk with a
""Cookie Received While Shutting Down"" error cause to its peer.¶


B)

In this case, both sides might be attempting to start an association
at about the same time, but the peer endpoint sent its INIT chunk
after responding to the local endpoint's INIT chunk.
Thus, it might have picked a new Verification Tag, not being aware of the
previous tag it had sent this endpoint.
The endpoint SHOULD stay in or enter the ESTABLISHED state, but it MUST update
its peer's Verification Tag from the State Cookie, stop any T1-init or
T1-cookie timers that might be running, and send a COOKIE ACK chunk.¶


C)

In this case, the local endpoint's cookie has arrived late.
Before it arrived, the local endpoint sent an INIT chunk and received an
INIT ACK chunk and finally sent a COOKIE ECHO chunk with the peer's same tag
but a new tag of its own.
The cookie SHOULD be silently discarded.
The endpoint SHOULD NOT change states and SHOULD leave any timers running.¶


D)

When both local and remote tags match, the endpoint SHOULD enter the
ESTABLISHED state if it is in the COOKIE-ECHOED state.
It SHOULD stop any T1-cookie timer that is running and send a COOKIE ACK chunk.¶



Note: The ""peer's Verification Tag"" is the tag received in the Initiate Tag
field of the INIT or INIT ACK chunk.¶


5.2.4.1. An Example of an Association Restart

In the following example, ""A"" initiates the association after a restart
has occurred.
Endpoint ""Z"" had no knowledge of the restart until the exchange (i.e.,
Heartbeats had not yet detected the failure of ""A"")
(assuming no bundling or fragmentation occurs):¶



Endpoint A                                          Endpoint Z
<-------------- Association is established---------------------->
Tag=Tag_A                                             Tag=Tag_Z
<--------------------------------------------------------------->
{A crashes and restarts}
{app sets up an association with Z}
(build TCB)
INIT [I-Tag=Tag_A'
      & other info]  --------\
(Start T1-init timer)         \
(Enter COOKIE-WAIT state)      \---> (find an existing TCB,
                                      populate TieTags if needed,
                                      compose Cookie_Z with Tie-Tags
                                      and other info)
                                /--- INIT ACK [Veri Tag=Tag_A',
                               /               I-Tag=Tag_Z',
(Cancel T1-init timer) <------/                Cookie_Z]
                                     (leave original TCB in place)
COOKIE ECHO [Veri=Tag_Z',
             Cookie_Z]-------\
(Start T1-init timer)         \
(Enter COOKIE-ECHOED state)    \---> (Find existing association,
                                      Tie-Tags in Cookie_Z match
                                      Tie-Tags in TCB,
                                      Tags do not match, i.e.,
                                      case X X M M above,
                                      Announce Restart to ULP
                                      and reset association).
                               /---- COOKIE ACK
(Cancel T1-init timer, <------/
 Enter ESTABLISHED state)
{app sends 1st user data; strm 0}
DATA [TSN=Initial TSN_A
    Strm=0,Seq=0 & user data]--\
(Start T3-rtx timer)            \
                                 \->
                              /--- SACK [TSN Ack=init TSN_A,Block=0]
(Cancel T3-rtx timer) <------/


Figure 5:
A Restart Example








5.2.5. Handle Duplicate COOKIE ACK Chunk

At any state other than COOKIE-ECHOED, an endpoint SHOULD silently
discard a received COOKIE ACK chunk.¶





5.2.6. Handle Stale Cookie Error

Receipt of an ERROR chunk with a ""Stale Cookie"" error cause indicates
one of a number of possible events:¶

A)

The association failed to completely set up before the State Cookie issued by
the sender was processed.¶


B)

An old State Cookie was processed after setup completed.¶


C)

An old State Cookie is received from someone that the receiver is not
interested in having an association with and the ABORT chunk was lost.¶



When processing an ERROR chunk with a ""Stale Cookie"" error cause, an endpoint
SHOULD first examine if an association is in the process of being set up, i.e.,
the association is in the COOKIE-ECHOED state.
In all cases, if the association is not in the COOKIE-ECHOED state, the
ERROR chunk SHOULD be silently discarded.¶
If the association is in the COOKIE-ECHOED state, the endpoint MAY elect
one of the following three alternatives.¶

1)

Send a new INIT chunk to the endpoint to generate a new State Cookie and
reattempt the setup procedure.¶


2)

Discard the TCB and report to the upper layer the inability to set up
the association.¶


3)

Send a new INIT chunk to the endpoint, adding a Cookie Preservative
parameter requesting an extension to the life time of the State Cookie.
When calculating the time extension, an implementation SHOULD use the RTT
information measured based on the previous COOKIE ECHO/ERROR chunk exchange
and SHOULD add no more than 1 second beyond the measured RTT, due to long
State Cookie life times making the endpoint more subject to a replay attack.¶










5.3. Other Initialization Issues




5.3.1. Selection of Tag Value

Initiate Tag values SHOULD be selected from the range of 1 to 232 - 1.
It is very important that the Initiate Tag value be randomized to
help protect against off-path attacks.
The methods described in [RFC4086] can be used for the
Initiate Tag randomization.
Careful selection of Initiate Tags is also necessary to prevent old duplicate
packets from previous associations being mistakenly processed as belonging
to the current association.¶
Moreover, the Verification Tag value used by either endpoint in a
given association MUST NOT change during the life time of an association.
A new Verification Tag value MUST be used each time the endpoint tears down
and then reestablishes an association to the same peer.¶







5.4. Path Verification

During association establishment, the two peers exchange a list of
addresses.
In the predominant case, these lists accurately represent the addresses
owned by each peer.
However, a misbehaving peer might supply addresses that it does not own.
To prevent this, the following rules are applied to all addresses of the
new association:¶

1)

Any addresses passed to the sender of the INIT chunk by its upper layer
in the request to initialize an association are automatically considered to be
CONFIRMED.¶


2)

For the receiver of the COOKIE ECHO chunk, the only CONFIRMED address
is the address to which the packet containing the INIT ACK chunk was sent.¶


3)

All other addresses not covered by rules 1 and 2 are considered
UNCONFIRMED and are subject to probing for verification.¶



To probe an address for verification, an endpoint will send
HEARTBEAT chunks including a 64-bit random nonce and a path indicator (to
identify the address that the HEARTBEAT chunk is sent to) within the Heartbeat
Info parameter.¶
Upon receipt of the HEARTBEAT ACK chunk, a verification is made that the
nonce included in the Heartbeat Info parameter is the one sent to the
address indicated inside the Heartbeat Info parameter.
When this match occurs, the address that the original HEARTBEAT was sent to
is now considered CONFIRMED and available for normal data transfer.¶
These probing procedures are started when an association moves to the
ESTABLISHED state and are ended when all paths are confirmed.¶
In each RTO, a probe MAY be sent on an active UNCONFIRMED path in an
attempt to move it to the CONFIRMED state.
If during this probing the path becomes inactive, this rate is lowered to the
normal HEARTBEAT rate.
At the expiration of the RTO timer, the error counter of any path that was
probed but not CONFIRMED is incremented by one and subjected to path failure
detection, as defined in Section 8.2.
When probing UNCONFIRMED addresses, however, the association overall error
count is not incremented.¶
The number of packets containing HEARTBEAT chunks sent at each RTO SHOULD
be limited by the 'HB.Max.Burst' parameter.
It is an implementation decision as to how to distribute packets containing
HEARTBEAT chunks to the peer's addresses for path verification.¶
Whenever a path is confirmed, an indication MAY be given to the upper
layer.¶
An endpoint MUST NOT send any chunks to an UNCONFIRMED address, with
the following exceptions:¶


A HEARTBEAT chunk including a nonce MAY be sent to an UNCONFIRMED address.¶


A HEARTBEAT ACK chunk MAY be sent to an UNCONFIRMED address.¶


A COOKIE ACK chunk MAY be sent to an UNCONFIRMED address, but it MUST be
bundled with a HEARTBEAT chunk including a nonce.
An implementation that does not support bundling MUST NOT send a COOKIE ACK
chunk to an UNCONFIRMED address.¶


A COOKIE ECHO chunk MAY be sent to an UNCONFIRMED address, but it MUST
be bundled with a HEARTBEAT chunk including a nonce, and the size of the
SCTP packet MUST NOT exceed the PMTU.
If the implementation does not support bundling or if the bundled COOKIE ECHO
chunk plus HEARTBEAT chunk (including nonce) would result in an SCTP packet
larger than the PMTU, then the implementation MUST NOT send a COOKIE ECHO chunk
to an UNCONFIRMED address.¶









6. User Data Transfer

Data transmission MUST only happen in the ESTABLISHED, SHUTDOWN-PENDING,
and SHUTDOWN-RECEIVED states.
The only exception to this is that DATA chunks are allowed to be bundled with
an outbound COOKIE ECHO chunk when in the COOKIE-WAIT state.¶
DATA chunks MUST only be received according to the rules below in
ESTABLISHED, SHUTDOWN-PENDING, and SHUTDOWN-SENT states.
A DATA chunk received in CLOSED is out of the blue and SHOULD be handled per
Section 8.4.
A DATA chunk received in any other state SHOULD be discarded.¶
A SACK chunk MUST be processed in ESTABLISHED, SHUTDOWN-PENDING, and
SHUTDOWN-RECEIVED states.
An incoming SACK chunk MAY be processed in COOKIE-ECHOED.
A SACK chunk in the CLOSED state is out of the blue and SHOULD be processed
according to the rules in Section 8.4.
A SACK chunk received in any other state SHOULD be discarded.¶
For transmission efficiency, SCTP defines mechanisms for bundling of
small user messages and fragmentation of large user messages.
The following diagram depicts the flow of user messages through SCTP.¶
In this section, the term ""data sender"" refers to the endpoint that
transmits a DATA chunk, and the term ""data receiver"" refers to the
endpoint that receives a DATA chunk.
A data receiver will transmit SACK chunks.¶



           +-------------------------+
           |      User Messages      |
           +-------------------------+
 SCTP user        ^  |
==================|==|=======================================
                  |  v (1)
       +------------------+    +---------------------+
       | SCTP DATA Chunks |    | SCTP Control Chunks |
       +------------------+    +---------------------+
                  ^  |             ^  |
                  |  v (2)         |  v (2)
               +--------------------------+
               |       SCTP packets       |
               +--------------------------+
 SCTP                      ^  |
===========================|==|===========================
                           |  v
       Connectionless Packet Transfer Service (e.g., IP)


Figure 6:
Illustration of User Data Transfer


The following applies:¶

1)

When converting user messages into DATA chunks, an endpoint
MUST fragment large user messages into multiple DATA chunks.
The size of each DATA chunk SHOULD be smaller than or equal to the
Association Maximum DATA Chunk Size (AMDCS).
The data receiver will normally reassemble the fragmented message from DATA
chunks before delivery to the user (see Section 6.9
for details).¶


2)

Multiple DATA and control chunks MAY be bundled by the sender into a single
SCTP packet for transmission, as long as the final size of the SCTP packet does
not exceed the current PMTU.
The receiver will unbundle the packet back into the original chunks.
Control chunks MUST come before DATA chunks in the packet.¶



The fragmentation and bundling mechanisms, as detailed in Sections
6.9 and 6.10, are OPTIONAL
to implement by the data sender, but they MUST be implemented by the data
receiver, i.e., an endpoint MUST properly receive and process bundled or
fragmented data.¶



6.1. Transmission of DATA Chunks

This section specifies the rules for sending DATA chunks.
In particular, it defines zero window probing, which is required to
avoid the indefinite stalling of an association in case of a loss of
packets containing SACK chunks performing window updates.¶
This document is specified as if there is a single retransmission timer
per destination transport address, but implementations MAY have a
retransmission timer for each DATA chunk.¶
The following general rules MUST be applied by the data sender for
transmission and/or retransmission of outbound DATA chunks:¶

A)

At any given time, the data sender MUST NOT transmit new data to
any destination transport address if its peer's rwnd indicates
that the peer has no buffer space (i.e., rwnd is smaller than the size of the
next DATA chunk; see Section 6.2.1),
except for zero window probes.¶
A zero window probe is a DATA chunk sent when the receiver has no buffer
space.
This rule allows the sender to probe for a change in rwnd that the sender
missed due to the SACK chunks having been lost in transit from the data
receiver to the data sender.
A zero window probe MUST only be sent when the cwnd allows (see rule B below).
A zero window probe SHOULD only be sent when all outstanding DATA chunks have
been cumulatively acknowledged and no DATA chunks are in flight.
Senders MUST support zero window probing.¶
If the sender continues to receive SACK chunks from the peer while doing 
zero window probing, the unacknowledged window probes SHOULD NOT increment the
error counter for the association or any destination transport address.
This is because the receiver could keep its window closed for an indefinite 
time.
Section 6.2 describes the
receiver behavior when it advertises a zero window.
The sender SHOULD send the first zero window probe after 1 RTO when it detects
that the receiver has closed its window and SHOULD increase the probe interval
exponentially afterwards.
Also note that the cwnd SHOULD be adjusted according to
Section 7.2.1.
Zero window probing does not affect the calculation of cwnd.¶
The sender MUST also have an algorithm for sending new DATA chunks to avoid
silly window syndrome (SWS) as described in [RFC1122].
The algorithm can be similar to the one described in Section 4.2.3.4 of [RFC1122].¶


B)

At any given time, the sender MUST NOT transmit new data to a given
transport address if it has cwnd + (PMDCS - 1) or more bytes of data outstanding
to that transport address.
If data is available, the sender SHOULD exceed cwnd by up to (PMDCS - 1) bytes
on a new data transmission if the flightsize does not currently reach cwnd.
The breach of cwnd MUST constitute one packet only.¶


C)

When the time comes for the sender to transmit, before sending new
DATA chunks, the sender MUST first transmit any DATA chunks that are marked
for retransmission (limited by the current cwnd).¶


D)

When the time comes for the sender to transmit new DATA chunks, the
protocol parameter 'Max.Burst' SHOULD be used to limit the number of packets sent.
The limit MAY be applied by adjusting cwnd temporarily, as follows:¶

if ((flightsize + Max.Burst * PMDCS) < cwnd)
    cwnd = flightsize + Max.Burst * PMDCS
¶

Or, it MAY be applied by strictly limiting the number of packets emitted by
the output routine.
When calculating the number of packets to transmit, and particularly when
using the formula above, cwnd SHOULD NOT be changed permanently.¶


E)

Then, the sender can send as many new DATA chunks as rule A and rule B
allow.¶



Multiple DATA chunks committed for transmission MAY be bundled in a
single packet.
Furthermore, DATA chunks being retransmitted MAY be bundled with new
DATA chunks, as long as the resulting SCTP packet size does not exceed the PMTU.
A ULP can request that no bundling is performed, but this only turns off
any delays that an SCTP implementation might be using to increase bundling
efficiency.
It does not in itself stop all bundling from occurring (i.e., in case of
congestion or retransmission).¶
Before an endpoint transmits a DATA chunk, if any received DATA
chunks have not been acknowledged (e.g., due to delayed ack), the
sender SHOULD create a SACK chunk and bundle it with the outbound DATA
chunk, as long as the size of the final SCTP packet does not exceed
the current PMTU.
See Section 6.2.¶
When the window is full (i.e., transmission is
disallowed by rule A and/or rule B), the sender MAY still accept send
requests from its upper layer but MUST transmit no more DATA chunks
until some or all of the outstanding DATA chunks are acknowledged and
transmission is allowed by rule A and rule B again.¶
Whenever a transmission or retransmission is made to any address, if
the T3-rtx timer of that address is not currently running, the sender
MUST start that timer.
If the timer for that address is already running, the sender MUST restart
the timer if the earliest (i.e., lowest TSN) outstanding DATA chunk sent to
that address is being retransmitted.
Otherwise, the data sender MUST NOT restart the timer.¶
When starting or restarting the T3-rtx timer, the timer value SHOULD be
adjusted according to the timer rules defined in Sections
6.3.2 and
6.3.3.¶
The data sender MUST NOT use a TSN that is more than 231 - 1 above
the beginning TSN of the current send window.¶
For each stream, the data sender MUST NOT have more than 216 - 1
ordered user messages in the current send window.¶
Whenever the sender of a DATA chunk can benefit from the corresponding
SACK chunk being sent back without delay, the sender MAY set the I bit in the
DATA chunk header.
Please note that why the sender has set the I bit is irrelevant to the
receiver.¶
Reasons for setting the I bit include, but are not limited to, the
following (see Section 4 of [RFC7053] for a discussion of the
benefits):¶


The application requests that the I bit of the last DATA chunk of
a user message be set when providing the user message to the SCTP
implementation (see Section 11.1).¶


The sender is in the SHUTDOWN-PENDING state.¶


The sending of a DATA chunk fills the congestion or receiver window.¶







6.2. Acknowledgement on Reception of DATA Chunks

The SCTP endpoint MUST always acknowledge the reception of each valid
DATA chunk when the DATA chunk received is inside its receive window.¶
When the receiver's advertised window is 0, the receiver MUST drop
any new incoming DATA chunk with a TSN larger than the largest TSN
received so far.
Also, if the new incoming DATA chunk holds a TSN value less than the largest
TSN received so far, then the receiver SHOULD drop the largest TSN held for
reordering and accept the new incoming DATA chunk.
In either case, if such a DATA chunk is dropped, the receiver MUST immediately
send back a SACK chunk with the current receive window showing only DATA chunks
received and accepted so far.
The dropped DATA chunk(s) MUST NOT be included in the SACK chunk, as they were
not accepted.
The receiver MUST also have an algorithm for advertising its receive window
to avoid receiver silly window syndrome (SWS), as described in
[RFC1122].
The algorithm can be similar to the one described in Section 4.2.3.3 of [RFC1122].¶
The guidelines on the delayed acknowledgement algorithm specified in
Section 4.2 of [RFC5681] SHOULD be followed.
Specifically, an acknowledgement SHOULD be generated for at least every
second packet (not every second DATA chunk) received and SHOULD be generated
within 200 ms of the arrival of any unacknowledged DATA chunk.
In some situations, it might be beneficial for an SCTP transmitter to be
more conservative than the algorithms detailed in this document allow.
However, an SCTP transmitter MUST NOT be more aggressive in sending SACK chunks
than the following algorithms allow.¶
An SCTP receiver MUST NOT generate more than one SACK chunk for every
incoming packet, other than to update the offered window as the
receiving application consumes new data.
When the window opens up, an SCTP receiver SHOULD send additional SACK chunks
to update the window even if no new data is received.
The receiver MUST avoid sending a large number of window updates -- in
particular, large bursts of them.
One way to achieve this is to send a window update only if the window can be
increased by at least a quarter of the receive buffer size of the
association.¶
Implementation Note: The maximum delay for generating an acknowledgement
MAY be configured by the SCTP administrator, either statically or dynamically,
in order to meet the specific timing requirement of the protocol being
carried.¶
An implementation MUST NOT allow the maximum delay (protocol parameter
'SACK.Delay') to be configured to be more than 500 ms.
In other words, an implementation MAY lower the value of 'SACK.Delay'
below 500 ms but MUST NOT raise it above 500 ms.¶
Acknowledgements MUST be sent in SACK chunks unless shutdown was
requested by the ULP, in which case an endpoint MAY send an
acknowledgement in the SHUTDOWN chunk.
A SACK chunk can acknowledge the reception of multiple DATA chunks.
See Section 3.3.4 for SACK chunk format.
In particular, the SCTP endpoint MUST fill in the Cumulative TSN Ack field to
indicate the latest sequential TSN (of a valid DATA chunk) it has received.
Any received DATA chunks with TSN greater than the value in the
Cumulative TSN Ack field are reported in the Gap Ack Block fields.
The SCTP endpoint MUST report as many Gap Ack Blocks as can fit in a single SACK
chunk such that the size of the SCTP packet does not exceed the current PMTU.¶
The SHUTDOWN chunk does not contain Gap Ack Block fields.
Therefore, the endpoint SHOULD use a SACK chunk instead of the SHUTDOWN
chunk to acknowledge DATA chunks received out of order.¶
Upon receipt of an SCTP packet containing a DATA chunk with the I bit set,
the receiver SHOULD NOT delay the sending of the corresponding SACK chunk, i.e.,
the receiver SHOULD immediately respond with the corresponding SACK chunk.¶
When a packet arrives with duplicate DATA chunk(s) and with no new
DATA chunk(s), the endpoint MUST immediately send a SACK chunk with no
delay.
If a packet arrives with duplicate DATA chunk(s) bundled with
new DATA chunks, the endpoint MAY immediately send a SACK chunk.
Normally, receipt of duplicate DATA chunks will occur when the original SACK
chunk was lost and the peer's RTO has expired.
The duplicate TSN number(s) SHOULD be reported in the SACK chunk as duplicate.¶
When an endpoint receives a SACK chunk, it MAY use the duplicate TSN
information to determine if SACK chunk loss is occurring.
Further use of this data is for future study.¶
The data receiver is responsible for maintaining its receive buffers.
The data receiver SHOULD notify the data sender in a timely manner of
changes in its ability to receive data.
How an implementation manages its receive buffers is dependent on many
factors (e.g., operating system, memory management system, amount of memory,
etc.).
However, the data sender strategy defined in
Section 6.2.1 is based on the assumption of
receiver operation similar to the following:¶

A)

At initialization of the association, the endpoint tells the peer
how much receive buffer space it has allocated to the association
in the INIT or INIT ACK chunk.
The endpoint sets a_rwnd to this value.¶


B)

As DATA chunks are received and buffered, decrement a_rwnd by the
number of bytes received and buffered.
This is, in effect, closing rwnd at the data sender and restricting the amount
of data it can transmit.¶


C)

As DATA chunks are delivered to the ULP and released from the
receive buffers, increment a_rwnd by the number of bytes delivered
to the upper layer.
This is, in effect, opening up rwnd on the data sender and allowing it to
send more data.
The data receiver SHOULD NOT increment a_rwnd unless it has released bytes
from its receive buffer.
For example, if the receiver is holding fragmented DATA chunks in a reassembly
queue, it SHOULD NOT increment a_rwnd.¶


D)

When sending a SACK chunk, the data receiver SHOULD place the current
value of a_rwnd into the a_rwnd field.
The data receiver SHOULD take into account that the data sender will not
retransmit DATA chunks that are acked via the Cumulative TSN Ack (i.e., will
drop from its retransmit queue).¶



Under certain circumstances, the data receiver MAY drop DATA
chunks that it has received but has not released from its receive
buffers (i.e., delivered to the ULP).
These DATA chunks might have been acked in Gap Ack Blocks.
For example, the data receiver might be holding data in its receive buffers
while reassembling a fragmented user message from its peer when it runs out of
receive buffer space.
It MAY drop these DATA chunks even though it has acknowledged them in
Gap Ack Blocks.
If a data receiver drops DATA chunks, it MUST NOT include them in Gap Ack Blocks
in subsequent SACK chunks until they are received again via retransmission.
In addition, the endpoint SHOULD take into account the dropped data when
calculating its a_rwnd.¶
An endpoint SHOULD NOT revoke a SACK chunk and discard data.
Only in extreme circumstances might an endpoint use this procedure (such as
out of buffer space).
The data receiver SHOULD take into account that dropping data that has been
acked in Gap Ack Blocks can result in suboptimal retransmission strategies in
the data sender and thus in suboptimal performance.¶
The following example illustrates the use of delayed acknowledgements:¶



Endpoint A                                      Endpoint Z

{App sends 3 messages; strm 0}
DATA [TSN=7,Strm=0,Seq=3] ------------> (ack delayed)
(Start T3-rtx timer)

DATA [TSN=8,Strm=0,Seq=4] ------------> (send ack)
                              /------- SACK [TSN Ack=8,block=0]
(cancel T3-rtx timer)  <-----/

DATA [TSN=9,Strm=0,Seq=5] ------------> (ack delayed)
(Start T3-rtx timer)
                                       ...
                                       {App sends 1 message; strm 1}
                                       (bundle SACK with DATA)
                                /----- SACK [TSN Ack=9,block=0] \
                               /         DATA [TSN=6,Strm=1,Seq=2]
(cancel T3-rtx timer)  <------/        (Start T3-rtx timer)

(ack delayed)
(send ack)
SACK [TSN Ack=6,block=0] -------------> (cancel T3-rtx timer)


Figure 7:
Delayed Acknowledgement Example


If an endpoint receives a DATA chunk with no user data (i.e., the
Length field is set to 16), it SHOULD send an ABORT chunk with a ""No User Data""
error cause.¶
An endpoint SHOULD NOT send a DATA chunk with no user data part.
This avoids the need to be able to return a zero-length user
message in the API, especially in the socket API as specified in
[RFC6458] for details.¶



6.2.1. Processing a Received SACK Chunk

Each SACK chunk an endpoint receives contains an a_rwnd value.
This value represents the amount of buffer space the data receiver, at the time
of transmitting the SACK chunk, has left of its total receive buffer space
(as specified in the INIT/INIT ACK chunk).
Using a_rwnd, Cumulative TSN Ack, and Gap Ack Blocks, the data sender can
develop a representation of the peer's receive buffer space.¶
One of the problems the data sender takes into account when
processing a SACK chunk is that a SACK chunk can be received out of order.
That is, a SACK chunk sent by the data receiver can pass an earlier SACK chunk
and be received first by the data sender.
If a SACK chunk is received out of order, the data sender can develop an
incorrect view of the peer's receive buffer space.¶
Since there is no explicit identifier that can be used to detect out-of-order
SACK chunks, the data sender uses heuristics to determine if a SACK chunk is
new.¶
An endpoint SHOULD use the following rules to calculate the rwnd,
using the a_rwnd value, the Cumulative TSN Ack, and Gap Ack Blocks in
a received SACK chunk.¶

A)

At the establishment of the association, the endpoint initializes
the rwnd to the Advertised Receiver Window Credit (a_rwnd) the peer specified
in the INIT or INIT ACK chunk.¶


B)

Any time a DATA chunk is transmitted (or retransmitted) to a peer, the
endpoint subtracts the data size of the chunk from the rwnd of that peer.¶


C)

Any time a DATA chunk is marked for retransmission, either via T3-rtx timer
expiration (Section 6.3.3) or
via Fast Retransmit (Section 7.2.4),
add the data size of those chunks to the rwnd.¶


D)

Any time a SACK chunk arrives, the endpoint performs the following:¶

i)

If Cumulative TSN Ack is less than the Cumulative TSN Ack Point,
then drop the SACK chunk.
Since Cumulative TSN Ack is monotonically increasing, a SACK chunk whose
Cumulative TSN Ack is less than the Cumulative TSN Ack Point indicates an
out-of-order SACK chunk.¶


ii)

Set rwnd equal to the newly received a_rwnd minus the number of bytes still
outstanding after processing the Cumulative TSN Ack and the Gap Ack Blocks.¶


iii)

If the SACK chunk is missing a TSN that was previously acknowledged via
a Gap Ack Block (e.g., the data receiver reneged on the data), then consider
the corresponding DATA that might be possibly missing:
Count one miss indication towards Fast Retransmit as described in
Section 7.2.4,
and if no retransmit timer is running for the destination address to which the
DATA chunk was originally transmitted, then T3-rtx is started for that
destination address.¶


iv)

If the Cumulative TSN Ack matches or exceeds the Fast Recovery exit point
(Section 7.2.4),
Fast Recovery is exited.¶













6.3. Management of Retransmission Timer

An SCTP endpoint uses a retransmission timer T3-rtx to ensure data
delivery in the absence of any feedback from its peer.
The duration of this timer is referred to as RTO (retransmission timeout).¶
When an endpoint's peer is multi-homed, the endpoint will calculate a
separate RTO for each different destination transport address of its
peer endpoint.¶
The computation and management of RTO in SCTP follow closely how TCP
manages its retransmission timer.
To compute the current RTO, an endpoint maintains two state variables per
destination transport address: SRTT (smoothed round-trip time) and
RTTVAR (round-trip time variation).¶



6.3.1. RTO Calculation

The rules governing the computation of SRTT, RTTVAR, and RTO are as follows:¶

C1)

Until an RTT measurement has been made for a packet sent to the given
destination transport address, set RTO to the protocol parameter
'RTO.Initial'.¶


C2)

When the first RTT measurement R is made, perform:¶

SRTT = R
RTTVAR = R/2
RTO = SRTT + 4 * RTTVAR
¶



C3)

When a new RTT measurement R' is made, perform:¶

RTTVAR = (1 - RTO.Beta) * RTTVAR + RTO.Beta * |SRTT - R'|
SRTT = (1 - RTO.Alpha) * SRTT + RTO.Alpha * R'
¶

Note: The value of SRTT used in the update to RTTVAR is its
value before updating SRTT itself using the second assignment.¶
After the computation, update:¶

RTO = SRTT + 4 * RTTVAR
¶



C4)

When data is in flight and when allowed by rule C5 below, a new
RTT measurement MUST be made each round trip.
Furthermore, new RTT measurements SHOULD be made no more than once per
round trip for a given destination transport address.
There are two reasons for this recommendation:
First, it appears that measuring more frequently often does not in practice
yield any significant benefit [ALLMAN99];
second, if measurements are made more often, then the values of 'RTO.Alpha' and
'RTO.Beta' in rule C3 above SHOULD be adjusted so that SRTT and RTTVAR still
adjust to changes at roughly the same rate (in terms of how many round
trips it takes them to reflect new values) as they would if making only one
measurement per round trip and using 'RTO.Alpha' and 'RTO.Beta' as given in rule C3.
However, the exact nature of these adjustments remains a research issue.¶


C5)

Karn's algorithm: RTT measurements MUST NOT be made using chunks that
were retransmitted (and thus for which it is ambiguous whether the reply was
for the first instance of the chunk or for a later instance).¶
RTT measurements SHOULD only be made using a DATA chunk with TSN r if no
DATA chunk with TSN less than or equal to r was retransmitted since the DATA
chunk with TSN r was sent first.¶


C6)

Whenever RTO is computed, if it is less than 'RTO.Min' seconds, then it is
rounded up to 'RTO.Min' seconds.
The reason for this rule is that RTOs that do not have a high minimum value are
susceptible to unnecessary timeouts [ALLMAN99].¶


C7)

A maximum value MAY be placed on RTO, provided it is at least
'RTO.Max' seconds.¶



There is no requirement for the clock granularity G used for computing
RTT measurements and the different state variables, other than:¶

G1)

Whenever RTTVAR is computed, if RTTVAR == 0, then adjust RTTVAR = G.¶



Experience [ALLMAN99] has shown that finer clock granularities
(less than 100 msec) perform somewhat better than more coarse granularities.¶
See Section 16 for suggested parameter values.¶





6.3.2. Retransmission Timer Rules

The rules for managing the retransmission timer are as follows:¶

R1)

Every time a DATA chunk is sent to any address (including a retransmission),
if the T3-rtx timer of that address is not running, start it running so that
it will expire after the RTO of that address.
 The RTO used here is that obtained after any doubling due to previous
T3-rtx timer expirations on the corresponding destination address as discussed
in rule E2 below.¶


R2)

Whenever all outstanding data sent to an address have been acknowledged,
turn off the T3-rtx timer of that address.¶


R3)

Whenever a SACK chunk is received that acknowledges the DATA chunk with
the earliest outstanding TSN for that address, restart the T3-rtx timer for that
address with its current RTO (if there is still outstanding data on that
address).¶


R4)

Whenever a SACK chunk is received missing a TSN that was previously
acknowledged via a Gap Ack Block, start the T3-rtx for the destination address
to which the DATA chunk was originally transmitted if it is not already
running.¶



The following example shows the use of various timer rules (assuming
that the receiver uses delayed acks).¶



Endpoint A                                         Endpoint Z
{App begins to send}
Data [TSN=7,Strm=0,Seq=3] ------------> (ack delayed)
(Start T3-rtx timer)
                                        {App sends 1 message; strm 1}
                                        (bundle ack with data)
DATA [TSN=8,Strm=0,Seq=4] ----\     /-- SACK [TSN Ack=7,Block=0]
                               \   /      DATA [TSN=6,Strm=1,Seq=2]
                                \ /     (Start T3-rtx timer)
                                 \
                                / \
(Restart T3-rtx timer)  <------/   \--> (ack delayed)
(ack delayed)
{send ack}
SACK [TSN Ack=6,Block=0] --------------> (Cancel T3-rtx timer)
                                        ..
                                        (send ack)
(Cancel T3-rtx timer)  <-------------- SACK [TSN Ack=8,Block=0]


Figure 8:
Timer Rule Examples







6.3.3. Handle T3-rtx Expiration

Whenever the retransmission timer T3-rtx expires for a destination address,
do the following:¶

E1)

For the destination address for which the timer expires, adjust its ssthresh
with rules defined in Section 7.2.3 and set
cwnd = PMDCS.¶


E2)

For the destination address for which the timer expires, set
RTO = RTO * 2 (""back off the timer"").
The maximum value discussed in rule C7 above ('RTO.Max') MAY be used to provide
an upper bound to this doubling operation.¶


E3)

Determine how many of the earliest (i.e., lowest TSN) outstanding
DATA chunks for the address for which the T3-rtx has expired will fit into a
single SCTP packet, subject to the PMTU corresponding to the
destination transport address to which the retransmission is being sent
(this might be different from the address for which the timer expires;
see Section 6.4).
Call this value K.
Bundle and retransmit those K DATA chunks in a single packet to the destination
endpoint.¶


E4)

Start the retransmission timer T3-rtx on the destination address to which
the retransmission is sent if rule R1 above indicates to do so.
The RTO to be used for starting T3-rtx SHOULD be the one for the destination
address to which the retransmission is sent, which, when the receiver is
multi-homed, might be different from the destination address for which the
timer expired (see Section 6.4 below).¶



After retransmitting, once a new RTT measurement is obtained (which can
happen only when new data has been sent and acknowledged, per rule C5,
or for a measurement made from a HEARTBEAT chunk;
see Section 8.3), the computation in rule C3 is
performed, including the computation of RTO, which might result in ""collapsing""
RTO back down after it has been subject to doubling (rule E2).¶
Any DATA chunks that were sent to the address for which the
T3-rtx timer expired but did not fit in an SCTP packet of size smaller than or
equal to the PMTU (rule E3 above) SHOULD be marked for retransmission and sent
as soon as cwnd allows (normally, when a SACK chunk arrives).¶
The final rule for managing the retransmission timer concerns failover
(see Section 6.4.1):¶

F1)

Whenever an endpoint switches from the current destination
transport address to a different one, the current retransmission
timers are left running.
As soon as the endpoint transmits a packet containing DATA chunk(s) to the
new transport address, start the timer on that transport address, using the
RTO value of the destination address to which the data is being sent, if
rule R1 indicates to do so.¶










6.4. Multi-Homed SCTP Endpoints

An SCTP endpoint is considered multi-homed if there is more than one
transport address that can be used as a destination address to reach that
endpoint.¶
Moreover, the ULP of an endpoint selects one of the multiple
destination addresses of a multi-homed peer endpoint as the primary
path (see Sections 5.1.2 and
11.1 for details).¶
By default, an endpoint SHOULD always transmit to the primary path,
unless the SCTP user explicitly specifies the destination transport
address (and possibly source transport address) to use.¶
An endpoint SHOULD transmit reply chunks (e.g., INIT ACK, COOKIE ACK, and
HEARTBEAT ACK) in response to control chunks to the same destination
transport address from which it received the control chunk to which
it is replying.¶
The selection of the destination transport address for packets
containing SACK chunks is implementation dependent.
However, an endpoint SHOULD NOT vary the destination transport address of
a SACK chunk when it receives DATA chunks coming from the same source
address.¶
When acknowledging multiple DATA chunks received in packets
from different source addresses in a single SACK chunk, the SACK chunk MAY
be transmitted to one of the destination transport addresses from
which the DATA or control chunks being acknowledged were received.¶
When a receiver of a duplicate DATA chunk sends a SACK chunk to a multi-homed
endpoint, it MAY be beneficial to vary the destination address
and not use the source address of the DATA chunk.
The reason is that receiving a duplicate from a multi-homed endpoint might
indicate that the return path (as specified in the source address of the DATA
chunk) for the SACK chunk is broken.¶
Furthermore, when its peer is multi-homed, an endpoint SHOULD try to
retransmit a chunk that timed out to an active destination transport
address that is different from the last destination address to which
the chunk was sent.¶
When its peer is multi-homed, an endpoint SHOULD send fast retransmissions
to the same destination transport address to which the original data was sent.
If the primary path has been changed and the original data was sent to the
old primary path before the Fast Retransmit, the implementation MAY send it to
the new primary path.¶
Retransmissions do not affect the total outstanding data count.
However, if the DATA chunk is retransmitted onto a different destination
address, both the outstanding data counts on the new destination address and
the old destination address to which the data chunk was last sent is
adjusted accordingly.¶



6.4.1. Failover from an Inactive Destination Address

Some of the transport addresses of a multi-homed SCTP endpoint might become
inactive due to either the occurrence of certain error conditions
(see Section 8.2) or adjustments from the
SCTP user.¶
When there is outbound data to send and the primary path becomes inactive
(e.g., due to failures) or where the SCTP user explicitly requests to send data
to an inactive destination transport address before reporting an error to its
ULP, the SCTP endpoint SHOULD try to send the data to an alternate active
destination transport address if one exists.¶
When retransmitting data that timed out, if the endpoint is multi-homed,
it needs to consider each source-destination address pair in its
retransmission selection policy.
When retransmitting timed-out data, the endpoint SHOULD attempt to pick the
most divergent source-destination pair from the original source-destination
pair to which the packet was transmitted.¶
Note: Rules for picking the most divergent source-destination pair
are an implementation decision and are not specified within this document.¶







6.5. Stream Identifier and Stream Sequence Number

Every DATA chunk MUST carry a valid stream identifier.
If an endpoint receives a DATA chunk with an invalid stream identifier, it
SHOULD acknowledge the reception of the DATA chunk following the
normal procedure, immediately send an ERROR chunk with cause set to
""Invalid Stream Identifier"" (see Section 3.3.10),
and discard the DATA chunk.
The endpoint MAY bundle the ERROR chunk and the SACK chunk in the same
packet.¶
The Stream Sequence Number in all the outgoing streams MUST start from 0 when
the association is established.
The Stream Sequence Number of an outgoing stream MUST be incremented by 1 for
each ordered user message sent on that outgoing stream.
In particular, when the Stream Sequence Number reaches the value 65535, the
next Stream Sequence Number MUST be set to 0.
For unordered user messages, the Stream Sequence Number MUST NOT be changed.¶





6.6. Ordered and Unordered Delivery

Within a stream, an endpoint MUST deliver DATA chunks received with
the U flag set to 0 to the upper layer according to the order of
their Stream Sequence Number.
If DATA chunks arrive out of order of their Stream Sequence Number,
the endpoint MUST hold the received DATA chunks from delivery to the ULP until
they are reordered.¶
However, an SCTP endpoint can indicate that no ordered delivery is
required for a particular DATA chunk transmitted within the stream by
setting the U flag of the DATA chunk to 1.¶
When an endpoint receives a DATA chunk with the U flag set to 1, it
bypasses the ordering mechanism and immediately deliver the data
to the upper layer (after reassembly if the user data is fragmented
by the data sender).¶
This provides an effective way of transmitting ""out-of-band"" data in
a given stream.
Also, a stream can be used as an ""unordered"" stream by simply setting the
U flag to 1 in all DATA chunks sent through that stream.¶
Implementation Note: When sending an unordered DATA chunk, an implementation
MAY choose to place the DATA chunk in an outbound packet that is at the head of
the outbound transmission queue if possible.¶
The 'Stream Sequence Number' field in a DATA chunk with U flag set to
1 has no significance.
The sender can fill the 'Stream Sequence Number' with arbitrary value, but
the receiver MUST ignore the field.¶
Note: When transmitting ordered and unordered data, an endpoint does
not increment its Stream Sequence Number when transmitting a DATA chunk with
U flag set to 1.¶





6.7. Report Gaps in Received DATA TSNs

Upon the reception of a new DATA chunk, an endpoint examines the
continuity of the TSNs received.
If the endpoint detects a gap in the received DATA chunk sequence, it SHOULD
send a SACK chunk with Gap Ack Blocks immediately.
The data receiver continues sending a SACK chunk after receipt of each
SCTP packet that does not fill the gap.¶
Based on the Gap Ack Block from the received SACK chunk, the endpoint can
calculate the missing DATA chunks and make decisions on whether to
retransmit them (see Section 6.2.1
for details).¶
Multiple gaps can be reported in one single SACK chunk
(see Section 3.3.4).¶
When its peer is multi-homed, the SCTP endpoint SHOULD always try to
send the SACK chunk to the same destination address from which the last
DATA chunk was received.¶
Upon the reception of a SACK chunk, the endpoint MUST remove all DATA chunks
that have been acknowledged by the SACK chunk's Cumulative TSN Ack from its
transmit queue.
All DATA chunks with TSNs not included in the Gap Ack Blocks that are smaller
than the highest-acknowledged TSN reported in the SACK chunk MUST be treated as
""missing"" by the sending endpoint.
The number of ""missing"" reports for each outstanding DATA chunk MUST be
recorded by the data sender to make retransmission decisions.
See Section 7.2.4 for details.¶
The following example shows the use of SACK chunk to report a gap.¶



Endpoint A                                    Endpoint Z
{App sends 3 messages; strm 0}
DATA [TSN=6,Strm=0,Seq=2] ---------------> (ack delayed)
(Start T3-rtx timer)

DATA [TSN=7,Strm=0,Seq=3] --------> X (lost)

DATA [TSN=8,Strm=0,Seq=4] ---------------> (gap detected,
                                            immediately send ack)
                                /----- SACK [TSN Ack=6,Block=1,
                               /             Start=2,End=2]
                        <-----/
(remove 6 from out-queue,
 and mark 7 as ""1"" missing report)


Figure 9:
Reporting a Gap Using SACK Chunk


The maximum number of Gap Ack Blocks that can be reported within a
single SACK chunk is limited by the current PMTU.
When a single SACK chunk cannot cover all the Gap Ack Blocks needed to be
reported due to the PMTU limitation, the endpoint MUST send only one SACK chunk.
This single SACK chunk MUST report the Gap Ack Blocks from the lowest to
highest TSNs, within the size limit set by the PMTU, and leave the remaining
highest TSN numbers unacknowledged.¶





6.8. CRC32c Checksum Calculation

When sending an SCTP packet, the endpoint MUST strengthen the data integrity
of the transmission by including the CRC32c checksum value calculated on the
packet, as described below.¶
After the packet is constructed (containing the SCTP common header
and one or more control or DATA chunks), the transmitter MUST:¶

1)

fill in the proper Verification Tag in the SCTP common header and initialize
the checksum field to 0,¶


2)

calculate the CRC32c checksum of the whole packet, including the SCTP common
header and all the chunks (refer to Appendix A for details of
the CRC32c algorithm), and¶


3)

put the resultant value into the checksum field in the common header and
leave the rest of the bits unchanged.¶



When an SCTP packet is received, the receiver MUST first check the CRC32c
checksum as follows:¶

1)

Store the received CRC32c checksum value aside.¶


2)

Replace the 32 bits of the checksum field in the received SCTP packet with
0 and calculate a CRC32c checksum value of the whole received packet.¶


3)

Verify that the calculated CRC32c checksum is the same as the received
CRC32c checksum.
If it is not, the receiver MUST treat the packet as an invalid SCTP packet.¶



The default procedure for handling invalid SCTP packets is to silently
discard them.¶
Any hardware implementation SHOULD permit alternative verification of the
CRC in software.¶





6.9. Fragmentation and Reassembly

An endpoint MAY support fragmentation when sending DATA chunks, but
it MUST support reassembly when receiving DATA chunks.
If an endpoint supports fragmentation, it MUST fragment a user message if
the size of the user message to be sent causes the outbound SCTP
packet size to exceed the current PMTU.
An endpoint that does not support fragmentation and is requested to send a
user message such that the outbound SCTP packet size would exceed the
current PMTU MUST return an error to its upper layer and MUST NOT attempt to
send the user message.¶
An SCTP implementation MAY provide a mechanism to the upper layer that
disables fragmentation when sending DATA chunks.
When fragmentation of DATA chunks is disabled, the SCTP implementation MUST
behave in the same way an implementation that does not support fragmentation,
i.e., it  rejects calls that would result in sending SCTP packets that exceed
the current PMTU.¶
Implementation Note: In this error case, the SEND primitive discussed
in Section 11.1.5 would need to return an error to the
upper layer.¶
If its peer is multi-homed, the endpoint SHOULD choose a DATA chunk size
smaller than or equal to the AMDCS.¶
Once a user message is fragmented, it cannot be re-fragmented.
Instead, if the PMTU has been reduced, then IP fragmentation MUST be used.
Therefore, an SCTP association can fail if IP fragmentation is not working on
any path.
Please see Section 7.3 for details of
PMTU discovery.¶
When determining when to fragment, the SCTP implementation MUST take
into account the SCTP packet header as well as the DATA chunk header(s).
The implementation MUST also take into account the space required for a SACK
chunk if bundling a SACK chunk with the DATA chunk.¶
Fragmentation takes the following steps:¶

1)

The data sender MUST break the user message into a series of DATA chunks.
The sender SHOULD choose a size of DATA chunks that is smaller than or equal
to the AMDCS.¶


2)

The transmitter MUST then assign, in sequence, a separate TSN to each of the
DATA chunks in the series.
The transmitter assigns the same Stream Sequence Number to each of the
DATA chunks.
If the user indicates that the user message is to be delivered using unordered
delivery, then the U flag of each DATA chunk of the user message MUST be set
to 1.¶


3)

The transmitter MUST also set the B/E bits of the first DATA chunk in the
series to 10, the B/E bits of the last DATA chunk in the series to 01,
and the B/E bits of all other DATA chunks in the series to 00.¶



An endpoint MUST recognize fragmented DATA chunks by examining the B/E bits
in each of the received DATA chunks and queue the fragmented DATA chunks for
reassembly.
Once the user message is reassembled, SCTP passes the reassembled user
message to the specific stream for possible reordering and final
dispatching.¶
If the data receiver runs out of buffer space while still waiting for
more fragments to complete the reassembly of the message, it SHOULD dispatch
part of its inbound message through a partial delivery API
(see Section 11), freeing some of its receive buffer space so
that the rest of the message can be received.¶





6.10. Bundling

An endpoint bundles chunks by simply including multiple chunks in one
outbound SCTP packet.
The total size of the resultant SCTP packet MUST be less that or equal to the
current PMTU.¶
If its peer endpoint is multi-homed, the sending endpoint SHOULD choose a
size no larger than the PMTU of the current primary path.¶
When bundling control chunks with DATA chunks, an endpoint MUST place
control chunks first in the outbound SCTP packet.
The transmitter MUST transmit DATA chunks within an SCTP packet in increasing
order of TSN.¶
Note: Since control chunks are placed first in a packet and since
DATA chunks are transmitted before SHUTDOWN or SHUTDOWN ACK
chunks, DATA chunks cannot be bundled with SHUTDOWN or SHUTDOWN ACK
chunks.¶
Partial chunks MUST NOT be placed in an SCTP packet.
A partial chunk is a chunk that is not completely contained in the SCTP packet;
i.e., the SCTP packet is too short to contain all the bytes of the chunk as
indicated by the chunk length.¶
An endpoint MUST process received chunks in their order in the packet.
The receiver uses the Chunk Length field to determine the end of a chunk
and beginning of the next chunk, taking account of the
fact that all chunks end on a 4-byte boundary.
If the receiver detects a partial chunk, it MUST drop the chunk.¶
An endpoint MUST NOT bundle INIT, INIT ACK, or SHUTDOWN COMPLETE chunks
with any other chunks.¶







7. Congestion Control

Congestion control is one of the basic functions in SCTP.
To manage congestion, the mechanisms and algorithms in this section are to be
employed.¶
Implementation Note: As far as its specific performance requirements
are met, an implementation is always allowed to adopt a more conservative
congestion control algorithm than the one defined below.¶
The congestion control algorithms used by SCTP are based on
[RFC5681].
This section describes how the algorithms defined in [RFC5681]
are adapted for use in SCTP.
We first list differences in protocol designs between TCP and SCTP and then
describe SCTP's congestion control scheme.
The description will use the same terminology as in TCP congestion control
whenever appropriate.¶
SCTP congestion control is always applied to the entire association
and not to individual streams.¶



7.1. SCTP Differences from TCP Congestion Control

Gap Ack Blocks in the SCTP SACK chunk carry the same semantic meaning as the
TCP SACK.
TCP considers the information carried in the SACK as advisory information only.
SCTP considers the information carried in the Gap Ack Blocks in the SACK chunk
as advisory.
In SCTP, any DATA chunk that has been acknowledged by a SACK chunk, including
DATA that arrived at the receiving end out of order, is not considered fully
delivered until the Cumulative TSN Ack Point passes the TSN of the DATA chunk
(i.e., the DATA chunk has been acknowledged by the Cumulative TSN Ack
field in the SACK chunk).
Consequently, the value of cwnd controls the amount of outstanding data,
rather than (as in the case of non-SACK TCP) the upper bound between the
highest acknowledged sequence number and the latest DATA chunk that can be
sent within the congestion window.
SCTP SACK leads to different implementations of Fast Retransmit and Fast
Recovery than non-SACK TCP.
As an example, see [FALL96].¶
The biggest difference between SCTP and TCP, however, is multi-homing.
SCTP is designed to establish robust communication associations between
two endpoints, each of which might be reachable by more than one transport address.
Potentially different addresses might lead to different data paths between the
two endpoints;
thus, ideally, one needs a separate set of congestion control parameters for
each of the paths.
The treatment here of congestion control for multi-homed receivers is new with
SCTP and might require refinement in the future.
The current algorithms make the following assumptions:¶


The sender usually uses the same destination address until being instructed
by the upper layer to do otherwise; however, SCTP MAY change to an alternate
destination in the event an address is marked inactive
(see Section 8.2).
Also, SCTP MAY retransmit to a different transport address than the original
transmission.¶


The sender keeps a separate congestion control parameter set for each of
the destination addresses it can send to (not each source-destination pair but
for each destination).
The parameters SHOULD decay if the address is not used for a long enough time
period.
[RFC5681] specifies this period of time as a retransmission
timeout.¶


For each of the destination addresses, an endpoint does slow start upon
the first transmission to that address.¶


Note: TCP guarantees in-sequence delivery of data to its upper-layer
protocol within a single TCP session.
This means that when TCP notices a gap in the received sequence number, it
waits until the gap is filled before delivering the data that was received
with sequence numbers higher than that of the missing data.
On the other hand, SCTP can deliver data to its upper-layer protocol, even if
there is a gap in TSN if the Stream Sequence Numbers are in sequence for a
particular stream (i.e., the missing DATA chunks are for a different stream)
or if unordered delivery is indicated.
Although this does not affect cwnd, it might affect rwnd calculation.¶





7.2. SCTP Slow-Start and Congestion Avoidance

The slow-start and congestion avoidance algorithms MUST be used by an
endpoint to control the amount of data being injected into the network.
The congestion control in SCTP is employed in regard to the association, not
to an individual stream.
In some situations, it might be beneficial for an SCTP sender to be more
conservative than the algorithms allow;
however, an SCTP sender MUST NOT be more aggressive than the following
algorithms allow.¶
Like TCP, an SCTP endpoint uses the following three control variables
to regulate its transmission rate.¶


Receiver advertised window size (rwnd, in bytes), which is set by the
receiver based on its available buffer space for incoming packets.¶
Note: This variable is kept on the entire association.¶


Congestion control window (cwnd, in bytes), which is adjusted by the sender
based on observed network conditions.¶
Note: This variable is maintained on a per-destination-address basis.¶


Slow-start threshold (ssthresh, in bytes), which is used by the
sender to distinguish slow-start and congestion avoidance phases.¶
Note: This variable is maintained on a per-destination-address basis.¶


SCTP also requires one additional control variable, partial_bytes_acked,
which is used during the congestion avoidance phase to facilitate cwnd
adjustment.¶
Unlike TCP, an SCTP sender MUST keep a set of the control variables
cwnd, ssthresh, and partial_bytes_acked for EACH destination address
of its peer (when its peer is multi-homed).
When calculating one of these variables, the length of the DATA chunk, including
the padding, SHOULD be used.¶
Only one rwnd is kept for the whole association (no matter if the peer is
multi-homed or has a single address).¶



7.2.1. Slow-Start

Beginning data transmission into a network with unknown conditions or
after a sufficiently long idle period requires SCTP to probe the
network to determine the available capacity.
The slow-start algorithm is used for this purpose at the beginning of a
transfer or after repairing loss detected by the retransmission timer.¶


The initial cwnd before data transmission MUST be set to
min(4 * PMDCS, max(2 * PMDCS, 4404)) bytes if the peer address is an IPv4 address
and to min(4 * PMDCS, max(2 * PMDCS, 4344)) bytes if the peer address is an
IPv6 address.¶


The initial cwnd after a retransmission timeout MUST be no more than
PMDCS, and only one packet is allowed to be in flight until successful
acknowledgement.¶


The initial value of ssthresh SHOULD be arbitrarily high (e.g.,
the size of the largest-possible advertised window).¶


Whenever cwnd is greater than zero, the endpoint is allowed to have cwnd
bytes of data outstanding on that transport address.
A limited overbooking as described in rule B in 
Section 6.1 SHOULD be supported.¶


When cwnd is less than or equal to ssthresh, an SCTP endpoint MUST
use the slow-start algorithm to increase cwnd only if the current
congestion window is being fully utilized and the data sender is not in
Fast Recovery.
Only when these two conditions are met can the cwnd be increased;
otherwise, the cwnd MUST NOT be increased.
If these conditions are met, then cwnd MUST be increased by, at most, the
lesser of¶


the total size of the previously outstanding DATA chunk(s) acknowledged and¶


L times the destination's PMDCS.¶


The first upper bound protects against the ACK-Splitting attack outlined in
[SAVAGE99].
The positive integer L SHOULD be 1 and MAY be larger than 1.
See [RFC3465] for details of choosing L.¶
In instances where its peer endpoint is multi-homed, if an endpoint
receives a SACK chunk that results in updating the cwnd, then it SHOULD update
its cwnd (or cwnds) apportioned to the destination addresses to which it
transmitted the acknowledged data.¶


While the endpoint does not transmit data on a given transport address,
the cwnd of the transport address SHOULD be adjusted to max(cwnd / 2, 4 * PMDCS)
once per RTO.
Before the first cwnd adjustment, the ssthresh of the transport address SHOULD
be set to the cwnd.¶







7.2.2. Congestion Avoidance

When cwnd is greater than ssthresh, cwnd SHOULD be incremented by PMDCS per
RTT if the sender has cwnd or more bytes of data outstanding for the
corresponding transport address.
The basic recommendations for incrementing cwnd during congestion avoidance
are as follows:¶


SCTP MAY increment cwnd by PMDCS.¶


SCTP SHOULD increment cwnd by PMDCS once per RTT when the sender has cwnd
or more bytes of data outstanding for the corresponding transport address.¶


SCTP MUST NOT increment cwnd by more than PMDCS per RTT.¶


In practice, an implementation can achieve this goal in the following way:¶


partial_bytes_acked is initialized to 0.¶


Whenever cwnd is greater than ssthresh, upon each SACK chunk arrival,
increase partial_bytes_acked by the total number of bytes (including the chunk
header and the padding) of all new DATA chunks acknowledged in that SACK chunk,
including chunks acknowledged by the new Cumulative TSN Ack, by Gap Ack Blocks,
and by the number of bytes of duplicated chunks reported in
Duplicate TSNs.¶


When (1) partial_bytes_acked is greater than cwnd and (2) before the arrival
of the SACK chunk the sender had less than cwnd bytes of data outstanding (i.e.,
before the arrival of the SACK chunk, flightsize was less than cwnd), reset
partial_bytes_acked to cwnd.¶


When (1) partial_bytes_acked is equal to or greater than cwnd and (2) before
the arrival of the SACK chunk the sender had cwnd or more bytes of data outstanding
(i.e., before the arrival of the SACK chunk, flightsize was greater than or equal to
cwnd), partial_bytes_acked is reset to (partial_bytes_acked - cwnd).
Next, cwnd is increased by PMDCS.¶


Same as in the slow start, when the sender does not transmit DATA chunks
on a given transport address, the cwnd of the transport address SHOULD be
adjusted to max(cwnd / 2, 4 * PMDCS) per RTO.¶


When all of the data transmitted by the sender has been acknowledged by the
receiver, partial_bytes_acked is initialized to 0.¶







7.2.3. Congestion Control

Upon detection of packet losses from SACK chunks
(see Section 7.2.4), an endpoint SHOULD
do the following:¶

ssthresh = max(cwnd / 2, 4 * PMDCS)
cwnd = ssthresh
partial_bytes_acked = 0
¶

Basically, a packet loss causes cwnd to be cut in half.¶
When the T3-rtx timer expires on an address, SCTP SHOULD perform slow start
by:¶

ssthresh = max(cwnd / 2, 4 * PMDCS)
cwnd = PMDCS
partial_bytes_acked = 0
¶

and ensure that no more than one SCTP packet will be in flight for that address
until the endpoint receives acknowledgement for successful delivery of data to
that address.¶





7.2.4. Fast Retransmit on Gap Reports

In the absence of data loss, an endpoint performs delayed acknowledgement.
However, whenever an endpoint notices a hole in the arriving TSN sequence, it
SHOULD start sending a SACK chunk back every time a packet arrives carrying data
until the hole is filled.¶
Whenever an endpoint receives a SACK chunk that indicates that some TSNs are
missing, it SHOULD wait for two further miss indications (via subsequent SACK
chunks for a total of three missing reports) on the same TSNs before taking 
action with regard to Fast Retransmit.¶
Miss indications SHOULD follow the Highest TSN Newly Acknowledged (HTNA)
algorithm.
For each incoming SACK chunk, miss indications are incremented only for
missing TSNs prior to the HTNA in the SACK chunk.
A newly acknowledged DATA chunk is one not previously acknowledged in a
SACK chunk.
If an endpoint is in Fast Recovery and a SACK chunks arrives that advances the
Cumulative TSN Ack Point, the miss indications are incremented for all TSNs
reported missing in the SACK chunk.¶
When the third consecutive miss indication is received for one or more TSNs,
the data sender does the following:¶

1)

Mark the DATA chunk(s) with three miss indications for retransmission.¶


2)

If not in Fast Recovery, adjust the ssthresh and cwnd of the destination
address(es) to which the missing DATA chunks were last sent, according to the
formula described in Section 7.2.3.¶


3)

If not in Fast Recovery, determine how many of the earliest
(i.e., lowest TSN) DATA chunks marked for retransmission will fit
into a single packet, subject to constraint of the PMTU of
the destination transport address to which the packet is being sent.
Call this value K.
Retransmit those K DATA chunks in a single packet.
When a Fast Retransmit is being performed, the sender SHOULD ignore the value
of cwnd and SHOULD NOT delay retransmission for this single packet.¶


4)

Restart the T3-rtx timer only if the last SACK chunk acknowledged the
lowest outstanding TSN number sent to that address or the endpoint is
retransmitting the first outstanding DATA chunk sent to that address.¶


5)

Mark the DATA chunk(s) as being fast retransmitted and thus ineligible for a
subsequent Fast Retransmit.  Those TSNs marked for retransmission due to the Fast-Retransmit algorithm that
did not fit in the sent datagram carrying K other TSNs are also marked as
ineligible for a subsequent Fast Retransmit.
However, as they are marked for retransmission, they will be retransmitted
later on as soon as cwnd allows.¶


6)

If not in Fast Recovery, enter Fast Recovery and mark the highest
outstanding TSN as the Fast Recovery exit point.
When a SACK chunk acknowledges all TSNs up to and including this exit point,
Fast Recovery is exited.
While in Fast Recovery, the ssthresh and cwnd SHOULD NOT change for any
destinations due to a subsequent Fast Recovery event (i.e., one SHOULD NOT
reduce the cwnd further due to a subsequent Fast Retransmit).¶



Note: Before the above adjustments, if the received SACK chunk also
acknowledges new DATA chunks and advances the Cumulative TSN Ack Point,
the cwnd adjustment rules defined in Sections 7.2.1 and
7.2.2 MUST be applied first.¶




7.2.5. Reinitialization

During the lifetime of an SCTP association, events can happen that result
in using the network under unknown new conditions.
When detected by an SCTP implementation, the congestion control MUST be
reinitialized.¶


7.2.5.1. Change of Differentiated Services Code Points

SCTP implementations MAY allow an application to configure the
Differentiated Services Code Point (DSCP) used for sending packets.
If a DSCP change might result in outgoing packets being queued in
different queues, the congestion control parameters for all affected
destination addresses MUST be reset to their initial values.¶



7.2.5.2. Change of Routes

SCTP implementations MAY be aware of routing changes affecting packets
sent to a destination address.
In particular, this includes the selection of a different source address used
for sending packets to a destination address.
If such a routing change happens, the congestion control parameters for the
affected destination addresses MUST be reset to their initial values.¶







7.3. PMTU Discovery

[RFC8899],
[RFC8201], and [RFC1191] specify
""Packetization Layer Path MTU Discovery"",
whereby an endpoint maintains an estimate of PMTU along a given Internet path
and refrains from sending packets along that path that exceed the PMTU, other
than occasional attempts to probe for a change in the PMTU.
[RFC8899] is thorough in its
discussion of the PMTU discovery mechanism and strategies for determining the
current end-to-end PMTU setting as well as detecting changes in this value.¶
An endpoint SHOULD apply these techniques and SHOULD do so on a
per-destination-address basis.¶
There are two important SCTP-specific points regarding PMTU discovery:¶

1)

SCTP associations can span multiple addresses.
An endpoint MUST maintain separate PMTU estimates for each destination address
of its peer.¶


2)

The sender SHOULD track an AMDCS that will be the
smallest PMDCS discovered for all of the peer's destination addresses.
When fragmenting messages into multiple parts, this AMDCS SHOULD
be used to calculate the size of each DATA chunk.
This will allow retransmissions to be seamlessly sent to an alternate address
without encountering IP fragmentation.¶










8. Fault Management




8.1. Endpoint Failure Detection

An endpoint SHOULD keep a counter on the total number of consecutive
retransmissions to its peer (this includes data retransmissions to all the
destination transport addresses of the peer if it is multi-homed), including
the number of unacknowledged HEARTBEAT chunks observed on the path that is
currently used for data transfer.
Unacknowledged HEARTBEAT chunks observed on paths different from the
path currently used for data transfer SHOULD NOT increment the association
error counter, as this could lead to association closure even if the path
that is currently used for data transfer is available (but idle).
If the value of this counter exceeds the limit indicated in the protocol
parameter 'Association.Max.Retrans', the endpoint SHOULD consider the peer
endpoint unreachable and SHALL stop transmitting any more data to it
(and thus the association enters the CLOSED state).
In addition, the endpoint SHOULD report the failure to the upper layer and
optionally report back all outstanding user data remaining in its outbound
queue.
The association is automatically closed when the peer endpoint becomes
unreachable.¶
The counter used for endpoint failure detection MUST be reset each time a
DATA chunk sent to that peer endpoint is acknowledged (by the reception of
a SACK chunk).
When a HEARTBEAT ACK chunk is received from the peer endpoint, the counter
SHOULD also be reset.
The receiver of the HEARTBEAT ACK chunk MAY choose not to clear the counter
if there is outstanding data on the association.
This allows for handling the possible difference in reachability based on
DATA chunks and HEARTBEAT chunks.¶





8.2. Path Failure Detection

When its peer endpoint is multi-homed, an endpoint SHOULD keep an
error counter for each of the destination transport addresses of the
peer endpoint.¶
Each time the T3-rtx timer expires on any address, or when a
HEARTBEAT chunk sent to an idle address is not acknowledged within an RTO,
the error counter of that destination address will be incremented.
When the value in the error counter exceeds the protocol parameter
'Path.Max.Retrans' of that destination address, the endpoint SHOULD
mark the destination transport address as inactive, and a
notification SHOULD be sent to the upper layer.¶
When an outstanding TSN is acknowledged or a HEARTBEAT chunk sent to that
address is acknowledged with a HEARTBEAT ACK chunk, the endpoint SHOULD
clear the error counter of the destination transport address to which
the DATA chunk was last sent (or HEARTBEAT chunk was sent) and SHOULD also
report to the upper layer when an inactive destination address is
marked as active.
When the peer endpoint is multi-homed and the last chunk sent to it was a
retransmission to an alternate address, there exists an ambiguity as
 to whether or not the acknowledgement could be credited to the
address of the last chunk sent.
However, this ambiguity does not seem to have significant consequences for
SCTP behavior.
If this ambiguity is undesirable, the transmitter MAY choose not to clear the
error counter if the last chunk sent was a retransmission.¶
Note: When configuring the SCTP endpoint, the user ought to avoid having the
value of 'Association.Max.Retrans' larger than the summation of the
'Path.Max.Retrans' of all the destination addresses for the remote endpoint.
Otherwise, all the destination addresses might become inactive while the endpoint
still considers the peer endpoint reachable.
When this condition occurs, how SCTP chooses to function is implementation
specific.¶
When the primary path is marked inactive (due to excessive retransmissions,
for instance), the sender MAY automatically transmit new packets to an
alternate destination address if one exists and is active.
If more than one alternate address is active when the primary path is marked
inactive, only ONE transport address SHOULD be chosen and used as the new
destination transport address.¶





8.3. Path Heartbeat

By default, an SCTP endpoint SHOULD monitor the reachability of the
idle destination transport address(es) of its peer by sending a
HEARTBEAT chunk periodically to the destination transport address(es).
The sending of HEARTBEAT chunks MAY begin upon reaching the ESTABLISHED state
and is discontinued after sending either a SHUTDOWN chunk or SHUTDOWN ACK chunk.
A receiver of a HEARTBEAT chunk MUST respond to a HEARTBEAT chunk with a
HEARTBEAT ACK chunk after entering the COOKIE-ECHOED state (sender of the
INIT chunk) or the ESTABLISHED state (receiver of the INIT chunk), up until
reaching the SHUTDOWN-SENT state (sender of the SHUTDOWN chunk)
or the SHUTDOWN-ACK-SENT state (receiver of the SHUTDOWN chunk).¶
A destination transport address is considered ""idle"" if no new chunk
that can be used for updating path RTT (usually including first transmission
DATA, INIT, COOKIE ECHO, or HEARTBEAT chunks, etc.) and no HEARTBEAT chunk
has been sent to it within the current heartbeat period of that address.
This applies to both active and inactive destination addresses.¶
The upper layer can optionally initiate the following functions:¶

A)

Disable heartbeat on a specific destination transport address of a
given association,¶


B)

Change the 'HB.interval',¶


C)

Re-enable heartbeat on a specific destination transport address of a given
association, and¶


D)

Request the sending of an on-demand HEARTBEAT chunk on a specific
destination transport address of a given association.¶



The endpoint SHOULD increment the respective error counter of the destination
transport address each time a HEARTBEAT chunk is sent to that address and not
acknowledged within one RTO.¶
When the value of this counter exceeds the protocol parameter
'Path.Max.Retrans', the endpoint SHOULD mark the corresponding destination
address as inactive if it is not so marked and SHOULD also report to
the upper layer the change in reachability of this destination address.
After this, the endpoint SHOULD continue sending HEARTBEAT chunks on this
destination address but SHOULD stop increasing the counter.¶
The sender of the HEARTBEAT chunk SHOULD include in the Heartbeat Information
field of the chunk the current time when the packet is sent and the
destination address to which the packet is sent.¶
Implementation Note: An alternative implementation of the heartbeat
mechanism that can be used is to increment the error counter variable every time
a HEARTBEAT chunk is sent to a destination.
Whenever a HEARTBEAT ACK chunk arrives, the sender SHOULD clear the error
counter of the destination that the HEARTBEAT chunk was sent to.
This, in effect, would clear the previously stroked error (and any other error
counts as well).¶
The receiver of the HEARTBEAT chunk SHOULD immediately respond with a
HEARTBEAT ACK chunk that contains the Heartbeat Information TLV, together with
any other received TLVs, copied unchanged from the received HEARTBEAT chunk.¶
Upon the receipt of the HEARTBEAT ACK chunk, the sender of the HEARTBEAT
chunk SHOULD clear the error counter of the destination transport address
to which the HEARTBEAT chunk was sent and mark the destination transport
address as active if it is not so marked.
The endpoint SHOULD report to the upper layer when an inactive
destination address is marked as active due to the reception of the latest
HEARTBEAT ACK chunk.
The receiver of the HEARTBEAT ACK chunk SHOULD also clear the association
overall error count (as defined in
Section 8.1).¶
The receiver of the HEARTBEAT ACK chunk SHOULD also perform an RTT
measurement for that destination transport address using the time value carried
in the HEARTBEAT ACK chunk.¶
On an idle destination address that is allowed to heartbeat, it is
RECOMMENDED that a HEARTBEAT chunk is sent once per RTO of that destination
address plus the protocol parameter 'HB.interval', with jittering of +/- 50% of
the RTO value and exponential backoff of the RTO if the previous HEARTBEAT
chunk is unanswered.¶
A primitive is provided for the SCTP user to change the 'HB.interval' and turn
on or off the heartbeat on a given destination address.
The 'HB.interval' set by the SCTP user is added to the RTO of that
destination (including any exponential backoff).
Only one heartbeat SHOULD be sent each time the heartbeat timer expires (if
multiple destinations are idle).
It is an implementation decision on how to choose which of the candidate idle
destinations to heartbeat to (if more than one destination is idle).¶
When tuning the 'HB.interval', there is a side effect that
SHOULD be taken into account.
When this value is increased, i.e., the time between the sending of HEARTBEAT
chunks is longer, the detection of lost ABORT chunks takes longer as well.
If a peer endpoint sends an ABORT chunk for any reason and the ABORT chunk is
lost, the local endpoint will only discover the lost ABORT chunk by sending a
DATA chunk or HEARTBEAT chunk (thus causing the peer to send another ABORT chunk).
This is to be considered when tuning the heartbeat timer.
If the sending of HEARTBEAT chunks is disabled, only sending DATA chunks to the
association will discover a lost ABORT chunk from the peer.¶





8.4. Handle ""Out of the Blue"" Packets

An SCTP packet is called an ""Out of the Blue"" (OOTB) packet if it is
correctly formed (i.e., passed the receiver's CRC32c check;
see Section 6.8),
but the receiver is not able to identify the association to which this
packet belongs.¶
The receiver of an OOTB packet does the following:¶

1)

If the OOTB packet is to or from a non-unicast address, a receiver SHOULD
silently discard the packet.
Otherwise,¶


2)

If the OOTB packet contains an ABORT chunk, the receiver MUST silently
discard the OOTB packet and take no further action.
Otherwise,¶


3)

If the packet contains an INIT chunk with a Verification Tag set
to 0, it SHOULD be processed as described in
Section 5.1.
If, for whatever reason, the INIT chunk cannot be processed normally and an
ABORT chunk has to be sent in response, the Verification Tag of the packet
containing the ABORT chunk MUST be the Initiate Tag of the received INIT chunk,
and the T bit of the ABORT chunk has to be set to 0, indicating that the
Verification Tag is not reflected.
Otherwise,¶


4)

If the packet contains a COOKIE ECHO chunk as the first chunk, it MUST be
processed as described in Section 5.1.
Otherwise,¶


5)

If the packet contains a SHUTDOWN ACK chunk, the receiver SHOULD respond to
the sender of the OOTB packet with a SHUTDOWN COMPLETE chunk.
When sending the SHUTDOWN COMPLETE chunk, the receiver of the OOTB packet MUST
fill in the Verification Tag field of the outbound packet with the
Verification Tag received in the SHUTDOWN ACK chunk and set the T bit in the
Chunk Flags to indicate that the Verification Tag is reflected.
Otherwise,¶


6)

If the packet contains a SHUTDOWN COMPLETE chunk, the receiver SHOULD
silently discard the packet and take no further action.
Otherwise,¶


7)

If the packet contains an ERROR chunk with the ""Stale Cookie"" error cause
or a COOKIE ACK chunk, the SCTP packet SHOULD be silently discarded.
Otherwise,¶


8)

The receiver SHOULD respond to the sender of the OOTB packet with an
ABORT chunk.
When sending the ABORT chunk, the receiver of the OOTB packet MUST fill in the
Verification Tag field of the outbound packet with the value found in the
Verification Tag field of the OOTB packet and set the T bit in the Chunk Flags
to indicate that the Verification Tag is reflected.
After sending this ABORT chunk, the receiver of the OOTB packet MUST discard the
OOTB packet and MUST NOT take any further action.¶








8.5. Verification Tag

The Verification Tag rules defined in this section apply when sending or
receiving SCTP packets that do not contain an INIT, SHUTDOWN COMPLETE,
COOKIE ECHO (see Section 5.1),
ABORT, or SHUTDOWN ACK chunk.
The rules for sending and receiving SCTP packets containing one of these chunk
types are discussed separately in
Section 8.5.1.¶
When sending an SCTP packet, the endpoint MUST fill in the Verification Tag
field of the outbound packet with the tag value in the Initiate Tag parameter
of the INIT or INIT ACK chunk received from its peer.¶
When receiving an SCTP packet, the endpoint MUST ensure that the value in
the Verification Tag field of the received SCTP packet matches its own tag.
If the received Verification Tag value does not match the receiver's own tag
value, the receiver MUST silently discard the packet and MUST NOT process it
any further, except for those cases listed in
Section 8.5.1 below.¶



8.5.1. Exceptions in Verification Tag Rules


A) Rules for packets carrying an INIT chunk:


The sender MUST set the Verification Tag of the packet to 0.¶

When an endpoint receives an SCTP packet with the Verification Tag set to 0,
it SHOULD verify that the packet contains only an INIT chunk.
Otherwise, the receiver MUST silently discard the packet.¶




B) Rules for packets carrying an ABORT chunk:


The endpoint MUST always fill in the Verification Tag field of the outbound
packet with the destination endpoint's tag value if it is known.¶

If the ABORT chunk is sent in response to an OOTB packet, the endpoint
MUST follow the procedure described in
Section 8.4.¶

The receiver of an ABORT chunk MUST accept the packet if the
Verification Tag field of the packet matches its own tag and the T bit is not
set OR if it is set to its Peer's Tag and the T bit is set in the Chunk Flags.
Otherwise, the receiver MUST silently discard the packet and take no further
action.¶




C) Rules for packets carrying a SHUTDOWN COMPLETE chunk:


When sending a SHUTDOWN COMPLETE chunk, if the receiver of the
SHUTDOWN ACK chunk has a TCB, then the destination endpoint's tag MUST be used
and the T bit MUST NOT be set.
Only where no TCB exists SHOULD the sender use the Verification Tag from the
SHUTDOWN ACK chunk and MUST set the T bit.¶

The receiver of a SHUTDOWN COMPLETE chunk accepts the packet if the
Verification Tag field of the packet matches its own tag and the T bit is not
set OR if it is set to its Peer's Tag and the T bit is set in the Chunk Flags.
Otherwise, the receiver MUST silently discard the packet and take no further
action.
An endpoint MUST ignore the SHUTDOWN COMPLETE chunk if it is not in the
SHUTDOWN-ACK-SENT state.¶




D) Rules for packets carrying a COOKIE ECHO chunk:


When sending a COOKIE ECHO chunk, the endpoint MUST use the value of the
Initiate Tag received in the INIT ACK chunk.¶

The receiver of a COOKIE ECHO chunk follows the procedures in
Section 5.¶




E) Rules for packets carrying a SHUTDOWN ACK chunk:


If the receiver is in COOKIE-ECHOED or COOKIE-WAIT state, the procedures
in Section 8.4 SHOULD be followed;
in other words, it is treated as an OOTB packet.¶














9. Termination of Association

An endpoint SHOULD terminate its association when it exits from service.
An association can be terminated by either abort or shutdown.
An abort of an association is abortive by definition in that any data pending
on either end of the association is discarded and not delivered to the peer.
A shutdown of an association is considered a graceful close where all data in
queue by either endpoint is delivered to the respective peers.
However, in the case of a shutdown, SCTP does not support a half-open state
(like TCP), wherein one side might continue sending data while the other end is
closed.
When either endpoint performs a shutdown, the association on each peer will
stop accepting new data from its user and only deliver data in queue at the time
of sending or receiving the SHUTDOWN chunk.¶



9.1. Abort of an Association

When an endpoint decides to abort an existing association, it MUST send an
ABORT chunk to its peer endpoint.
The sender MUST fill in the peer's Verification Tag in the outbound packet and
MUST NOT bundle any DATA chunk with the ABORT chunk.
If the association is aborted on request of the upper layer, a
""User-Initiated Abort"" error cause
(see Section 3.3.10.12) SHOULD be present in
the ABORT chunk.¶
An endpoint MUST NOT respond to any received packet that contains an ABORT
chunk (also see Section 8.4).¶
An endpoint receiving an ABORT chunk MUST apply the special Verification Tag check
rules described in Section 8.5.1.¶
After checking the Verification Tag, the receiving endpoint MUST remove the
association from its record and SHOULD report the termination to its upper
layer.
If a ""User-Initiated Abort"" error cause is present in the ABORT chunk, the Upper
Layer Abort Reason SHOULD be made available to the upper layer.¶





9.2. Shutdown of an Association

Using the SHUTDOWN primitive (see Section 11.1), the
upper layer of an endpoint in an association can gracefully close the
association.
This will allow all outstanding DATA chunks from the peer of the
shutdown initiator to be delivered before the association terminates.¶
Upon receipt of the SHUTDOWN primitive from its upper layer, the endpoint
enters the SHUTDOWN-PENDING state and remains there until all outstanding data
has been acknowledged by its peer.
The endpoint accepts no new data from its upper layer but retransmits data to
the peer endpoint if necessary to fill gaps.¶
Once all its outstanding data has been acknowledged, the endpoint sends
a SHUTDOWN chunk to its peer, including in the Cumulative TSN Ack field the last
sequential TSN it has received from the peer.
It SHOULD then start the T2-shutdown timer and enter the SHUTDOWN-SENT state.
If the timer expires, the endpoint MUST resend the SHUTDOWN chunk with the
updated last sequential TSN received from its peer.¶
The rules in Section 6.3 MUST be
followed to determine the proper timer value for T2-shutdown.
To indicate any gaps in TSN, the endpoint MAY also bundle a SACK chunk with the
SHUTDOWN chunk in the same SCTP packet.¶
An endpoint SHOULD limit the number of retransmissions of the SHUTDOWN chunk
to the protocol parameter 'Association.Max.Retrans'.
If this threshold is exceeded, the endpoint SHOULD destroy the TCB and SHOULD
report the peer endpoint unreachable to the upper layer (and thus the
association enters the CLOSED state).
The reception of any packet from its peer (i.e., as the peer sends all of its
queued DATA chunks) SHOULD clear the endpoint's retransmission count and restart
the T2-shutdown timer, giving its peer ample opportunity to transmit all of its
queued DATA chunks that have not yet been sent.¶
Upon reception of the SHUTDOWN chunk, the peer endpoint does the following:¶


enter the SHUTDOWN-RECEIVED state,¶


stop accepting new data from its SCTP user, and¶


verify, by checking the Cumulative TSN Ack field of the chunk, that all its
outstanding DATA chunks have been received by the SHUTDOWN chunk sender.¶


Once an endpoint has reached the SHUTDOWN-RECEIVED state, it MUST ignore
ULP shutdown requests but MUST continue responding to SHUTDOWN chunks from its
peer.¶
If there are still outstanding DATA chunks left, the SHUTDOWN chunk receiver
MUST continue to follow normal data transmission procedures defined in
Section 6, until all outstanding DATA chunks are
acknowledged; however, the SHUTDOWN chunk receiver MUST NOT accept new data
from its SCTP user.¶
While in the SHUTDOWN-SENT state, the SHUTDOWN chunk sender MUST immediately
respond to each received packet containing one or more DATA chunks with a
SHUTDOWN chunk and restart the T2-shutdown timer.
If a SHUTDOWN chunk by itself cannot acknowledge all of the received DATA chunks
(i.e., there are TSNs that can be acknowledged that are larger than the
cumulative TSN and thus gaps exist in the TSN sequence) or  if duplicate TSNs
have been received, then a SACK chunk MUST also be sent.¶
The sender of the SHUTDOWN chunk MAY also start an overall guard timer
T5-shutdown-guard to bound the overall time for the shutdown sequence.
At the expiration of this timer, the sender SHOULD abort the association by
sending an ABORT chunk. If the T5-shutdown-guard timer is used, it SHOULD
be set to the RECOMMENDED value of 5 times 'RTO.Max'.¶
If the receiver of the SHUTDOWN chunk has no more outstanding DATA chunks,
the SHUTDOWN chunk receiver MUST send a SHUTDOWN ACK chunk and start a
T2-shutdown timer of its own, entering the SHUTDOWN-ACK-SENT state.
If the timer expires, the endpoint MUST resend the SHUTDOWN ACK chunk.¶
The sender of the SHUTDOWN ACK chunk SHOULD limit the number of
retransmissions of the SHUTDOWN ACK chunk to the protocol parameter
'Association.Max.Retrans'.
If this threshold is exceeded, the endpoint SHOULD destroy the TCB and SHOULD
report the peer endpoint unreachable to the upper layer (and thus the
association enters the CLOSED state).¶
Upon the receipt of the SHUTDOWN ACK chunk, the sender of the SHUTDOWN chunk
MUST stop the T2-shutdown timer, send a SHUTDOWN COMPLETE chunk to its peer, and
remove all record of the association.¶
Upon reception of the SHUTDOWN COMPLETE chunk, the endpoint verifies that
it is in the SHUTDOWN-ACK-SENT state;
if it is not, the chunk SHOULD be discarded.
If the endpoint is in the SHUTDOWN-ACK-SENT state, the endpoint SHOULD stop
the T2-shutdown timer and remove all knowledge of the association (and thus the
association enters the CLOSED state).¶
An endpoint SHOULD ensure that all its outstanding DATA chunks have been
acknowledged before initiating the shutdown procedure.¶
An endpoint SHOULD reject any new data request from its upper layer if it is
in the SHUTDOWN-PENDING, SHUTDOWN-SENT, SHUTDOWN-RECEIVED, or SHUTDOWN-ACK-SENT
state.¶
If an endpoint is in the SHUTDOWN-ACK-SENT state and receives an INIT
chunk (e.g., if the SHUTDOWN COMPLETE chunk was lost) with source and destination
transport addresses (either in the IP addresses or in the INIT chunk) that
belong to this association, it SHOULD discard the INIT chunk and retransmit
the SHUTDOWN ACK chunk.¶
Note: Receipt of a packet containing an INIT chunk with the same source and
destination IP addresses as used in transport addresses assigned to an endpoint
but with a different port number indicates the initialization of a separate
association.¶
The sender of the INIT or COOKIE ECHO chunk SHOULD respond to the receipt of
a SHUTDOWN ACK chunk with a stand-alone SHUTDOWN COMPLETE chunk in an
SCTP packet with the Verification Tag field of its common header set to the
same tag that was received in the packet containing the SHUTDOWN ACK chunk.
This is considered an OOTB packet as defined in
Section 8.4.
The sender of the INIT chunk lets T1-init continue running and remains in the
COOKIE-WAIT or COOKIE-ECHOED state.
Normal T1-init timer expiration will cause the INIT or COOKIE chunk to be
retransmitted and thus start a new association.¶
If a SHUTDOWN chunk is received in the COOKIE-WAIT or COOKIE ECHOED state,
the SHUTDOWN chunk SHOULD be silently discarded.¶
If an endpoint is in the SHUTDOWN-SENT state and receives a SHUTDOWN chunk
from its peer, the endpoint SHOULD respond immediately with a SHUTDOWN ACK chunk
to its peer and move into the SHUTDOWN-ACK-SENT state, restarting its
T2-shutdown timer.¶
If an endpoint is in the SHUTDOWN-ACK-SENT state and receives a SHUTDOWN ACK,
it MUST stop the T2-shutdown timer, send a SHUTDOWN COMPLETE chunk to its peer,
and remove all record of the association.¶







10. ICMP Handling

Whenever an ICMP message is received by an SCTP endpoint, the following
procedures MUST be followed to ensure proper utilization of the information
being provided by layer 3.¶

ICMP1)

An implementation MAY ignore all ICMPv4 messages where the type field is not
set to ""Destination Unreachable"".¶


ICMP2)

An implementation MAY ignore all ICMPv6 messages where the type field is
not ""Destination Unreachable"", ""Parameter Problem"", or ""Packet Too Big"".¶


ICMP3)

An implementation SHOULD ignore any ICMP messages where the code indicates
""Port Unreachable"".¶


ICMP4)

An implementation MAY ignore all ICMPv6 messages of type ""Parameter Problem""
if the code is not ""Unrecognized Next Header Type Encountered"".¶


ICMP5)

An implementation MUST use the payload of the ICMP message (v4 or v6) to
locate the association that sent the message to which ICMP is responding.
If the association cannot be found, an implementation SHOULD ignore the
ICMP message.¶


ICMP6)

An implementation MUST validate that the Verification Tag contained in the
ICMP message matches the Verification Tag of the peer.
If the Verification Tag is not 0 and does not match, discard the ICMP message.
If it is 0 and the ICMP message contains enough bytes to verify that the
chunk type is an INIT chunk and that the Initiate Tag matches the tag of the
peer, continue with ICMP7.
If the ICMP message is too short or the chunk type or the Initiate Tag does
not match, silently discard the packet.¶


ICMP7)

If the ICMP message is either an ICMPv6 message of type ""Packet Too Big""
or an ICMPv4 message of type ""Destination Unreachable"" and code
""Fragmentation Needed"", an implementation SHOULD process this information as
defined for PMTU discovery.¶


ICMP8)

If the ICMP code is ""Unrecognized Next Header Type Encountered"" or
""Protocol Unreachable"", an implementation MUST treat this message as an abort
with the T bit set if it does not contain an INIT chunk.
If it does contain an INIT chunk and the association is in the
COOKIE-WAIT state, handle the ICMP message like an ABORT chunk.¶


ICMP9)

If the ICMP type is ""Destination Unreachable"", the implementation MAY move
the destination to the unreachable state or, alternatively, increment the
path error counter.
SCTP MAY provide information to the upper layer indicating the reception of
ICMP messages when reporting a network status change.¶



These procedures differ from [RFC1122] and from its
requirements for processing of port-unreachable messages and the requirements
that an implementation MUST abort associations in response to a
protocol unreachable message.

Port-unreachable messages are not processed, since an implementation will send
an ABORT chunk, not a port-unreachable message. The stricter handling of the
protocol unreachable message is due to security concerns for hosts that do
not support SCTP.¶





11. Interface with Upper Layer

The Upper Layer Protocols (ULPs) request services by passing primitives
to SCTP and receive notifications from SCTP for various events.¶
The primitives and notifications described in this section can be
used as a guideline for implementing SCTP.
The following functional description of ULP interface primitives is shown for
illustrative purposes.
Different SCTP implementations can have different ULP interfaces.
However, all SCTP implementations are expected to provide a certain minimum set
of services to guarantee that all SCTP implementations can support the same
protocol hierarchy.¶
Please note that this section is informational only.¶
[RFC6458] and Section 7 (""Socket API Considerations"") of [RFC7053] define an extension of the socket API for SCTP as
described in this document.¶



11.1. ULP-to-SCTP

The following sections functionally characterize a ULP/SCTP interface.
The notation used is similar to most procedure or function calls in high-level
languages.¶
The ULP primitives described below specify the basic functions that
SCTP performs to support inter-process communication.
Individual implementations define their own exact format and provide
combinations or subsets of the basic functions in single calls.¶


11.1.1. Initialize


INITIALIZE ([local port],[local eligible address list])
-> local SCTP instance name
¶

This primitive allows SCTP to initialize its internal data structures
and allocate necessary resources for setting up its operation
environment.
Once SCTP is initialized, ULP can communicate directly with other endpoints
without re-invoking this primitive.¶
SCTP will return a local SCTP instance name to the ULP.¶

Mandatory attributes:
None.¶


Optional attributes:


local port:
SCTP port number, if ULP wants it to be specified.¶


local eligible address list:
an address list that the local SCTP endpoint binds.
By default, if an address list is not included, all IP addresses assigned to
the host are used by the local endpoint.¶






Implementation Note: If this optional attribute is supported by an
implementation, it will be the responsibility of the implementation
to enforce that the IP source address field of any SCTP packets sent
by this endpoint contains one of the IP addresses indicated in the local
eligible address list.¶




11.1.2. Associate


ASSOCIATE(local SCTP instance name,
initial destination transport addr list, outbound stream count)
-> association id [,destination transport addr list]
[,outbound stream count]
¶

This primitive allows the upper layer to initiate an association to a specific
peer endpoint.¶
The peer endpoint is specified by one or more of the transport
addresses that defines the endpoint (see Section 1.3).
If the local SCTP instance has not been initialized, the ASSOCIATE is considered
an error.¶
An association id, which is a local handle to the SCTP association,
will be returned on successful establishment of the association.
If SCTP is not able to open an SCTP association with the peer endpoint,
an error is returned.¶
Other association parameters can be returned, including the complete
destination transport addresses of the peer as well as the outbound
stream count of the local endpoint.
One of the transport addresses from the returned destination addresses will
be selected by the local endpoint as the default primary path for sending
SCTP packets to this peer.
The returned ""destination transport addr list"" can be used by the ULP to change
the default primary path or to force sending a packet to a specific
transport address.¶
Implementation Note: If the ASSOCIATE primitive is implemented as a
blocking function call, the ASSOCIATE primitive can return
association parameters in addition to the association id upon
successful establishment.
If ASSOCIATE primitive is implemented as a non-blocking call, only the
association id is returned and association parameters are passed
using the COMMUNICATION UP notification.¶

Mandatory attributes:


local SCTP instance name:
obtained from the INITIALIZE operation.¶


initial destination transport addr list:
a non-empty list of transport addresses of the peer endpoint with which
the association is to be established.¶


outbound stream count:
the number of outbound streams the ULP would like to open towards this
peer endpoint.¶





Optional attributes:
None.¶








11.1.3. Shutdown


SHUTDOWN(association id) -> result
¶

Gracefully closes an association.
Any locally queued user data will be delivered to the peer.
The association will be terminated only after the peer acknowledges all the
SCTP packets sent.
A success code will be returned on successful termination of the association.
If attempting to terminate the association results in a failure, an error code
is returned.¶

Mandatory attributes:


association id:
local handle to the SCTP association.¶





Optional attributes:
None.¶







11.1.4. Abort


ABORT(association id [, Upper Layer Abort Reason]) -> result
¶

Ungracefully closes an association.
Any locally queued user data will be discarded, and an ABORT chunk is sent to
the peer.
A success code will be returned on successful abort of the association.
If attempting to abort the association results in a failure, an error code
is returned.¶

Mandatory attributes:


association id:
local handle to the SCTP association.¶





Optional attributes:


Upper Layer Abort Reason:
reason of the abort to be passed to the peer.¶










11.1.5. Send


SEND(association id, buffer address, byte count [,context]
[,stream id] [,life time] [,destination transport address]
[,unordered flag] [,no-bundle flag] [,payload protocol-id]
[,sack-immediately flag]) -> result
¶

This is the main method to send user data via SCTP.¶

Mandatory attributes:


association id:
local handle to the SCTP association.¶


buffer address:
the location where the user message to be transmitted is stored.¶


byte count:
the size of the user data in number of bytes.¶





Optional attributes:


context:
optional information provided that will be carried in the SEND FAILURE
notification to the ULP if the transportation of this user message fails.¶


stream id:
indicates which stream to send the data on.
If not specified, stream 0 will be used.¶


life time:

specifies the life time of the user data.
The user data will not be sent by SCTP after the life time expires.
This parameter can be used to avoid efforts to transmit stale user messages.
SCTP notifies the ULP if the data cannot be initiated to transport (i.e., sent
to the destination via SCTP's SEND primitive) within the life time variable.
However, the user data will be transmitted if SCTP has attempted to transmit
a chunk before the life time expired.¶
Implementation Note: In order to better support the data life time
option, the transmitter can hold back the assigning of the TSN number
to an outbound DATA chunk to the last moment.
And, for implementation simplicity, once a TSN number has been assigned, the
sender considers the send of this DATA chunk as committed,
overriding any life time option attached to the DATA chunk.¶


destination transport address:
specified as one of the destination transport addresses of the peer endpoint
to which this packet is sent.
Whenever possible, SCTP uses this destination transport address for
sending the packets, instead of the current primary path.¶


unordered flag:
this flag, if present, indicates that the user would like the data delivered
in an unordered fashion to the peer (i.e., the U flag is set to 1 on all DATA
chunks carrying this message).¶


no-bundle flag:
instructs SCTP not to delay the sending of DATA chunks for this user data
just to allow it to be bundled with other outbound DATA chunks.
When faced with network congestion, SCTP might still bundle the data, even when
this flag is present.¶


payload protocol-id:
a 32-bit unsigned integer that is to be passed to the peer, indicating the type
of payload protocol data being transmitted.
Note that the upper layer is responsible for the host to network byte order
conversion of this field, which is passed by SCTP as 4 bytes of opaque
data.¶


sack-immediately flag:
set the I bit on the last DATA chunk used for the user message to be
transmitted.¶










11.1.6. Set Primary


SETPRIMARY(association id, destination transport address,
[source transport address]) -> result
¶

Instructs the local SCTP to use the specified destination transport address as
the primary path for sending packets.¶
The result of attempting this operation is returned.
If the specified destination transport address is not present in the
""destination transport address list"" returned earlier in an ASSOCIATE
primitive or COMMUNICATION UP notification, an error is returned.¶

Mandatory attributes:


association id:
local handle to the SCTP association.¶


destination transport address:
specified as one of the transport addresses of the peer endpoint, which is
used as the primary address for sending packets.
This overrides the current primary address information maintained by the
local SCTP endpoint.¶





Optional attributes:


source transport address:
optionally, some implementations can allow you to set the default source address
placed in all outgoing IP datagrams.¶









11.1.7. Receive


RECEIVE(association id, buffer address, buffer size [,stream id])
-> byte count [,transport address] [,stream id]
[,stream sequence number] [,partial flag] [,payload protocol-id]
¶

This primitive reads the first user message in the SCTP in-queue
into the buffer specified by ULP, if there is one available.
The size of the message read, in bytes, will be returned.
It might, depending on the specific implementation, also return other
information, such as the sender's address, the stream id on which it
is received, whether there are more messages available for retrieval,
etc.
For ordered messages, their Stream Sequence Number might also be returned.¶
Depending upon the implementation, if this primitive is invoked when no
message is available, the implementation returns an indication of this condition
or blocks the invoking process until data does become available.¶

Mandatory attributes:


association id:
local handle to the SCTP association.¶


buffer address:
the memory location indicated by the ULP to store the received message.¶


buffer size:
the maximum size of data to be received, in bytes.¶





Optional attributes:


stream id:
to indicate which stream to receive the data on.¶


stream sequence number:
the Stream Sequence Number assigned by the sending SCTP peer.¶


partial flag:
if this returned flag is set to 1, then this primitive contains a partial
delivery of the whole message.
When this flag is set, the stream id and stream sequence number
accompanies this primitive.
When this flag is set to 0, it indicates that no more deliveries will be
received for this stream sequence number.¶


payload protocol-id:
a 32-bit unsigned integer that is received from the peer indicating the type
of payload protocol of the received data.
Note that the upper layer is responsible for the host to network byte order
conversion of this field, which is passed by SCTP as 4 bytes of opaque
data.¶









11.1.8. Status


STATUS(association id) -> status data
¶

This primitive returns a data block containing the following information:¶


association connection state,¶


destination transport address list,¶


destination transport address reachability states,¶


current receiver window size,¶


current congestion window sizes,¶


number of unacknowledged DATA chunks,¶


number of DATA chunks pending receipt,¶


primary path,¶


most recent SRTT on primary path,¶


RTO on primary path,¶


SRTT and RTO on other destination addresses, etc.¶



Mandatory attributes:


association id:
local handle to the SCTP association.¶





Optional attributes:
None.¶






11.1.9. Change Heartbeat


CHANGE HEARTBEAT(association id, destination transport address,
new state [,interval]) -> result
¶

Instructs the local endpoint to enable or disable heartbeat on the
specified destination transport address.¶
The result of attempting this operation is returned.¶
Note: Even when enabled, heartbeat will not take place if the destination
transport address is not idle.¶

Mandatory attributes:


association id:
local handle to the SCTP association.¶


destination transport address:
specified as one of the transport addresses of the peer endpoint.¶


new state:
the new state of heartbeat for this destination transport address
(either enabled or disabled).¶





Optional attributes:


interval:
if present, indicates the frequency of the heartbeat if this is to enable
heartbeat on a destination transport address.
This value is added to the RTO of the destination transport address.
This value, if present, affects all destinations.¶









11.1.10. Request Heartbeat


REQUESTHEARTBEAT(association id, destination transport address)
-> result
¶

Instructs the local endpoint to perform a heartbeat on the specified
destination transport address of the given association.
The returned result indicates whether the transmission of the HEARTBEAT
chunk to the destination address is successful.¶

Mandatory attributes:


association id:
local handle to the SCTP association.¶


destination transport address:
the transport address of the association on which a heartbeat is issued.¶





Optional attributes:
None.¶






11.1.11. Get SRTT Report


GETSRTTREPORT(association id, destination transport address)
-> srtt result
¶

Instructs the local SCTP to report the current SRTT measurement on the
specified destination transport address of the given association.
The returned result can be an integer containing the most recent SRTT in
milliseconds.¶

Mandatory attributes:


association id:
local handle to the SCTP association.¶


destination transport address:
the transport address of the association on which the SRTT measurement is to
be reported.¶





Optional attributes:
None.¶






11.1.12. Set Failure Threshold


SETFAILURETHRESHOLD(association id, destination transport address,
failure threshold) -> result
¶

This primitive allows the local SCTP to customize the reachability failure
detection threshold 'Path.Max.Retrans' for the specified destination address.
Note that this can also be done using the SETPROTOCOLPARAMETERS primitive
(Section 11.1.13).¶

Mandatory attributes:


association id:
local handle to the SCTP association.¶


destination transport address:
the transport address of the association on which the failure detection
threshold is to be set.¶


failure threshold:
the new value of 'Path.Max.Retrans' for the destination address.¶





Optional attributes:

None.¶







11.1.13. Set Protocol Parameters


SETPROTOCOLPARAMETERS(association id,
[destination transport address,] protocol parameter list)
-> result
¶

This primitive allows the local SCTP to customize the protocol parameters.¶

Mandatory attributes:


association id:
local handle to the SCTP association.¶


protocol parameter list:
the specific names and values of the protocol parameters
(e.g., 'Association.Max.Retrans' (see Section 16)
or other parameters like the DSCP) that the SCTP user wishes to customize.¶





Optional attributes:


destination transport address:
some of the protocol parameters might be set on a per-destination-transport-address basis.¶










11.1.14. Receive Unsent Message


RECEIVE_UNSENT(data retrieval id, buffer address, buffer size
[,stream id] [, stream sequence number] [,partial flag]
[,payload protocol-id])
¶

This primitive reads a user message that has never been sent
into the buffer specified by ULP.¶

Mandatory attributes:


data retrieval id:
the identification passed to the ULP in the SEND FAILURE notification.¶


buffer address:
the memory location indicated by the ULP to store the received message.¶


buffer size:
the maximum size of data to be received, in bytes.¶





Optional attributes:


stream id:
this is a return value that is set to indicate which stream the data was
sent to.¶


stream sequence number:
this value is returned, indicating the Stream Sequence Number that was
associated with the message.¶


partial flag:
if this returned flag is set to 1, then this message is a partial delivery of
the whole message.
When this flag is set, the stream id and stream sequence number
accompanies this primitive.
When this flag is set to 0, it indicates that no more deliveries will be
received for this stream sequence number.¶


payload protocol-id:
The 32-bit unsigned integer that was set to be sent to the peer, indicating
the type of payload protocol of the received data.¶









11.1.15. Receive Unacknowledged Message


RECEIVE_UNACKED(data retrieval id, buffer address, buffer size,
[,stream id] [,stream sequence number] [,partial flag]
[,payload protocol-id])
¶

This primitive reads a user message that has been sent and has not been
acknowledged by the peer into the buffer specified by ULP.¶

Mandatory attributes:


data retrieval id:
the identification passed to the ULP in the SEND FAILURE notification.¶


buffer address:
the memory location indicated by the ULP to store the received message.¶


buffer size:
the maximum size of data to be received, in bytes.¶





Optional attributes:


stream id:
this is a return value that is set to indicate which stream the data was sent
to.¶


stream sequence number:
this value is returned, indicating the Stream Sequence Number that was
associated with the message.¶


partial flag:
if this returned flag is set to 1, then this message is a partial delivery of
the whole message.
When this flag is set, the stream id and stream sequence number
accompanies this primitive.
When this flag is set to 0, it indicates that no more deliveries will be
received for this stream sequence number.¶


payload protocol-id:
the 32-bit unsigned integer that was sent to the peer indicating the type of
payload protocol of the received data.¶









11.1.16. Destroy SCTP Instance


DESTROY(local SCTP instance name)
¶


Mandatory attributes:


local SCTP instance name:
this is the value that was passed to
the application in the initialize primitive and it indicates which
SCTP instance is to be destroyed.¶





Optional attributes:
None.¶









11.2. SCTP-to-ULP

It is assumed that the operating system or application environment
provides a means for the SCTP to asynchronously signal the ULP process.
When SCTP does signal a ULP process, certain information is passed to
the ULP.¶
Implementation Note: In some cases, this might be done through a separate
socket or error channel.¶


11.2.1. DATA ARRIVE Notification

SCTP invokes this notification on the ULP when a user message is
successfully received and ready for retrieval.¶
The following might optionally be passed with the notification:¶

association id:
local handle to the SCTP association.¶


stream id:
to indicate which stream the data is received on.¶






11.2.2. SEND FAILURE Notification

If a message cannot be delivered, SCTP invokes this notification
on the ULP.¶
The following might optionally be passed with the notification:¶

association id:
local handle to the SCTP association.¶


data retrieval id:
an identification used to retrieve unsent and unacknowledged data.¶


mode:
indicates whether no part of the message never has been sent or if at
least part of it has been sent but it is not completely acknowledged.¶


cause code:
indicating the reason of the failure, e.g., size too
large, message life time expiration, etc.¶


context:
optional information associated with this message
(see Section 11.1.5).¶






11.2.3. NETWORK STATUS CHANGE Notification

When a destination transport address is marked inactive (e.g., when SCTP
detects a failure) or marked active (e.g., when SCTP detects a recovery),
SCTP invokes this notification on the ULP.¶
The following is passed with the notification:¶

association id:
local handle to the SCTP association.¶


destination transport address:
this indicates the destination
transport address of the peer endpoint affected by the change.¶


new-status:
this indicates the new status.¶






11.2.4. COMMUNICATION UP Notification

This notification is used when SCTP becomes ready to send or receive
user messages or when a lost communication to an endpoint is restored.¶
Implementation Note: If the ASSOCIATE primitive is implemented as a
blocking function call, the association parameters are returned as a
result of the ASSOCIATE primitive itself.
In that case, the COMMUNICATION UP notification is optional at the association
initiator's side.¶
The following is passed with the notification:¶

association id:
local handle to the SCTP association.¶


status:
this indicates what type of event has occurred.¶


destination transport address list:
the complete set of transport addresses of the peer.¶


outbound stream count:
the maximum number of streams allowed to be used in this association by the ULP.¶


inbound stream count:
the number of streams the peer endpoint has requested
with this association (this might not be the same number as
'outbound stream count').¶






11.2.5. COMMUNICATION LOST Notification

When SCTP loses communication to an endpoint completely (e.g., via Heartbeats)
or detects that the endpoint has performed an abort operation, it invokes
this notification on the ULP.¶
The following is passed with the notification:¶

association id:
local handle to the SCTP association.¶


status:
this indicates what type of event has occurred;
the status might indicate that a failure OR a normal termination event occurred
in response to a shutdown or abort request.¶



The following might be passed with the notification:¶

last-acked:
the TSN last acked by that peer endpoint.¶


last-sent:
the TSN last sent to that peer endpoint.¶


Upper Layer Abort Reason:
the abort reason specified in case of a
user-initiated abort.¶






11.2.6. COMMUNICATION ERROR Notification

When SCTP receives an ERROR chunk from its peer and decides to notify its ULP,
it can invoke this notification on the ULP.¶
The following can be passed with the notification:¶

association id:
local handle to the SCTP association.¶


error info:
this indicates the type of error and optionally some additional
information received through the ERROR chunk.¶






11.2.7. RESTART Notification

When SCTP detects that the peer has restarted, it might send this notification
to its ULP.¶
The following can be passed with the notification:¶

association id:
local handle to the SCTP association.¶






11.2.8. SHUTDOWN COMPLETE Notification

When SCTP completes the shutdown procedures
(Section 9.2), this notification is passed
to the upper layer.¶
The following can be passed with the notification:¶

association id:
local handle to the SCTP association.¶











12. Security Considerations




12.1. Security Objectives

As a common transport protocol designed to reliably carry time-sensitive
user messages, such as billing or signaling messages for telephony services,
between two networked endpoints, SCTP has the following security objectives:¶

availability of reliable and timely data transport services¶

integrity of the user-to-user information carried by SCTP¶







12.2. SCTP Responses to Potential Threats

SCTP could potentially be used in a wide variety of risk situations.
It is important for operators of systems running SCTP to analyze
their particular situations and decide on the appropriate counter-measures.¶
Operators of systems running SCTP might consult [RFC2196] for
guidance in securing their site.¶


12.2.1. Countering Insider Attacks

The principles of [RFC2196] might be applied to minimize the
risk of theft of information or sabotage by insiders.
Such procedures include publication of security policies, control of access at
the physical, software, and network levels, and separation of services.¶



12.2.2. Protecting against Data Corruption in the Network

Where the risk of undetected errors in datagrams delivered by the lower-layer
transport services is considered to be too great, additional integrity
protection is required.
If this additional protection were provided in the application layer, the
SCTP header would remain vulnerable to deliberate integrity attacks.
While the existing SCTP mechanisms for detection of packet replays are
considered sufficient for normal operation, stronger protections are needed to
protect SCTP when the operating environment contains significant risk of
deliberate attacks from a sophisticated adversary.¶
The SCTP Authentication extension SCTP-AUTH [RFC4895] MAY be
used when the threat environment requires stronger integrity protections
but does not require confidentiality.¶



12.2.3. Protecting Confidentiality

In most cases, the risk of breach of confidentiality applies to the
signaling data payload, not to the SCTP or lower-layer protocol overheads.
If that is true, encryption of the SCTP user data only might be considered.
As with the supplementary checksum service, user data encryption MAY be
performed by the SCTP user application.
[RFC6083] MAY be used for this.
Alternately, the user application MAY use an implementation-specific API to
request that the IP Encapsulating Security Payload (ESP)
[RFC4303] be used to provide confidentiality and integrity.¶
Particularly for mobile users, the requirement for confidentiality might
include the masking of IP addresses and ports.
In this case, ESP SHOULD be used instead of application-level confidentiality.
If ESP is used to protect confidentiality of SCTP traffic, an ESP cryptographic
transform that includes cryptographic integrity protection MUST be used, because,
if there is a confidentiality threat, there will also be a strong integrity
threat.¶
Regardless of where confidentiality is provided, the Internet Key
Exchange Protocol version 2 (IKEv2) [RFC7296] SHOULD be used for
key management of ESP.¶
Operators might consult [RFC4301] for more information on the
security services available at and immediately above the Internet Protocol
layer.¶



12.2.4. Protecting against Blind Denial-of-Service Attacks

A blind attack is one where the attacker is unable to intercept or otherwise
see the content of data flows passing to and from the target SCTP node.
Blind denial-of-service attacks can take the form of flooding, masquerade,
or improper monopolization of services.¶


12.2.4.1. Flooding

The objective of flooding is to cause loss of service and incorrect
behavior at target systems through resource exhaustion, interference
with legitimate transactions, and exploitation of buffer-related
software bugs.
Flooding can be directed either at the SCTP node or at resources in the
intervening IP Access Links or the Internet.
Where the latter entities are the target, flooding will manifest itself as loss
of network services, including potentially the breach of any firewalls in
place.¶
In general, protection against flooding begins at the equipment
design level, where it includes measures such as:¶


avoiding commitment of limited resources before determining that the request
for service is legitimate.¶


giving priority to completion of processing in progress over the acceptance
of new work.¶


identification and removal of duplicate or stale queued requests for
service.¶


not responding to unexpected packets sent to non-unicast addresses.¶


Network equipment is expected to be capable of generating an alarm and log if a
suspicious increase in traffic occurs.
The log provides information, such as the identity of the incoming link
and source address(es) used, which will help the network or SCTP system operator
to take protective measures.
Procedures are expected to be in place for the operator to act on such alarms if a clear
pattern of abuse emerges.¶
The design of SCTP is resistant to flooding attacks, particularly in its use
of a four-way startup handshake, its use of a cookie to defer commitment of
resources at the responding SCTP node until the handshake is completed, and its
use of a Verification Tag to prevent insertion of extraneous packets into the
flow of an established association.¶
ESP might be useful in reducing the risk of certain kinds of
denial-of-service attacks.¶
Support for the Host Name Address parameter has been removed from the
protocol.
Endpoints receiving INIT or INIT ACK chunks containing the Host Name Address
parameter MUST send an ABORT chunk in response and MAY include an
""Unresolvable Address"" error cause.¶



12.2.4.2. Blind Masquerade

Masquerade can be used to deny service in several ways:¶


by tying up resources at the target SCTP node to which the impersonated node
has limited access.
For example, the target node can by policy permit a maximum of one
SCTP association with the impersonated SCTP node.
The masquerading attacker can attempt to establish an association purporting to
come from the impersonated node so that the latter cannot do so when it requires
it.¶


by deliberately allowing the impersonation to be detected, thereby
provoking counter-measures that cause the impersonated node to be locked out of
the target SCTP node.¶


by interfering with an established association by inserting extraneous
content such as a SHUTDOWN chunk.¶


SCTP reduces the risk of blind masquerade attacks through IP spoofing
by use of the four-way startup handshake.
Because the initial exchange is memoryless, no lockout mechanism is triggered
by blind masquerade attacks.
In addition, the packet containing the INIT ACK chunk with the State Cookie
is transmitted back to the IP address from which it received the packet
containing the INIT chunk.
Thus, the attacker would not receive the INIT ACK chunk containing the
State Cookie.
SCTP protects against insertion of extraneous packets into the flow of an
established association by use of the Verification Tag.¶
Logging of received INIT chunks and abnormalities, such as unexpected
INIT ACK chunks, might be considered as a way to detect patterns of hostile
activity.
However, the potential usefulness of such logging has to be weighed against the
increased SCTP startup processing it implies, rendering the SCTP node more
vulnerable to flooding attacks.
Logging is pointless without the establishment of operating procedures to
review and analyze the logs on a routine basis.¶



12.2.4.3. Improper Monopolization of Services

Attacks under this heading are performed openly and legitimately by the
attacker.
They are directed against fellow users of the target SCTP node or of the shared
resources between the attacker and the target node.
Possible attacks include the opening of a large number of associations between
the attacker's node and the target or transfer of large volumes of information
within a legitimately established association.¶
Policy limits are expected to be placed on the number of associations per
adjoining SCTP node.
SCTP user applications are expected to be capable of detecting large volumes of
illegitimate or ""no-op"" messages within a given association and either logging
or terminating the association as a result, based on local policy.¶







12.3. SCTP Interactions with Firewalls

It is helpful for some firewalls if they can inspect just the first
fragment of a fragmented SCTP packet and unambiguously determine whether it
corresponds to an INIT chunk (for further information, please refer to
[RFC1858]).
Accordingly, we stress the requirements, as stated in
Section 3.1, that
(1) an INIT chunk MUST NOT be bundled with any other chunk in a packet and
(2) a packet containing an INIT chunk MUST have a zero Verification Tag.
The receiver of an INIT chunk MUST silently discard the INIT chunk and all
further chunks if the INIT chunk is bundled with other chunks or the packet
has a non-zero Verification Tag.¶





12.4. Protection of Non-SCTP-capable Hosts

To provide a non-SCTP-capable host with the same level of protection
against attacks as for SCTP-capable ones, all SCTP implementations MUST
implement the ICMP handling described in Section 10.¶
When an SCTP implementation receives a packet containing multiple control or
DATA chunks and the processing of the packet would result in sending multiple
chunks in response, the sender of the response chunk(s) MUST NOT send more than
one packet containing chunks other than DATA chunks.
This requirement protects the network for triggering a packet burst in response
to a single packet.
If bundling is supported, multiple response chunks that fit into a single
packet MAY be bundled together into one single response packet.
If bundling is not supported, then the sender MUST NOT send more than one
response chunk and MUST discard all other responses.
Note that this rule does not apply to a SACK chunk, since a SACK chunk is,
in itself, a response to DATA chunks, and a SACK chunk does not require a
response of more DATA chunks.¶
An SCTP implementation MUST abort the association if it receives a SACK
chunk acknowledging a TSN that has not been sent.¶
An SCTP implementation that receives an INIT chunk that would require a large
packet in response, due to the inclusion of multiple ""Unrecognized Parameter""
parameters, MAY (at its discretion) elect to omit some or all of the
""Unrecognized Parameter"" parameters to reduce the size of the INIT ACK chunk.
Due to a combination of the size of the State Cookie parameter and the number of
addresses a receiver of an INIT chunk indicates to a peer, it is always
possible that the INIT ACK chunk will be larger than the original INIT chunk.
An SCTP implementation SHOULD attempt to make the INIT ACK chunk as small as
possible to reduce the possibility of byte amplification attacks.¶







13. Network Management Considerations

The MIB module for SCTP defined in [RFC3873] applies for the
version of the protocol specified in this document.¶





14. Recommended Transmission Control Block (TCB) Parameters

This section details a set of parameters that are expected to be contained
within the TCB for an implementation.
This section is for illustrative purposes and is not considered to be
requirements on an implementation or as an exhaustive list of all parameters
inside an SCTP TCB.
Each implementation might need its own additional parameters for optimization.¶



14.1. Parameters Necessary for the SCTP Instance


Associations:
A list of current associations and mappings to the data consumers for each
association.
This might be in the form of a hash table or other implementation-dependent
structure.
The data consumers might be process identification information, such as file
descriptors, named pipe pointer, or table pointers dependent on how SCTP is
implemented.¶


Secret Key:
A secret key used by this endpoint to compute the MAC.
This SHOULD be a cryptographic quality random number with a sufficient length.
Discussion in [RFC4086] can be helpful in selection of the
key.¶


Address List:
The list of IP addresses that this instance has bound.
This information is passed to one's peer(s) in INIT and INIT ACK chunks.¶


SCTP Port:
The local SCTP port number to which the endpoint is bound.¶








14.2. Parameters Necessary per Association (i.e., the TCB)


Peer Verification Tag:
Tag value to be sent in every packet and is received in the INIT or
INIT ACK chunk.¶


My Verification Tag:
Tag expected in every inbound packet and sent in the INIT or INIT ACK chunk.¶


State:

COOKIE-WAIT, COOKIE-ECHOED, ESTABLISHED, SHUTDOWN-PENDING, SHUTDOWN-SENT,
SHUTDOWN-RECEIVED, SHUTDOWN-ACK-SENT.¶
Note: No ""CLOSED"" state is illustrated, since, if an association is ""CLOSED"",
its TCB SHOULD be removed.¶


Peer Transport Address List:
A list of SCTP transport addresses to which the peer is bound.
This information is derived from the INIT or INIT ACK chunk and is used to
associate an inbound packet with a given association.
Normally, this information is hashed or keyed for quick lookup and access
of the TCB.¶


Primary Path:
This is the current primary destination transport address of the peer endpoint.
It might also specify a source transport address on this endpoint.¶


Overall Error Count:
The overall association error count.¶


Overall Error Threshold:
The threshold for this association that, if the Overall Error Count reaches, will
cause this association to be torn down.¶


Peer Rwnd:
Current calculated value of the peer's rwnd.¶


Next TSN:
The next TSN number to be assigned to a new DATA chunk.
This is sent in the INIT or INIT ACK chunk to the peer and incremented each
time a DATA chunk is assigned a TSN (normally, just prior to transmit or during
fragmentation).¶


Last Rcvd TSN:
This is the last TSN received in sequence.
This value is set initially by taking the peer's Initial TSN, received in the
INIT or INIT ACK chunk, and subtracting one from it.¶


Mapping Array:
An array of bits or bytes indicating which out-of-order TSNs have been
received (relative to the Last Rcvd TSN).
If no gaps exist, i.e., no out-of-order packets have been received, this
array will be set to all zero.
This structure might be in the form of a circular buffer or bit array.¶


Ack State:
This flag indicates if the next received packet is to be responded to with
a SACK chunk.
This is initialized to 0.
When a packet is received, it is incremented.
If this value reaches 2 or more, a SACK chunk is sent and the value is reset
to 0.
Note: This is used only when no DATA chunks are received out of order.
When DATA chunks are out of order, SACK chunks are not delayed
(see Section 6).¶


Inbound Streams:
An array of structures to track the inbound streams, normally including the
next sequence number expected and possibly the stream number.¶


Outbound Streams:
An array of structures to track the outbound streams, normally including the
next sequence number to be sent on the stream.¶


Reasm Queue:
A reassembly queue.¶


Receive Buffer:
A buffer to store received user data that has not been delivered to the
upper layer.¶


Local Transport Address List:
The list of local IP addresses bound in to this association.¶


Association Maximum DATA Chunk Size:
The smallest Path Maximum DATA Chunk Size of all destination addresses.¶








14.3. Per Transport Address Data

For each destination transport address in the peer's address list
derived from the INIT or INIT ACK chunk, a number of data elements need to be
maintained, including:¶

Error Count:
The current error count for this destination.¶


Error Threshold:
Current error threshold for this destination, i.e., what value marks the
destination down if error count reaches this value.¶


cwnd:
The current congestion window.¶


ssthresh:
The current ssthresh value.¶


RTO:
The current retransmission timeout value.¶


SRTT:
The current smoothed round-trip time.¶


RTTVAR:
The current RTT variation.¶


partial bytes acked:
The tracking method for increase of cwnd when in congestion avoidance mode
(see Section 7.2.2).¶


state:
The current state of this destination, i.e., DOWN, UP, ALLOW-HEARTBEAT,
NO-HEARTBEAT, etc.¶


PMTU:
The current known PMTU.¶


PMDCS:
The current known PMDCS.¶


Per Destination Timer:
A timer used by each destination.¶


RTO-Pending:
A flag used to track if one of the DATA chunks sent to this address is
currently being used to compute an RTT.
If this flag is 0, the next DATA chunk sent to this destination is expected to
be used to compute an RTT and this flag is expected to be set.
Every time the RTT calculation completes (i.e., the DATA chunk is acknowledged),
clear this flag.¶


last-time:
The time to which this destination was last sent.
This can be used to determine if the sending of a HEARTBEAT chunk is needed.¶








14.4. General Parameters Needed


Out Queue:
A queue of outbound DATA chunks.¶


In Queue:
A queue of inbound DATA chunks.¶










15. IANA Considerations

This document defines five registries that IANA maintains:¶


through definition of additional chunk types,¶


through definition of additional chunk flags,¶


through definition of additional parameter types,¶


through definition of additional cause codes within ERROR chunks, or¶


through definition of additional payload protocol identifiers.¶


IANA has performed the following updates for the above five
registries:¶


In the ""Chunk Types"" registry, IANA has replaced the registry
reference to [RFC4960] and [RFC6096] with a
reference to this document.¶
In addition, in the Notes section, the reference to Section 3.2 of [RFC6096] has been updated with a reference to
Section 15.2 of this document.¶
Finally, each reference to [RFC4960] has been replaced with a reference to
this document for the following chunk types:¶


Payload Data (DATA)¶


Initiation (INIT)¶


Initiation Acknowledgement (INIT ACK)¶


Selective Acknowledgement (SACK)¶


Heartbeat Request (HEARTBEAT)¶


Heartbeat Acknowledgement (HEARTBEAT ACK)¶


Abort (ABORT)¶


Shutdown (SHUTDOWN)¶


Shutdown Acknowledgement (SHUTDOWN ACK)¶


Operation Error (ERROR)¶


State Cookie (COOKIE ECHO)¶


Cookie Acknowledgement (COOKIE ACK)¶


Reserved for Explicit Congestion Notification Echo (ECNE)¶


Reserved for Congestion Window Reduced (CWR)¶


Shutdown Complete (SHUTDOWN COMPLETE)¶


Reserved for IETF-defined Chunk Extensions¶




In the ""Chunk Parameter Types"" registry, IANA has replaced
the registry reference to [RFC4960] with a reference to this document.¶
IANA has changed the name of the ""Unrecognized Parameters"" chunk parameter type to
""Unrecognized Parameter"" in the ""Chunk Parameter Types"" registry.¶
In addition, each reference to [RFC4960] has been replaced with a reference to
this document for the following chunk parameter types:¶


Heartbeat Info¶


IPv4 Address¶


IPv6 Address¶


State Cookie¶


Unrecognized Parameter¶


Cookie Preservative¶


Host Name Address¶


Supported Address Types¶


IANA has added a reference to this document for the following chunk parameter type:¶


Reserved for ECN Capable (0x8000)¶


Also, IANA has added the value 65535 to be reserved for IETF-defined extensions.¶


In the ""Chunk Flags"" registry, IANA replaced
the registry reference to [RFC6096] with a reference to this document.¶
In addition, each reference to [RFC4960] has been replaced with a reference to
this document for the following DATA chunk flags:¶


E bit¶


B bit¶


U bit¶


IANA has also replaced the reference to [RFC7053] with a reference to
this document for the following DATA chunk flag:¶


I bit¶


IANA has replaced the reference to [RFC4960] with a reference to
this document for the following ABORT chunk flag:¶


T bit¶


IANA has replaced the reference to [RFC4960] with a reference to
this document for the following SHUTDOWN COMPLETE chunk flag:¶


T bit¶




In the ""Error Cause Codes"" registry, IANA has replaced
the registry reference to [RFC4960] with a reference to this document.¶
IANA has changed the name of the ""User Initiated Abort"" error cause to
""User-Initiated Abort"" and the name of the ""Stale Cookie Error"" error cause
to ""Stale Cookie"" in the ""Error Cause Codes"" registry.¶
In addition, each reference to [RFC4960] has been replaced with a reference to
this document for the following cause codes:¶


Invalid Stream Identifier¶


Missing Mandatory Parameter¶


Stale Cookie¶


Out of Resource¶


Unresolvable Address¶


Unrecognized Chunk Type¶


Invalid Mandatory Parameter¶


Unrecognized Parameters¶


No User Data¶


Cookie Received While Shutting Down¶


Restart of an Association with New Addresses¶


IANA has also replaced each reference to [RFC4460] with a reference to
this document for the following cause codes:¶


User-Initiated Abort¶


Protocol Violation¶




In the ""SCTP Payload Protocol Identifiers"" registry, IANA has
replaced the registry reference to [RFC4960] with a reference
to this document.¶
IANA has replaced the reference to [RFC4960] with a reference to
this document for the following SCTP payload protocol identifier:¶


Reserved by SCTP¶




SCTP requires that the IANA ""Port Numbers"" registry be opened for SCTP port
registrations; Section 15.6 describes how.
An IESG-appointed Expert Reviewer supports IANA in evaluating SCTP port
allocation requests.¶
In the ""Service Name and Transport Protocol Port Number Registry"", IANA has replaced each reference to [RFC4960] with a reference to
this document for the following SCTP port numbers:¶


9 (discard)¶


20 (ftp-data)¶


21 (ftp)¶


22 (ssh)¶


80 (http)¶


179 (bgp)¶


443 (https)¶


Furthermore, in the ""Hypertext Transfer Protocol (HTTP) Digest Algorithm Values""
registry, IANA has replaced the reference to Appendix B of [RFC4960] with a reference to
Appendix A of this document.¶
In addition, in the ""ONC RPC Netids (Standards Action)"" registry, IANA has replaced each
reference to [RFC4960] with a reference to
this document for the following netids:¶


sctp¶


sctp6¶


In the ""IPFIX Information Elements"" registry, IANA has replaced each reference to [RFC4960] with a reference to
this document for the following elements with the name:¶


sourceTransportPort¶


destinationTransportPort¶


collectorTransportPort¶


exporterTransportPort¶


postNAPTSourceTransportPort¶


postNAPTDestinationTransportPort¶





15.1. IETF-Defined Chunk Extension

The assignment of new chunk type codes is done through an IETF
Review action, as defined in [RFC8126].
Documentation for a new chunk MUST contain the following information:¶

a)

A long and short name for the new chunk type.¶


b)

A detailed description of the structure of the chunk, which MUST conform to
the basic structure defined in Section 3.2.¶


c)

A detailed definition and description of intended use of each field within
the chunk, including the chunk flags if any.
Defined chunk flags will be used as initial entries in the chunk flags table
for the new chunk type.¶


d)

A detailed procedural description of the use of the new chunk type within
the operation of the protocol.¶



The last chunk type (255) is reserved for future extension if necessary.¶
For each new chunk type, IANA creates a registration table for the
chunk flags of that type.
The procedure for registering particular chunk flags is described in
Section 15.2.¶





15.2. IETF-Defined Chunk Flags Registration

The assignment of new chunk flags is done through an RFC Required action,
as defined in [RFC8126].
Documentation for the chunk flags MUST contain the following information:¶

a)

A name for the new chunk flag.¶


b)

A detailed procedural description of the use of the new chunk flag within
the operation of the protocol.
It MUST be considered that implementations not supporting the flag will send 0
on transmit and just ignore it on receipt.¶



IANA selects a chunk flags value.
This MUST be one of 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, or 0x80, which
MUST be unique within the chunk flag values for the specific chunk type.¶





15.3. IETF-Defined Chunk Parameter Extension

The assignment of new chunk parameter type codes is done through an IETF
Review action, as defined in [RFC8126].
Documentation of the chunk parameter MUST contain the following information:¶

a)

Name of the parameter type.¶


b)

Detailed description of the structure of the parameter field.
This structure MUST conform to the general Type-Length-Value format described
in Section 3.2.1.¶


c)

Detailed definition of each component of the parameter value.¶


d)

Detailed description of the intended use of this parameter type and an
indication of whether and under what circumstances multiple instances of this
parameter type can be found within the same chunk.¶


e)

Each parameter type MUST be unique across all chunks.¶








15.4. IETF-Defined Additional Error Causes

Additional cause codes can be allocated through a Specification Required action as defined in [RFC8126].
Provided documentation MUST include the following information:¶

a)

Name of the error condition.¶


b)

Detailed description of the conditions under which an SCTP endpoint
issues an ERROR (or ABORT) chunk with this cause code.¶


c)

Expected action by the SCTP endpoint that receives an ERROR (or ABORT) chunk
containing this cause code.¶


d)

Detailed description of the structure and content of data fields that
accompany this cause code.¶



The initial word (32 bits) of a cause code parameter MUST conform to the
format shown in Section 3.3.10, that is:¶


first 2 bytes contain the cause code value¶


last 2 bytes contain the length of the error cause.¶







15.5. Payload Protocol Identifiers

The assignment of payload protocol identifiers is done using the First Come
First Served policy, as defined in [RFC8126].¶
Except for value 0, which is reserved to indicate an unspecified payload
protocol identifier in a DATA chunk, an SCTP implementation will not be
responsible for standardizing or verifying any payload protocol identifiers.
An SCTP implementation simply receives the identifier from the upper layer
and carries it with the corresponding payload data.¶
The upper layer, i.e., the SCTP user, SHOULD standardize any specific
protocol identifier with IANA if it is so desired.
The use of any specific payload protocol identifier is out of the scope of
this specification.¶





15.6. Port Numbers Registry

SCTP services can use contact port numbers to provide service to unknown
callers, as in TCP and UDP.
An IESG-appointed Expert Reviewer supports IANA in evaluating SCTP port
allocation requests, according to the procedure defined in
[RFC8126].
The details of this process are defined in [RFC6335].¶







16. Suggested SCTP Protocol Parameter Values

The following protocol parameters are RECOMMENDED:¶

RTO.Initial:

1 second¶


RTO.Min:

1 second¶


RTO.Max:

60 seconds¶


Max.Burst:

4¶


RTO.Alpha:

1/8¶


RTO.Beta:

1/4¶


Valid.Cookie.Life:

60 seconds¶


Association.Max.Retrans:

10 attempts¶


Path.Max.Retrans:

5 attempts (per destination address)¶


Max.Init.Retransmits:

8 attempts¶


HB.interval:

30 seconds¶


HB.Max.Burst:

1¶


SACK.Delay:

200 milliseconds¶



Implementation Note: The SCTP implementation can allow ULP to customize some
of these protocol parameters (see Section 11).¶
'RTO.Min' SHOULD be set as described above in this section.¶




17. References



17.1. Normative References


[ITU.V42.1994]

International Telecommunications Union, ""Error-correcting Procedures for DCEs Using Asynchronous-to-Synchronous Conversion"", ITU-T Recommendation V.42, 1994. 

[RFC1122]

Braden, R., Ed., ""Requirements for Internet Hosts - Communication Layers"", STD 3, RFC 1122, DOI 10.17487/RFC1122, October 1989, <https://www.rfc-editor.org/info/rfc1122>. 

[RFC1123]

Braden, R., Ed., ""Requirements for Internet Hosts - Application and Support"", STD 3, RFC 1123, DOI 10.17487/RFC1123, October 1989, <https://www.rfc-editor.org/info/rfc1123>. 

[RFC1191]

Mogul, J. and S. Deering, ""Path MTU discovery"", RFC 1191, DOI 10.17487/RFC1191, November 1990, <https://www.rfc-editor.org/info/rfc1191>. 

[RFC1982]

Elz, R. and R. Bush, ""Serial Number Arithmetic"", RFC 1982, DOI 10.17487/RFC1982, August 1996, <https://www.rfc-editor.org/info/rfc1982>. 

[RFC2119]

Bradner, S., ""Key words for use in RFCs to Indicate Requirement Levels"", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>. 

[RFC4291]

Hinden, R. and S. Deering, ""IP Version 6 Addressing Architecture"", RFC 4291, DOI 10.17487/RFC4291, February 2006, <https://www.rfc-editor.org/info/rfc4291>. 

[RFC4303]

Kent, S., ""IP Encapsulating Security Payload (ESP)"", RFC 4303, DOI 10.17487/RFC4303, December 2005, <https://www.rfc-editor.org/info/rfc4303>. 

[RFC4895]

Tuexen, M., Stewart, R., Lei, P., and E. Rescorla, ""Authenticated Chunks for the Stream Control Transmission Protocol (SCTP)"", RFC 4895, DOI 10.17487/RFC4895, August 2007, <https://www.rfc-editor.org/info/rfc4895>. 

[RFC5681]

Allman, M., Paxson, V., and E. Blanton, ""TCP Congestion Control"", RFC 5681, DOI 10.17487/RFC5681, September 2009, <https://www.rfc-editor.org/info/rfc5681>. 

[RFC6335]

Cotton, M., Eggert, L., Touch, J., Westerlund, M., and S. Cheshire, ""Internet Assigned Numbers Authority (IANA) Procedures for the Management of the Service Name and Transport Protocol Port Number Registry"", BCP 165, RFC 6335, DOI 10.17487/RFC6335, August 2011, <https://www.rfc-editor.org/info/rfc6335>. 

[RFC6083]

Tuexen, M., Seggelmann, R., and E. Rescorla, ""Datagram Transport Layer Security (DTLS) for Stream Control Transmission Protocol (SCTP)"", RFC 6083, DOI 10.17487/RFC6083, January 2011, <https://www.rfc-editor.org/info/rfc6083>. 

[RFC7296]

Kaufman, C., Hoffman, P., Nir, Y., Eronen, P., and T. Kivinen, ""Internet Key Exchange Protocol Version 2 (IKEv2)"", STD 79, RFC 7296, DOI 10.17487/RFC7296, October 2014, <https://www.rfc-editor.org/info/rfc7296>. 

[RFC8126]

Cotton, M., Leiba, B., and T. Narten, ""Guidelines for Writing an IANA Considerations Section in RFCs"", BCP 26, RFC 8126, DOI 10.17487/RFC8126, June 2017, <https://www.rfc-editor.org/info/rfc8126>. 

[RFC8174]

Leiba, B., ""Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words"", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>. 

[RFC8200]

Deering, S. and R. Hinden, ""Internet Protocol, Version 6 (IPv6) Specification"", STD 86, RFC 8200, DOI 10.17487/RFC8200, July 2017, <https://www.rfc-editor.org/info/rfc8200>. 

[RFC8201]

McCann, J., Deering, S., Mogul, J., and R. Hinden, Ed., ""Path MTU Discovery for IP version 6"", STD 87, RFC 8201, DOI 10.17487/RFC8201, July 2017, <https://www.rfc-editor.org/info/rfc8201>. 

[RFC8899]

Fairhurst, G., Jones, T., Tüxen, M., Rüngeler, I., and T. Völker, ""Packetization Layer Path MTU Discovery for Datagram Transports"", RFC 8899, DOI 10.17487/RFC8899, September 2020, <https://www.rfc-editor.org/info/rfc8899>. 





17.2. Informative References


[FALL96]

Fall, K. and S. Floyd, ""Simulation-based Comparisons of Tahoe, Reno, and SACK TCP"", SIGCOM 99, V. 26, N. 3, pp 5-21, July 1996. 

[SAVAGE99]

Savage, S., Cardwell, N., Wetherall, D., and T. Anderson, ""TCP Congestion Control with a Misbehaving Receiver"", ACM Computer Communications Review 29(5), October 1999. 

[ALLMAN99]

Allman, M. and V. Paxson, ""On Estimating End-to-End Network Path Properties"", SIGCOM 99, October 1999. 

[WILLIAMS93]

Williams, R., ""A PAINLESS GUIDE TO CRC ERROR DETECTION ALGORITHMS"", SIGCOM 99, August 1993, <https://archive.org/stream/PainlessCRC/crc_v3.txt>. 

[RFC0768]

Postel, J., ""User Datagram Protocol"", STD 6, RFC 768, DOI 10.17487/RFC0768, August 1980, <https://www.rfc-editor.org/info/rfc768>. 

[RFC0793]

Postel, J., ""Transmission Control Protocol"", STD 7, RFC 793, DOI 10.17487/RFC0793, September 1981, <https://www.rfc-editor.org/info/rfc793>. 

[RFC1858]

Ziemba, G., Reed, D., and P. Traina, ""Security Considerations for IP Fragment Filtering"", RFC 1858, DOI 10.17487/RFC1858, October 1995, <https://www.rfc-editor.org/info/rfc1858>. 

[RFC2104]

Krawczyk, H., Bellare, M., and R. Canetti, ""HMAC: Keyed-Hashing for Message Authentication"", RFC 2104, DOI 10.17487/RFC2104, February 1997, <https://www.rfc-editor.org/info/rfc2104>. 

[RFC2196]

Fraser, B., ""Site Security Handbook"", FYI 8, RFC 2196, DOI 10.17487/RFC2196, September 1997, <https://www.rfc-editor.org/info/rfc2196>. 

[RFC2522]

Karn, P. and W. Simpson, ""Photuris: Session-Key Management Protocol"", RFC 2522, DOI 10.17487/RFC2522, March 1999, <https://www.rfc-editor.org/info/rfc2522>. 

[RFC2960]

Stewart, R., Xie, Q., Morneault, K., Sharp, C., Schwarzbauer, H., Taylor, T., Rytina, I., Kalla, M., Zhang, L., and V. Paxson, ""Stream Control Transmission Protocol"", RFC 2960, DOI 10.17487/RFC2960, October 2000, <https://www.rfc-editor.org/info/rfc2960>. 

[RFC3465]

Allman, M., ""TCP Congestion Control with Appropriate Byte Counting (ABC)"", RFC 3465, DOI 10.17487/RFC3465, February 2003, <https://www.rfc-editor.org/info/rfc3465>. 

[RFC3873]

Pastor, J. and M. Belinchon, ""Stream Control Transmission Protocol (SCTP) Management Information Base (MIB)"", RFC 3873, DOI 10.17487/RFC3873, September 2004, <https://www.rfc-editor.org/info/rfc3873>. 

[RFC4086]

Eastlake 3rd, D., Schiller, J., and S. Crocker, ""Randomness Requirements for Security"", BCP 106, RFC 4086, DOI 10.17487/RFC4086, June 2005, <https://www.rfc-editor.org/info/rfc4086>. 

[RFC4301]

Kent, S. and K. Seo, ""Security Architecture for the Internet Protocol"", RFC 4301, DOI 10.17487/RFC4301, December 2005, <https://www.rfc-editor.org/info/rfc4301>. 

[RFC4460]

Stewart, R., Arias-Rodriguez, I., Poon, K., Caro, A., and M. Tuexen, ""Stream Control Transmission Protocol (SCTP) Specification Errata and Issues"", RFC 4460, DOI 10.17487/RFC4460, April 2006, <https://www.rfc-editor.org/info/rfc4460>. 

[RFC4960]

Stewart, R., Ed., ""Stream Control Transmission Protocol"", RFC 4960, DOI 10.17487/RFC4960, September 2007, <https://www.rfc-editor.org/info/rfc4960>. 

[RFC6096]

Tuexen, M. and R. Stewart, ""Stream Control Transmission Protocol (SCTP) Chunk Flags Registration"", RFC 6096, DOI 10.17487/RFC6096, January 2011, <https://www.rfc-editor.org/info/rfc6096>. 

[RFC6458]

Stewart, R., Tuexen, M., Poon, K., Lei, P., and V. Yasevich, ""Sockets API Extensions for the Stream Control Transmission Protocol (SCTP)"", RFC 6458, DOI 10.17487/RFC6458, December 2011, <https://www.rfc-editor.org/info/rfc6458>. 

[RFC6951]

Tuexen, M. and R. Stewart, ""UDP Encapsulation of Stream Control Transmission Protocol (SCTP) Packets for End-Host to End-Host Communication"", RFC 6951, DOI 10.17487/RFC6951, May 2013, <https://www.rfc-editor.org/info/rfc6951>. 

[RFC7053]

Tuexen, M., Ruengeler, I., and R. Stewart, ""SACK-IMMEDIATELY Extension for the Stream Control Transmission Protocol"", RFC 7053, DOI 10.17487/RFC7053, November 2013, <https://www.rfc-editor.org/info/rfc7053>. 

[RFC8260]

Stewart, R., Tuexen, M., Loreto, S., and R. Seggelmann, ""Stream Schedulers and User Message Interleaving for the Stream Control Transmission Protocol"", RFC 8260, DOI 10.17487/RFC8260, November 2017, <https://www.rfc-editor.org/info/rfc8260>. 

[RFC8261]

Tuexen, M., Stewart, R., Jesup, R., and S. Loreto, ""Datagram Transport Layer Security (DTLS) Encapsulation of SCTP Packets"", RFC 8261, DOI 10.17487/RFC8261, November 2017, <https://www.rfc-editor.org/info/rfc8261>. 

[RFC8540]

Stewart, R., Tuexen, M., and M. Proshin, ""Stream Control Transmission Protocol: Errata and Issues in RFC 4960"", RFC 8540, DOI 10.17487/RFC8540, February 2019, <https://www.rfc-editor.org/info/rfc8540>. 







Appendix A. CRC32c Checksum Calculation

We define a 'reflected value' as one that is the opposite of the normal
bit order of the machine.
The 32-bit CRC (Cyclic Redundancy Check) is calculated, as described for CRC32c
and uses the polynomial code 0x11EDC6F41 (Castagnoli93) or
x32+x28+x27+x26+x25+x23+x22+x20+x19+x18+x14+x13+x11+x10+x9+x8+x6+x0.
The CRC is computed using a procedure similar to
ETHERNET CRC [ITU.V42.1994], modified to reflect
transport-level usage.¶
CRC computation uses polynomial division. A message bit-string M is
transformed to a polynomial, M(X), and the CRC is calculated from M(X) using
polynomial arithmetic.¶
When CRCs are used at the link layer, the polynomial is derived from
on-the-wire bit ordering: the first bit 'on the wire' is the high-order
coefficient.
Since SCTP is a transport-level protocol, it cannot know the actual
serial-media bit ordering.
Moreover, different links in the path between SCTP endpoints can use different
link-level bit orders.¶
A convention therefore is established for mapping SCTP transport
messages to polynomials for purposes of CRC computation.
The bit-ordering for mapping SCTP messages to polynomials is that bytes are
taken most-significant first, but, within each byte, bits are taken
least-significant first.
The first byte of the message provides the eight highest coefficients.
Within each byte, the least-significant SCTP bit gives the most-significant
polynomial coefficient within that byte, and the most-significant SCTP bit is
the least-significant polynomial coefficient in that byte.
(This bit ordering is sometimes called 'mirrored' or 'reflected'
[WILLIAMS93].)
CRC polynomials are to be transformed back into SCTP transport-level
byte values, using a consistent mapping.¶
The SCTP transport-level CRC value can be calculated as follows:¶


CRC input data is assigned to a byte stream, numbered from 0 to N-1.¶


The transport-level byte stream is mapped to a polynomial value.
An N-byte PDU with j bytes numbered 0 to N-1 is considered as
coefficients of a polynomial M(x) of order 8*N-1, with bit 0 of
byte j being coefficient x8*(N-j)-8 and bit 7 of byte j being
coefficient x8*(N-j)-1.¶


The CRC remainder register is initialized with all 1s and the CRC is computed
with an algorithm that simultaneously multiplies by x32 and divides by the
CRC polynomial.¶


The polynomial is multiplied by x32 and divided by G(x), the generator
polynomial, producing a remainder R(x) of degree less than or equal to 31.¶


The coefficients of R(x) are considered a 32-bit sequence.¶


The bit sequence is complemented.
The result is the CRC polynomial.¶


The CRC polynomial is mapped back into SCTP transport-level bytes.
The coefficient of x31 gives the value of bit 7 of SCTP byte 0,
and the coefficient of x24 gives the value of bit 0 of byte 0.
The coefficient of x7 gives bit 7 of byte 3, and the coefficient
of x0 gives bit 0 of byte 3.
The resulting 4-byte transport-level sequence is the 32-bit SCTP checksum
value.¶


Implementation Note: Standards documents, textbooks, and vendor
literature on CRCs often follow an alternative formulation, in which the
register used to hold the remainder of the long-division algorithm is
initialized to zero rather than all ones, and instead the first 32 bits of the
message are complemented.
The long-division algorithm used in our formulation is specified such that the
initial multiplication by 232 and the long-division are combined into one
simultaneous operation.
For such algorithms, and for messages longer than 64 bits, the two
specifications are precisely equivalent.
That equivalence is the intent of this document.¶
Implementors of SCTP are warned that both specifications are to be
found in the literature, sometimes with no restriction on the long-division
algorithm.
The choice of formulation in this document is to permit non-SCTP usage, where
the same CRC algorithm can be used to protect messages shorter than 64 bits.¶
There can be a computational advantage in validating the association
against the Verification Tag, prior to performing a checksum, as invalid tags
will result in the same action as a bad checksum in most cases.
The exceptions for this technique would be packets containing INIT chunks and
some SHUTDOWN-COMPLETE chunks, as well as a stale COOKIE ECHO chunks.
These special-case exchanges represent small packets and will minimize
the effect of the checksum calculation.¶
The following non-normative sample code is taken from an open-source
CRC generator [WILLIAMS93], using the ""mirroring"" technique and
yielding a lookup table for SCTP CRC32c with 256 entries, each 32 bits wide.
While neither especially slow nor especially fast, as software table-lookup
CRCs go, it has the advantage of working on both big-endian and little-endian
CPUs, using the same (host-order) lookup tables, and using only the
predefined ntohl() and htonl() operations.
The code is somewhat modified from [WILLIAMS93] to ensure
portability between big-endian and little-endian architectures, use fixed-sized
types to allow portability between 32-bit and 64-bit platforms, and use
general C code improvements.
(Note that, if the byte endian-ness of the target architecture is known to be
little endian, the final bit-reversal and byte-reversal steps can be folded
into a single operation.)¶

<CODE BEGINS>
/****************************************************************/
/* Note: The definitions for Ross Williams's table generator    */
/* would be TB_WIDTH=4, TB_POLY=0x1EDC6F41, TB_REVER=TRUE.      */
/* For Mr. Williams's direct calculation code, use the settings */
/* cm_width=32, cm_poly=0x1EDC6F41, cm_init=0xFFFFFFFF,         */
/* cm_refin=TRUE, cm_refot=TRUE, cm_xorot=0x00000000.           */
/****************************************************************/

/* Example of the crc table file */
#ifndef __crc32cr_h__
#define __crc32cr_h__

#define CRC32C_POLY 0x1EDC6F41UL
#define CRC32C(c,d) (c=(c>>8)^crc_c[(c^(d))&0xFF])

uint32_t crc_c[256] = {
  0x00000000UL, 0xF26B8303UL, 0xE13B70F7UL, 0x1350F3F4UL,
  0xC79A971FUL, 0x35F1141CUL, 0x26A1E7E8UL, 0xD4CA64EBUL,
  0x8AD958CFUL, 0x78B2DBCCUL, 0x6BE22838UL, 0x9989AB3BUL,
  0x4D43CFD0UL, 0xBF284CD3UL, 0xAC78BF27UL, 0x5E133C24UL,
  0x105EC76FUL, 0xE235446CUL, 0xF165B798UL, 0x030E349BUL,
  0xD7C45070UL, 0x25AFD373UL, 0x36FF2087UL, 0xC494A384UL,
  0x9A879FA0UL, 0x68EC1CA3UL, 0x7BBCEF57UL, 0x89D76C54UL,
  0x5D1D08BFUL, 0xAF768BBCUL, 0xBC267848UL, 0x4E4DFB4BUL,
  0x20BD8EDEUL, 0xD2D60DDDUL, 0xC186FE29UL, 0x33ED7D2AUL,
  0xE72719C1UL, 0x154C9AC2UL, 0x061C6936UL, 0xF477EA35UL,
  0xAA64D611UL, 0x580F5512UL, 0x4B5FA6E6UL, 0xB93425E5UL,
  0x6DFE410EUL, 0x9F95C20DUL, 0x8CC531F9UL, 0x7EAEB2FAUL,
  0x30E349B1UL, 0xC288CAB2UL, 0xD1D83946UL, 0x23B3BA45UL,
  0xF779DEAEUL, 0x05125DADUL, 0x1642AE59UL, 0xE4292D5AUL,
  0xBA3A117EUL, 0x4851927DUL, 0x5B016189UL, 0xA96AE28AUL,
  0x7DA08661UL, 0x8FCB0562UL, 0x9C9BF696UL, 0x6EF07595UL,
  0x417B1DBCUL, 0xB3109EBFUL, 0xA0406D4BUL, 0x522BEE48UL,
  0x86E18AA3UL, 0x748A09A0UL, 0x67DAFA54UL, 0x95B17957UL,
  0xCBA24573UL, 0x39C9C670UL, 0x2A993584UL, 0xD8F2B687UL,
  0x0C38D26CUL, 0xFE53516FUL, 0xED03A29BUL, 0x1F682198UL,
  0x5125DAD3UL, 0xA34E59D0UL, 0xB01EAA24UL, 0x42752927UL,
  0x96BF4DCCUL, 0x64D4CECFUL, 0x77843D3BUL, 0x85EFBE38UL,
  0xDBFC821CUL, 0x2997011FUL, 0x3AC7F2EBUL, 0xC8AC71E8UL,
  0x1C661503UL, 0xEE0D9600UL, 0xFD5D65F4UL, 0x0F36E6F7UL,
  0x61C69362UL, 0x93AD1061UL, 0x80FDE395UL, 0x72966096UL,
  0xA65C047DUL, 0x5437877EUL, 0x4767748AUL, 0xB50CF789UL,
  0xEB1FCBADUL, 0x197448AEUL, 0x0A24BB5AUL, 0xF84F3859UL,
  0x2C855CB2UL, 0xDEEEDFB1UL, 0xCDBE2C45UL, 0x3FD5AF46UL,
  0x7198540DUL, 0x83F3D70EUL, 0x90A324FAUL, 0x62C8A7F9UL,
  0xB602C312UL, 0x44694011UL, 0x5739B3E5UL, 0xA55230E6UL,
  0xFB410CC2UL, 0x092A8FC1UL, 0x1A7A7C35UL, 0xE811FF36UL,
  0x3CDB9BDDUL, 0xCEB018DEUL, 0xDDE0EB2AUL, 0x2F8B6829UL,
  0x82F63B78UL, 0x709DB87BUL, 0x63CD4B8FUL, 0x91A6C88CUL,
  0x456CAC67UL, 0xB7072F64UL, 0xA457DC90UL, 0x563C5F93UL,
  0x082F63B7UL, 0xFA44E0B4UL, 0xE9141340UL, 0x1B7F9043UL,
  0xCFB5F4A8UL, 0x3DDE77ABUL, 0x2E8E845FUL, 0xDCE5075CUL,
  0x92A8FC17UL, 0x60C37F14UL, 0x73938CE0UL, 0x81F80FE3UL,
  0x55326B08UL, 0xA759E80BUL, 0xB4091BFFUL, 0x466298FCUL,
  0x1871A4D8UL, 0xEA1A27DBUL, 0xF94AD42FUL, 0x0B21572CUL,
  0xDFEB33C7UL, 0x2D80B0C4UL, 0x3ED04330UL, 0xCCBBC033UL,
  0xA24BB5A6UL, 0x502036A5UL, 0x4370C551UL, 0xB11B4652UL,
  0x65D122B9UL, 0x97BAA1BAUL, 0x84EA524EUL, 0x7681D14DUL,
  0x2892ED69UL, 0xDAF96E6AUL, 0xC9A99D9EUL, 0x3BC21E9DUL,
  0xEF087A76UL, 0x1D63F975UL, 0x0E330A81UL, 0xFC588982UL,
  0xB21572C9UL, 0x407EF1CAUL, 0x532E023EUL, 0xA145813DUL,
  0x758FE5D6UL, 0x87E466D5UL, 0x94B49521UL, 0x66DF1622UL,
  0x38CC2A06UL, 0xCAA7A905UL, 0xD9F75AF1UL, 0x2B9CD9F2UL,
  0xFF56BD19UL, 0x0D3D3E1AUL, 0x1E6DCDEEUL, 0xEC064EEDUL,
  0xC38D26C4UL, 0x31E6A5C7UL, 0x22B65633UL, 0xD0DDD530UL,
  0x0417B1DBUL, 0xF67C32D8UL, 0xE52CC12CUL, 0x1747422FUL,
  0x49547E0BUL, 0xBB3FFD08UL, 0xA86F0EFCUL, 0x5A048DFFUL,
  0x8ECEE914UL, 0x7CA56A17UL, 0x6FF599E3UL, 0x9D9E1AE0UL,
  0xD3D3E1ABUL, 0x21B862A8UL, 0x32E8915CUL, 0xC083125FUL,
  0x144976B4UL, 0xE622F5B7UL, 0xF5720643UL, 0x07198540UL,
  0x590AB964UL, 0xAB613A67UL, 0xB831C993UL, 0x4A5A4A90UL,
  0x9E902E7BUL, 0x6CFBAD78UL, 0x7FAB5E8CUL, 0x8DC0DD8FUL,
  0xE330A81AUL, 0x115B2B19UL, 0x020BD8EDUL, 0xF0605BEEUL,
  0x24AA3F05UL, 0xD6C1BC06UL, 0xC5914FF2UL, 0x37FACCF1UL,
  0x69E9F0D5UL, 0x9B8273D6UL, 0x88D28022UL, 0x7AB90321UL,
  0xAE7367CAUL, 0x5C18E4C9UL, 0x4F48173DUL, 0xBD23943EUL,
  0xF36E6F75UL, 0x0105EC76UL, 0x12551F82UL, 0xE03E9C81UL,
  0x34F4F86AUL, 0xC69F7B69UL, 0xD5CF889DUL, 0x27A40B9EUL,
  0x79B737BAUL, 0x8BDCB4B9UL, 0x988C474DUL, 0x6AE7C44EUL,
  0xBE2DA0A5UL, 0x4C4623A6UL, 0x5F16D052UL, 0xAD7D5351UL,
};

#endif


/* Example of table build routine */

#include <stdio.h>
#include <stdlib.h>

#define OUTPUT_FILE   ""crc32cr.h""
#define CRC32C_POLY    0x1EDC6F41UL

static FILE *tf;

static uint32_t
reflect_32(uint32_t b)
{
  int i;
  uint32_t rw = 0UL;

  for (i = 0; i < 32; i++) {
    if (b & 1)
      rw |= 1UL << (31 - i);
    b >>= 1;
  }
  return (rw);
}

static uint32_t
build_crc_table (int index)
{
  int i;
  uint32_t rb;

  rb = reflect_32(index);

  for (i = 0; i < 8; i++) {
    if (rb & 0x80000000UL)
      rb = (rb << 1) ^ (uint32_t)CRC32C_POLY;
    else
      rb <<= 1;
  }
  return (reflect_32(rb));
}

int
main (void)
{
  int i;

  printf(""\nGenerating CRC32c table file <%s>.\n"",
  OUTPUT_FILE);
  if ((tf = fopen(OUTPUT_FILE, ""w"")) == NULL) {
    printf(""Unable to open %s.\n"", OUTPUT_FILE);
    exit (1);
  }
  fprintf(tf, ""#ifndef __crc32cr_h__\n"");
  fprintf(tf, ""#define __crc32cr_h__\n\n"");
  fprintf(tf, ""#define CRC32C_POLY 0x%08XUL\n"",
    (uint32_t)CRC32C_POLY);
  fprintf(tf,
    ""#define CRC32C(c,d) (c=(c>>8)^crc_c[(c^(d))&0xFF])\n"");
  fprintf(tf, ""\nuint32_t crc_c[256] =\n{\n"");
  for (i = 0; i < 256; i++) {
    fprintf(tf, ""0x%08XUL,"", build_crc_table (i));
    if ((i & 3) == 3)
      fprintf(tf, ""\n"");
    else
      fprintf(tf, "" "");
  }
  fprintf(tf, ""};\n\n#endif\n"");

  if (fclose(tf) != 0)
    printf(""Unable to close <%s>.\n"", OUTPUT_FILE);
  else
    printf(""\nThe CRC32c table has been written to <%s>.\n"",
      OUTPUT_FILE);
  return (0);
}

/* Example of crc insertion */

#include ""crc32cr.h""

uint32_t
generate_crc32c(unsigned char *buffer, unsigned int length)
{
  unsigned int i;
  uint32_t crc32 = 0xffffffffUL;
  uint32_t result;
  uint32_t byte0, byte1, byte2, byte3;

  for (i = 0; i < length; i++) {
    CRC32C(crc32, buffer[i]);
  }

  result = ~crc32;

  /*  result now holds the negated polynomial remainder,
   *  since the table and algorithm are ""reflected"" [williams95].
   *  That is, result has the same value as if we mapped the message
   *  to a polynomial, computed the host-bit-order polynomial
   *  remainder, performed final negation, and then did an
   *  end-for-end bit-reversal.
   *  Note that a 32-bit bit-reversal is identical to four in-place
   *  8-bit bit-reversals followed by an end-for-end byteswap.
   *  In other words, the bits of each byte are in the right order,
   *  but the bytes have been byteswapped.  So, we now do an explicit
   *  byteswap.  On a little-endian machine, this byteswap and
   *  the final ntohl cancel out and could be elided.
   */

  byte0 = result & 0xff;
  byte1 = (result>>8) & 0xff;
  byte2 = (result>>16) & 0xff;
  byte3 = (result>>24) & 0xff;
  crc32 = ((byte0 << 24) |
           (byte1 << 16) |
           (byte2 << 8)  |
           byte3);
  return (crc32);
}

int
insert_crc32(unsigned char *buffer, unsigned int length)
{
  SCTP_message *message;
  uint32_t crc32;

  message = (SCTP_message *)buffer;
  message->common_header.checksum = 0UL;
  crc32 = generate_crc32c(buffer,length);
  /* and insert it into the message */
  message->common_header.checksum = htonl(crc32);
  return (1);
}

int
validate_crc32(unsigned char *buffer, unsigned int length)
{
  SCTP_message *message;
  unsigned int i;
  uint32_t original_crc32;
  uint32_t crc32;

  /* save and zero checksum */
  message = (SCTP_message *)buffer;
  original_crc32 = ntohl(message->common_header.checksum);
  message->common_header.checksum = 0L;
  crc32 = generate_crc32c(buffer, length);
  return ((original_crc32 == crc32) ? 1 : -1);
}
<CODE ENDS>
¶






Acknowledgements

An undertaking represented by this updated document is not a small
feat and represents the summation of the initial coauthors of
[RFC2960]:
Q. Xie,
K. Morneault,
C. Sharp,
H. Schwarzbauer,
T. Taylor,
I. Rytina,
M. Kalla,
L. Zhang,
and V. Paxson.¶
Add to that, the comments from everyone who contributed to
[RFC2960]:
Mark Allman,
R. J. Atkinson,
Richard Band,
Scott Bradner,
Steve Bellovin,
Peter Butler,
Ram Dantu,
R. Ezhirpavai,
Mike Fisk,
Sally Floyd,
Atsushi Fukumoto,
Matt Holdrege,
Henry Houh,
Christian Huitema,
Gary Lehecka,
Jonathan Lee,
David Lehmann,
John Loughney,
Daniel Luan,
Barry Nagelberg,
Thomas Narten,
Erik Nordmark,
Lyndon Ong,
Shyamal Prasad,
Kelvin Porter,
Heinz Prantner,
Jarno Rajahalme,
Raymond E. Reeves,
Renee Revis,
Ivan Arias Rodriguez,
A. Sankar,
Greg Sidebottom,
Brian Wyld,
La Monte Yarroll,
and many others for their invaluable comments.¶
Then, add the coauthors of [RFC4460]:
I. Arias-Rodriguez,
K. Poon,
and
A. Caro.¶
Then, add to these the efforts of all the subsequent seven
SCTP interoperability tests and those who commented on [RFC4460],
as shown in its acknowledgements:
Barry Zuckerman,
La Monte Yarroll,
Qiaobing Xie,
Wang Xiaopeng,
Jonathan Wood,
Jeff Waskow,
Mike Turner,
John Townsend,
Sabina Torrente,
Cliff Thomas,
Yuji Suzuki,
Manoj Solanki,
Sverre Slotte,
Keyur Shah,
Jan Rovins,
Ben Robinson,
Renee Revis,
Ian Periam,
RC Monee,
Sanjay Rao,
Sujith Radhakrishnan,
Heinz Prantner,
Biren Patel,
Nathalie Mouellic,
Mitch Miers,
Bernward Meyknecht,
Stan McClellan,
Oliver Mayor,
Tomas Orti Martin,
Sandeep Mahajan,
David Lehmann,
Jonathan Lee,
Philippe Langlois,
Karl Knutson,
Joe Keller,
Gareth Keily,
Andreas Jungmaier,
Janardhan Iyengar,
Mutsuya Irie,
John Hebert,
Kausar Hassan,
Fred Hasle,
Dan Harrison,
Jon Grim,
Laurent Glaude,
Steven Furniss,
Atsushi Fukumoto,
Ken Fujita,
Steve Dimig,
Thomas Curran,
Serkan Cil,
Melissa Campbell,
Peter Butler,
Rob Brennan,
Harsh Bhondwe,
Brian Bidulock,
Caitlin Bestler,
Jon Berger,
Robby Benedyk,
Stephen Baucke,
Sandeep Balani,
and
Ronnie Sellar.¶
A special thanks to Mark Allman, who actually should
have been a coauthor of [RFC4460] for his work on the max-burst but managed to wiggle out due to a
technicality.¶
Also, we would like to acknowledge Lyndon Ong and
Phil Conrad for their valuable input and many
contributions.¶
Furthermore, you have [RFC4960] and those who have commented
upon that, including Alfred Hönes and
Ronnie Sellars.¶
Then, add the coauthor of [RFC8540]:
Maksim Proshin.¶
And people who have commented on [RFC8540]:
Pontus Andersson,
Eric W. Biederman,
Cedric Bonnet,
Spencer Dawkins,
Gorry Fairhurst,
Benjamin Kaduk,
Mirja Kühlewind,
Peter Lei,
Gyula Marosi,
Lionel Morand,
Jeff Morriss,
Tom Petch,
Kacheong Poon,
Julien Pourtet,
Irene Rüngeler,
Michael Welzl,
and
Qiaobing Xie.¶
And, finally, the people who have provided comments for this document, including
Gorry Fairhurst,
Martin Duke,
Benjamin Kaduk,
Tero Kivinen,
Eliot Lear,
Marcelo Ricardo Leitner,
David Mandelberg,
John Preuß Mattsson,
Claudio Porfiri,
Maksim Proshin,
Ines Robles,
Timo Völker,
Magnus Westerlund,
and
Zhouming.¶
Our thanks cannot be adequately expressed to all of you who have participated
in the coding, testing, and updating process of this document.
All we can say is, Thank You!¶





Authors' Addresses


Randall R. Stewart
Netflix, Inc.
2455 Heritage Green Ave

Davenport, FL 33837

United States of America

Email:
randall@lakerest.net



Michael Tüxen
Münster University of Applied Sciences
Stegerwaldstrasse 39

48565 Steinfurt

Germany

Email:
tuexen@fh-muenster.de



Karen E. E. Nielsen
Kamstrup A/S
Industrivej 28

DK-8660 Skanderborg

Denmark

Email:
kee@kamstrup.com





"
RFC4340,"
[RFC Home] [TEXT|PDF|HTML] [Tracker] [IPR] [Errata] [Info page]                                                                 PROPOSED STANDARDUpdated by: 5595, 5596, 6335, 6773 Errata ExistNetwork Working Group                                          E. Kohler
Request for Comments: 4340                                          UCLA
Category: Standards Track                                     M. Handley
                                                                     UCL
                                                                S. Floyd
                                                                    ICIR
                                                              March 2006


              Datagram Congestion Control Protocol (DCCP)

Status of This Memo

   This document specifies an Internet standards track protocol for the
   Internet community, and requests discussion and suggestions for
   improvements.  Please refer to the current edition of the ""Internet
   Official Protocol Standards"" (STD 1) for the standardization state
   and status of this protocol.  Distribution of this memo is unlimited.

Copyright Notice

   Copyright (C) The Internet Society (2006).

Abstract

   The Datagram Congestion Control Protocol (DCCP) is a transport
   protocol that provides bidirectional unicast connections of
   congestion-controlled unreliable datagrams.  DCCP is suitable for
   applications that transfer fairly large amounts of data and that can
   benefit from control over the tradeoff between timeliness and
   reliability.

Table of Contents

   1. Introduction ....................................................5
   2. Design Rationale ................................................6
   3. Conventions and Terminology .....................................7
      3.1. Numbers and Fields .........................................7
      3.2. Parts of a Connection ......................................8
      3.3. Features ...................................................9
      3.4. Round-Trip Times ...........................................9
      3.5. Security Limitation ........................................9
      3.6. Robustness Principle ......................................10
   4. Overview .......................................................10
      4.1. Packet Types ..............................................10
      4.2. Packet Sequencing .........................................11
      4.3. States ....................................................12
      4.4. Congestion Control Mechanisms .............................14



Kohler, et al.              Standards Track                     [Page 1]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


      4.5. Feature Negotiation Options ...............................15
      4.6. Differences from TCP ......................................16
      4.7. Example Connection ........................................17
   5. Packet Formats .................................................18
      5.1. Generic Header ............................................19
      5.2. DCCP-Request Packets ......................................22
      5.3. DCCP-Response Packets .....................................23
      5.4. DCCP-Data, DCCP-Ack, and DCCP-DataAck Packets .............23
      5.5. DCCP-CloseReq and DCCP-Close Packets ......................25
      5.6. DCCP-Reset Packets ........................................25
      5.7. DCCP-Sync and DCCP-SyncAck Packets ........................28
      5.8. Options ...................................................29
           5.8.1. Padding Option .....................................31
           5.8.2. Mandatory Option ...................................31
   6. Feature Negotiation ............................................32
      6.1. Change Options ............................................32
      6.2. Confirm Options ...........................................33
      6.3. Reconciliation Rules ......................................33
           6.3.1. Server-Priority ....................................34
           6.3.2. Non-Negotiable .....................................34
      6.4. Feature Numbers ...........................................35
      6.5. Feature Negotiation Examples ..............................36
      6.6. Option Exchange ...........................................37
           6.6.1. Normal Exchange ....................................38
           6.6.2. Processing Received Options ........................38
           6.6.3. Loss and Retransmission ............................40
           6.6.4. Reordering .........................................41
           6.6.5. Preference Changes .................................42
           6.6.6. Simultaneous Negotiation ...........................42
           6.6.7. Unknown Features ...................................43
           6.6.8. Invalid Options ....................................43
           6.6.9. Mandatory Feature Negotiation ......................44
   7. Sequence Numbers ...............................................44
      7.1. Variables .................................................45
      7.2. Initial Sequence Numbers ..................................45
      7.3. Quiet Time ................................................46
      7.4. Acknowledgement Numbers ...................................47
      7.5. Validity and Synchronization ..............................47
           7.5.1. Sequence and Acknowledgement Number Windows ........48
           7.5.2. Sequence Window Feature ............................49
           7.5.3. Sequence-Validity Rules ............................49
           7.5.4. Handling Sequence-Invalid Packets ..................51
           7.5.5. Sequence Number Attacks ............................52
           7.5.6. Sequence Number Handling Examples ..................54
      7.6. Short Sequence Numbers ....................................55
           7.6.1. Allow Short Sequence Numbers Feature ...............55
           7.6.2. When to Avoid Short Sequence Numbers ...............56
      7.7. NDP Count and Detecting Application Loss ..................56



Kohler, et al.              Standards Track                     [Page 2]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


           7.7.1. NDP Count Usage Notes ..............................57
           7.7.2. Send NDP Count Feature .............................57
   8. Event Processing ...............................................58
      8.1. Connection Establishment ..................................58
           8.1.1. Client Request .....................................58
           8.1.2. Service Codes ......................................59
           8.1.3. Server Response ....................................61
           8.1.4. Init Cookie Option .................................62
           8.1.5. Handshake Completion ...............................63
      8.2. Data Transfer .............................................63
      8.3. Termination ...............................................64
           8.3.1. Abnormal Termination ...............................66
      8.4. DCCP State Diagram ........................................66
      8.5. Pseudocode ................................................67
   9. Checksums ......................................................72
      9.1. Header Checksum Field .....................................73
      9.2. Header Checksum Coverage Field ............................73
           9.2.1. Minimum Checksum Coverage Feature ..................74
      9.3. Data Checksum Option ......................................75
           9.3.1. Check Data Checksum Feature ........................76
           9.3.2. Checksum Usage Notes ...............................76
   10. Congestion Control ............................................76
      10.1. TCP-like Congestion Control ..............................77
      10.2. TFRC Congestion Control ..................................78
      10.3. CCID-Specific Options, Features, and Reset Codes .........78
      10.4. CCID Profile Requirements ................................80
      10.5. Congestion State .........................................81
   11. Acknowledgements ..............................................81
      11.1. Acks of Acks and Unidirectional Connections ..............82
      11.2. Ack Piggybacking .........................................83
      11.3. Ack Ratio Feature ........................................84
      11.4. Ack Vector Options .......................................85
           11.4.1. Ack Vector Consistency ............................88
           11.4.2. Ack Vector Coverage ...............................89
      11.5. Send Ack Vector Feature ..................................90
      11.6. Slow Receiver Option .....................................90
      11.7. Data Dropped Option ......................................91
           11.7.1. Data Dropped and Normal Congestion Response .......94
           11.7.2. Particular Drop Codes .............................95
   12. Explicit Congestion Notification ..............................96
      12.1. ECN Incapable Feature ....................................96
      12.2. ECN Nonces ...............................................97
      12.3. Aggression Penalties .....................................98
   13. Timing Options ................................................99
      13.1. Timestamp Option .........................................99
      13.2. Elapsed Time Option ......................................99
      13.3. Timestamp Echo Option ...................................100
   14. Maximum Packet Size ..........................................101



Kohler, et al.              Standards Track                     [Page 3]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


      14.1. Measuring PMTU ..........................................102
      14.2. Sender Behavior .........................................103
   15. Forward Compatibility ........................................104
   16. Middlebox Considerations .....................................105
   17. Relations to Other Specifications ............................106
      17.1. RTP .....................................................106
      17.2. Congestion Manager and Multiplexing .....................108
   18. Security Considerations ......................................108
      18.1. Security Considerations for Partial Checksums ...........109
   19. IANA Considerations ..........................................110
      19.1. Packet Types Registry ...................................110
      19.2. Reset Codes Registry ....................................110
      19.3. Option Types Registry ...................................110
      19.4. Feature Numbers Registry ................................111
      19.5. Congestion Control Identifiers Registry .................111
      19.6. Ack Vector States Registry ..............................111
      19.7. Drop Codes Registry .....................................112
      19.8. Service Codes Registry ..................................112
      19.9. Port Numbers Registry ...................................112
   20. Thanks .......................................................114
   A.  Appendix: Ack Vector Implementation Notes ....................116
       A.1. Packet Arrival ..........................................118
            A.1.1. New Packets ......................................118
            A.1.2. Old Packets ......................................119
       A.2. Sending Acknowledgements ................................120
       A.3. Clearing State ..........................................120
       A.4. Processing Acknowledgements .............................122
   B.  Appendix: Partial Checksumming Design Motivation .............123
   Normative References .............................................124
   Informative References ...........................................125

List of Tables

   Table 1: DCCP Packet Types .......................................21
   Table 2: DCCP Reset Codes ........................................28
   Table 3: DCCP Options ............................................30
   Table 4: DCCP Feature Numbers.....................................35
   Table 5: DCCP Congestion Control Identifiers .....................77
   Table 6: DCCP Ack Vector States ..................................86
   Table 7: DCCP Drop Codes .........................................92











Kohler, et al.              Standards Track                     [Page 4]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


1.  Introduction

   The Datagram Congestion Control Protocol (DCCP) is a transport
   protocol that implements bidirectional, unicast connections of
   congestion-controlled, unreliable datagrams.  Specifically, DCCP
   provides the following:

   o  Unreliable flows of datagrams.

   o  Reliable handshakes for connection setup and teardown.

   o  Reliable negotiation of options, including negotiation of a
      suitable congestion control mechanism.

   o  Mechanisms allowing servers to avoid holding state for
      unacknowledged connection attempts and already-finished
      connections.

   o  Congestion control incorporating Explicit Congestion Notification
      (ECN) [RFC3168] and the ECN Nonce [RFC3540].

   o  Acknowledgement mechanisms communicating packet loss and ECN
      information.  Acks are transmitted as reliably as the relevant
      congestion control mechanism requires, possibly completely
      reliably.

   o  Optional mechanisms that tell the sending application, with high
      reliability, which data packets reached the receiver, and whether
      those packets were ECN marked, corrupted, or dropped in the
      receive buffer.

   o  Path Maximum Transmission Unit (PMTU) discovery [RFC1191].

   o  A choice of modular congestion control mechanisms.  Two mechanisms
      are currently specified: TCP-like Congestion Control [RFC4341] and
      TCP-Friendly Rate Control (TFRC) [RFC4342].  DCCP is easily
      extensible to further forms of unicast congestion control.

   DCCP is intended for applications such as streaming media that can
   benefit from control over the tradeoffs between delay and reliable
   in-order delivery.  TCP is not well suited for these applications,
   since reliable in-order delivery and congestion control can cause
   arbitrarily long delays.  UDP avoids long delays, but UDP
   applications that implement congestion control must do so on their
   own.  DCCP provides built-in congestion control, including ECN






Kohler, et al.              Standards Track                     [Page 5]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   support, for unreliable datagram flows, avoiding the arbitrary delays
   associated with TCP.  It also implements reliable connection setup,
   teardown, and feature negotiation.

2.  Design Rationale

   One DCCP design goal was to give most streaming UDP applications
   little reason not to switch to DCCP, once it is deployed.  To
   facilitate this, DCCP was designed to have as little overhead as
   possible, both in terms of the packet header size and in terms of the
   state and CPU overhead required at end hosts.  Only the minimal
   necessary functionality was included in DCCP, leaving other
   functionality, such as forward error correction (FEC), semi-
   reliability, and multiple streams, to be layered on top of DCCP as
   desired.

   Different forms of conformant congestion control are appropriate for
   different applications.  For example, on-line games might want to
   make quick use of any available bandwidth, while streaming media
   might trade off this responsiveness for a steadier, less bursty rate.
   (Sudden rate changes can cause unacceptable UI glitches such as
   audible pauses or clicks in the playout stream.)  DCCP thus allows
   applications to choose from a set of congestion control mechanisms.
   One alternative, TCP-like Congestion Control, halves the congestion
   window in response to a packet drop or mark, as in TCP.  Applications
   using this congestion control mechanism will respond quickly to
   changes in available bandwidth, but must tolerate the abrupt changes
   in congestion window typical of TCP.  A second alternative, TCP-
   Friendly Rate Control (TFRC) [RFC3448], a form of equation-based
   congestion control, minimizes abrupt changes in the sending rate
   while maintaining longer-term fairness with TCP.  Other alternatives
   can be added as future congestion control mechanisms are
   standardized.

   DCCP also lets unreliable traffic safely use ECN.  A UDP kernel
   Application Programming Interface (API) might not allow applications
   to set UDP packets as ECN capable, since the API could not guarantee
   that the application would properly detect or respond to congestion.
   DCCP kernel APIs will have no such issues, since DCCP implements
   congestion control itself.

   We chose not to require the use of the Congestion Manager [RFC3124],
   which allows multiple concurrent streams between the same sender and
   receiver to share congestion control.  The current Congestion Manager
   can only be used by applications that have their own end-to-end
   feedback about packet losses, but this is not the case for many of
   the applications currently using UDP.  In addition, the current
   Congestion Manager does not easily support multiple congestion



Kohler, et al.              Standards Track                     [Page 6]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   control mechanisms or mechanisms where the state about past packet
   drops or marks is maintained at the receiver rather than the sender.
   DCCP should be able to make use of CM where desired by the
   application, but we do not see any benefit in making the deployment
   of DCCP contingent on the deployment of CM itself.

   We intend for DCCP's protocol mechanisms, which are described in this
   document, to suit any application desiring unicast congestion-
   controlled streams of unreliable datagrams.  However, the congestion
   control mechanisms currently approved for use with DCCP, which are
   described in separate Congestion Control ID Profiles [RFC4341,
   RFC4342], may cause problems for some applications, including high-
   bandwidth interactive video.  These applications should be able to
   use DCCP once suitable Congestion Control ID Profiles are
   standardized.

3.  Conventions and Terminology

   The key words ""MUST"", ""MUST NOT"", ""REQUIRED"", ""SHALL"", ""SHALL NOT"",
   ""SHOULD"", ""SHOULD NOT"", ""RECOMMENDED"", ""MAY"", and ""OPTIONAL"" in this
   document are to be interpreted as described in [RFC2119].

3.1.  Numbers and Fields

   All multi-byte numerical quantities in DCCP, such as port numbers,
   Sequence Numbers, and arguments to options, are transmitted in
   network byte order (most significant byte first).

   We occasionally refer to the ""left"" and ""right"" sides of a bit field.
   ""Left"" means towards the most significant bit, and ""right"" means
   towards the least significant bit.

   Random numbers in DCCP are used for their security properties and
   SHOULD be chosen according to the guidelines in [RFC4086].

   All operations on DCCP sequence numbers use circular arithmetic
   modulo 2^48, as do comparisons such as ""greater"" and ""greatest"".
   This form of arithmetic preserves the relationships between sequence
   numbers as they roll over from 2^48 - 1 to 0.  Implementation
   strategies for DCCP sequence numbers will resemble those for other
   circular arithmetic spaces, including TCP's sequence numbers [RFC793]
   and DNS's serial numbers [RFC1982].  It may make sense to store DCCP
   sequence numbers in the most significant 48 bits of 64-bit integers
   and set the least significant 16 bits to zero, since this supports a
   common technique that implements circular comparison A < B by testing
   whether (A - B) < 0 using conventional two's-complement arithmetic.





Kohler, et al.              Standards Track                     [Page 7]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   Reserved bitfields in DCCP packet headers MUST be set to zero by
   senders and MUST be ignored by receivers, unless otherwise specified.
   This allows for future protocol extensions.  In particular, DCCP
   processors MUST NOT reset a DCCP connection simply because a Reserved
   field has non-zero value [RFC3360].

3.2.  Parts of a Connection

   Each DCCP connection runs between two hosts, which we often name DCCP
   A and DCCP B.  Each connection is actively initiated by one of the
   hosts, which we call the client; the other, initially passive host is
   called the server.  The term ""DCCP endpoint"" is used to refer to
   either of the two hosts explicitly named by the connection (the
   client and the server).  The term ""DCCP processor"" refers more
   generally to any host that might need to process a DCCP header; this
   includes the endpoints and any middleboxes on the path, such as
   firewalls and network address translators.

   DCCP connections are bidirectional: data may pass from either
   endpoint to the other.  This means that data and acknowledgements may
   flow in both directions simultaneously.  Logically, however, a DCCP
   connection consists of two separate unidirectional connections,
   called half-connections.  Each half-connection consists of the
   application data sent by one endpoint and the corresponding
   acknowledgements sent by the other endpoint.  We can illustrate this
   as follows:

      +--------+  A-to-B half-connection:         +--------+
      |        |    -->  application data  -->    |        |
      |        |    <--  acknowledgements  <--    |        |
      | DCCP A |                                  | DCCP B |
      |        |  B-to-A half-connection:         |        |
      |        |    <--  application data  <--    |        |
      +--------+    -->  acknowledgements  -->    +--------+

   Although they are logically distinct, in practice the half-
   connections overlap; a DCCP-DataAck packet, for example, contains
   application data relevant to one half-connection and acknowledgement
   information relevant to the other.

   In the context of a single half-connection, the terms ""HC-Sender"" and
   ""HC-Receiver"" denote the endpoints sending application data and
   acknowledgements, respectively.  For example, DCCP A is the
   HC-Sender and DCCP B is the HC-Receiver in the A-to-B
   half-connection.






Kohler, et al.              Standards Track                     [Page 8]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


3.3.  Features

   A DCCP feature is a connection attribute on whose value the two
   endpoints agree.  Many properties of a DCCP connection are controlled
   by features, including the congestion control mechanisms in use on
   the two half-connections.  The endpoints achieve agreement through
   the exchange of feature negotiation options in DCCP headers.

   DCCP features are identified by a feature number and an endpoint.
   The notation ""F/X"" represents the feature with feature number F
   located at DCCP endpoint X.  Each valid feature number thus
   corresponds to two features, which are negotiated separately and need
   not have the same value.  The two endpoints know, and agree on, the
   value of every valid feature.  DCCP A is the ""feature location"" for
   all features F/A, and the ""feature remote"" for all features F/B.

3.4.  Round-Trip Times

   DCCP round-trip time measurements are performed by congestion control
   mechanisms; different mechanisms may measure round-trip time in
   different ways, or not measure it at all.  However, the main DCCP
   protocol does use round-trip times occasionally, such as in the
   initial values for certain timers.  Each DCCP implementation thus
   defines a default round-trip time for use when no estimate is
   available.  This parameter should default to not less than 0.2
   seconds, a reasonably conservative round-trip time for Internet TCP
   connections.  Protocol behavior specified in terms of ""round-trip
   time"" values actually refers to ""a current round-trip time estimate
   taken by some CCID, or, if no estimate is available, the default
   round-trip time parameter"".

   The maximum segment lifetime, or MSL, is the maximum length of time a
   packet can survive in the network.  The DCCP MSL should equal that of
   TCP, which is normally two minutes.

3.5.  Security Limitation

   DCCP provides no protection against attackers who can snoop on a
   connection in progress, or who can guess valid sequence numbers in
   other ways.  Applications desiring stronger security should use IPsec
   [RFC2401]; depending on the level of security required, application-
   level cryptography may also suffice.  These issues are discussed
   further in Sections 7.5.5 and 18.








Kohler, et al.              Standards Track                     [Page 9]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


3.6.  Robustness Principle

   DCCP implementations will follow TCP's ""general principle of
   robustness"": ""be conservative in what you do, be liberal in what you
   accept from others"" [RFC793].

4.  Overview

   DCCP's high-level connection dynamics echo those of TCP.  Connections
   progress through three phases: initiation, including a three-way
   handshake; data transfer; and termination.  Data can flow both ways
   over the connection.  An acknowledgement framework lets senders
   discover how much data has been lost and thus avoid unfairly
   congesting the network.  Of course, DCCP provides unreliable datagram
   semantics, not TCP's reliable bytestream semantics.  The application
   must package its data into explicit frames and must retransmit its
   own data as necessary.  It may be useful to think of DCCP as TCP
   minus bytestream semantics and reliability, or as UDP plus congestion
   control, handshakes, and acknowledgements.

4.1.  Packet Types

   Ten packet types implement DCCP's protocol functions.  For example,
   every new connection attempt begins with a DCCP-Request packet sent
   by the client.  In this way a DCCP-Request packet resembles a TCP
   SYN, but since DCCP-Request is a packet type there is no way to send
   an unexpected flag combination, such as TCP's SYN+FIN+ACK+RST.

   Eight packet types occur during the progress of a typical connection,
   shown here.  Note the three-way handshakes during initiation and
   termination.

      Client                                      Server
      ------                                      ------
                       (1) Initiation
      DCCP-Request -->
                                       <-- DCCP-Response
      DCCP-Ack -->
                       (2) Data transfer
      DCCP-Data, DCCP-Ack, DCCP-DataAck -->
                   <-- DCCP-Data, DCCP-Ack, DCCP-DataAck
                       (3) Termination
                                       <-- DCCP-CloseReq
      DCCP-Close -->
                                          <-- DCCP-Reset

   The two remaining packet types are used to resynchronize after bursts
   of loss.



Kohler, et al.              Standards Track                    [Page 10]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   Every DCCP packet starts with a fixed-size generic header.
   Particular packet types include additional fixed-size header data;
   for example, DCCP-Acks include an Acknowledgement Number.  DCCP
   options and any application data follow the fixed-size header.

   The packet types are as follows:

   DCCP-Request
      Sent by the client to initiate a connection (the first part of the
      three-way initiation handshake).

   DCCP-Response
      Sent by the server in response to a DCCP-Request (the second part
      of the three-way initiation handshake).

   DCCP-Data
      Used to transmit application data.

   DCCP-Ack
      Used to transmit pure acknowledgements.

   DCCP-DataAck
      Used to transmit application data with piggybacked acknowledgement
      information.

   DCCP-CloseReq
      Sent by the server to request that the client close the
      connection.

   DCCP-Close
      Used by the client or the server to close the connection; elicits
      a DCCP-Reset in response.

   DCCP-Reset
      Used to terminate the connection, either normally or abnormally.

   DCCP-Sync, DCCP-SyncAck
      Used to resynchronize sequence numbers after large bursts of loss.

4.2.  Packet Sequencing

   Each DCCP packet carries a sequence number so that losses can be
   detected and reported.  Unlike TCP sequence numbers, which are byte-
   based, DCCP sequence numbers increment by one per packet.  For
   example:






Kohler, et al.              Standards Track                    [Page 11]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


      DCCP A                                      DCCP B
      ------                                      ------
      DCCP-Data(seqno 1) -->
      DCCP-Data(seqno 2) -->
                         <-- DCCP-Ack(seqno 10, ackno 2)
      DCCP-DataAck(seqno 3, ackno 10) -->
                                 <-- DCCP-Data(seqno 11)

   Every DCCP packet increments the sequence number, whether or not it
   contains application data.  DCCP-Ack pure acknowledgements increment
   the sequence number; for instance, DCCP B's second packet above uses
   sequence number 11, since sequence number 10 was used for an
   acknowledgement.  This lets endpoints detect all packet loss,
   including acknowledgement loss.  It also means that endpoints can get
   out of sync after long bursts of loss.  The DCCP-Sync and DCCP-
   SyncAck packet types are used to recover (Section 7.5).

   Since DCCP provides unreliable semantics, there are no
   retransmissions, and having a TCP-style cumulative acknowledgement
   field doesn't make sense.  DCCP's Acknowledgement Number field equals
   the greatest sequence number received, rather than the smallest
   sequence number not received.  Separate options indicate any
   intermediate sequence numbers that weren't received.

4.3.  States

   DCCP endpoints progress through different states during the course of
   a connection, corresponding roughly to the three phases of
   initiation, data transfer, and termination.  The figure below shows
   the typical progress through these states for a client and server.





















Kohler, et al.              Standards Track                    [Page 12]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


      Client                                             Server
      ------                                             ------
                        (0) No connection
      CLOSED                                             LISTEN

                        (1) Initiation
      REQUEST      DCCP-Request -->
                                   <-- DCCP-Response     RESPOND
      PARTOPEN     DCCP-Ack or DCCP-DataAck -->

                        (2) Data transfer
      OPEN          <-- DCCP-Data, Ack, DataAck -->      OPEN

                        (3) Termination
                                   <-- DCCP-CloseReq     CLOSEREQ
      CLOSING      DCCP-Close -->
                                      <-- DCCP-Reset     CLOSED
      TIMEWAIT
      CLOSED

   The nine possible states are as follows.  They are listed in
   increasing order, so that ""state >= CLOSEREQ"" means the same as
   ""state = CLOSEREQ or state = CLOSING or state = TIMEWAIT"".  Section 8
   describes the states in more detail.

   CLOSED
      Represents nonexistent connections.

   LISTEN
      Represents server sockets in the passive listening state.  LISTEN
      and CLOSED are not associated with any particular DCCP connection.

   REQUEST
      A client socket enters this state, from CLOSED, after sending a
      DCCP-Request packet to try to initiate a connection.

   RESPOND
      A server socket enters this state, from LISTEN, after receiving a
      DCCP-Request from a client.

   PARTOPEN
      A client socket enters this state, from REQUEST, after receiving a
      DCCP-Response from the server.  This state represents the third
      phase of the three-way handshake.  The client may send application
      data in this state, but it MUST include an Acknowledgement Number
      on all of its packets.





Kohler, et al.              Standards Track                    [Page 13]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   OPEN
      The central data transfer portion of a DCCP connection.  Client
      and server sockets enter this state from PARTOPEN and RESPOND,
      respectively.  Sometimes we speak of SERVER-OPEN and CLIENT-OPEN
      states, corresponding to the server's OPEN state and the client's
      OPEN state.

   CLOSEREQ
      A server socket enters this state, from SERVER-OPEN, to order the
      client to close the connection and to hold TIMEWAIT state.

   CLOSING
      Server and client sockets can both enter this state to close the
      connection.

   TIMEWAIT
      A server or client socket remains in this state for 2MSL (4
      minutes) after the connection has been torn down, to prevent
      mistakes due to the delivery of old packets.  Only one of the
      endpoints has to enter TIMEWAIT state (the other can enter CLOSED
      state immediately), and a server can request its client to hold
      TIMEWAIT state using the DCCP-CloseReq packet type.

4.4.  Congestion Control Mechanisms

   DCCP connections are congestion controlled, but unlike in TCP, DCCP
   applications have a choice of congestion control mechanism.  In fact,
   the two half-connections can be governed by different mechanisms.
   Mechanisms are denoted by one-byte congestion control identifiers, or
   CCIDs.  The endpoints negotiate their CCIDs during connection
   initiation.  Each CCID describes how the HC-Sender limits data packet
   rates, how the HC-Receiver sends congestion feedback via
   acknowledgements, and so forth.  CCIDs 2 and 3 are currently defined;
   CCIDs 0, 1, and 4-255 are reserved.  Other CCIDs may be defined in
   the future.

   CCID 2 provides TCP-like Congestion Control, which is similar to that
   of TCP.  The sender maintains a congestion window and sends packets
   until that window is full.  Packets are acknowledged by the receiver.
   Dropped packets and ECN [RFC3168] indicate congestion; the response
   to congestion is to halve the congestion window.  Acknowledgements in
   CCID 2 contain the sequence numbers of all received packets within
   some window, similar to a selective acknowledgement (SACK) [RFC2018].

   CCID 3 provides TCP-Friendly Rate Control (TFRC), an equation-based
   form of congestion control intended to respond to congestion more
   smoothly than CCID 2.  The sender maintains a transmit rate, which it
   updates using the receiver's estimate of the packet loss and mark



Kohler, et al.              Standards Track                    [Page 14]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   rate.  CCID 3 behaves somewhat differently than TCP in the short
   term, but is designed to operate fairly with TCP over the long term.

   Section 10 describes DCCP's CCIDs in more detail.  The behaviors of
   CCIDs 2 and 3 are fully defined in separate profile documents
   [RFC4341, RFC4342].

4.5.  Feature Negotiation Options

   DCCP endpoints use Change and Confirm options to negotiate and agree
   on feature values.  Feature negotiation will almost always happen on
   the connection initiation handshake, but it can begin at any time.

   There are four feature negotiation options in all: Change L, Confirm
   L, Change R, and Confirm R.  The ""L"" options are sent by the feature
   location and the ""R"" options are sent by the feature remote.  A
   Change R option says to the feature location, ""change this feature
   value as follows"".  The feature location responds with Confirm L,
   meaning, ""I've changed it"".  Some features allow Change R options to
   contain multiple values sorted in preference order.  For example:

      Client                                        Server
      ------                                        ------
      Change R(CCID, 2) -->
                                    <-- Confirm L(CCID, 2)
                 * agreement that CCID/Server = 2 *

      Change R(CCID, 3 4) -->
                               <-- Confirm L(CCID, 4, 4 2)
                 * agreement that CCID/Server = 4 *

   Both exchanges negotiate the CCID/Server feature's value, which is
   the CCID in use on the server-to-client half-connection.  In the
   second exchange, the client requests that the server use either CCID
   3 or CCID 4, with 3 preferred; the server chooses 4 and supplies its
   preference list, ""4 2"".

   The Change L and Confirm R options are used for feature negotiations
   initiated by the feature location.  In the following example, the
   server requests that CCID/Server be set to 3 or 2, with 3 preferred,
   and the client agrees.










Kohler, et al.              Standards Track                    [Page 15]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


      Client                                       Server
      ------                                       ------
                                  <-- Change L(CCID, 3 2)
      Confirm R(CCID, 3, 3 2)  -->
                 * agreement that CCID/Server = 3 *

   Section 6 describes the feature negotiation options further,
   including the retransmission strategies that make negotiation
   reliable.

4.6.  Differences from TCP

   DCCP's differences from TCP apart from those discussed so far include
   the following:

   o  Copious space for options (up to 1008 bytes or the PMTU).

   o  Different acknowledgement formats.  The CCID for a connection
      determines how much acknowledgement information needs to be
      transmitted.  For example, in CCID 2 (TCP-like), this is about one
      ack per 2 packets, and each ack must declare exactly which packets
      were received.  In CCID 3 (TFRC), it is about one ack per round-
      trip time, and acks must declare at minimum just the lengths of
      recent loss intervals.

   o  Denial of Service (DoS) protection.  Several mechanisms help limit
      the amount of state that possibly-misbehaving clients can force
      DCCP servers to maintain.  An Init Cookie option analogous to
      TCP's SYN Cookies [SYNCOOKIES] avoids SYN-flood-like attacks.
      Only one connection endpoint has to hold TIMEWAIT state; the
      DCCP-CloseReq packet, which may only be sent by the server, passes
      that state to the client.  Various rate limits let servers avoid
      attacks that might force extensive computation or packet
      generation.

   o  Distinguishing different kinds of loss.  A Data Dropped option
      (Section 11.7) lets an endpoint declare that a packet was dropped
      because of corruption, because of receive buffer overflow, and so
      on.  This facilitates research into more appropriate rate-control
      responses for these non-network-congestion losses (although
      currently such losses will cause a congestion response).

   o  Acknowledgeability.  In TCP, a packet may be acknowledged only
      once the data is reliably queued for application delivery.  This
      does not make sense in DCCP, where an application might, for
      example, request a drop-from-front receive buffer.  A DCCP packet
      may be acknowledged as soon as its header has been successfully
      processed.  Concretely, a packet becomes acknowledgeable at Step 8



Kohler, et al.              Standards Track                    [Page 16]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


      of Section 8.5's packet processing pseudocode.  Acknowledgeability
      does not guarantee data delivery, however: the Data Dropped option
      may later report that the packet's application data was discarded.

   o  No receive window.  DCCP is a congestion control protocol, not a
      flow control protocol.

   o  No simultaneous open.  Every connection has one client and one
      server.

   o  No half-closed states.  DCCP has no states corresponding to TCP's
      FINWAIT and CLOSEWAIT, where one half-connection is explicitly
      closed while the other is still active.  The Data Dropped option's
      Drop Code 1, Application Not Listening (Section 11.7), can achieve
      a similar effect, however.

4.7.  Example Connection

   The progress of a typical DCCP connection is as follows.  (This
   description is informative, not normative.)

          Client                                  Server
          ------                                  ------
      0.  [CLOSED]                              [LISTEN]
      1.  DCCP-Request -->
      2.                               <-- DCCP-Response
      3.  DCCP-Ack -->
      4.  DCCP-Data, DCCP-Ack, DCCP-DataAck -->
                   <-- DCCP-Data, DCCP-Ack, DCCP-DataAck
      5.                               <-- DCCP-CloseReq
      6.  DCCP-Close -->
      7.                                  <-- DCCP-Reset
      8.  [TIMEWAIT]

   1. The client sends the server a DCCP-Request packet specifying the
      client and server ports, the service being requested, and any
      features being negotiated, including the CCID that the client
      would like the server to use.  The client may optionally piggyback
      an application request on the DCCP-Request packet.  The server may
      ignore this application request.

   2. The server sends the client a DCCP-Response packet indicating that
      it is willing to communicate with the client.  This response
      indicates any features and options that the server agrees to,
      begins other feature negotiations as desired, and optionally
      includes Init Cookies that wrap up all this information and that
      must be returned by the client for the connection to complete.




Kohler, et al.              Standards Track                    [Page 17]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   3. The client sends the server a DCCP-Ack packet that acknowledges
      the DCCP-Response packet.  This acknowledges the server's initial
      sequence number and returns any Init Cookies in the DCCP-Response.
      It may also continue feature negotiation.  The client may
      piggyback an application-level request on this ack, producing a
      DCCP-DataAck packet.

   4. The server and client then exchange DCCP-Data packets, DCCP-Ack
      packets acknowledging that data, and, optionally, DCCP-DataAck
      packets containing data with piggybacked acknowledgements.  If the
      client has no data to send, then the server will send DCCP-Data
      and DCCP-DataAck packets, while the client will send DCCP-Acks
      exclusively.  (However, the client may not send DCCP-Data packets
      before receiving at least one non-DCCP-Response packet from the
      server.)

   5. The server sends a DCCP-CloseReq packet requesting a close.

   6. The client sends a DCCP-Close packet acknowledging the close.

   7. The server sends a DCCP-Reset packet with Reset Code 1, ""Closed"",
      and clears its connection state.  DCCP-Resets are part of normal
      connection termination; see Section 5.6.

   8. The client receives the DCCP-Reset packet and holds state for two
      maximum segment lifetimes, or 2MSL, to allow any remaining packets
      to clear the network.

   An alternative connection closedown sequence is initiated by the
   client:

   5b. The client sends a DCCP-Close packet closing the connection.

   6b. The server sends a DCCP-Reset packet with Reset Code 1, ""Closed"",
       and clears its connection state.

   7b. The client receives the DCCP-Reset packet and holds state for
       2MSL to allow any remaining packets to clear the network.

5.  Packet Formats

   The DCCP header can be from 12 to 1020 bytes long.  The initial part
   of the header has the same semantics for all currently defined packet
   types.  Following this comes any additional fixed-length fields
   required by the packet type, and then a variable-length list of
   options.  The application data area follows the header.  In some
   packet types, this area contains data for the application; in other
   packet types, its contents are ignored.



Kohler, et al.              Standards Track                    [Page 18]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


      +---------------------------------------+  -.
      |            Generic Header             |   |
      +---------------------------------------+   |
      | Additional Fields (depending on type) |   +- DCCP Header
      +---------------------------------------+   |
      |          Options (optional)           |   |
      +=======================================+  -'
      |         Application Data Area         |
      +---------------------------------------+

5.1.  Generic Header

   The DCCP generic header takes different forms depending on the value
   of X, the Extended Sequence Numbers bit.  If X is one, the Sequence
   Number field is 48 bits long, and the generic header takes 16 bytes,
   as follows.

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |          Source Port          |           Dest Port           |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |  Data Offset  | CCVal | CsCov |           Checksum            |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |     |       |X|               |                               .
      | Res | Type  |=|   Reserved    |  Sequence Number (high bits)  .
      |     |       |1|               |                               .
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      .                  Sequence Number (low bits)                   |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   If X is zero, only the low 24 bits of the Sequence Number are
   transmitted, and the generic header is 12 bytes long.

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |          Source Port          |           Dest Port           |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |  Data Offset  | CCVal | CsCov |           Checksum            |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |     |       |X|                                               |
      | Res | Type  |=|          Sequence Number (low bits)           |
      |     |       |0|                                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+






Kohler, et al.              Standards Track                    [Page 19]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   The generic header fields are defined as follows.

   Source and Destination Ports: 16 bits each
      These fields identify the connection, similar to the corresponding
      fields in TCP and UDP.  The Source Port represents the relevant
      port on the endpoint that sent this packet, and the Destination
      Port represents the relevant port on the other endpoint.  When
      initiating a connection, the client SHOULD choose its Source Port
      randomly to reduce the likelihood of attack.

      DCCP APIs should treat port numbers similarly to TCP and UDP port
      numbers.  For example, machines that distinguish between
      ""privileged"" and ""unprivileged"" ports for TCP and UDP should do
      the same for DCCP.

   Data Offset: 8 bits
      The offset from the start of the packet's DCCP header to the start
      of its application data area, in 32-bit words.  The receiver MUST
      ignore packets whose Data Offset is smaller than the minimum-sized
      header for the given Type or larger than the DCCP packet itself.

   CCVal: 4 bits
      Used by the HC-Sender CCID.  For example, the A-to-B CCID's
      sender, which is active at DCCP A, MAY send 4 bits of information
      per packet to its receiver by encoding that information in CCVal.
      The sender MUST set CCVal to zero unless its HC-Sender CCID
      specifies otherwise, and the receiver MUST ignore the CCVal field
      unless its HC-Receiver CCID specifies otherwise.

   Checksum Coverage (CsCov): 4 bits
      Checksum Coverage determines the parts of the packet that are
      covered by the Checksum field.  This always includes the DCCP
      header and options, but some or all of the application data may be
      excluded.  This can improve performance on noisy links for
      applications that can tolerate corruption.  See Section 9.

   Checksum: 16 bits
      The Internet checksum of the packet's DCCP header (including
      options), a network-layer pseudoheader, and, depending on Checksum
      Coverage, all, some, or none of the application data.  See Section
      9.

   Reserved (Res): 3 bits
      Senders MUST set this field to all zeroes on generated packets,
      and receivers MUST ignore its value.






Kohler, et al.              Standards Track                    [Page 20]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   Type: 4 bits
      The Type field specifies the type of the packet.  The following
      values are defined:

                         Type   Meaning
                         ----   -------
                           0    DCCP-Request
                           1    DCCP-Response
                           2    DCCP-Data
                           3    DCCP-Ack
                           4    DCCP-DataAck
                           5    DCCP-CloseReq
                           6    DCCP-Close
                           7    DCCP-Reset
                           8    DCCP-Sync
                           9    DCCP-SyncAck
                         10-15  Reserved

                     Table 1: DCCP Packet Types

      Receivers MUST ignore any packets with reserved type.  That is,
      packets with reserved type MUST NOT be processed, and they MUST
      NOT be acknowledged as received.

   Extended Sequence Numbers (X): 1 bit
      Set to one to indicate the use of an extended generic header with
      48-bit Sequence and Acknowledgement Numbers.  DCCP-Data, DCCP-
      DataAck, and DCCP-Ack packets MAY set X to zero or one.  All
      DCCP-Request, DCCP-Response, DCCP-CloseReq, DCCP-Close, DCCP-
      Reset, DCCP-Sync, and DCCP-SyncAck packets MUST set X to one;
      endpoints MUST ignore any such packets with X set to zero.  High-
      rate connections SHOULD set X to one on all packets to gain
      increased protection against wrapped sequence numbers and attacks.
      See Section 7.6.

   Sequence Number: 48 or 24 bits
      Identifies the packet uniquely in the sequence of all packets the
      source sent on this connection.  Sequence Number increases by one
      with every packet sent, including packets such as DCCP-Ack that
      carry no application data.  See Section 7.

   All currently defined packet types except DCCP-Request and DCCP-Data
   carry an Acknowledgement Number Subheader in the four or eight bytes
   immediately following the generic header.  When X=1, its format is:







Kohler, et al.              Standards Track                    [Page 21]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |           Reserved            |    Acknowledgement Number     .
      |                               |          (high bits)          .
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      .               Acknowledgement Number (low bits)               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   When X=0, only the low 24 bits of the Acknowledgement Number are
   transmitted, giving the Acknowledgement Number Subheader this format:

      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |   Reserved    |       Acknowledgement Number (low bits)       |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   Reserved: 16 or 8 bits
      Senders MUST set this field to all zeroes on generated packets,
      and receivers MUST ignore its value.

   Acknowledgement Number: 48 or 24 bits
      Generally contains GSR, the Greatest Sequence Number Received on
      any acknowledgeable packet so far.  A packet is acknowledgeable
      if and only if its header was successfully processed by the
      receiver; Section 7.4 describes this further.  Options such as
      Ack Vector (Section 11.4) combine with the Acknowledgement
      Number to provide precise information about which packets have
      arrived.

      Acknowledgement Numbers on DCCP-Sync and DCCP-SyncAck packets
      need not equal GSR.  See Section 5.7.

5.2.  DCCP-Request Packets

   A client initiates a DCCP connection by sending a DCCP-Request
   packet.  These packets MAY contain application data and MUST use
   48-bit sequence numbers (X=1).

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      /            Generic DCCP Header with X=1 (16 bytes)            /
      /                   with Type=0 (DCCP-Request)                  /
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                         Service Code                          |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      /                      Options and Padding                      /
      +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
      /                       Application Data                        /
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+



Kohler, et al.              Standards Track                    [Page 22]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   Service Code: 32 bits
      Describes the application-level service to which the client
      application wants to connect.  Service Codes are intended to
      provide information about which application protocol a connection
      intends to use, thus aiding middleboxes and reducing reliance on
      globally well-known ports.  See Section 8.1.2.

5.3.  DCCP-Response Packets

   The server responds to valid DCCP-Request packets with DCCP-Response
   packets.  This is the second phase of the three-way handshake.
   DCCP-Response packets MAY contain application data and MUST use
   48-bit sequence numbers (X=1).

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      /            Generic DCCP Header with X=1 (16 bytes)            /
      /                  with Type=1 (DCCP-Response)                  /
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      /          Acknowledgement Number Subheader (8 bytes)           /
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                         Service Code                          |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      /                      Options and Padding                      /
      +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
      /                       Application Data                        /
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   Acknowledgement Number: 48 bits
      Contains GSR.  Since DCCP-Responses are only sent during
      connection initiation, this will always equal the Sequence Number
      on a received DCCP-Request.

   Service Code: 32 bits
      MUST equal the Service Code on the corresponding DCCP-Request.

5.4.  DCCP-Data, DCCP-Ack, and DCCP-DataAck Packets

   The central data transfer portion of every DCCP connection uses
   DCCP-Data, DCCP-Ack, and DCCP-DataAck packets.  These packets MAY use
   24-bit sequence numbers, depending on the value of the Allow Short
   Sequence Numbers feature (Section 7.6.1).  DCCP-Data packets carry
   application data without acknowledgements.







Kohler, et al.              Standards Track                    [Page 23]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      /              Generic DCCP Header (16 or 12 bytes)             /
      /                    with Type=2 (DCCP-Data)                    /
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      /                      Options and Padding                      /
      +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
      /                       Application Data                        /
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   DCCP-Ack packets dispense with the data but contain an
   Acknowledgement Number.  They are used for pure acknowledgements.

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      /              Generic DCCP Header (16 or 12 bytes)             /
      /                    with Type=3 (DCCP-Ack)                     /
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      /        Acknowledgement Number Subheader (8 or 4 bytes)        /
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      /                      Options and Padding                      /
      +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
      /                Application Data Area (Ignored)                /
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   DCCP-DataAck packets carry both application data and an
   Acknowledgement Number.  This piggybacks acknowledgement information
   on a data packet.

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      /              Generic DCCP Header (16 or 12 bytes)             /
      /                  with Type=4 (DCCP-DataAck)                   /
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      /        Acknowledgement Number Subheader (8 or 4 bytes)        /
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      /                      Options and Padding                      /
      +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
      /                       Application Data                        /
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   A DCCP-Data or DCCP-DataAck packet may have a zero-length application
   data area, which indicates that the application sent a zero-length
   datagram.  This differs from DCCP-Request and DCCP-Response packets,
   where an empty application data area indicates the absence of



Kohler, et al.              Standards Track                    [Page 24]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   application data (not the presence of zero-length application data).
   The API SHOULD report any received zero-length datagrams to the
   receiving application.

   A DCCP-Ack packet MAY have a non-zero-length application data area,
   which essentially pads the DCCP-Ack to a desired length.  Receivers
   MUST ignore the content of the application data area in DCCP-Ack
   packets.

   DCCP-Ack and DCCP-DataAck packets often include additional
   acknowledgement options, such as Ack Vector, as required by the
   congestion control mechanism in use.

5.5.  DCCP-CloseReq and DCCP-Close Packets

   DCCP-CloseReq and DCCP-Close packets begin the handshake that
   normally terminates a connection.  Either client or server may send a
   DCCP-Close packet, which will elicit a DCCP-Reset packet.  Only the
   server can send a DCCP-CloseReq packet, which indicates that the
   server wants to close the connection but does not want to hold its
   TIMEWAIT state.  Both packet types MUST use 48-bit sequence numbers
   (X=1).

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      /            Generic DCCP Header with X=1 (16 bytes)            /
      /         with Type=5 (DCCP-CloseReq) or 6 (DCCP-Close)         /
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      /          Acknowledgement Number Subheader (8 bytes)           /
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      /                      Options and Padding                      /
      +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
      /                Application Data Area (Ignored)                /
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   As with DCCP-Ack packets, DCCP-CloseReq and DCCP-Close packets MAY
   have non-zero-length application data areas, whose contents receivers
   MUST ignore.

5.6.  DCCP-Reset Packets

   DCCP-Reset packets unconditionally shut down a connection.
   Connections normally terminate with a DCCP-Reset, but resets may be
   sent for other reasons, including bad port numbers, bad option
   behavior, incorrect ECN Nonce Echoes, and so forth.  DCCP-Resets MUST
   use 48-bit sequence numbers (X=1).




Kohler, et al.              Standards Track                    [Page 25]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      /            Generic DCCP Header with X=1 (16 bytes)            /
      /                   with Type=7 (DCCP-Reset)                    /
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      /          Acknowledgement Number Subheader (8 bytes)           /
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |  Reset Code   |    Data 1     |    Data 2     |    Data 3     |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      /                      Options and Padding                      /
      +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
      /              Application Data Area (Error Text)               /
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   Reset Code: 8 bits
      Represents the reason that the sender reset the DCCP connection.

   Data 1, Data 2, and Data 3: 8 bits each
      The Data fields provide additional information about why the
      sender reset the DCCP connection.  The meanings of these fields
      depend on the value of Reset Code.

   Application Data Area: Error Text
      If present, Error Text is a human-readable text string encoded in
      Unicode UTF-8, and preferably in English, that describes the error
      in more detail.  For example, a DCCP-Reset with Reset Code 11,
      ""Aggression Penalty"", might contain Error Text such as ""Aggression
      Penalty: Received 3 bad ECN Nonce Echoes, assuming misbehavior"".

   The following Reset Codes are currently defined.  Unless otherwise
   specified, the Data 1, 2, and 3 fields MUST be set to 0 by the sender
   of the DCCP-Reset and ignored by its receiver.  Section references
   describe concrete situations that will cause each Reset Code to be
   generated; they are not meant to be exhaustive.

   0, ""Unspecified""
      Indicates the absence of a meaningful Reset Code.  Use of Reset
      Code 0 is NOT RECOMMENDED: the sender should choose a Reset Code
      that more clearly defines why the connection is being reset.

   1, ""Closed""
      Normal connection close.  See Section 8.3.

   2, ""Aborted""
      The sending endpoint gave up on the connection because of lack of
      progress.  See Sections 8.1.1 and 8.1.5.




Kohler, et al.              Standards Track                    [Page 26]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   3, ""No Connection""
      No connection exists.  See Section 8.3.1.

   4, ""Packet Error""
      A valid packet arrived with unexpected type.  For example, a
      DCCP-Data packet with valid header checksum and sequence numbers
      arrived at a connection in the REQUEST state.  See Section 8.3.1.
      The Data 1 field equals the offending packet type as an eight-bit
      number; thus, an offending packet with Type 2 will result in a
      Data 1 value of 2.

   5, ""Option Error""
      An option was erroneous, and the error was serious enough to
      warrant resetting the connection.  See Sections 6.6.7, 6.6.8, and
      11.4.  The Data 1 field equals the offending option type; Data 2
      and Data 3 equal the first two bytes of option data (or zero if
      the option had less than two bytes of data).

   6, ""Mandatory Error""
      The sending endpoint could not process an option O that was
      immediately preceded by Mandatory.  The Data fields report the
      option type and data of option O, using the format of Reset Code
      5, ""Option Error"".  See Section 5.8.2.

   7, ""Connection Refused""
      The Destination Port didn't correspond to a port open for
      listening.  Sent only in response to DCCP-Requests.  See Section
      8.1.3.

   8, ""Bad Service Code""
      The Service Code didn't equal the service code attached to the
      Destination Port.  Sent only in response to DCCP-Requests.  See
      Section 8.1.3.

   9, ""Too Busy""
      The server is too busy to accept new connections.  Sent only in
      response to DCCP-Requests.  See Section 8.1.3.

   10, ""Bad Init Cookie""
      The Init Cookie echoed by the client was incorrect or missing.
      See Section 8.1.4.

   11, ""Aggression Penalty""
      This endpoint has detected congestion control-related misbehavior
      on the part of the other endpoint.  See Section 12.3.






Kohler, et al.              Standards Track                    [Page 27]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   12-127, Reserved
      Receivers should treat these codes as they do Reset Code 0,
      ""Unspecified"".

   128-255, CCID-specific codes
      Semantics depend on the connection's CCIDs.  See Section 10.3.
      Receivers should treat unknown CCID-specific Reset Codes as they
      do Reset Code 0, ""Unspecified"".

   The following table summarizes this information.

          Reset
          Code   Name                    Data 1     Data 2 & 3
          -----  ----                    ------     ----------
            0    Unspecified               0            0
            1    Closed                    0            0
            2    Aborted                   0            0
            3    No Connection             0            0
            4    Packet Error           pkt type        0
            5    Option Error           option #   option data
            6    Mandatory Error        option #   option data
            7    Connection Refused        0            0
            8    Bad Service Code          0            0
            9    Too Busy                  0            0
           10    Bad Init Cookie           0            0
           11    Aggression Penalty        0            0
          12-127 Reserved
         128-255 CCID-specific codes

                        Table 2: DCCP Reset Codes

   Options on DCCP-Reset packets are processed before the connection is
   shut down.  This means that certain combinations of options,
   particularly involving Mandatory, may cause an endpoint to respond to
   a valid DCCP-Reset with another DCCP-Reset.  This cannot lead to a
   reset storm; since the first endpoint has already reset the
   connection, the second DCCP-Reset will be ignored.

5.7.  DCCP-Sync and DCCP-SyncAck Packets

   DCCP-Sync packets help DCCP endpoints recover synchronization after
   bursts of loss and recover from half-open connections.  Each valid
   received DCCP-Sync immediately elicits a DCCP-SyncAck.  Both packet
   types MUST use 48-bit sequence numbers (X=1).







Kohler, et al.              Standards Track                    [Page 28]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      /            Generic DCCP Header with X=1 (16 bytes)            /
      /          with Type=8 (DCCP-Sync) or 9 (DCCP-SyncAck)          /
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      /          Acknowledgement Number Subheader (8 bytes)           /
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      /                      Options and Padding                      /
      +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
      /                Application Data Area (Ignored)                /
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   The Acknowledgement Number field has special semantics for DCCP-Sync
   and DCCP-SyncAck packets.  First, the packet corresponding to a
   DCCP-Sync's Acknowledgement Number need not have been
   acknowledgeable.  Thus, receivers MUST NOT assume that a packet was
   processed simply because it appears in the Acknowledgement Number
   field of a DCCP-Sync packet.  This differs from all other packet
   types, where the Acknowledgement Number by definition corresponds to
   an acknowledgeable packet.  Second, the Acknowledgement Number on any
   DCCP-SyncAck packet MUST correspond to the Sequence Number on an
   acknowledgeable DCCP-Sync packet.  In the presence of reordering,
   this might not equal GSR.

   As with DCCP-Ack packets, DCCP-Sync and DCCP-SyncAck packets MAY have
   non-zero-length application data areas, whose contents receivers MUST
   ignore.  Padded DCCP-Sync packets may be useful when performing Path
   MTU discovery; see Section 14.

5.8.  Options

   Any DCCP packet may contain options, which occupy space at the end of
   the DCCP header.  Each option is a multiple of 8 bits in length.
   Individual options are not padded to multiples of 32 bits, and any
   option may begin on any byte boundary.  However, the combination of
   all options MUST add up to a multiple of 32 bits; Padding options
   MUST be added as necessary to fill out option space to a word
   boundary.  Any options present are included in the header checksum.

   The first byte of an option is the option type.  Options with types 0
   through 31 are single-byte options.  Other options are followed by a
   byte indicating the option's length.  This length value includes the
   two bytes of option-type and option-length as well as any option-data
   bytes; it must therefore be greater than or equal to two.

   Options MUST be processed sequentially, starting with the first
   option in the packet header.  Options with unknown types MUST be



Kohler, et al.              Standards Track                    [Page 29]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   ignored.  Also, options with nonsensical lengths (length byte less
   than two or more than the remaining space in the options portion of
   the header) MUST be ignored, and any option space following an option
   with nonsensical length MUST likewise be ignored.  Unless otherwise
   specified, multiple occurrences of the same option MUST be processed
   independently; for some options, this will mean in practice that the
   last valid occurrence of an option takes precedence.

   The following options are currently defined:

               Option                           DCCP-  Section
       Type    Length     Meaning               Data?  Reference
       ----    ------     -------               -----  ---------
         0        1       Padding                 Y      5.8.1
         1        1       Mandatory               N      5.8.2
         2        1       Slow Receiver           Y      11.6
       3-31       1       Reserved
        32     variable   Change L                N      6.1
        33     variable   Confirm L               N      6.2
        34     variable   Change R                N      6.1
        35     variable   Confirm R               N      6.2
        36     variable   Init Cookie             N      8.1.4
        37       3-8      NDP Count               Y      7.7
        38     variable   Ack Vector [Nonce 0]    N      11.4
        39     variable   Ack Vector [Nonce 1]    N      11.4
        40     variable   Data Dropped            N      11.7
        41        6       Timestamp               Y      13.1
        42      6/8/10    Timestamp Echo          Y      13.3
        43       4/6      Elapsed Time            N      13.2
        44        6       Data Checksum           Y      9.3
       45-127  variable   Reserved
      128-255  variable   CCID-specific options   -      10.3

                        Table 3: DCCP Options

   Not all options are suitable for all packet types.  For example,
   since the Ack Vector option is interpreted relative to the
   Acknowledgement Number, it isn't suitable on DCCP-Request and DCCP-
   Data packets, which have no Acknowledgement Number.  If an option
   occurs on an unexpected packet type, it MUST generally be ignored;
   any such restrictions are mentioned in each option's description.
   The table summarizes the most common restriction: when the DCCP-
   Data? column value is N, the corresponding option MUST be ignored
   when received on a DCCP-Data packet.  (Section 7.5.5 describes why
   such options are ignored as opposed to, say, causing a reset.)

   Options with invalid values MUST be ignored unless otherwise
   specified.  For example, any Data Checksum option with option length



Kohler, et al.              Standards Track                    [Page 30]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   4 MUST be ignored, since all valid Data Checksum options have option
   length 6.

   This section describes two generic options, Padding and Mandatory.
   Other options are described later.

5.8.1.  Padding Option

   +--------+
   |00000000|
   +--------+
     Type=0

   Padding is a single-byte ""no-operation"" option used to pad between or
   after options.  If the length of a packet's other options is not a
   multiple of 32 bits, then Padding options are REQUIRED to pad out the
   options area to the length implied by Data Offset.  Padding may also
   be used between options; for example, to align the beginning of a
   subsequent option on a 32-bit boundary.  There is no guarantee that
   senders will use this option, so receivers must be prepared to
   process options even if they do not begin on a word boundary.

5.8.2.  Mandatory Option

   +--------+
   |00000001|
   +--------+
     Type=1

   Mandatory is a single-byte option that marks the immediately
   following option as mandatory.  Say that the immediately following
   option is O.  Then the Mandatory option has no effect if the
   receiving DCCP endpoint understands and processes O.  If the endpoint
   does not understand or process O, however, then it MUST reset the
   connection using Reset Code 6, ""Mandatory Failure"".  For instance,
   the endpoint would reset the connection if it did not understand O's
   type; if it understood O's type, but not O's data; if O's data was
   invalid for O's type; if O was a feature negotiation option, and the
   endpoint did not understand the enclosed feature number; or if the
   endpoint understood O, but chose not to perform the action O implies.
   This list is not exhaustive and, in particular, individual option
   specifications may describe additional situations in which the
   endpoint should reset the connection and situations in which it
   should not.

   Mandatory options MUST NOT be sent on DCCP-Data packets, and any
   Mandatory options received on DCCP-Data packets MUST be ignored.




Kohler, et al.              Standards Track                    [Page 31]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   The connection is in error and should be reset with Reset Code 5,
   ""Option Error"", if option O is absent (Mandatory was the last byte of
   the option list), or if option O equals Mandatory.  However, the
   combination ""Mandatory Padding"" is valid, and MUST behave like two
   bytes of Padding.

   Section 6.6.9 describes the behavior of Mandatory feature negotiation
   options in more detail.

6.  Feature Negotiation

   Four DCCP options, Change L, Confirm L, Change R, and Confirm R, are
   used to negotiate feature values.  Change options initiate a
   negotiation; Confirm options complete that negotiation.  The ""L""
   options are sent by the feature location, and the ""R"" options are
   sent by the feature remote.  Change options are retransmitted to
   ensure reliability.

   All these options have the same format.  The first byte of option
   data is the feature number, and the second and subsequent data bytes
   hold one or more feature values.  The exact format of the feature
   value area depends on the feature type; see Section 6.3.

   +--------+--------+--------+--------+--------
   |  Type  | Length |Feature#| Value(s) ...
   +--------+--------+--------+--------+--------

   Together, the feature number and the option type (""L"" or ""R"")
   uniquely identify the feature to which an option applies.  The exact
   format of the Value(s) area depends on the feature number.

   Feature negotiation options MUST NOT be sent on DCCP-Data packets,
   and any feature negotiation options received on DCCP-Data packets
   MUST be ignored.

6.1.  Change Options

   Change L and Change R options initiate feature negotiation.  The
   option to use depends on the relevant feature's location: To start a
   negotiation for feature F/A, DCCP A will send a Change L option; to
   start a negotiation for F/B, it will send a Change R option.  Change
   options are retransmitted until some response is received.  They
   contain at least one Value, and thus have a length of at least 4.








Kohler, et al.              Standards Track                    [Page 32]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


              +--------+--------+--------+--------+--------
   Change L:  |00100000| Length |Feature#| Value(s) ...
              +--------+--------+--------+--------+--------
               Type=32

              +--------+--------+--------+--------+--------
   Change R:  |00100010| Length |Feature#| Value(s) ...
              +--------+--------+--------+--------+--------
               Type=34

6.2.  Confirm Options

   Confirm L and Confirm R options complete feature negotiation and are
   sent in response to Change R and Change L options, respectively.
   Confirm options MUST NOT be generated except in response to Change
   options.  Confirm options need not be retransmitted, since Change
   options are retransmitted as necessary.  The first byte of the
   Confirm option contains the feature number from the corresponding
   Change.  Following this is the selected Value, and then possibly the
   sender's preference list.

              +--------+--------+--------+--------+--------
   Confirm L: |00100001| Length |Feature#| Value(s) ...
              +--------+--------+--------+--------+--------
               Type=33

              +--------+--------+--------+--------+--------
   Confirm R: |00100011| Length |Feature#| Value(s) ...
              +--------+--------+--------+--------+--------
               Type=35

   If an endpoint receives an invalid Change option -- with an unknown
   feature number, or an invalid value -- it will respond with an empty
   Confirm option containing the problematic feature number, but no
   value.  Such options have length 3.

6.3.  Reconciliation Rules

   Reconciliation rules determine how the two sets of preferences for a
   given feature are resolved into a unique result.  The reconciliation
   rule depends only on the feature number.  Each reconciliation rule
   must have the property that the result is uniquely determined given
   the contents of Change options sent by the two endpoints.

   All current DCCP features use one of two reconciliation rules:
   server-priority (""SP"") and non-negotiable (""NN"").





Kohler, et al.              Standards Track                    [Page 33]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


6.3.1.  Server-Priority

   The feature value is a fixed-length byte string (length determined by
   the feature number).  Each Change option contains a list of values
   ordered by preference, with the most preferred value coming first.
   Each Confirm option contains the confirmed value, followed by the
   confirmer's preference list.  Thus, the feature's current value will
   generally appear twice in Confirm options' data, once as the current
   value and once in the confirmer's preference list.

   To reconcile the preference lists, select the first entry in the
   server's list that also occurs in the client's list.  If there is no
   shared entry, the feature's value MUST NOT change, and the Confirm
   option will confirm the feature's previous value (unless the Change
   option was Mandatory; see Section 6.6.9).

6.3.2.  Non-Negotiable

   The feature value is a byte string.  Each option contains exactly one
   feature value.  The feature location signals a new value by sending a
   Change L option.  The feature remote MUST accept any valid value,
   responding with a Confirm R option containing the new value, and it
   MUST send empty Confirm R options in response to invalid values
   (unless the Change L option was Mandatory; see Section 6.6.9).
   Change R and Confirm L options MUST NOT be sent for non-negotiable
   features; see Section 6.6.8.  Non-negotiable features use the feature
   negotiation mechanism to achieve reliability.
























Kohler, et al.              Standards Track                    [Page 34]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


6.4.  Feature Numbers

   This document defines the following feature numbers.

                                          Rec'n Initial        Section
   Number   Meaning                       Rule   Value  Req'd Reference
   ------   -------                       -----  -----  ----- ---------
      0     Reserved
      1     Congestion Control ID (CCID)   SP      2      Y     10
      2     Allow Short Seqnos             SP      0      Y     7.6.1
      3     Sequence Window                NN     100     Y     7.5.2
      4     ECN Incapable                  SP      0      N     12.1
      5     Ack Ratio                      NN      2      N     11.3
      6     Send Ack Vector                SP      0      N     11.5
      7     Send NDP Count                 SP      0      N     7.7.2
      8     Minimum Checksum Coverage      SP      0      N     9.2.1
      9     Check Data Checksum            SP      0      N     9.3.1
    10-127  Reserved
   128-255  CCID-specific features                              10.3

                      Table 4: DCCP Feature Numbers

   Rec'n Rule     The reconciliation rule used for the feature.  SP
                  means server-priority, NN means non-negotiable.

   Initial Value  The initial value for the feature.  Every feature has
                  a known initial value.

   Req'd          This column is ""Y"" if and only if every DCCP
                  implementation MUST understand the feature.  If it is
                  ""N"", then the feature behaves like an extension (see
                  Section 15), and it is safe to respond to Change
                  options for the feature with empty Confirm options.
                  Of course, a CCID might require the feature; a DCCP
                  that implements CCID 2 MUST support Ack Ratio and
                  Send Ack Vector, for example.















Kohler, et al.              Standards Track                    [Page 35]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


6.5.  Feature Negotiation Examples

   Here are three example feature negotiations for features located at
   the server, the first two for the Congestion Control ID feature, the
   last for the Ack Ratio.

                 Client                     Server
                 ------                     ------
      1. Change R(CCID, 2 3 1)  -->
         (""2 3 1"" is client's preference list)
      2.                        <--  Confirm L(CCID, 3, 3 2 1)
                               (3 is the negotiated value;
                               ""3 2 1"" is server's pref list)
                  * agreement that CCID/Server = 3 *


      1.                   XXX  <--  Change L(CCID, 3 2 1)
      2.                             Retransmission:
                                <--  Change L(CCID, 3 2 1)
      3. Confirm R(CCID, 3, 2 3 1)  -->
                  * agreement that CCID/Server = 3 *


      1.                        <--  Change L(Ack Ratio, 3)
      2. Confirm R(Ack Ratio, 3)  -->
               * agreement that Ack Ratio/Server = 3 *

   This example shows a simultaneous negotiation.

                  Client                     Server
                  ------                     ------
      1a. Change R(CCID, 2 3 1)  -->
       b.                        <--  Change L(CCID, 3 2 1)
      2a.                        <--  Confirm L(CCID, 3, 3 2 1)
       b. Confirm R(CCID, 3, 2 3 1)  -->
                   * agreement that CCID/Server = 3 *

   Here are the byte encodings of several Change and Confirm options.
   Each option is sent by DCCP A.

   Change L(CCID, 2 3) = 32,5,1,2,3
      DCCP B should change CCID/A's value (feature number 1, a server-
      priority feature); DCCP A's preferred values are 2 and 3, in that
      preference order.







Kohler, et al.              Standards Track                    [Page 36]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   Change L(Sequence Window, 1024) = 32,9,3,0,0,0,0,4,0
      DCCP B should change Sequence Window/A's value (feature number 3,
      a non-negotiable feature) to the 6-byte string 0,0,0,0,4,0 (the
      value 1024).

   Confirm L(CCID, 2, 2 3) = 33,6,1,2,2,3
      DCCP A has changed CCID/A's value to 2; its preferred values are 2
      and 3, in that preference order.

   Empty Confirm L(126) = 33,3,126
      DCCP A doesn't implement feature number 126, or DCCP B's proposed
      value for feature 126/A was invalid.

   Change R(CCID, 3 2) = 34,5,1,3,2
      DCCP B should change CCID/B's value; DCCP A's preferred values are
      3 and 2, in that preference order.

   Confirm R(CCID, 2, 3 2) = 35,6,1,2,3,2
      DCCP A has changed CCID/B's value to 2; its preferred values were
      3 and 2, in that preference order.

   Confirm R(Sequence Window, 1024) = 35,9,3,0,0,0,0,4,0
      DCCP A has changed Sequence Window/B's value to the 6-byte string
      0,0,0,0,4,0 (the value 1024).

   Empty Confirm R(126) = 35,3,126
      DCCP A doesn't implement feature number 126, or DCCP B's proposed
      value for feature 126/B was invalid.

6.6.  Option Exchange

   A few basic rules govern feature negotiation option exchange.

   1. Every non-reordered Change option gets a Confirm option in
      response.

   2. Change options are retransmitted until a response for the latest
      Change is received.

   3. Feature negotiation options are processed in strictly-increasing
      order by Sequence Number.

   The rest of this section describes the consequences of these rules in
   more detail.







Kohler, et al.              Standards Track                    [Page 37]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


6.6.1.  Normal Exchange

   Change options are generated when a DCCP endpoint wants to change the
   value of some feature.  Generally, this will happen at the beginning
   of a connection, although it may happen at any time.  We say the
   endpoint ""generates"" or ""sends"" a Change L or Change R option, but of
   course the option must be attached to a packet.  The endpoint may
   attach the option to a packet it would have generated anyway (such as
   a DCCP-Request), or it may create a ""feature negotiation packet"",
   often a DCCP-Ack or DCCP-Sync, just to carry the option.  Feature
   negotiation packets are controlled by the relevant congestion control
   mechanism.  For example, DCCP A may send a DCCP-Ack or DCCP-Sync for
   feature negotiation only if the B-to-A CCID would allow sending a
   DCCP-Ack.  In addition, an endpoint SHOULD generate at most one
   feature negotiation packet per round-trip time.

   On receiving a Change L or Change R option, a DCCP endpoint examines
   the included preference list, reconciles that with its own preference
   list, calculates the new value, and sends back a Confirm R or Confirm
   L option, respectively, informing its peer of the new value or that
   the feature was not understood.  Every non-reordered Change option
   MUST result in a corresponding Confirm option, and any packet
   including a Confirm option MUST carry an Acknowledgement Number.
   (Section 6.6.4 describes how Change reordering is detected and
   handled.)  Generated Confirm options may be attached to packets that
   would have been sent anyway (such as DCCP-Response or DCCP-SyncAck)
   or to new feature negotiation packets, as described above.

   The Change-sending endpoint MUST wait to receive a corresponding
   Confirm option before changing its stored feature value.  The
   Confirm-sending endpoint changes its stored feature value as soon as
   it sends the Confirm.

   A packet MAY contain more than one feature negotiation option,
   possibly including two options that refer to the same feature; as
   usual, the options are processed sequentially.

6.6.2.  Processing Received Options

   DCCP endpoints exist in one of three states relative to each feature.
   STABLE is the normal state, where the endpoint knows the feature's
   value and thinks the other endpoint agrees.  An endpoint enters the
   CHANGING state when it first sends a Change for the feature and
   returns to STABLE once it receives a corresponding Confirm.  The
   final state, UNSTABLE, indicates that an endpoint in CHANGING state
   changed its preference list but has not yet transmitted a Change
   option with the new preference list.




Kohler, et al.              Standards Track                    [Page 38]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   Feature state transitions at a feature location are implemented
   according to this diagram.  The diagram ignores sequence number and
   option validity issues; these are handled explicitly in the
   pseudocode that follows.

                                                          timeout/
 rcv Confirm R      app/protocol evt : snd Change L       rcv non-ack
 : ignore      +---------------------------------------+  : snd Change L
      +----+   |                                       |  +----+
      |    v   |                   rcv Change R        v  |    v
   +------------+  rcv Confirm R   : calc new value, +------------+
   |            |  : accept value    snd Confirm L   |            |
   |   STABLE   |<-----------------------------------|  CHANGING  |
   |            |        rcv empty Confirm R         |            |
   +------------+        : revert to old value       +------------+
       |    ^                                            |    ^
       +----+                                  pref list |    | snd
 rcv Change R                                  changes   |    | Change L
 : calc new value, snd Confirm L                         v    |
                                                     +------------+
                                                 +---|            |
                            rcv Confirm/Change R |   |  UNSTABLE  |
                            : ignore             +-->|            |
                                                     +------------+

   Feature locations SHOULD use the following pseudocode, which
   corresponds to the state diagram, to react to each feature
   negotiation option on each valid non-Data packet received.  The
   pseudocode refers to ""P.seqno"" and ""P.ackno"", which are properties of
   the packet; ""O.type"" and ""O.len"", which are properties of the option;
   ""FGSR"" and ""FGSS"", which are properties of the connection and handle
   reordering as described in Section 6.6.4; ""F.state"", which is the
   feature's state (STABLE, CHANGING, or UNSTABLE); and ""F.value"", which
   is the feature's value.

   First, check for unknown features (Section 6.6.7);
      If F is unknown,
         If the option was Mandatory,   /* Section 6.6.9 */
            Reset connection and return
         Otherwise, if O.type == Change R,
            Send Empty Confirm L on a future packet

         Return

   Second, check for reordering (Section 6.6.4);
      If F.state == UNSTABLE or P.seqno <= FGSR
              or (O.type == Confirm R and P.ackno < FGSS),
         Ignore option and return



Kohler, et al.              Standards Track                    [Page 39]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   Third, process Change R options;
      If O.type == Change R,
         If the option's value is valid,   /* Section 6.6.8 */
            Calculate new value
            Send Confirm L on a future packet
            Set F.state := STABLE
         Otherwise, if the option was Mandatory,
            Reset connection and return
         Otherwise,
            Send Empty Confirm L on a future packet
            /* Remain in existing state.  If that's CHANGING, this
               endpoint will retransmit its Change L option later. */

   Fourth, process Confirm R options (but only in CHANGING state).
      If F.state == CHANGING and O.type == Confirm R,
         If O.len > 3,   /* nonempty */
            If the option's value is valid,
               Set F.value := new value
            Otherwise,
               Reset connection and return
         Set F.state := STABLE

   Versions of this diagram and pseudocode are also used by feature
   remotes; simply switch the ""L""s and ""R""s, so that the relevant
   options are Change R and Confirm L.

6.6.3.  Loss and Retransmission

   Packets containing Change and Confirm options might be lost or
   delayed by the network.  Therefore, Change options are repeatedly
   transmitted to achieve reliability.  We refer to this as
   ""retransmission"", although of course there are no packet-level
   retransmissions in DCCP: a Change option that is sent again will be
   sent on a new packet with a new sequence number.

   A CHANGING endpoint transmits another Change option once it realizes
   that it has not heard back from the other endpoint.  The new Change
   option need not contain the same payload as the original; reordering
   protection will ensure that agreement is reached based on the most
   recently transmitted option.

   A CHANGING endpoint MUST continue retransmitting Change options until
   it gets some response or the connection terminates.

   Endpoints SHOULD use an exponential-backoff timer to decide when to
   retransmit Change options.  (Packets generated specifically for
   feature negotiation MUST use such a timer.)  The timer interval is
   initially set to not less than one round-trip time, and should back



Kohler, et al.              Standards Track                    [Page 40]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   off to not less than 64 seconds.  The backoff protects against
   delayed agreement due to the reordering protection algorithms
   described in the next section.  Again, endpoints may piggyback Change
   options on packets they would have sent anyway or create new packets
   to carry the options.  Any new packets are controlled by the relevant
   congestion-control mechanism.

   Confirm options are never retransmitted, but the Confirm-sending
   endpoint MUST generate a Confirm option after every non-reordered
   Change.

6.6.4.  Reordering

   Reordering might cause packets containing Change and Confirm options
   to arrive in an unexpected order.  Endpoints MUST ignore feature
   negotiation options that do not arrive in strictly-increasing order
   by Sequence Number.  The rest of this section presents two algorithms
   that fulfill this requirement.

   The first algorithm introduces two sequence number variables that
   each endpoint maintains for the connection.

   FGSR      Feature Greatest Sequence Number Received: The greatest
             sequence number received, considering only valid packets
             that contained one or more feature negotiation options
             (Change and/or Confirm).  This value is initialized to
             ISR - 1.

   FGSS      Feature Greatest Sequence Number Sent: The greatest
             sequence number sent, considering only packets that
             contained one or more new Change options.  A Change option
             is new if and only if it was generated during a transition
             from the STABLE or UNSTABLE state to the CHANGING state;
             Change options generated within the CHANGING state are
             retransmissions and MUST have exactly the same contents as
             previously transmitted options, allowing tolerance for
             reordering.  FGSS is initialized to ISS.

   Each endpoint checks two conditions on sequence numbers to decide
   whether to process received feature negotiation options.

   1. If a packet's Sequence Number is less than or equal to FGSR, then
      its Change options MUST be ignored.

   2. If a packet's Sequence Number is less than or equal to FGSR, if it
      has no Acknowledgement Number, OR if its Acknowledgement Number is
      less than FGSS, then its Confirm options MUST be ignored.




Kohler, et al.              Standards Track                    [Page 41]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   Alternatively, an endpoint MAY maintain separate FGSR and FGSS values
   for every feature.  FGSR(F/X) would equal the greatest sequence
   number received, considering only packets that contained Change or
   Confirm options applying to feature F/X; FGSS(F/X) would be defined
   similarly.  This algorithm requires more state, but is slightly more
   forgiving to multiple overlapped feature negotiations.  Either
   algorithm MAY be used; the first algorithm, with connection-wide FGSR
   and FGSS variables, is RECOMMENDED.

   One consequence of these rules is that a CHANGING endpoint will
   ignore any Confirm option that does not acknowledge the latest Change
   option sent.  This ensures that agreement, once achieved, used the
   most recent available information about the endpoints' preferences.

6.6.5.  Preference Changes

   Endpoints are allowed to change their preference lists at any time.
   However, an endpoint that changes its preference list while in the
   CHANGING state MUST transition to the UNSTABLE state.  It will
   transition back to CHANGING once it has transmitted a Change option
   with the new preference list.  This ensures that agreement is based
   on active preference lists.  Without the UNSTABLE state, simultaneous
   negotiation -- where the endpoints began independent negotiations for
   the same feature at the same time -- might lead to the negotiation's
   terminating with the endpoints thinking the feature had different
   values.

6.6.6.  Simultaneous Negotiation

   The two endpoints might simultaneously open negotiation for the same
   feature, after which an endpoint in the CHANGING state will receive a
   Change option for the same feature.  Such received Change options can
   act as responses to the original Change options.  The CHANGING
   endpoint MUST examine the received Change's preference list,
   reconcile that with its own preference list (as expressed in its
   generated Change options), and generate the corresponding Confirm
   option.  It can then transition to the STABLE state.














Kohler, et al.              Standards Track                    [Page 42]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


6.6.7.  Unknown Features

   Endpoints may receive Change options referring to feature numbers
   they do not understand -- for instance, when an extended DCCP
   converses with a non-extended DCCP.  Endpoints MUST respond to
   unknown Change options with Empty Confirm options (that is, Confirm
   options containing no data), which inform the CHANGING endpoint that
   the feature was not understood.  However, if the Change option was
   Mandatory, the connection MUST be reset; see Section 6.6.9.

   On receiving an empty Confirm option for some feature, the CHANGING
   endpoint MUST transition back to the STABLE state, leaving the
   feature's value unchanged.  Section 15 suggests that the default
   value for any extension feature correspond to ""extension not
   available"".

   Some features are required to be understood by all DCCPs (see Section
   6.4).  The CHANGING endpoint SHOULD reset the connection (with Reset
   Code 5, ""Option Error"") if it receives an empty Confirm option for
   such a feature.

   Since Confirm options are generated only in response to Change
   options, an endpoint should never receive a Confirm option referring
   to a feature number it does not understand.  Nevertheless, endpoints
   MUST ignore any such options they receive.

6.6.8.  Invalid Options

   A DCCP endpoint might receive a Change or Confirm option for a known
   feature that lists one or more values that it does not understand.
   Some, but not all, such options are invalid, depending on the
   relevant reconciliation rule (Section 6.3).  For instance:

   o  All features have length limitations, and options with invalid
      lengths are invalid.  For example, the Ack Ratio feature takes
      16-bit values, so valid ""Confirm R(Ack Ratio)"" options have option
      length 5.

   o  Some non-negotiable features have value limitations.  The Ack
      Ratio feature takes two-byte, non-zero integer values, so a
      ""Change L(Ack Ratio, 0)"" option is never valid.  Note that
      server-priority features do not have value limitations, since
      unknown values are handled as a matter of course.

   o  Any Confirm option that selects the wrong value, based on the two
      preference lists and the relevant reconciliation rule, is invalid.





Kohler, et al.              Standards Track                    [Page 43]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   However, unexpected Confirm options -- that refer to unknown feature
   numbers, or that don't appear to be part of a current negotiation --
   are not invalid, although they are ignored by the receiver.

   An endpoint receiving an invalid Change option MUST respond with the
   corresponding empty Confirm option.  An endpoint receiving an invalid
   Confirm option MUST reset the connection, with Reset Code 5, ""Option
   Error"".

6.6.9.  Mandatory Feature Negotiation

   Change options may be preceded by Mandatory options (Section 5.8.2).
   Mandatory Change options are processed like normal Change options
   except that the following failure cases will cause the receiver to
   reset the connection with Reset Code 6, ""Mandatory Failure"", rather
   than send a Confirm option.  The connection MUST be reset if:

   o  the Change option's feature number was not understood;

   o  the Change option's value was invalid, and the receiver would
      normally have sent an empty Confirm option in response; or

   o  for server-priority features, there was no shared entry in the two
      endpoints' preference lists.

   Other failure cases do not cause connection reset; in particular,
   reordering protection may cause a Mandatory Change option to be
   ignored without resetting the connection.

   Confirm options behave identically and have the same reset conditions
   whether or not they are Mandatory.

7.  Sequence Numbers

   DCCP uses sequence numbers to arrange packets into sequence, to
   detect losses and network duplicates, and to protect against
   attackers, half-open connections, and the delivery of very old
   packets.  Every packet carries a Sequence Number; most packet types
   carry an Acknowledgement Number as well.

   DCCP sequence numbers are packet based.  That is, Sequence Numbers
   generated by each endpoint increase by one, modulo 2^48, per packet.
   Even DCCP-Ack and DCCP-Sync packets, and other packets that don't
   carry user data, increment the Sequence Number.  Since DCCP is an
   unreliable protocol, there are no true retransmissions, but effective
   retransmissions, such as retransmissions of DCCP-Request packets,
   also increment the Sequence Number.  This lets DCCP implementations




Kohler, et al.              Standards Track                    [Page 44]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   detect network duplication, retransmissions, and acknowledgement
   loss; it is a significant departure from TCP practice.

7.1.  Variables

   DCCP endpoints maintain a set of sequence number variables for each
   connection.

   ISS     The Initial Sequence Number Sent by this endpoint.  This
           equals the Sequence Number of the first DCCP-Request or
           DCCP-Response sent.

   ISR     The Initial Sequence Number Received from the other endpoint.
           This equals the Sequence Number of the first DCCP-Request or
           DCCP-Response received.

   GSS     The Greatest Sequence Number Sent by this endpoint.  Here,
           and elsewhere, ""greatest"" is measured in circular sequence
           space.

   GSR     The Greatest Sequence Number Received from the other endpoint
           on an acknowledgeable packet.  (Section 7.4 defines this
           term.)

   GAR     The Greatest Acknowledgement Number Received from the other
           endpoint on an acknowledgeable packet that was not a DCCP-
           Sync.

   Some other variables are derived from these primitives.

   SWL and SWH
           (Sequence Number Window Low and High)  The extremes of the
           validity window for received packets' Sequence Numbers.

   AWL and AWH
           (Acknowledgement Number Window Low and High)  The extremes of
           the validity window for received packets' Acknowledgement
           Numbers.

7.2.  Initial Sequence Numbers

   The endpoints' initial sequence numbers are set by the first DCCP-
   Request and DCCP-Response packets sent.  Initial sequence numbers
   MUST be chosen to avoid two problems:

   o  delivery of old packets, where packets lingering in the network
      from an old connection are delivered to a new connection with the
      same addresses and port numbers; and



Kohler, et al.              Standards Track                    [Page 45]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   o  sequence number attacks, where an attacker can guess the sequence
      numbers that a future connection would use [M85].

   These problems are the same as those faced by TCP, and DCCP
   implementations SHOULD use TCP's strategies to avoid them [RFC793,
   RFC1948].  The rest of this section explains these strategies in more
   detail.

   To address the first problem, an implementation MUST ensure that the
   initial sequence number for a given <source address, source port,
   destination address, destination port> 4-tuple doesn't overlap with
   recent sequence numbers on previous connections with the same
   4-tuple.  (""Recent"" means sent within 2 maximum segment lifetimes, or
   4 minutes.)  The implementation MUST additionally ensure that the
   lower 24 bits of the initial sequence number don't overlap with the
   lower 24 bits of recent sequence numbers (unless the implementation
   plans to avoid short sequence numbers; see Section 7.6).  An
   implementation that has state for a recent connection with the same
   4-tuple can pick a good initial sequence number explicitly.
   Otherwise, it could tie initial sequence number selection to some
   clock, such as the 4-microsecond clock used by TCP [RFC793].  Two
   separate clocks may be required, one for the upper 24 bits and one
   for the lower 24 bits.

   To address the second problem, an implementation MUST provide each
   4-tuple with an independent initial sequence number space.  Then,
   opening a connection doesn't provide any information about initial
   sequence numbers on other connections to the same host.  [RFC1948]
   achieves this by adding a cryptographic hash of the 4-tuple and a
   secret to each initial sequence number.  For the secret, [RFC1948]
   recommends a combination of some truly random data [RFC4086], an
   administratively installed passphrase, the endpoint's IP address, and
   the endpoint's boot time, but truly random data is sufficient.  Care
   should be taken when the secret is changed; such a change alters all
   initial sequence number spaces, which might make an initial sequence
   number for some 4-tuple equal a recently sent sequence number for the
   same 4-tuple.  To avoid this problem, the endpoint might remember
   dead connection state for each 4-tuple or stay quiet for 2 maximum
   segment lifetimes around such a change.

7.3.  Quiet Time

   DCCP endpoints, like TCP endpoints, must take care before initiating
   connections when they boot.  In particular, they MUST NOT send
   packets whose sequence numbers are close to the sequence numbers of
   packets lingering in the network from before the boot.  The simplest
   way to enforce this rule is for DCCP endpoints to avoid sending any
   packets until one maximum segment lifetime (2 minutes) after boot.



Kohler, et al.              Standards Track                    [Page 46]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   Other enforcement mechanisms include remembering recent sequence
   numbers across boots and reserving the upper 8 or so bits of initial
   sequence numbers for a persistent counter that decrements by two each
   boot.  (The latter mechanism would require disallowing packets with
   short sequence numbers; see Section 7.6.1.)

7.4.  Acknowledgement Numbers

   Cumulative acknowledgements are meaningless in an unreliable
   protocol.  Therefore, DCCP's Acknowledgement Number field has a
   different meaning from TCP's.

   A received packet is classified as acknowledgeable if and only if its
   header was successfully processed by the receiving DCCP.  In terms of
   the pseudocode in Section 8.5, a received packet becomes
   acknowledgeable when the receiving endpoint reaches Step 8.  This
   means, for example, that all acknowledgeable packets have valid
   header checksums and sequence numbers.  A sent packet's
   Acknowledgement Number MUST equal the sending endpoint's GSR, the
   Greatest Sequence Number Received on an acknowledgeable packet, for
   all packet types except DCCP-Sync and DCCP-SyncAck.

   ""Acknowledgeable"" does not refer to data processing.  Even
   acknowledgeable packets may have their application data dropped, due
   to receive buffer overflow or corruption, for instance.  Data Dropped
   options report these data losses when necessary, letting congestion
   control mechanisms distinguish between network losses and endpoint
   losses.  This issue is discussed further in Sections 11.4 and 11.7.

   DCCP-Sync and DCCP-SyncAck packets' Acknowledgement Numbers differ as
   follows: The Acknowledgement Number on a DCCP-Sync packet corresponds
   to a received packet, but not necessarily to an acknowledgeable
   packet; in particular, it might correspond to an out-of-sync packet
   whose options were not processed.  The Acknowledgement Number on a
   DCCP-SyncAck packet always corresponds to an acknowledgeable DCCP-
   Sync packet; it might be less than GSR in the presence of reordering.

7.5.  Validity and Synchronization

   Any DCCP endpoint might receive packets that are not actually part of
   the current connection.  For instance, the network might deliver an
   old packet, an attacker might attempt to hijack a connection, or the
   other endpoint might crash, causing a half-open connection.

   DCCP, like TCP, uses sequence number checks to detect these cases.
   Packets whose Sequence and/or Acknowledgement Numbers are out of
   range are called sequence-invalid and are not processed normally.




Kohler, et al.              Standards Track                    [Page 47]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   Unlike TCP, DCCP requires a synchronization mechanism to recover from
   large bursts of loss.  One endpoint might send so many packets during
   a burst of loss that when one of its packets finally got through, the
   other endpoint would label its Sequence Number as invalid.  A
   handshake of DCCP-Sync and DCCP-SyncAck packets recovers from this
   case.

7.5.1.  Sequence and Acknowledgement Number Windows

   Each DCCP endpoint defines sequence validity windows that are subsets
   of the Sequence and Acknowledgement Number spaces.  These windows
   correspond to packets the endpoint expects to receive in the next few
   round-trip times.  The Sequence and Acknowledgement Number windows
   always contain GSR and GSS, respectively.  The window widths are
   controlled by Sequence Window features for the two half-connections.

   The Sequence Number validity window for packets from DCCP B is [SWL,
   SWH].  This window always contains GSR, the Greatest Sequence Number
   Received on a sequence-valid packet from DCCP B.  It is W packets
   wide, where W is the value of the Sequence Window/B feature.  One-
   fourth of the sequence window, rounded down, is less than or equal to
   GSR, and three-fourths is greater than GSR.  (This asymmetric
   placement assumes that bursts of loss are more common in the network
   than significant reorderings.)

     invalid  |       valid Sequence Numbers        |  invalid
   <---------*|*===========*=======================*|*--------->
         GSR -|GSR + 1 -   GSR                 GSR +|GSR + 1 +
    floor(W/4)|floor(W/4)                 ceil(3W/4)|ceil(3W/4)
               = SWL                           = SWH

   The Acknowledgement Number validity window for packets from DCCP B is
   [AWL, AWH].  The high end of the window, AWH, equals GSS, the
   Greatest Sequence Number Sent by DCCP A; the window is W' packets
   wide, where W' is the value of the Sequence Window/A feature.

     invalid  |    valid Acknowledgement Numbers    |  invalid
   <---------*|*===================================*|*--------->
      GSS - W'|GSS + 1 - W'                      GSS|GSS + 1
               = AWL                           = AWH

   SWL and AWL are initially adjusted so that they are not less than the
   initial Sequence Numbers received and sent, respectively:

         SWL := max(GSR + 1 - floor(W/4), ISR),
         AWL := max(GSS + 1 - W', ISS).





Kohler, et al.              Standards Track                    [Page 48]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   These adjustments MUST be applied only at the beginning of the
   connection.  (Long-lived connections may wrap sequence numbers so
   that they appear to be less than ISR or ISS; the adjustments MUST NOT
   be applied in that case.)

7.5.2.  Sequence Window Feature

   The Sequence Window/A feature determines the width of the Sequence
   Number validity window used by DCCP B and the width of the
   Acknowledgement Number validity window used by DCCP A.  DCCP A sends
   a ""Change L(Sequence Window, W)"" option to notify DCCP B that the
   Sequence Window/A value is W.

   Sequence Window has feature number 3 and is non-negotiable.  It takes
   48-bit (6-byte) integer values, like DCCP sequence numbers.  Change
   and Confirm options for Sequence Window are therefore 9 bytes long.
   New connections start with Sequence Window 100 for both endpoints.
   The minimum valid Sequence Window value is Wmin = 32.  The maximum
   valid Sequence Window value is Wmax = 2^46 - 1 = 70368744177663.
   Change options suggesting Sequence Window values out of this range
   are invalid and MUST be handled accordingly.

   A proper Sequence Window/A value must reflect the number of packets
   DCCP A expects to be in flight.  Only DCCP A can anticipate this
   number.  Values that are too small increase the risk of the endpoints
   getting out sync after bursts of loss, and values that are much too
   small can prevent productive communication whether or not there is
   loss.  On the other hand, too-large values increase the risk of
   connection hijacking; Section 7.5.5 quantifies this risk.  One good
   guideline is for each endpoint to set Sequence Window to about five
   times the maximum number of packets it expects to send in a round-
   trip time.  Endpoints SHOULD send Change L(Sequence Window) options,
   as necessary, as the connection progresses.  Also, an endpoint MUST
   NOT persistently send more than its Sequence Window number of packets
   per round-trip time; that is, DCCP A MUST NOT persistently send more
   than Sequence Window/A packets per RTT.

7.5.3.  Sequence-Validity Rules

   Sequence-validity depends on the received packet's type.  This table
   shows the sequence and acknowledgement number checks applied to each
   packet; a packet is sequence-valid if it passes both tests, and
   sequence-invalid if it does not.  Many of the checks refer to the
   sequence and acknowledgement number validity windows [SWL, SWH] and
   [AWL, AWH] defined in Section 7.5.1.






Kohler, et al.              Standards Track                    [Page 49]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


                                             Acknowledgement Number
   Packet Type      Sequence Number Check    Check
   -----------      ---------------------    ----------------------
   DCCP-Request     SWL <= seqno <= SWH (*)  N/A
   DCCP-Response    SWL <= seqno <= SWH (*)  AWL <= ackno <= AWH
   DCCP-Data        SWL <= seqno <= SWH      N/A
   DCCP-Ack         SWL <= seqno <= SWH      AWL <= ackno <= AWH
   DCCP-DataAck     SWL <= seqno <= SWH      AWL <= ackno <= AWH
   DCCP-CloseReq    GSR <  seqno <= SWH      GAR <= ackno <= AWH
   DCCP-Close       GSR <  seqno <= SWH      GAR <= ackno <= AWH
   DCCP-Reset       GSR <  seqno <= SWH      GAR <= ackno <= AWH
   DCCP-Sync        SWL <= seqno             AWL <= ackno <= AWH
   DCCP-SyncAck     SWL <= seqno             AWL <= ackno <= AWH

   (*) Check not applied if connection is in LISTEN or REQUEST state.

   In general, packets are sequence-valid if their Sequence and
   Acknowledgement Numbers lie within the corresponding valid windows,
   [SWL, SWH] and [AWL, AWH].  The exceptions to this rule are as
   follows:

   o  Since DCCP-CloseReq, DCCP-Close, and DCCP-Reset packets end a
      connection, they cannot have Sequence Numbers less than or equal
      to GSR, or Acknowledgement Numbers less than GAR.

   o  DCCP-Sync and DCCP-SyncAck Sequence Numbers are not strongly
      checked.  These packet types exist specifically to get the
      endpoints back into sync; checking their Sequence Numbers would
      eliminate their usefulness.

   The lenient checks on DCCP-Sync and DCCP-SyncAck packets allow
   continued operation after unusual events, such as endpoint crashes
   and large bursts of loss, but there's no need for leniency in the
   absence of unusual events -- that is, during ongoing successful
   communication.  Therefore, DCCP implementations SHOULD use the
   following, more stringent checks for active connections, where a
   connection is considered active if it has received valid packets from
   the other endpoint within the last three round-trip times.

                                             Acknowledgement Number
   Packet Type      Sequence Number Check    Check
   -----------      ---------------------    ----------------------
   DCCP-Sync        SWL <= seqno <= SWH      AWL <= ackno <= AWH
   DCCP-SyncAck     SWL <= seqno <= SWH      AWL <= ackno <= AWH

   Finally, an endpoint MAY apply the following more stringent checks to
   DCCP-CloseReq, DCCP-Close, and DCCP-Reset packets, further lowering
   the probability of successful blind attacks using those packet types.



Kohler, et al.              Standards Track                    [Page 50]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   Since these checks can cause extra synchronization overhead and delay
   connection closing when packets are lost, they should be considered
   experimental.

                                             Acknowledgement Number
   Packet Type      Sequence Number Check    Check
   -----------      ---------------------    ----------------------
   DCCP-CloseReq    seqno == GSR + 1         GAR <= ackno <= AWH
   DCCP-Close       seqno == GSR + 1         GAR <= ackno <= AWH
   DCCP-Reset       seqno == GSR + 1         GAR <= ackno <= AWH

   Note that sequence-validity is only one of the validity checks
   applied to received packets.

7.5.4.  Handling Sequence-Invalid Packets

   Endpoints respond to received sequence-invalid packets as follows.

   o  Any sequence-invalid DCCP-Sync or DCCP-SyncAck packet MUST be
      ignored.

   o  A sequence-invalid DCCP-Reset packet MUST elicit a DCCP-Sync
      packet in response (subject to a possible rate limit).  This
      response packet MUST use a new Sequence Number, and thus will
      increase GSS; GSR will not change, however, since the received
      packet was sequence-invalid.  The response packet's
      Acknowledgement Number MUST equal GSR.

   o  Any other sequence-invalid packet MUST elicit a similar DCCP-Sync
      packet, except that the response packet's Acknowledgement Number
      MUST equal the sequence-invalid packet's Sequence Number.

   On receiving a sequence-valid DCCP-Sync packet, the peer endpoint
   (say, DCCP B) MUST update its GSR variable and reply with a DCCP-
   SyncAck packet.  The DCCP-SyncAck packet's Acknowledgement Number
   will equal the DCCP-Sync's Sequence Number, which is not necessarily
   GSR.  Upon receiving this DCCP-SyncAck, which will be sequence-valid
   since it acknowledges the DCCP-Sync, DCCP A will update its GSR
   variable, and the endpoints will be back in sync.  As an exception,
   if the peer endpoint is in the REQUEST state, it MUST respond with a
   DCCP-Reset instead of a DCCP-SyncAck.  This serves to clean up DCCP
   A's half-open connection.

   To protect against denial-of-service attacks, DCCP implementations
   SHOULD impose a rate limit on DCCP-Syncs sent in response to
   sequence-invalid packets, such as not more than eight DCCP-Syncs per
   second.




Kohler, et al.              Standards Track                    [Page 51]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   DCCP endpoints MUST NOT process sequence-invalid packets except,
   perhaps, by generating a DCCP-Sync.  For instance, options MUST NOT
   be processed.  An endpoint MAY temporarily preserve sequence-invalid
   packets in case they become valid later, however; this can reduce the
   impact of bursts of loss by delivering more packets to the
   application.  In particular, an endpoint MAY preserve sequence-
   invalid packets for up to 2 round-trip times.  If, within that time,
   the relevant sequence windows change so that the packets become
   sequence-valid, the endpoint MAY process them again.

   Note that sequence-invalid DCCP-Reset packets cause DCCP-Syncs to be
   generated.  This is because endpoints in an unsynchronized state
   (CLOSED, REQUEST, and LISTEN) might not have enough information to
   generate a proper DCCP-Reset on the first try.  For example, if a
   peer endpoint is in CLOSED state and receives a DCCP-Data packet, it
   cannot guess the right Sequence Number to use on the DCCP-Reset it
   generates (since the DCCP-Data packet has no Acknowledgement Number).
   The DCCP-Sync generated in response to this bad reset serves as a
   challenge, and contains enough information for the peer to generate a
   proper DCCP-Reset.  However, the new DCCP-Reset may carry a different
   Reset Code than the original DCCP-Reset; probably the new Reset Code
   will be 3, ""No Connection"".  The endpoint SHOULD use information from
   the original DCCP-Reset when possible.

7.5.5.  Sequence Number Attacks

   Sequence and Acknowledgement Numbers form DCCP's main line of defense
   against attackers.  An attacker that cannot guess sequence numbers
   cannot easily manipulate or hijack a DCCP connection, and
   requirements like careful initial sequence number choice eliminate
   the most serious attacks.

   An attacker might still send many packets with randomly chosen
   Sequence and Acknowledgement Numbers, however.  If one of those
   probes ends up sequence-valid, it may shut down the connection or
   otherwise cause problems.  The easiest such attacks to execute are as
   follows:

   o  Send DCCP-Data packets with random Sequence Numbers.  If one of
      these packets hits the valid sequence number window, the attack
      packet's application data may be inserted into the data stream.

   o  Send DCCP-Sync packets with random Sequence and Acknowledgement
      Numbers.  If one of these packets hits the valid acknowledgement
      number window, the receiver will shift its sequence number window
      accordingly, getting out of sync with the correct endpoint --
      perhaps permanently.




Kohler, et al.              Standards Track                    [Page 52]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   The attacker has to guess both Source and Destination Ports for any
   of these attacks to succeed.  Additionally, the connection would have
   to be inactive for the DCCP-Sync attack to succeed, assuming the
   victim implemented the more stringent checks for active connections
   recommended in Section 7.5.3.

   To quantify the probability of success, let N be the number of attack
   packets the attacker is willing to send, W be the relevant sequence
   window width, and L be the length of sequence numbers (24 or 48).
   The attacker's best strategy is to space the attack packets evenly
   over sequence space.  Then the probability of hitting one sequence
   number window is P = WN/2^L.

   The success probability for a DCCP-Data attack using short sequence
   numbers thus equals P = WN/2^24.  For W = 100, then, the attacker
   must send more than 83,000 packets to achieve a 50% chance of
   success.  For reference, the easiest TCP attack -- sending a SYN with
   a random sequence number, which will cause a connection reset if it
   falls within the window -- with W = 8760 (a common default) and
   L = 32 requires more than 245,000 packets to achieve a 50% chance of
   success.

   A fast connection's W will generally be high, increasing the attack
   success probability for fixed N.  If this probability gets
   uncomfortably high with L = 24, the endpoint SHOULD prevent the use
   of short sequence numbers by manipulating the Allow Short Sequence
   Numbers feature (see Section 7.6.1).  The probability limit depends
   on the application, however.  Some applications, such as those
   already designed to handle corruption, are quite resilient to data
   injection attacks.

   The DCCP-Sync attack has L = 48, since DCCP-Sync packets use long
   sequence numbers exclusively; in addition, the success probability is
   halved, since only half the Sequence Number space is valid.  Attacks
   have a correspondingly smaller probability of success.  For a large W
   of 2000 packets, then, the attacker must send more than 10^11 packets
   to achieve a 50% chance of success.

   Attacks involving DCCP-Ack, DCCP-DataAck, DCCP-CloseReq, DCCP-Close,
   and DCCP-Reset packets are more difficult, since Sequence and
   Acknowledgement Numbers must both be guessed.  The probability of
   attack success for these packet types equals P = WXN/2^(2L), where W
   is the Sequence Number window, X is the Acknowledgement Number
   window, and N and L are as before.

   Since DCCP-Data attacks with short sequence numbers are relatively
   easy for attackers to execute, DCCP has been engineered to prevent
   these attacks from escalating to connection resets or other serious



Kohler, et al.              Standards Track                    [Page 53]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   consequences.  In particular, any options whose processing might
   cause the connection to be reset are ignored when they appear on
   DCCP-Data packets.

7.5.6.  Sequence Number Handling Examples

   In the following example, DCCP A and DCCP B recover from a large
   burst of loss that runs DCCP A's sequence numbers out of DCCP B's
   appropriate sequence number window.

   DCCP A                                           DCCP B
   (GSS=1,GSR=10)                                   (GSS=10,GSR=1)
               -->   DCCP-Data(seq 2)     XXX
                         ...
               -->   DCCP-Data(seq 100)   XXX
               -->   DCCP-Data(seq 101)           -->  ???
                                                    seqno out of range;
                                                    send Sync
      OK       <--   DCCP-Sync(seq 11, ack 101)   <--
                                                    (GSS=11,GSR=1)
               -->   DCCP-SyncAck(seq 102, ack 11)   -->   OK
   (GSS=102,GSR=11)                                 (GSS=11,GSR=102)

   In the next example, a DCCP connection recovers from a simple blind
   attack.

   DCCP A                                           DCCP B
   (GSS=1,GSR=10)                                   (GSS=10,GSR=1)
                *ATTACKER*  -->  DCCP-Data(seq 10^6)  -->  ???
                                                    seqno out of range;
                                                    send Sync
      ???      <--   DCCP-Sync(seq 11, ack 10^6)  <--
   ackno out of range; ignore
   (GSS=1,GSR=10)                                   (GSS=11,GSR=1)

   The final example demonstrates recovery from a half-open connection.

   DCCP A                                           DCCP B
   (GSS=1,GSR=10)                                   (GSS=10,GSR=1)
   (Crash)
   CLOSED                                               OPEN
   REQUEST     -->   DCCP-Request(seq 400)        -->   ???
   !!          <--   DCCP-Sync(seq 11, ack 400)   <--   OPEN
   REQUEST     -->   DCCP-Reset(seq 401, ack 11)  -->   (Abort)
   REQUEST                                              CLOSED
   REQUEST     -->   DCCP-Request(seq 402)        -->   ...





Kohler, et al.              Standards Track                    [Page 54]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


7.6.  Short Sequence Numbers

   DCCP sequence numbers are 48 bits long.  This large sequence space
   protects DCCP connections against some blind attacks, such as the
   injection of DCCP-Resets into the connection.  However, DCCP-Data,
   DCCP-Ack, and DCCP-DataAck packets, which make up the body of any
   DCCP connection, may reduce header space by transmitting only the
   lower 24 bits of the relevant Sequence and Acknowledgement Numbers.
   The receiving endpoint will extend these numbers to 48 bits using the
   following pseudocode:

   procedure Extend_Sequence_Number(S, REF)
      /* S is a 24-bit sequence number from the packet header.
         REF is the relevant 48-bit reference sequence number:
         GSS if S is an Acknowledgement Number, and GSR if S is a
         Sequence Number. */
      Set REF_low := low 24 bits of REF
      Set REF_hi := high 24 bits of REF
      If REF_low (<) S           /* circular comparison mod 2^24 */
            and S |<| REF_low,   /* conventional, non-circular
                                    comparison */
         Return (((REF_hi + 1) mod 2^24) << 24) | S
      Otherwise, if S (<) REF_low and REF_low |<| S,
         Return (((REF_hi - 1) mod 2^24) << 24) | S
      Otherwise,
         Return (REF_hi << 24) | S

   The two different kinds of comparison in the if statements detect
   when the low-order bits of the sequence space have wrapped.  (The
   circular comparison ""REF_low (<) S"" returns true if and only if
   (S - REF_low), calculated using two's-complement arithmetic and then
   represented as an unsigned number, is less than or equal to 2^23
   (mod 2^24).)  When this happens, the high-order bits are incremented
   or decremented, as appropriate.

7.6.1.  Allow Short Sequence Numbers Feature

   Endpoints can require that all packets use long sequence numbers by
   leaving the Allow Short Sequence Numbers feature value at its default
   of zero.  This can reduce the risk that data will be inappropriately
   injected into the connection.  DCCP A sends a ""Change L(Allow Short
   Seqnos, 1)"" option to indicate its desire to send packets with short
   sequence numbers.

   Allow Short Sequence Numbers has feature number 2 and is server-
   priority.  It takes one-byte Boolean values.  When Allow Short
   Seqnos/B is zero, DCCP B MUST NOT send packets with short sequence
   numbers and DCCP A MUST ignore any packets with short sequence



Kohler, et al.              Standards Track                    [Page 55]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   numbers that are received.  Values of two or more are reserved.  New
   connections start with Allow Short Sequence Numbers 0 for both
   endpoints.

7.6.2.  When to Avoid Short Sequence Numbers

   Short sequence numbers reduce the rate DCCP connections can safely
   achieve and increase the risks of certain kinds of attacks, including
   blind data injection.  Very-high-rate DCCP connections, and
   connections with large sequence windows (Section 7.5.2), SHOULD NOT
   use short sequence numbers on their data packets.  The attack risk
   issues have been discussed in Section 7.5.5; we discuss the rate
   limitation issue here.

   The sequence-validity mechanism assumes that the network does not
   deliver extremely old data.  In particular, it assumes that the
   network must have dropped any packet by the time the connection wraps
   around and uses its sequence number again.  This constraint limits
   the maximum connection rate that can be safely achieved.  Let MSL
   equal the maximum segment lifetime, P equal the average DCCP packet
   size in bits, and L equal the length of sequence numbers (24 or 48
   bits).  Then the maximum safe rate, in bits per second, is
   R = P*(2^L)/2MSL.

   For the default MSL of 2 minutes, 1500-byte DCCP packets, and short
   sequence numbers, the safe rate is therefore approximately 800 Mb/s.
   Although 2 minutes is a very large MSL for any networks that could
   sustain that rate with such small packets, long sequence numbers
   allow much higher rates under the same constraints: up to 14 petabits
   a second for 1500-byte packets and the default MSL.

7.7.  NDP Count and Detecting Application Loss

   DCCP's sequence numbers increment by one on every packet, including
   non-data packets (packets that don't carry application data).  This
   makes DCCP sequence numbers suitable for detecting any network loss,
   but not for detecting the loss of application data.  The NDP Count
   option reports the length of each burst of non-data packets.  This
   lets the receiving DCCP reliably determine when a burst of loss
   included application data.

   +--------+--------+-------- ... --------+
   |00100101| Length |      NDP Count      |
   +--------+--------+-------- ... --------+
    Type=37  Len=3-8       (1-6 bytes)

   If a DCCP endpoint's Send NDP Count feature is one (see below), then
   that endpoint MUST send an NDP Count option on every packet whose



Kohler, et al.              Standards Track                    [Page 56]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   immediate predecessor was a non-data packet.  Non-data packets
   consist of DCCP packet types DCCP-Ack, DCCP-Close, DCCP-CloseReq,
   DCCP-Reset, DCCP-Sync, and DCCP-SyncAck.  The other packet types,
   namely DCCP-Request, DCCP-Response, DCCP-Data, and DCCP-DataAck, are
   considered data packets, although not all DCCP-Request and DCCP-
   Response packets will actually carry application data.

   The value stored in NDP Count equals the number of consecutive non-
   data packets in the run immediately previous to the current packet.
   Packets with no NDP Count option are considered to have NDP Count
   zero.

   The NDP Count option can carry one to six bytes of data.  The
   smallest option format that can hold the NDP Count SHOULD be used.

   With NDP Count, the receiver can reliably tell only whether a burst
   of loss contained at least one data packet.  For example, the
   receiver cannot always tell whether a burst of loss contained a non-
   data packet.

7.7.1.  NDP Count Usage Notes

   Say that K consecutive sequence numbers are missing in some burst of
   loss, and that the Send NDP Count feature is on.  Then some
   application data was lost within those sequence numbers unless the
   packet following the hole contains an NDP Count option whose value is
   greater than or equal to K.

   For example, say that an endpoint sent the following sequence of
   non-data packets (Nx) and data packets (Dx).

      N0  N1  D2  N3  D4  D5  N6  D7  D8  D9  D10 N11 N12 D13

   Those packets would have NDP Counts as follows.

      N0  N1  D2  N3  D4  D5  N6  D7  D8  D9  D10 N11 N12 D13
      -   1   2   -   1   -   -   1   -   -   -   -   1   2

   NDP Count is not useful for applications that include their own
   sequence numbers with their packet headers.

7.7.2.  Send NDP Count Feature

   The Send NDP Count feature lets DCCP endpoints negotiate whether they
   should send NDP Count options on their packets.  DCCP A sends a
   ""Change R(Send NDP Count, 1)"" option to ask DCCP B to send NDP Count
   options.




Kohler, et al.              Standards Track                    [Page 57]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   Send NDP Count has feature number 7 and is server-priority.  It takes
   one-byte Boolean values.  DCCP B MUST send NDP Count options as
   described above when Send NDP Count/B is one, although it MAY send
   NDP Count options even when Send NDP Count/B is zero.  Values of two
   or more are reserved.  New connections start with Send NDP Count 0
   for both endpoints.

8.  Event Processing

   This section describes how DCCP connections move between states and
   which packets are sent when.  Note that feature negotiation takes
   place in parallel with the connection-wide state transitions
   described here.

8.1.  Connection Establishment

   DCCP connections' initiation phase consists of a three-way handshake:
   an initial DCCP-Request packet sent by the client, a DCCP-Response
   sent by the server in reply, and finally an acknowledgement from the
   client, usually via a DCCP-Ack or DCCP-DataAck packet.  The client
   moves from the REQUEST state to PARTOPEN, and finally to OPEN; the
   server moves from LISTEN to RESPOND, and finally to OPEN.

     Client State                             Server State
        CLOSED                                   LISTEN
   1.   REQUEST   -->       Request        -->
   2.             <--       Response       <--   RESPOND
   3.   PARTOPEN  -->     Ack, DataAck     -->
   4.             <--  Data, Ack, DataAck  <--   OPEN
   5.   OPEN      <->  Data, Ack, DataAck  <->   OPEN

8.1.1.  Client Request

   When a client decides to initiate a connection, it enters the REQUEST
   state, chooses an initial sequence number (Section 7.2), and sends a
   DCCP-Request packet using that sequence number to the intended
   server.

   DCCP-Request packets will commonly carry feature negotiation options
   that open negotiations for various connection parameters, such as
   preferred congestion control IDs for each half-connection.  They may
   also carry application data, but the client should be aware that the
   server may not accept such data.

   A client in the REQUEST state SHOULD use an exponential-backoff timer
   to send new DCCP-Request packets if no response is received.  The
   first retransmission should occur after approximately one second,
   backing off to not less than one packet every 64 seconds; or the



Kohler, et al.              Standards Track                    [Page 58]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   endpoint can use whatever retransmission strategy is followed for
   retransmitting TCP SYNs.  Each new DCCP-Request MUST increment the
   Sequence Number by one and MUST contain the same Service Code and
   application data as the original DCCP-Request.

   A client MAY give up on its DCCP-Requests after some time (3 minutes,
   for example).  When it does, it SHOULD send a DCCP-Reset packet to
   the server with Reset Code 2, ""Aborted"", to clean up state in case
   one or more of the Requests actually arrived.  A client in REQUEST
   state has never received an initial sequence number from its peer, so
   the DCCP-Reset's Acknowledgement Number MUST be set to zero.

   The client leaves the REQUEST state for PARTOPEN when it receives a
   DCCP-Response from the server.

8.1.2.  Service Codes

   Each DCCP-Request contains a 32-bit Service Code, which identifies
   the application-level service to which the client application is
   trying to connect.  Service Codes should correspond to application
   services and protocols.  For example, there might be a Service Code
   for SIP control connections and one for RTP audio connections.
   Middleboxes, such as firewalls, can use the Service Code to identify
   the application running on a nonstandard port (assuming the DCCP
   header has not been encrypted).

   Endpoints MUST associate a Service Code with every DCCP socket, both
   actively and passively opened.  The application will generally supply
   this Service Code.  Each active socket MUST have exactly one Service
   Code.  Passive sockets MAY, at the implementation's discretion, be
   associated with more than one Service Code; this might let multiple
   applications, or multiple versions of the same application, listen on
   the same port, differentiated by Service Code.  If the DCCP-Request's
   Service Code doesn't equal any of the server's Service Codes for the
   given port, the server MUST reject the request by sending a DCCP-
   Reset packet with Reset Code 8, ""Bad Service Code"".  A middlebox MAY
   also send such a DCCP-Reset in response to packets whose Service Code
   is considered unsuitable.

   Service Codes are not intended to be DCCP-specific and are allocated
   by IANA.  Following the policies outlined in [RFC2434], most Service
   Codes are allocated First Come First Served, subject to the following
   guidelines.

   o  Service Codes are allocated one at a time, or in small blocks.  A
      short English description of the intended service is REQUIRED to
      obtain a Service Code assignment, but no specification, standards




Kohler, et al.              Standards Track                    [Page 59]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


      track or otherwise, is necessary.  IANA maintains an association
      of Service Codes to the corresponding phrases.

   o  Users request specific Service Code values.  We suggest that users
      request Service Codes that can be represented using the ""SC:""
      formatting convention described below.  Thus, the ""Frobodyne Plotz
      Protocol"" might correspond to Service Code 17178548426 or,
      equivalently, ""SC:fdpz"".  The canonical interpretation of a
      Service Code field is numeric.

   o  Service Codes whose bytes each have values in the set {32, 45-57,
      65-90} use a Specification Required allocation policy.  That is,
      these Service Codes are used for international standard or
      standards-track specifications, IETF or otherwise.  (This set
      consists of the ASCII digits, uppercase letters, and characters
      space, '-', '.', and '/'.)

   o  Service Codes whose high-order byte equals 63 (ASCII '?') are
      reserved for Private Use.

   o  Service Code 0 represents the absence of a meaningful Service Code
      and MUST NOT be allocated.

   o  The value 4294967295 is an invalid Service Code.  Servers MUST
      reject any DCCP-Request with this Service Code value by sending a
      DCCP-Reset packet with Reset Code 8, ""Bad Service Code"".

   This design for Service Code allocation is based on the allocation of
   4-byte identifiers for Macintosh resources, PNG chunks, and TrueType
   and OpenType tables.

   In text settings, we recommend that Service Codes be written in one
   of three forms, prefixed by the ASCII letters SC and either a colon
   "":"" or equals sign ""="".  These forms are interpreted as follows.

   SC:     Indicates a Service Code representable using a subset of the
           ASCII characters.  The colon is followed by one to four
           characters taken from the following set: letters, digits, and
           the characters in ""-_+.*/?@"" (not including quotes).
           Numerically, these characters have values in {42-43, 45-57,
           63-90, 95, 97-122}.  The Service Code is calculated by
           padding the string on the right with spaces (value 32) and
           intepreting the four-character result as a 32-bit big-endian
           number.

   SC=     Indicates a decimal Service Code.  The equals sign is
           followed by any number of decimal digits, which specify the
           Service Code.  Values above 4294967294 are illegal.



Kohler, et al.              Standards Track                    [Page 60]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   SC=x or SC=X
           Indicates a hexadecimal Service Code.  The ""x"" or ""X"" is
           followed by any number of hexadecimal digits (upper or lower
           case), which specify the Service Code.  Values above
           4294967294 are illegal.

   Thus, the Service Code 1717858426 might be represented in text as
   either SC:fdpz, SC=1717858426, or SC=x6664707A.

8.1.3.  Server Response

   In the second phase of the three-way handshake, the server moves from
   the LISTEN state to RESPOND and sends a DCCP-Response message to the
   client.  In this phase, a server will often specify the features it
   would like to use, either from among those the client requested or in
   addition to those.  Among these options is the congestion control
   mechanism the server expects to use.

   The server MAY respond to a DCCP-Request packet with a DCCP-Reset
   packet to refuse the connection.  Relevant Reset Codes for refusing a
   connection include 7, ""Connection Refused"", when the DCCP-Request's
   Destination Port did not correspond to a DCCP port open for
   listening; 8, ""Bad Service Code"", when the DCCP-Request's Service
   Code did not correspond to the service code registered with the
   Destination Port; and 9, ""Too Busy"", when the server is currently too
   busy to respond to requests.  The server SHOULD limit the rate at
   which it generates these resets; for example, to not more than 1024
   per second.

   The server SHOULD NOT retransmit DCCP-Response packets; the client
   will retransmit the DCCP-Request if necessary.  (Note that the
   ""retransmitted"" DCCP-Request will have, at least, a different
   sequence number from the ""original"" DCCP-Request.  The server can
   thus distinguish true retransmissions from network duplicates.)  The
   server will detect that the retransmitted DCCP-Request applies to an
   existing connection because of its Source and Destination Ports.
   Every valid DCCP-Request received while the server is in the RESPOND
   state MUST elicit a new DCCP-Response.  Each new DCCP-Response MUST
   increment the server's Sequence Number by one and MUST include the
   same application data, if any, as the original DCCP-Response.

   The server MUST NOT accept more than one piece of DCCP-Request
   application data per connection.  In particular, the DCCP-Response
   sent in reply to a retransmitted DCCP-Request with application data
   SHOULD contain a Data Dropped option, in which the retransmitted
   DCCP-Request data is reported with Drop Code 0, Protocol Constraints.
   The original DCCP-Request SHOULD also be reported in the Data Dropped
   option, either in a Normal Block (if the server accepted the data or



Kohler, et al.              Standards Track                    [Page 61]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   there was no data) or in a Drop Code 0 Drop Block (if the server
   refused the data the first time as well).

   The Data Dropped and Init Cookie options are particularly useful for
   DCCP-Response packets (Sections 11.7 and 8.1.4).

   The server leaves the RESPOND state for OPEN when it receives a valid
   DCCP-Ack from the client, completing the three-way handshake.  It MAY
   also leave the RESPOND state for CLOSED after a timeout of not less
   than 4MSL (8 minutes); when doing so, it SHOULD send a DCCP-Reset
   with Reset Code 2, ""Aborted"", to clean up state at the client.

8.1.4.  Init Cookie Option

   +--------+--------+--------+--------+--------+--------
   |00100100| Length |         Init Cookie Value   ...
   +--------+--------+--------+--------+--------+--------
    Type=36

   The Init Cookie option lets a DCCP server avoid having to hold any
   state until the three-way connection setup handshake has completed,
   in a similar fashion as for TCP SYN cookies [SYNCOOKIES].  The server
   wraps up the Service Code, server port, and any options it cares
   about from both the DCCP-Request and DCCP-Response in an opaque
   cookie.  Typically the cookie will be encrypted using a secret known
   only to the server and will include a cryptographic checksum or magic
   value so that correct decryption can be verified.  When the server
   receives the cookie back in the response, it can decrypt the cookie
   and instantiate all the state it avoided keeping.  In the meantime,
   it need not move from the LISTEN state.

   The Init Cookie option MUST NOT be sent on DCCP-Request or DCCP-Data
   packets.  Any Init Cookie options received on DCCP-Request or DCCP-
   Data packets, or after the connection has been established (when the
   connection's state is >= OPEN), MUST be ignored.  The server MAY
   include Init Cookie options in its DCCP-Response.  If so, then the
   client MUST echo the same Init Cookie options, in the same order, in
   each succeeding DCCP packet until one of those packets is
   acknowledged (showing that the three-way handshake has completed) or
   the connection is reset.  As a result, the client MUST NOT use DCCP-
   Data packets until the three-way handshake completes or the
   connection is reset.  The Init Cookie options on a client packet MUST
   equal those received on the DCCP-Request indicated by the client
   packet's Acknowledgement Number.  The server SHOULD design its Init
   Cookie format so that Init Cookies can be checked for tampering; it
   SHOULD respond to a tampered Init Cookie option by resetting the
   connection with Reset Code 10, ""Bad Init Cookie"".




Kohler, et al.              Standards Track                    [Page 62]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   Init Cookie's precise implementation need not be specified here;
   since Init Cookies are opaque to the client, there are no
   interoperability concerns.  An example cookie format might encrypt
   (using a secret key) the connection's initial sequence and
   acknowledgement numbers, ports, Service Code, any options included on
   the DCCP-Request packet and the corresponding DCCP-Response, a random
   salt, and a magic number.  On receiving a reflected Init Cookie, the
   server would decrypt the cookie, validate it by checking its magic
   number, sequence numbers, and ports, and, if valid, create a
   corresponding socket using the options.

   Each individual Init Cookie option can hold at most 253 bytes of
   data, but a server can send multiple Init Cookie options to gain more
   space.

8.1.5.  Handshake Completion

   When the client receives a DCCP-Response from the server, it moves
   from the REQUEST state to PARTOPEN and completes the three-way
   handshake by sending a DCCP-Ack packet to the server.  The client
   remains in PARTOPEN until it can be sure that the server has received
   some packet the client sent from PARTOPEN (either the initial DCCP-
   Ack or a later packet).  Clients in the PARTOPEN state that want to
   send data MUST do so using DCCP-DataAck packets, not DCCP-Data
   packets.  This is because DCCP-Data packets lack Acknowledgement
   Numbers, so the server can't tell from a DCCP-Data packet whether the
   client saw its DCCP-Response.  Furthermore, if the DCCP-Response
   included an Init Cookie, that Init Cookie MUST be included on every
   packet sent in PARTOPEN.

   The single DCCP-Ack sent when entering the PARTOPEN state might, of
   course, be dropped by the network.  The client SHOULD ensure that
   some packet gets through eventually.  The preferred mechanism would
   be a roughly 200-millisecond timer, set every time a packet is
   transmitted in PARTOPEN.  If this timer goes off and the client is
   still in PARTOPEN, the client generates another DCCP-Ack and backs
   off the timer.  If the client remains in PARTOPEN for more than 4MSL
   (8 minutes), it SHOULD reset the connection with Reset Code 2,
   ""Aborted"".

   The client leaves the PARTOPEN state for OPEN when it receives a
   valid packet other than DCCP-Response, DCCP-Reset, or DCCP-Sync from
   the server.

8.2.  Data Transfer

   In the central data transfer phase of the connection, both server and
   client are in the OPEN state.



Kohler, et al.              Standards Track                    [Page 63]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   DCCP A sends DCCP-Data and DCCP-DataAck packets to DCCP B due to
   application events on host A.  These packets are congestion-
   controlled by the CCID for the A-to-B half-connection.  In contrast,
   DCCP-Ack packets sent by DCCP A are controlled by the CCID for the
   B-to-A half-connection.  Generally, DCCP A will piggyback
   acknowledgement information on DCCP-Data packets when acceptable,
   creating DCCP-DataAck packets.  DCCP-Ack packets are used when there
   is no data to send from DCCP A to DCCP B, or when the congestion
   state of the A-to-B CCID will not allow data to be sent.

   DCCP-Sync and DCCP-SyncAck packets may also occur in the data
   transfer phase.  Some cases causing DCCP-Sync generation are
   discussed in Section 7.5.  One important distinction between DCCP-
   Sync packets and other packet types is that DCCP-Sync elicits an
   immediate acknowledgement.  On receiving a valid DCCP-Sync packet, a
   DCCP endpoint MUST immediately generate and send a DCCP-SyncAck
   response (subject to any implementation rate limits); the
   Acknowledgement Number on that DCCP-SyncAck MUST equal the Sequence
   Number of the DCCP-Sync.

   A particular DCCP implementation might decide to initiate feature
   negotiation only once the OPEN state was reached, in which case it
   might not allow data transfer until some time later.  Data received
   during that time SHOULD be rejected and reported using a Data Dropped
   Drop Block with Drop Code 0, Protocol Constraints (see Section 11.7).

8.3.  Termination

   DCCP connection termination uses a handshake consisting of an
   optional DCCP-CloseReq packet, a DCCP-Close packet, and a DCCP-Reset
   packet.  The server moves from the OPEN state, possibly through the
   CLOSEREQ state, to CLOSED; the client moves from OPEN through CLOSING
   to TIMEWAIT, and after 2MSL wait time (4 minutes) to CLOSED.

   The sequence DCCP-CloseReq, DCCP-Close, DCCP-Reset is used when the
   server decides to close the connection but doesn't want to hold
   TIMEWAIT state:

     Client State                             Server State
        OPEN                                     OPEN
   1.             <--       CloseReq       <--   CLOSEREQ
   2.   CLOSING   -->        Close         -->
   3.             <--        Reset         <--   CLOSED (LISTEN)
   4.   TIMEWAIT
   5.   CLOSED






Kohler, et al.              Standards Track                    [Page 64]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   A shorter sequence occurs when the client decides to close the
   connection.

     Client State                             Server State
        OPEN                                     OPEN
   1.   CLOSING   -->        Close         -->
   2.             <--        Reset         <--   CLOSED (LISTEN)
   3.   TIMEWAIT
   4.   CLOSED

   Finally, the server can decide to hold TIMEWAIT state:

     Client State                             Server State
        OPEN                                     OPEN
   1.             <--        Close         <--   CLOSING
   2.   CLOSED    -->        Reset         -->
   3.                                            TIMEWAIT
   4.                                            CLOSED (LISTEN)

   In all cases, the receiver of the DCCP-Reset packet holds TIMEWAIT
   state for the connection.  As in TCP, TIMEWAIT state, where an
   endpoint quietly preserves a socket for 2MSL (4 minutes) after its
   connection has closed, ensures that no connection duplicating the
   current connection's source and destination addresses and ports can
   start up while old packets might remain in the network.

   The termination handshake proceeds as follows.  The receiver of a
   valid DCCP-CloseReq packet MUST respond with a DCCP-Close packet.
   The receiver of a valid DCCP-Close packet MUST respond with a DCCP-
   Reset packet with Reset Code 1, ""Closed"".  The receiver of a valid
   DCCP-Reset packet -- which is also the sender of the DCCP-Close
   packet (and possibly the receiver of the DCCP-CloseReq packet) --
   will hold TIMEWAIT state for the connection.

   A DCCP-Reset packet completes every DCCP connection, whether the
   termination is clean (due to application close; Reset Code 1,
   ""Closed"") or unclean.  Unlike TCP, which has two distinct termination
   mechanisms (FIN and RST), DCCP ends all connections in a uniform
   manner.  This is justified because some aspects of connection
   termination are the same independent of whether termination was
   clean.  For instance, the endpoint that receives a valid DCCP-Reset
   SHOULD hold TIMEWAIT state for the connection.  Processors that must
   distinguish between clean and unclean termination can examine the
   Reset Code.  DCCP implementations generally transition to the CLOSED
   state after sending a DCCP-Reset packet.

   Endpoints in the CLOSEREQ and CLOSING states MUST retransmit DCCP-
   CloseReq and DCCP-Close packets, respectively, until leaving those



Kohler, et al.              Standards Track                    [Page 65]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   states.  The retransmission timer should initially be set to go off
   in two round-trip times and should back off to not less than once
   every 64 seconds if no relevant response is received.

   Only the server can send a DCCP-CloseReq packet or enter the CLOSEREQ
   state.  A server receiving a sequence-valid DCCP-CloseReq packet MUST
   respond with a DCCP-Sync packet and otherwise ignore the DCCP-
   CloseReq.

   DCCP-Data, DCCP-DataAck, and DCCP-Ack packets received in CLOSEREQ or
   CLOSING states MAY be either processed or ignored.

8.3.1.  Abnormal Termination

   DCCP endpoints generate DCCP-Reset packets to terminate connections
   abnormally; a DCCP-Reset packet may be generated from any state.
   Resets sent in the CLOSED, LISTEN, and TIMEWAIT states use Reset Code
   3, ""No Connection"", unless otherwise specified.  Resets sent in the
   REQUEST or RESPOND states use Reset Code 4, ""Packet Error"", unless
   otherwise specified.

   DCCP endpoints in CLOSED, LISTEN, or TIMEWAIT state may need to
   generate a DCCP-Reset packet in response to a packet received from a
   peer.  Since these states have no associated sequence number
   variables, the Sequence and Acknowledgement Numbers on the DCCP-Reset
   packet R are taken from the received packet P, as follows.

   1. If P.ackno exists, then set R.seqno := P.ackno + 1.  Otherwise,
      set R.seqno := 0.

   2. Set R.ackno := P.seqno.

   3. If the packet used short sequence numbers (P.X == 0), then set the
      upper 24 bits of R.seqno and R.ackno to 0.

8.4.  DCCP State Diagram

   The most common state transitions discussed above can be summarized
   in the following state diagram.  The diagram is illustrative; the
   text in Section 8.5 and elsewhere should be considered definitive.
   For example, there are arcs (not shown) from every state except
   CLOSED to TIMEWAIT, contingent on the receipt of a valid DCCP-Reset.









Kohler, et al.              Standards Track                    [Page 66]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   +---------------------------+    +---------------------------+
   |                           v    v                           |
   |                        +----------+                        |
   |          +-------------+  CLOSED  +------------+           |
   |          | passive     +----------+  active    |           |
   |          |  open                      open     |           |
   |          |                         snd Request |           |
   |          v                                     v           |
   |     +----------+                          +----------+     |
   |     |  LISTEN  |                          | REQUEST  |     |
   |     +----+-----+                          +----+-----+     |
   |          | rcv Request            rcv Response |           |
   |          | snd Response             snd Ack    |           |
   |          v                                     v           |
   |     +----------+                          +----------+     |
   |     | RESPOND  |                          | PARTOPEN |     |
   |     +----+-----+                          +----+-----+     |
   |          | rcv Ack/DataAck         rcv packet  |           |
   |          |                                     |           |
   |          |             +----------+            |           |
   |          +------------>|   OPEN   |<-----------+           |
   |                        +--+-+--+--+                        |
   |       server active close | |  |   active close            |
   |           snd CloseReq    | |  | or rcv CloseReq           |
   |                           | |  |    snd Close              |
   |                           | |  |                           |
   |     +----------+          | |  |          +----------+     |
   |     | CLOSEREQ |<---------+ |  +--------->| CLOSING  |     |
   |     +----+-----+            |             +----+-----+     |
   |          | rcv Close        |        rcv Reset |           |
   |          | snd Reset        |                  |           |
   |<---------+                  |                  v           |
   |                             |             +----+-----+     |
   |                   rcv Close |             | TIMEWAIT |     |
   |                   snd Reset |             +----+-----+     |
   +-----------------------------+                  |           |
                                                    +-----------+
                                                 2MSL timer expires

8.5.  Pseudocode

   This section presents an algorithm describing the processing steps a
   DCCP endpoint must go through when it receives a packet.  A DCCP
   implementation need not implement the algorithm as it is described
   here, but any implementation MUST generate observable effects exactly
   as indicated by this pseudocode, except where allowed otherwise by
   another part of this document.




Kohler, et al.              Standards Track                    [Page 67]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   The received packet is written as P, the socket as S.  Socket
   variables are:

   S.SWL - sequence number window low
   S.SWH - sequence number window high
   S.AWL - acknowledgement number window low
   S.AWH - acknowledgement number window high
   S.ISS - initial sequence number sent
   S.ISR - initial sequence number received
   S.OSR - first OPEN sequence number received
   S.GSS - greatest sequence number sent
   S.GSR - greatest valid sequence number received
   S.GAR - greatest valid acknowledgement number received on a
           non-Sync; initialized to S.ISS
   ""Send packet"" actions always use, and increment, S.GSS.

   Step 1: Check header basics
      /* This step checks for malformed packets.  Packets that fail
         these checks are ignored -- they do not receive Resets in
         response */
      If the packet is shorter than 12 bytes, drop packet and return
      If P.type is not understood, drop packet and return
      If P.Data Offset is smaller than the given packet type's
            fixed header length or larger than the packet's length,
            drop packet and return
      If P.type is not Data, Ack, or DataAck and P.X == 0 (the packet
            has short sequence numbers), drop packet and return
      If the header checksum is incorrect, drop packet and return
      If P.CsCov is too large for the packet size, drop packet and
            return

   Step 2: Check ports and process TIMEWAIT state
      /* Flow ID is <src addr, src port, dst addr, dst port> 4-tuple */
      Look up flow ID in table and get corresponding socket
      If no socket, or S.state == TIMEWAIT,
         /* The following Reset's Sequence and Acknowledgement Numbers
            are taken from the input packet; see Section 8.3.1. */
         Generate Reset(No Connection) unless P.type == Reset
         Drop packet and return












Kohler, et al.              Standards Track                    [Page 68]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   Step 3: Process LISTEN state
      If S.state == LISTEN,
         If P.type == Request or P contains a valid Init Cookie option,
            /* Must scan the packet's options to check for Init
               Cookies.  Only Init Cookies are processed here,
               however; other options are processed in Step 8.  This
               scan need only be performed if the endpoint uses Init
               Cookies */
            /* Generate a new socket and switch to that socket */
            Set S := new socket for this port pair
            S.state = RESPOND
            Choose S.ISS (initial seqno) or set from Init Cookies
            Initialize S.GAR := S.ISS
            Set S.ISR, S.GSR, S.SWL, S.SWH from packet or Init Cookies
            Continue with S.state == RESPOND
            /* A Response packet will be generated in Step 11 */
         Otherwise,
            Generate Reset(No Connection) unless P.type == Reset
            Drop packet and return

   Step 4: Prepare sequence numbers in REQUEST
      If S.state == REQUEST,
         If (P.type == Response or P.type == Reset)
               and S.AWL <= P.ackno <= S.AWH,
            /* Set sequence number variables corresponding to the
               other endpoint, so P will pass the tests in Step 6 */
            Set S.GSR, S.ISR, S.SWL, S.SWH
            /* Response processing continues in Step 10; Reset
               processing continues in Step 9 */
         Otherwise,
            /* Only Response and Reset are valid in REQUEST state */
            Generate Reset(Packet Error)
            Drop packet and return

   Step 5: Prepare sequence numbers for Sync
      If P.type == Sync or P.type == SyncAck,
         If S.AWL <= P.ackno <= S.AWH and P.seqno >= S.SWL,
            /* P is valid, so update sequence number variables
               accordingly.  After this update, P will pass the tests
               in Step 6.  A SyncAck is generated if necessary in
               Step 15 */
            Update S.GSR, S.SWL, S.SWH
         Otherwise,
            Drop packet and return







Kohler, et al.              Standards Track                    [Page 69]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   Step 6: Check sequence numbers
      If P.X == 0 and the relevant Allow Short Seqnos feature is 0,
         /* Packet has short seqnos, but short seqnos not allowed */
         Drop packet and return
      Otherwise, if P.X == 0,
         Extend P.seqno and P.ackno to 48 bits using the procedure
         in Section 7.6
      Let LSWL = S.SWL and LAWL = S.AWL
      If P.type == CloseReq or P.type == Close or P.type == Reset,
         LSWL := S.GSR + 1, LAWL := S.GAR
      If LSWL <= P.seqno <= S.SWH
            and (P.ackno does not exist or LAWL <= P.ackno <= S.AWH),
         Update S.GSR, S.SWL, S.SWH
         If P.type != Sync,
            Update S.GAR
      Otherwise,
         If P.type == Reset,
            Send Sync packet acknowledging S.GSR
         Otherwise,
            Send Sync packet acknowledging P.seqno
         Drop packet and return

   Step 7: Check for unexpected packet types
      If (S.is_server and P.type == CloseReq)
           or (S.is_server and P.type == Response)
           or (S.is_client and P.type == Request)
           or (S.state >= OPEN and P.type == Request
               and P.seqno >= S.OSR)
           or (S.state >= OPEN and P.type == Response
               and P.seqno >= S.OSR)
           or (S.state == RESPOND and P.type == Data),
         Send Sync packet acknowledging P.seqno
         Drop packet and return

   Step 8: Process options and mark acknowledgeable
      /* Option processing is not specifically described here.
         Certain options, such as Mandatory, may cause the connection
         to be reset, in which case Steps 9 and on are not executed */
      Mark packet as acknowledgeable (in Ack Vector terms, Received
           or Received ECN Marked)

   Step 9: Process Reset
      If P.type == Reset,
         Tear down connection
         S.state := TIMEWAIT
         Set TIMEWAIT timer
         Drop packet and return




Kohler, et al.              Standards Track                    [Page 70]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   Step 10: Process REQUEST state (second part)
      If S.state == REQUEST,
         /* If we get here, P is a valid Response from the server (see
            Step 4), and we should move to PARTOPEN state.  PARTOPEN
            means send an Ack, don't send Data packets, retransmit
            Acks periodically, and always include any Init Cookie from
            the Response */
         S.state := PARTOPEN
         Set PARTOPEN timer
         Continue with S.state == PARTOPEN
         /* Step 12 will send the Ack completing the three-way
            handshake */

   Step 11: Process RESPOND state
      If S.state == RESPOND,
         If P.type == Request,
            Send Response, possibly containing Init Cookie
            If Init Cookie was sent,
               Destroy S and return
               /* Step 3 will create another socket when the client
                  completes the three-way handshake */
         Otherwise,
            S.OSR := P.seqno
            S.state := OPEN

   Step 12: Process PARTOPEN state
      If S.state == PARTOPEN,
         If P.type == Response,
            Send Ack
         Otherwise, if P.type != Sync,
            S.OSR := P.seqno
            S.state := OPEN

   Step 13: Process CloseReq
      If P.type == CloseReq and S.state < CLOSEREQ,
         Generate Close
         S.state := CLOSING
         Set CLOSING timer

   Step 14: Process Close
      If P.type == Close,
         Generate Reset(Closed)
         Tear down connection
         Drop packet and return







Kohler, et al.              Standards Track                    [Page 71]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   Step 15: Process Sync
      If P.type == Sync,
         Generate SyncAck

   Step 16: Process data
      /* At this point any application data on P can be passed to the
         application, except that the application MUST NOT receive
         data from more than one Request or Response */

9.  Checksums

   DCCP uses a header checksum to protect its header against corruption.
   Generally, this checksum also covers any application data.  DCCP
   applications can, however, request that the header checksum cover
   only part of the application data, or perhaps no application data at
   all.  Link layers may then reduce their protection on unprotected
   parts of DCCP packets.  For some noisy links, and for applications
   that can tolerate corruption, this can greatly improve delivery rates
   and perceived performance.

   Checksum coverage may eventually impact congestion control mechanisms
   as well.  A packet with corrupt application data and complete
   checksum coverage is treated as lost.  This incurs a heavy-duty loss
   response from the sender's congestion control mechanism, which can
   unfairly penalize connections on links with high background
   corruption.  The combination of reduced checksum coverage and Data
   Checksum options may let endpoints report packets as corrupt rather
   than dropped, using Data Dropped options and Drop Code 3 (see Section
   11.7).  This may eventually benefit applications.  However, further
   research is required to determine an appropriate response to
   corruption, which can sometimes correlate with congestion.  Corrupt
   packets currently incur a loss response.

   The Data Checksum option, which contains a strong CRC, lets endpoints
   detect application data corruption.  An API can then be used to avoid
   delivering corrupt data to the application, even if links deliver
   corrupt data to the endpoint due to reduced checksum coverage.
   However, the use of reduced checksum coverage for applications that
   demand correct data is currently considered experimental.  This is
   because the combined loss-plus-corruption rate for packets with
   reduced checksum coverage may be significantly higher than that for
   packets with full checksum coverage, although the loss rate will
   generally be lower.  Actual behavior will depend on link design;
   further research and experience is required.

   Reduced checksum coverage introduces some security considerations;
   see Section 18.1.  See Appendix B for further motivation and




Kohler, et al.              Standards Track                    [Page 72]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   discussion.  DCCP's implementation of reduced checksum coverage was
   inspired by UDP-Lite [RFC3828].

9.1.  Header Checksum Field

   DCCP uses the TCP/IP checksum algorithm.  The Checksum field in the
   DCCP generic header (see Section 5.1) equals the 16-bit one's
   complement of the one's complement sum of all 16-bit words in the
   DCCP header, DCCP options, a pseudoheader taken from the network-
   layer header, and, depending on the value of the Checksum Coverage
   field, some or all of the application data.  When calculating the
   checksum, the Checksum field itself is treated as 0.  If a packet
   contains an odd number of header and payload bytes to be checksummed,
   8 zero bits are added on the right to form a 16-bit word for checksum
   purposes.  The pad byte is not transmitted as part of the packet.

   The pseudoheader is calculated as for TCP.  For IPv4, it is 96 bits
   long and consists of the IPv4 source and destination addresses, the
   IP protocol number for DCCP (padded on the left with 8 zero bits),
   and the DCCP length as a 16-bit quantity (the length of the DCCP
   header with options, plus the length of any data); see [RFC793],
   Section 3.1.  For IPv6, it is 320 bits long, and consists of the IPv6
   source and destination addresses, the DCCP length as a 32-bit
   quantity, and the IP protocol number for DCCP (padded on the left
   with 24 zero bits); see [RFC2460], Section 8.1.

   Packets with invalid header checksums MUST be ignored.  In
   particular, their options MUST NOT be processed.

9.2.  Header Checksum Coverage Field

   The Checksum Coverage field in the DCCP generic header (see Section
   5.1) specifies what parts of the packet are covered by the Checksum
   field, as follows:

   CsCov = 0      The Checksum field covers the DCCP header, DCCP
                  options, network-layer pseudoheader, and all
                  application data in the packet, possibly padded on the
                  right with zeros to an even number of bytes.

   CsCov = 1-15   The Checksum field covers the DCCP header, DCCP
                  options, network-layer pseudoheader, and the initial
                  (CsCov-1)*4 bytes of the packet's application data.

   Thus, if CsCov is 1, none of the application data is protected by the
   header checksum.  The value (CsCov-1)*4 MUST be less than or equal to
   the length of the application data.  Packets with invalid CsCov
   values MUST be ignored; in particular, their options MUST NOT be



Kohler, et al.              Standards Track                    [Page 73]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   processed.  The meanings of values other than 0 and 1 should be
   considered experimental.

   Values other than 0 specify that corruption is acceptable in some or
   all of the DCCP packet's application data.  In fact, DCCP cannot even
   detect corruption in areas not covered by the header checksum, unless
   the Data Checksum option is used.  Applications should not make any
   assumptions about the correctness of received data not covered by the
   checksum and should, if necessary, introduce their own validity
   checks.

   A DCCP application interface should let sending applications suggest
   a value for CsCov for sent packets, defaulting to 0 (full coverage).
   The Minimum Checksum Coverage feature, described below, lets an
   endpoint refuse delivery of application data on packets with partial
   checksum coverage; by default, only fully covered application data is
   accepted.  Lower layers that support partial error detection MAY use
   the Checksum Coverage field as a hint of where errors do not need to
   be detected.  Lower layers MUST use a strong error detection
   mechanism to detect at least errors that occur in the sensitive part
   of the packet, and to discard damaged packets.  The sensitive part
   consists of the bytes between the first byte of the IP header and the
   last byte identified by Checksum Coverage.

   For more details on application and lower-layer interface issues
   relating to partial checksumming, see [RFC3828].

9.2.1.  Minimum Checksum Coverage Feature

   The Minimum Checksum Coverage feature lets a DCCP endpoint determine
   whether its peer is willing to accept packets with reduced Checksum
   Coverage.  For example, DCCP A sends a ""Change R(Minimum Checksum
   Coverage, 1)"" option to DCCP B to check whether B is willing to
   accept packets with Checksum Coverage set to 1.

   Minimum Checksum Coverage has feature number 8 and is server-
   priority.  It takes one-byte integer values between 0 and 15; values
   of 16 or more are reserved.  Minimum Checksum Coverage/B reflects
   values of Checksum Coverage that DCCP B finds unacceptable.  Say that
   the value of Minimum Checksum Coverage/B is MinCsCov.  Then:

   o  If MinCsCov = 0, then DCCP B only finds packets with CsCov = 0
      acceptable.

   o  If MinCsCov > 0, then DCCP B additionally finds packets with
      CsCov >= MinCsCov acceptable.





Kohler, et al.              Standards Track                    [Page 74]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   DCCP B MAY refuse to process application data from packets with
   unacceptable Checksum Coverage.  Such packets SHOULD be reported
   using Data Dropped options (Section 11.7) with Drop Code 0, Protocol
   Constraints.  New connections start with Minimum Checksum Coverage 0
   for both endpoints.

9.3.  Data Checksum Option

   The Data Checksum option holds a 32-bit CRC-32c cyclic redundancy-
   check code of a DCCP packet's application data.

   +--------+--------+--------+--------+--------+--------+
   |00101100|00000110|              CRC-32c              |
   +--------+--------+--------+--------+--------+--------+
    Type=44  Length=6

   The sending DCCP computes the CRC of the bytes comprising the
   application data area and stores it in the option data.  The CRC-32c
   algorithm used for Data Checksum is the same as that used for SCTP
   [RFC3309]; note that the CRC-32c of zero bytes of data equals zero.
   The DCCP header checksum will cover the Data Checksum option, so the
   data checksum must be computed before the header checksum.

   A DCCP endpoint receiving a packet with a Data Checksum option either
   MUST or MAY check the Data Checksum; the choice depends on the value
   of the Check Data Checksum feature described below.  If it checks the
   checksum, it computes the received application data's CRC-32c using
   the same algorithm as the sender and compares the result with the
   Data Checksum value.  If the CRCs differ, the endpoint reacts in one
   of two ways:

   o  The receiving application may have requested delivery of known-
      corrupt data via some optional API.  In this case, the packet's
      data MUST be delivered to the application, with a note that it is
      known to be corrupt.  Furthermore, the receiving endpoint MUST
      report the packet as delivered corrupt using a Data Dropped option
      (Drop Code 7, Delivered Corrupt).

   o  Otherwise, the receiving endpoint MUST drop the application data
      and report that data as dropped due to corruption using a Data
      Dropped option (Drop Code 3, Corrupt).

   In either case, the packet is considered acknowledgeable (since its
   header was processed) and will therefore be acknowledged using the
   equivalent of Ack Vector's Received or Received ECN Marked states.

   Although Data Checksum is intended for packets containing application
   data, it may be included on other packets, such as DCCP-Ack, DCCP-



Kohler, et al.              Standards Track                    [Page 75]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   Sync, and DCCP-SyncAck.  The receiver SHOULD calculate the
   application data area's CRC-32c on such packets, just as it does for
   DCCP-Data and similar packets.  If the CRCs differ, the packets
   similarly MUST be reported using Data Dropped options (Drop Code 3),
   although their application data areas would not be delivered to the
   application in any case.

9.3.1.  Check Data Checksum Feature

   The Check Data Checksum feature lets a DCCP endpoint determine
   whether its peer will definitely check Data Checksum options.  DCCP A
   sends a Mandatory ""Change R(Check Data Checksum, 1)"" option to DCCP B
   to require it to check Data Checksum options (the connection will be
   reset if it cannot).

   Check Data Checksum has feature number 9 and is server-priority.  It
   takes one-byte Boolean values.  DCCP B MUST check any received Data
   Checksum options when Check Data Checksum/B is one, although it MAY
   check them even when Check Data Checksum/B is zero.  Values of two or
   more are reserved.  New connections start with Check Data Checksum 0
   for both endpoints.

9.3.2.  Checksum Usage Notes

   Internet links must normally apply strong integrity checks to the
   packets they transmit [RFC3828, RFC3819].  This is the default case
   when the DCCP header's Checksum Coverage value equals zero (full
   coverage).  However, the DCCP Checksum Coverage value might not be
   zero.  By setting partial Checksum Coverage, the application
   indicates that it can tolerate corruption in the unprotected part of
   the application data.  Recognizing this, link layers may reduce error
   detection and/or correction strength when transmitting this
   unprotected part.  This, in turn, can significantly increase the
   likelihood of the endpoint's receiving corrupt data; Data Checksum
   lets the receiver detect that corruption with very high probability.

10.  Congestion Control

   Each congestion control mechanism supported by DCCP is assigned a
   congestion control identifier, or CCID: a number from 0 to 255.
   During connection setup, and optionally thereafter, the endpoints
   negotiate their congestion control mechanisms by negotiating the
   values for their Congestion Control ID features.  Congestion Control
   ID has feature number 1.  The CCID/A value equals the CCID in use for
   the A-to-B half-connection.  DCCP B sends a ""Change R(CCID, K)""
   option to ask DCCP A to use CCID K for its data packets.





Kohler, et al.              Standards Track                    [Page 76]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   CCID is a server-priority feature, so CCID negotiation options can
   list multiple acceptable CCIDs, sorted in descending order of
   priority.  For example, the option ""Change R(CCID, 2 3 4)"" asks the
   receiver to use CCID 2 for its packets, although CCIDs 3 and 4 are
   also acceptable.  (This corresponds to the bytes ""35, 6, 1, 2, 3, 4"":
   Change R option (35), option length (6), feature ID (1), CCIDs (2, 3,
   4).)  Similarly, ""Confirm L(CCID, 2, 2 3 4)"" tells the receiver that
   the sender is using CCID 2 for its packets, but that CCIDs 3 and 4
   might also be acceptable.

   Currently allocated CCIDs are as follows:

           CCID   Meaning                      Reference
           ----   -------                      ---------
            0-1   Reserved
             2    TCP-like Congestion Control  [RFC4341]
             3    TCP-Friendly Rate Control    [RFC4342]
           4-255  Reserved

           Table 5: DCCP Congestion Control Identifiers

   New connections start with CCID 2 for both endpoints.  If this is
   unacceptable for a DCCP endpoint, that endpoint MUST send Mandatory
   Change(CCID) options on its first packets.

   All CCIDs standardized for use with DCCP will correspond to
   congestion control mechanisms previously standardized by the IETF.
   We expect that for quite some time, all such mechanisms will be TCP
   friendly, but TCP-friendliness is not an explicit DCCP requirement.

   A DCCP implementation intended for general use, such as an
   implementation in a general-purpose operating system kernel, SHOULD
   implement at least CCID 2.  The intent is to make CCID 2 broadly
   available for interoperability, although particular applications
   might disallow its use.

10.1.  TCP-like Congestion Control

   CCID 2, TCP-like Congestion Control, denotes Additive Increase,
   Multiplicative Decrease (AIMD) congestion control with behavior
   modelled directly on TCP, including congestion window, slow start,
   timeouts, and so forth [RFC2581].  CCID 2 achieves maximum bandwidth
   over the long term, consistent with the use of end-to-end congestion
   control, but halves its congestion window in response to each
   congestion event.  This leads to the abrupt rate changes typical of
   TCP.  Applications should use CCID 2 if they prefer maximum bandwidth
   utilization to steadiness of rate.  This is often the case for
   applications that are not playing their data directly to the user.



Kohler, et al.              Standards Track                    [Page 77]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   For example, a hypothetical application that transferred files over
   DCCP, using application-level retransmissions for lost packets, would
   prefer CCID 2 to CCID 3.  On-line games may also prefer CCID 2.

   CCID 2 is further described in [RFC4341].

10.2.  TFRC Congestion Control

   CCID 3 denotes TCP-Friendly Rate Control (TFRC), an equation-based
   rate-controlled congestion control mechanism.  TFRC is designed to be
   reasonably fair when competing for bandwidth with TCP-like flows,
   where a flow is ""reasonably fair"" if its sending rate is generally
   within a factor of two of the sending rate of a TCP flow under the
   same conditions.  However, TFRC has a much lower variation of
   throughput over time compared with TCP, which makes CCID 3 more
   suitable than CCID 2 for applications such as streaming media where a
   relatively smooth sending rate is important.

   CCID 3 is further described in [RFC4342].  The TFRC congestion
   control algorithms were initially described in [RFC3448].

10.3.  CCID-Specific Options, Features, and Reset Codes

   Half of the option types, feature numbers, and Reset Codes are
   reserved for CCID-specific use.  CCIDs may often need new options,
   for communicating acknowledgement or rate information, for example;
   reserved option spaces let CCIDs create options at will without
   polluting the global option space.  Option 128 might have different
   meanings on a half-connection using CCID 4 and a half-connection
   using CCID 8.  CCID-specific options and features will never conflict
   with global options and features introduced by later versions of this
   specification.

   Any packet may contain information meant for either half-connection,
   so CCID-specific option types, feature numbers, and Reset Codes
   explicitly signal the half-connection to which they apply.

   o  Option numbers 128 through 191 are for options sent from the
      HC-Sender to the HC-Receiver; option numbers 192 through 255 are
      for options sent from the HC-Receiver to the HC-Sender.

   o  Reset Codes 128 through 191 indicate that the HC-Sender reset the
      connection (most likely because of some problem with
      acknowledgements sent by the HC-Receiver).  Reset Codes 192
      through 255 indicate that the HC-Receiver reset the connection
      (most likely because of some problem with data packets sent by the
      HC-Sender).




Kohler, et al.              Standards Track                    [Page 78]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   o  Finally, feature numbers 128 through 191 are used for features
      located at the HC-Sender; feature numbers 192 through 255 are for
      features located at the HC-Receiver.  Since Change L and Confirm L
      options for a feature are sent by the feature location, we know
      that any Change L(128) option was sent by the HC-Sender, while any
      Change L(192) option was sent by the HC-Receiver.  Similarly,
      Change R(128) options are sent by the HC-Receiver, while Change
      R(192) options are sent by the HC-Sender.

   For example, consider a DCCP connection where the A-to-B half-
   connection uses CCID 4 and the B-to-A half-connection uses CCID 5.
   Here is how a sampling of CCID-specific options are assigned to
   half-connections.

                                   Relevant    Relevant
        Packet  Option             Half-conn.  CCID
        ------  ------             ----------  ----
        A > B   128                  A-to-B     4
        A > B   192                  B-to-A     5
        A > B   Change L(128, ...)   A-to-B     4
        A > B   Change R(192, ...)   A-to-B     4
        A > B   Confirm L(128, ...)  A-to-B     4
        A > B   Confirm R(192, ...)  A-to-B     4
        A > B   Change R(128, ...)   B-to-A     5
        A > B   Change L(192, ...)   B-to-A     5
        A > B   Confirm R(128, ...)  B-to-A     5
        A > B   Confirm L(192, ...)  B-to-A     5
        B > A   128                  B-to-A     5
        B > A   192                  A-to-B     4
        B > A   Change L(128, ...)   B-to-A     5
        B > A   Change R(192, ...)   B-to-A     5
        B > A   Confirm L(128, ...)  B-to-A     5
        B > A   Confirm R(192, ...)  B-to-A     5
        B > A   Change R(128, ...)   A-to-B     4
        B > A   Change L(192, ...)   A-to-B     4
        B > A   Confirm R(128, ...)  A-to-B     4
        B > A   Confirm L(192, ...)  A-to-B     4

   Using CCID-specific options and feature options during a negotiation
   for the corresponding CCID feature is NOT RECOMMENDED, since it is
   difficult to predict which CCID will be in force when the option is
   processed.  For example, if a DCCP-Request contains the option
   sequence ""Change L(CCID, 3), 128"", the CCID-specific option ""128"" may
   be processed either by CCID 3 (if the server supports CCID 3) or by
   the default CCID 2 (if it does not).  However, it is safe to include
   CCID-specific options following certain Mandatory Change(CCID)





Kohler, et al.              Standards Track                    [Page 79]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   options.  For example, if a DCCP-Request contains the option sequence
   ""Mandatory, Change L(CCID, 3), 128"", then either the ""128"" option
   will be processed by CCID 3 or the connection will be reset.

   Servers that do not implement the default CCID 2 might nevertheless
   receive CCID 2-specific options on a DCCP-Request packet.  (Such a
   server MUST send Mandatory Change(CCID) options on its DCCP-Response,
   so CCID-specific options on any other packet won't refer to CCID 2.)
   The server MUST treat such options as non-understood.  Thus, it will
   reset the connection on encountering a Mandatory CCID-specific option
   or feature negotiation request, send an empty Confirm for a non-
   Mandatory Change option for a CCID-specific feature, and ignore other
   CCID-specific options.

10.4.  CCID Profile Requirements

   Each CCID Profile document MUST address at least the following
   requirements:

   o  The profile MUST include the name and number of the CCID being
      described.

   o  The profile MUST describe the conditions in which it is likely to
      be useful.  Often the best way to do this is by comparison to
      existing CCIDs.

   o  The profile MUST list and describe any CCID-specific options,
      features, and Reset Codes and SHOULD list those general options
      and features described in this document that are especially
      relevant to the CCID.

   o  Any newly defined acknowledgement mechanism MUST include a way to
      transmit ECN Nonce Echoes back to the sender.

   o  The profile MUST describe the format of data packets, including
      any options that should be included and the setting of the CCval
      header field.

   o  The profile MUST describe the format of acknowledgement packets,
      including any options that should be included.

   o  The profile MUST define how data packets are congestion
      controlled.  This includes responses to congestion events, to idle
      and application-limited periods, and to the DCCP Data Dropped and
      Slow Receiver options.  CCIDs that implement per-packet congestion
      control SHOULD discuss how packet size is factored in to
      congestion control decisions.




Kohler, et al.              Standards Track                    [Page 80]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   o  The profile MUST specify when acknowledgement packets are
      generated and how they are congestion controlled.

   o  The profile MUST define when a sender using the CCID is considered
      quiescent.

   o  The profile MUST say whether its CCID's acknowledgements ever need
      to be acknowledged and, if so, how often.

10.5.  Congestion State

   Most congestion control algorithms depend on past history to
   determine the current allowed sending rate.  In CCID 2, this
   congestion state includes a congestion window and a measurement of
   the number of packets outstanding in the network; in CCID 3, it
   includes the lengths of recent loss intervals.  Both CCIDs use an
   estimate of the round-trip time.  Congestion state depends on the
   network path and is invalidated by path changes.  Therefore, DCCP
   senders and receivers SHOULD reset their congestion state --
   essentially restarting congestion control from ""slow start"" or
   equivalent -- on significant changes in the end-to-end path.  For
   example, an endpoint that sends or receives a Mobile IPv6 Binding
   Update message [RFC3775] SHOULD reset its congestion state for any
   corresponding DCCP connections.

   A DCCP implementation MAY also reset its congestion state when a CCID
   changes (that is, when a negotiation for the CCID feature completes
   successfully and the new feature value differs from the old value).
   Thus, a connection in a heavily congested environment might evade
   end-to-end congestion control by frequently renegotiating a CCID,
   just as it could evade end-to-end congestion control by opening new
   connections for the same session.  This behavior is prohibited.  To
   prevent it, DCCP implementations MAY limit the rate at which CCID can
   be changed -- for instance, by refusing to change a CCID feature
   value more than once per minute.

11.  Acknowledgements

   Congestion control requires that receivers transmit information about
   packet losses and ECN marks to senders.  DCCP receivers MUST report
   all congestion they see, as defined by the relevant CCID profile.
   Each CCID says when acknowledgements should be sent, what options
   they must use, and so on.  DCCP acknowledgements are congestion
   controlled, although it is not required that the acknowledgement
   stream be more than very roughly TCP friendly; each CCID defines how
   acknowledgements are congestion controlled.





Kohler, et al.              Standards Track                    [Page 81]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   Most acknowledgements use DCCP options.  For example, on a half-
   connection with CCID 2 (TCP-like), the receiver reports
   acknowledgement information using the Ack Vector option.  This
   section describes common acknowledgement options and shows how acks
   using those options will commonly work.  Full descriptions of the ack
   mechanisms used for each CCID are laid out in the CCID profile
   specifications.

   Acknowledgement options, such as Ack Vector, depend on the DCCP
   Acknowledgement Number and are thus only allowed on packet types that
   carry that number.  Acknowledgement options received on other packet
   types, namely DCCP-Request and DCCP-Data, MUST be ignored.  Detailed
   acknowledgement options are not necessarily required on every packet
   that carries an Acknowledgement Number, however.

11.1.  Acks of Acks and Unidirectional Connections

   DCCP was designed to work well for both bidirectional and
   unidirectional flows of data, and for connections that transition
   between these states.  However, acknowledgements required for a
   unidirectional connection are very different from those required for
   a bidirectional connection.  In particular, unidirectional
   connections need to worry about acks of acks.

   The ack-of-acks problem arises because some acknowledgement
   mechanisms are reliable.  For example, an HC-Receiver using CCID 2,
   TCP-like Congestion Control, sends Ack Vectors containing completely
   reliable acknowledgement information.  The HC-Sender should
   occasionally inform the HC-Receiver that it has received an ack.  If
   it did not, the HC-Receiver might resend complete Ack Vector
   information, going back to the start of the connection, with every
   DCCP-Ack packet!  However, note that acks-of-acks need not be
   reliable themselves: when an ack-of-acks is lost, the HC-Receiver
   will simply maintain, and periodically retransmit, old
   acknowledgement-related state for a little longer.  Therefore, there
   is no need for acks-of-acks-of-acks.

   When communication is bidirectional, any required acks-of-acks are
   automatically contained in normal acknowledgements for data packets.
   On a unidirectional connection, however, the receiver DCCP sends no
   data, so the sender would not normally send acknowledgements.
   Therefore, the CCID in force on that half-connection must explicitly
   say whether, when, and how the HC-Sender should generate acks-of-
   acks.

   For example, consider a bidirectional connection where both half-
   connections use the same CCID (either 2 or 3), and where DCCP B goes
   ""quiescent"".  This means that the connection becomes unidirectional:



Kohler, et al.              Standards Track                    [Page 82]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   DCCP B stops sending data and sends only DCCP-Ack packets to DCCP A.
   In CCID 2, TCP-like Congestion Control, DCCP B uses Ack Vector to
   reliably communicate which packets it has received.  As described
   above, DCCP A must occasionally acknowledge a pure acknowledgement
   from DCCP B so that B can free old Ack Vector state.  For instance, A
   might send a DCCP-DataAck packet instead of DCCP-Data every now and
   then.  In CCID 3, however, acknowledgement state is generally
   bounded, so A does not need to acknowledge B's acknowledgements.

   When communication is unidirectional, a single CCID -- in the
   example, the A-to-B CCID -- controls both DCCPs' acknowledgements, in
   terms of their content, their frequency, and so forth.  For
   bidirectional connections, the A-to-B CCID governs DCCP B's
   acknowledgements (including its acks of DCCP A's acks) and the B-to-A
   CCID governs DCCP A's acknowledgements.

   DCCP A switches its ack pattern from bidirectional to unidirectional
   when it notices that DCCP B has gone quiescent.  It switches from
   unidirectional to bidirectional when it must acknowledge even a
   single DCCP-Data or DCCP-DataAck packet from DCCP B.

   Each CCID defines how to detect quiescence on that CCID, and how that
   CCID handles acks-of-acks on unidirectional connections.  The B-to-A
   CCID defines when DCCP B has gone quiescent.  Usually, this happens
   when a period has passed without B sending any data packets; in CCID
   2, for example, this period is the maximum of 0.2 seconds and two
   round-trip times.  The A-to-B CCID defines how DCCP A handles
   acks-of-acks once DCCP B has gone quiescent.

11.2.  Ack Piggybacking

   Acknowledgements of A-to-B data MAY be piggybacked on data sent by
   DCCP B, as long as that does not delay the acknowledgement longer
   than the A-to-B CCID would find acceptable.  However, data
   acknowledgements often require more than 4 bytes to express.  A large
   set of acknowledgements prepended to a large data packet might exceed
   the allowed maximum packet size.  In this case, DCCP B SHOULD send
   separate DCCP-Data and DCCP-Ack packets, or wait, but not too long,
   for a smaller datagram.

   Piggybacking is particularly common at DCCP A when the B-to-A
   half-connection is quiescent -- that is, when DCCP A is just
   acknowledging DCCP B's acknowledgements.  There are three reasons to
   acknowledge DCCP B's acknowledgements: to allow DCCP B to free up
   information about previously acknowledged data packets from A; to
   shrink the size of future acknowledgements; and to manipulate the
   rate at which future acknowledgements are sent.  Since these are




Kohler, et al.              Standards Track                    [Page 83]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   secondary concerns, DCCP A can generally afford to wait indefinitely
   for a data packet to piggyback its acknowledgement onto; if DCCP B
   wants to elicit an acknowledgement, it can send a DCCP-Sync.

   Any restrictions on ack piggybacking are described in the relevant
   CCID's profile.

11.3.  Ack Ratio Feature

   The Ack Ratio feature lets HC-Senders influence the rate at which
   HC-Receivers generate DCCP-Ack packets, thus controlling reverse-path
   congestion.  This differs from TCP, which presently has no congestion
   control for pure acknowledgement traffic.  Ack Ratio reverse-path
   congestion control does not try to be TCP friendly.  It just tries to
   avoid congestion collapse, and to be somewhat better than TCP in the
   presence of a high packet loss or mark rate on the reverse path.

   Ack Ratio applies to CCIDs whose HC-Receivers clock acknowledgements
   off the receipt of data packets.  The value of Ack Ratio/A equals the
   rough ratio of data packets sent by DCCP A to DCCP-Ack packets sent
   by DCCP B.  Higher Ack Ratios correspond to lower DCCP-Ack rates; the
   sender raises Ack Ratio when the reverse path is congested and lowers
   Ack Ratio when it is not.  Each CCID profile defines how it controls
   congestion on the acknowledgement path, and, particularly, whether
   Ack Ratio is used.  CCID 2, for example, uses Ack Ratio for
   acknowledgement congestion control, but CCID 3 does not.  However,
   each Ack Ratio feature has a value whether or not that value is used
   by the relevant CCID.

   Ack Ratio has feature number 5 and is non-negotiable.  It takes two-
   byte integer values.  An Ack Ratio/A value of four means that DCCP B
   will send at least one acknowledgement packet for every four data
   packets sent by DCCP A.  DCCP A sends a ""Change L(Ack Ratio)"" option
   to notify DCCP B of its ack ratio.  An Ack Ratio value of zero
   indicates that the relevant half-connection does not use an Ack Ratio
   to control its acknowledgement rate.  New connections start with Ack
   Ratio 2 for both endpoints; this Ack Ratio results in acknowledgement
   behavior analogous to TCP's delayed acks.

   Ack Ratio should be treated as a guideline rather than a strict
   requirement.  We intend Ack Ratio-controlled acknowledgement behavior
   to resemble TCP's acknowledgement behavior when there is no reverse-
   path congestion, and to be somewhat more conservative when there is
   reverse-path congestion.  Following this intent is more important
   than implementing Ack Ratio precisely.  In particular:






Kohler, et al.              Standards Track                    [Page 84]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   o  Receivers MAY piggyback acknowledgement information on data
      packets, creating DCCP-DataAck packets.  The Ack Ratio does not
      apply to piggybacked acknowledgements.  However, if the data
      packets are too big to carry acknowledgement information, or if
      the data sending rate is lower than Ack Ratio would suggest, then
      DCCP B SHOULD send enough pure DCCP-Ack packets to maintain the
      rate of one acknowledgement per Ack Ratio received data packets.

   o  Receivers MAY rate-pace their acknowledgements rather than send
      acknowledgements immediately upon the receipt of data packets.
      Receivers that rate-pace acknowledgements SHOULD pick a rate that
      approximates the effect of Ack Ratio and SHOULD include Elapsed
      Time options (Section 13.2) to help the sender calculate round-
      trip times.

   o  Receivers SHOULD implement delayed acknowledgement timers like
      TCP's, whereby any packet's acknowledgement is delayed by at most
      T seconds.  This delay lets the receiver collect additional
      packets to acknowledge and thus reduce the per-packet overhead of
      acknowledgements; but if T seconds have passed by and the ack is
      still around, it is sent out right away.  The default value of T
      should be 0.2 seconds, as is common in TCP implementations.  This
      may lead to sending more acknowledgement packets than Ack Ratio
      would suggest.

   o  Receivers SHOULD send acknowledgements immediately on receiving
      packets marked ECN Congestion Experienced or packets whose out-
      of-order sequence numbers potentially indicate loss.  However,
      there is no need to send such immediate acknowledgements for
      marked packets more than once per round-trip time.

   o  Receivers MAY ignore Ack Ratio if they perform their own
      congestion control on acknowledgements.  For example, a receiver
      that knows the loss and mark rate for its DCCP-Ack packets might
      maintain a TCP-friendly acknowledgement rate on its own.  Such a
      receiver MUST either ensure that it always obtains sufficient
      acknowledgement loss and mark information or fall back to Ack
      Ratio when sufficient information is not available, as might
      happen during periods when the receiver is quiescent.

11.4.  Ack Vector Options

   The Ack Vector gives a run-length encoded history of data packets
   received at the client.  Each byte of the vector gives the state of
   that data packet in the loss history, and the number of preceding
   packets with the same state.  The option's data looks like this:





Kohler, et al.              Standards Track                    [Page 85]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   +--------+--------+--------+--------+--------+--------
   |0010011?| Length |SSLLLLLL|SSLLLLLL|SSLLLLLL|  ...
   +--------+--------+--------+--------+--------+--------
   Type=38/39         \___________ Vector ___________...

   The two Ack Vector options (option types 38 and 39) differ only in
   the values they imply for ECN Nonce Echo.  Section 12.2 describes
   this further.

   The vector itself consists of a series of bytes, each of whose
   encoding is:

    0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+
   |Sta| Run Length|
   +-+-+-+-+-+-+-+-+

   Sta[te] occupies the most significant two bits of each byte and can
   have one of four values, as follows:

                    State  Meaning
                    -----  -------
                      0    Received
                      1    Received ECN Marked
                      2    Reserved
                      3    Not Yet Received

                  Table 6: DCCP Ack Vector States

   The term ""ECN marked"" refers to packets with ECN code point 11, CE
   (Congestion Experienced); packets received with this ECN code point
   MUST be reported using State 1, Received ECN Marked.  Packets
   received with ECN code points 00, 01, or 10 (Non-ECT, ECT(0), or
   ECT(1), respectively) MUST be reported using State 0, Received.

   Run Length, the least significant six bits of each byte, specifies
   how many consecutive packets have the given State.  Run Length zero
   says the corresponding State applies to one packet only; Run Length
   63 says it applies to 64 consecutive packets.  Run lengths of 65 or
   more must be encoded in multiple bytes.

   The first byte in the first Ack Vector option refers to the packet
   indicated in the Acknowledgement Number; subsequent bytes refer to
   older packets.  Ack Vector MUST NOT be sent on DCCP-Data and DCCP-
   Request packets, which lack an Acknowledgement Number, and any Ack
   Vector options encountered on such packets MUST be ignored.





Kohler, et al.              Standards Track                    [Page 86]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   An Ack Vector containing the decimal values 0,192,3,64,5 and for
   which the Acknowledgement Number is decimal 100 indicates that:

      Packet 100 was received (Acknowledgement Number 100, State 0, Run
      Length 0);

      Packet 99 was lost (State 3, Run Length 0);

      Packets 98, 97, 96 and 95 were received (State 0, Run Length 3);

      Packet 94 was ECN marked (State 1, Run Length 0); and

      Packets 93, 92, 91, 90, 89, and 88 were received (State 0, Run
      Length 5).

   A single Ack Vector option can acknowledge up to 16192 data packets.
   Should more packets need to be acknowledged than can fit in 253 bytes
   of Ack Vector, then multiple Ack Vector options can be sent; the
   second Ack Vector begins where the first left off, and so forth.

   Ack Vector states are subject to two general constraints.  (These
   principles SHOULD also be followed for other acknowledgement
   mechanisms; referring to Ack Vector states simplifies their
   explanation.)

   1. Packets reported as State 0 or State 1 MUST be acknowledgeable:
      their options have been processed by the receiving DCCP stack.
      Any data on the packet need not have been delivered to the
      receiving application; in fact, the data may have been dropped.

   2. Packets reported as State 3 MUST NOT be acknowledgeable.  Feature
      negotiations and options on such packets MUST NOT have been
      processed, and the Acknowledgement Number MUST NOT correspond to
      such a packet.

   Packets dropped in the application's receive buffer MUST be reported
   as Received or Received ECN Marked (States 0 and 1), depending on
   their ECN state; such packets' ECN Nonces MUST be included in the
   Nonce Echo.  The Data Dropped option informs the sender that some
   packets reported as received actually had their application data
   dropped.

   One or more Ack Vector options that, together, report the status of a
   packet with a sequence number less than ISN, the initial sequence
   number, SHOULD be considered invalid.  The receiving DCCP SHOULD
   either ignore the options or reset the connection with Reset Code 5,
   ""Option Error"".  No Ack Vector option can refer to a packet that has
   not yet been sent, as the Acknowledgement Number checks in Section



Kohler, et al.              Standards Track                    [Page 87]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   7.5.3 ensure, but because of attack, implementation bug, or
   misbehavior, an Ack Vector option can claim that a packet was
   received before it is actually delivered.  Section 12.2 describes how
   this is detected and how senders should react.  Packets that haven't
   been included in any Ack Vector option SHOULD be treated as ""not yet
   received"" (State 3) by the sender.

   Appendix A provides a non-normative description of the details of
   DCCP acknowledgement handling in the context of an abstract Ack
   Vector implementation.

11.4.1.  Ack Vector Consistency

   A DCCP sender will commonly receive multiple acknowledgements for
   some of its data packets.  For instance, an HC-Sender might receive
   two DCCP-Acks with Ack Vectors, both of which contained information
   about sequence number 24.  (Information about a sequence number is
   generally repeated in every ack until the HC-Sender acknowledges an
   ack.  In this case, perhaps the HC-Receiver is sending acks faster
   than the HC-Sender is acknowledging them.)  In a perfect world, the
   two Ack Vectors would always be consistent.  However, there are many
   reasons why they might not be.  For example:

   o  The HC-Receiver received packet 24 between sending its acks, so
      the first ack said 24 was not received (State 3) and the second
      said it was received or ECN marked (State 0 or 1).

   o  The HC-Receiver received packet 24 between sending its acks, and
      the network reordered the acks.  In this case, the packet will
      appear to transition from State 0 or 1 to State 3.

   o  The network duplicated packet 24, and one of the duplicates was
      ECN marked.  This might show up as a transition between States 0
      and 1.

   To cope with these situations, HC-Sender DCCP implementations SHOULD
   combine multiple received Ack Vector states according to this table:

                               Received State
                                 0   1   3
                               +---+---+---+
                             0 | 0 |0/1| 0 |
                       Old     +---+---+---+
                             1 | 1 | 1 | 1 |
                      State    +---+---+---+
                             3 | 0 | 1 | 3 |
                               +---+---+---+




Kohler, et al.              Standards Track                    [Page 88]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   To read the table, choose the row corresponding to the packet's old
   state and the column corresponding to the packet's state in the newly
   received Ack Vector; then read the packet's new state off the table.
   For an old state of 0 (received non-marked) and received state of 1
   (received ECN marked), the packet's new state may be set to either 0
   or 1.  The HC-Sender implementation will be indifferent to ack
   reordering if it chooses new state 1 for that cell.

   The HC-Receiver should collect information about received packets
   according to the following table:

                              Received Packet
                                 0   1   3
                               +---+---+---+
                             0 | 0 |0/1| 0 |
                     Stored    +---+---+---+
                             1 |0/1| 1 | 1 |
                      State    +---+---+---+
                             3 | 0 | 1 | 3 |
                               +---+---+---+

   This table equals the sender's table except that, when the stored
   state is 1 and the received state is 0, the receiver is allowed to
   switch its stored state to 0.

   An HC-Sender MAY choose to throw away old information gleaned from
   the HC-Receiver's Ack Vectors, in which case it MUST ignore newly
   received acknowledgements from the HC-Receiver for those old packets.
   It is often kinder to save recent Ack Vector information for a while
   so that the HC-Sender can undo its reaction to presumed congestion
   when a ""lost"" packet unexpectedly shows up (the transition from State
   3 to State 0).

11.4.2.  Ack Vector Coverage

   We can divide the packets that have been sent from an HC-Sender to an
   HC-Receiver into four roughly contiguous groups.  From oldest to
   youngest, these are:

   1. Packets already acknowledged by the HC-Receiver, where the
      HC-Receiver knows that the HC-Sender has definitely received the
      acknowledgements;

   2. Packets already acknowledged by the HC-Receiver, where the
      HC-Receiver cannot be sure that the HC-Sender has received the
      acknowledgements;

   3. Packets not yet acknowledged by the HC-Receiver; and



Kohler, et al.              Standards Track                    [Page 89]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   4. Packets not yet received by the HC-Receiver.

   The union of groups 2 and 3 is called the Acknowledgement Window.
   Generally, every Ack Vector generated by the HC-Receiver will cover
   the whole Acknowledgement Window: Ack Vector acknowledgements are
   cumulative.  (This simplifies Ack Vector maintenance at the
   HC-Receiver; see Appendix A, below.)  As packets are received, this
   window both grows on the right and shrinks on the left.  It grows
   because there are more packets, and shrinks because the HC-Sender's
   Acknowledgement Numbers will acknowledge previous acknowledgements,
   moving packets from group 2 into group 1.

11.5.  Send Ack Vector Feature

   The Send Ack Vector feature lets DCCPs negotiate whether they should
   use Ack Vector options to report congestion.  Ack Vector provides
   detailed loss information and lets senders report back to their
   applications whether particular packets were dropped.  Send Ack
   Vector is mandatory for some CCIDs and optional for others.

   Send Ack Vector has feature number 6 and is server-priority.  It
   takes one-byte Boolean values.  DCCP A MUST send Ack Vector options
   on its acknowledgements when Send Ack Vector/A has value one,
   although it MAY send Ack Vector options even when Send Ack Vector/A
   is zero.  Values of two or more are reserved.  New connections start
   with Send Ack Vector 0 for both endpoints.  DCCP B sends a ""Change
   R(Send Ack Vector, 1)"" option to DCCP A to ask A to send Ack Vector
   options as part of its acknowledgement traffic.

11.6.  Slow Receiver Option

   An HC-Receiver sends the Slow Receiver option to its sender to
   indicate that it is having trouble keeping up with the sender's data.
   The HC-Sender SHOULD NOT increase its sending rate for approximately
   one round-trip time after seeing a packet with a Slow Receiver
   option.  After one round-trip time, the effect of Slow Receiver
   disappears, allowing the HC-Sender to increase its rate.  Therefore,
   the HC-Receiver SHOULD continue to send Slow Receiver options if it
   needs to prevent the HC-Sender from going faster in the long term.
   The Slow Receiver option does not indicate congestion, and the HC-
   Sender need not reduce its sending rate.  (If necessary, the receiver
   can force the sender to slow down by dropping packets, with or
   without Data Dropped, or by reporting false ECN marks.)  APIs should
   let receiver applications set Slow Receiver and sending applications
   determine whether their receivers are Slow.






Kohler, et al.              Standards Track                    [Page 90]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   Slow Receiver is a one-byte option.

   +--------+
   |00000010|
   +--------+
    Type=2

   Slow Receiver does not specify why the receiver is having trouble
   keeping up with the sender.  Possible reasons include lack of buffer
   space, CPU overload, and application quotas.  A sending application
   might react to Slow Receiver by reducing its application-level
   sending rate, for example.

   The sending application should not react to Slow Receiver by sending
   more data, however.  Although the optimal response to a CPU-bound
   receiver might be to reduce compression and send more data (a
   highly-compressed data format might overwhelm a slow CPU more
   seriously than would the higher memory requirements of a less-
   compressed data format), this kind of format change should be
   requested at the application level, not via the Slow Receiver option.

   Slow Receiver implements a portion of TCP's receive window
   functionality.

11.7.  Data Dropped Option

   The Data Dropped option indicates that the application data on one or
   more received packets did not actually reach the application.  Data
   Dropped additionally reports why the data was dropped: perhaps the
   data was corrupt, or perhaps the receiver cannot keep up with the
   sender's current rate and the data was dropped in some receive
   buffer.  Using Data Dropped, DCCP endpoints can discriminate between
   different kinds of loss; this differs from TCP, in which all loss is
   reported the same way.

   Unless it is explicitly specified otherwise, DCCP congestion control
   mechanisms MUST react as if each Data Dropped packet was marked as
   ECN Congestion Experienced by the network.  We intend for Data
   Dropped to enable research into richer congestion responses to
   corrupt and other endpoint-dropped packets, but DCCP CCIDs MUST react
   conservatively to Data Dropped until this behavior is standardized.
   Section 11.7.2, below, describes congestion responses for all current
   Drop Codes.

   If a received packet's application data is dropped for one of the
   reasons listed below, this SHOULD be reported using a Data Dropped
   option.  Alternatively, the receiver MAY choose to report as




Kohler, et al.              Standards Track                    [Page 91]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   ""received"" only those packets whose data were not dropped, subject to
   the constraint that packets not reported as received MUST NOT have
   had their options processed.

   The option's data looks like this:

   +--------+--------+--------+--------+--------+--------
   |00101000| Length | Block  | Block  | Block  |  ...
   +--------+--------+--------+--------+--------+--------
    Type=40          \___________ Vector ___________ ...

   The Vector consists of a series of bytes, called Blocks, each of
   whose encoding corresponds to one of two choices:

    0 1 2 3 4 5 6 7                  0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+                +-+-+-+-+-+-+-+-+
   |0| Run Length  |       or       |1|DrpCd|Run Len|
   +-+-+-+-+-+-+-+-+                +-+-+-+-+-+-+-+-+
     Normal Block                      Drop Block

   The first byte in the first Data Dropped option refers to the packet
   indicated by the Acknowledgement Number; subsequent bytes refer to
   older packets.  Data Dropped MUST NOT be sent on DCCP-Data or DCCP-
   Request packets, which lack an Acknowledgement Number, and any Data
   Dropped options received on such packets MUST be ignored.

   Normal Blocks, which have high bit 0, indicate that any received
   packets in the Run Length had their data delivered to the
   application.  Drop Blocks, which have high bit 1, indicate that
   received packets in the Run Len[gth] were not delivered as usual.
   The 3-bit Drop Code [DrpCd] field says what happened; generally, no
   data from that packet reached the application.  Packets reported as
   ""not yet received"" MUST be included in Normal Blocks; packets not
   covered by any Data Dropped option are treated as if they were in a
   Normal Block.  Defined Drop Codes for Drop Blocks are as follows.

                  Drop Code  Meaning
                  ---------  -------
                      0      Protocol Constraints
                      1      Application Not Listening
                      2      Receive Buffer
                      3      Corrupt
                     4-6     Reserved
                      7      Delivered Corrupt

                   Table 7: DCCP Drop Codes





Kohler, et al.              Standards Track                    [Page 92]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   In more detail:

      0   The packet data was dropped due to protocol constraints.  For
          example, the data was included on a DCCP-Request packet, but
          the receiving application does not allow such piggybacking; or
          the data was included on a packet with inappropriately low
          Checksum Coverage.

      1   The packet data was dropped because the application is no
          longer listening.  See Section 11.7.2.

      2   The packet data was dropped in a receive buffer, probably
          because of receive buffer overflow.  See Section 11.7.2.

      3   The packet data was dropped due to corruption.  See Section
          9.3.

      7   The packet data was corrupted but was delivered to the
          application anyway.  See Section 9.3.

   For example, assume that a packet arrives with Acknowledgement Number
   100, an Ack Vector reporting all packets as received, and a Data
   Dropped option containing the decimal values 0,160,3,162.  Then:

      Packet 100 was received (Acknowledgement Number 100, Normal Block,
      Run Length 0).

      Packet 99 was dropped in a receive buffer (Drop Block, Drop Code
      2, Run Length 0).

      Packets 98, 97, 96, and 95 were received (Normal Block, Run Length
      3).

      Packets 95, 94, and 93 were dropped in the receive buffer (Drop
      Block, Drop Code 2, Run Length 2).

   Run lengths of more than 128 (for Normal Blocks) or 16 (for Drop
   Blocks) must be encoded in multiple Blocks.  A single Data Dropped
   option can acknowledge up to 32384 Normal Block data packets,
   although the receiver SHOULD NOT send a Data Dropped option when all
   relevant packets fit into Normal Blocks.  Should more packets need to
   be acknowledged than can fit in 253 bytes of Data Dropped, then
   multiple Data Dropped options can be sent.  The second option will
   begin where the first left off, and so forth.

   One or more Data Dropped options that, together, report the status of
   more packets than have been sent, or that change the status of a
   packet, or that disagree with Ack Vector or equivalent options (by



Kohler, et al.              Standards Track                    [Page 93]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   reporting a ""not yet received"" packet as ""dropped in the receive
   buffer"", for example) SHOULD be considered invalid.  The receiving
   DCCP SHOULD either ignore such options, or respond by resetting the
   connection with Reset Code 5, ""Option Error"".

   A DCCP application interface should let receiving applications
   specify the Drop Codes corresponding to received packets.  For
   example, this would let applications calculate their own checksums
   but still report ""dropped due to corruption"" packets via the Data
   Dropped option.  The interface SHOULD NOT let applications reduce the
   ""seriousness"" of a packet's Drop Code; for example, the application
   should not be able to upgrade a packet from delivered corrupt (Drop
   Code 7) to delivered normally (no Drop Code).

   Data Dropped information is transmitted reliably.  That is, endpoints
   SHOULD continue to transmit Data Dropped options until receiving an
   acknowledgement indicating that the relevant options have been
   processed.  In Ack Vector terms, each acknowledgement should contain
   Data Dropped options that cover the whole Acknowledgement Window
   (Section 11.4.2), although when every packet in that window would be
   placed in a Normal Block, no actual option is required.

11.7.1.  Data Dropped and Normal Congestion Response

   When deciding on a response to a particular acknowledgement or set of
   acknowledgements containing Data Dropped options, a congestion
   control mechanism MUST consider dropped packets, ECN Congestion
   Experienced marks (including marked packets that are included in Data
   Dropped), and packets singled out in Data Dropped.  For window-based
   mechanisms, the valid response space is defined as follows.

   Assume an old window of W.  Independently calculate a new window
   W_new1 that assumes no packets were Data Dropped (so W_new1 contains
   only the normal congestion response), and a new window W_new2 that
   assumes no packets were lost or marked (so W_new2 contains only the
   Data Dropped response).  We are assuming that Data Dropped
   recommended a reduction in congestion window, so W_new2 < W.

   Then the actual new window W_new MUST NOT be larger than the minimum
   of W_new1 and W_new2; and the sender MAY combine the two responses,
   by setting

         W_new = W + min(W_new1 - W, 0) + min(W_new2 - W, 0).

   The details of how this is accomplished are specified in CCID profile
   documents.  Non-window-based congestion control mechanisms MUST
   behave analogously; again, CCID profiles define how.




Kohler, et al.              Standards Track                    [Page 94]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


11.7.2.  Particular Drop Codes

   Drop Code 0, Protocol Constraints, does not indicate any kind of
   congestion, so the sender's CCID SHOULD react to packets with Drop
   Code 0 as if they were received (with or without ECN Congestion
   Experienced marks, as appropriate).  However, the sending endpoint
   SHOULD NOT send data until it believes the protocol constraint no
   longer applies.

   Drop Code 1, Application Not Listening, means the application running
   at the endpoint that sent the option is no longer listening for data.
   For example, a server might close its receiving half-connection to
   new data after receiving a complete request from the client.  This
   would limit the amount of state available at the server for incoming
   data and thus reduce the potential damage from certain denial-of-
   service attacks.  A Data Dropped option containing Drop Code 1 SHOULD
   be sent whenever received data is ignored due to a non-listening
   application.  Once an endpoint reports Drop Code 1 for a packet, it
   SHOULD report Drop Code 1 for every succeeding data packet on that
   half-connection; once an endpoint receives a Drop State 1 report, it
   SHOULD expect that no more data will ever be delivered to the other
   endpoint's application, so it SHOULD NOT send more data.

   Drop Code 2, Receive Buffer, indicates congestion inside the
   receiving host.  For instance, if a drop-from-tail kernel socket
   buffer is too full to accept a packet's application data, that packet
   should be reported as Drop Code 2.  For a drop-from-head or more
   complex socket buffer, the dropped packet should be reported as Drop
   Code 2.  DCCP implementations may also provide an API by which
   applications can mark received packets as Drop Code 2, indicating
   that the application ran out of space in its user-level receive
   buffer.  (However, it is not generally useful to report packets as
   dropped due to Drop Code 2 after more than a couple of round-trip
   times have passed.  The HC-Sender may have forgotten its
   acknowledgement state for the packet by that time, so the Data
   Dropped report will have no effect.)  Every packet newly acknowledged
   as Drop Code 2 SHOULD reduce the sender's instantaneous rate by one
   packet per round-trip time, unless the sender is already sending one
   packet per RTT or less.  Each CCID profile defines the CCID-specific
   mechanism by which this is accomplished.

   Currently, the other Drop Codes (namely Drop Code 3, Corrupt; Drop
   Code 7, Delivered Corrupt; and reserved Drop Codes 4-6) MUST cause
   the relevant CCID to behave as if the relevant packets were ECN
   marked (ECN Congestion Experienced).






Kohler, et al.              Standards Track                    [Page 95]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


12.  Explicit Congestion Notification

   The DCCP protocol is fully ECN-aware [RFC3168].  Each CCID specifies
   how its endpoints respond to ECN marks.  Furthermore, DCCP, unlike
   TCP, allows senders to control the rate at which acknowledgements are
   generated (with options like Ack Ratio); since acknowledgements are
   congestion controlled, they also qualify as ECN-Capable Transport.

   Each CCID profile describes how that CCID interacts with ECN, both
   for data traffic and pure-acknowledgement traffic.  A sender SHOULD
   set ECN-Capable Transport on its packets' IP headers unless the
   receiver's ECN Incapable feature is on or the relevant CCID disallows
   it.

   The rest of this section describes the ECN Incapable feature and the
   interaction of the ECN Nonce with acknowledgement options such as Ack
   Vector.

12.1.  ECN Incapable Feature

   DCCP endpoints are ECN-aware by default, but the ECN Incapable
   feature lets an endpoint reject the use of Explicit Congestion
   Notification.  The use of this feature is NOT RECOMMENDED.  ECN
   incapability both avoids ECN's possible benefits and prevents senders
   from using the ECN Nonce to check for receiver misbehavior.  A DCCP
   stack MAY therefore leave the ECN Incapable feature unimplemented,
   acting as if all connections were ECN capable.  Note that the
   inappropriate firewall interactions that dogged TCP's implementation
   of ECN [RFC3360] involve TCP header bits, not the IP header's ECN
   bits; we know of no middlebox that would block ECN-capable DCCP
   packets but allow ECN-incapable DCCP packets.

   ECN Incapable has feature number 4 and is server-priority.  It takes
   one-byte Boolean values.  DCCP A MUST be able to read ECN bits from
   received frames' IP headers when ECN Incapable/A is zero.  (This is
   independent of whether it can set ECN bits on sent frames.)  DCCP A
   thus sends a ""Change L(ECN Inapable, 1)"" option to DCCP B to inform
   it that A cannot read ECN bits.  If the ECN Incapable/A feature is
   one, then all of DCCP B's packets MUST be sent as ECN incapable.  New
   connections start with ECN Incapable 0 (that is, ECN capable) for
   both endpoints.  Values of two or more are reserved.

   If a DCCP is not ECN capable, it MUST send Mandatory ""Change L(ECN
   Incapable, 1)"" options to the other endpoint until acknowledged (by
   ""Confirm R(ECN Incapable, 1)"") or the connection closes.
   Furthermore, it MUST NOT accept any data until the other endpoint





Kohler, et al.              Standards Track                    [Page 96]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   sends ""Confirm R(ECN Incapable, 1)"".  It SHOULD send Data Dropped
   options on its acknowledgements, with Drop Code 0 (""protocol
   constraints""), if the other endpoint does send data inappropriately.

12.2.  ECN Nonces

   Congestion avoidance will not occur, and the receiver will sometimes
   get its data faster, if the sender isn't told about congestion
   events.  Thus, the receiver has some incentive to falsify
   acknowledgement information, reporting that marked or dropped packets
   were actually received unmarked.  This problem is more serious with
   DCCP than with TCP, since TCP provides reliable transport: it is more
   difficult with TCP to lie about lost packets without breaking the
   application.

   ECN Nonces are a general mechanism to prevent ECN cheating (or loss
   cheating).  Two values for the two-bit ECN header field indicate
   ECN-Capable Transport, 01 and 10.  The second code point, 10, is the
   ECN Nonce.  In general, a protocol sender chooses between these code
   points randomly on its output packets, remembering the sequence it
   chose.  On every acknowledgement, the protocol receiver reports the
   number of ECN Nonces it has received thus far.  This is called the
   ECN Nonce Echo.  Since ECN marking and packet dropping both destroy
   the ECN Nonce, a receiver that lies about an ECN mark or packet drop
   has a 50% chance of guessing right and avoiding discipline.  The
   sender may react punitively to an ECN Nonce mismatch, possibly up to
   dropping the connection.  The ECN Nonce Echo field need not be an
   integer; one bit is enough to catch 50% of infractions, and the
   probability of success drops exponentially as more packets are sent
   [RFC3540].

   In DCCP, the ECN Nonce Echo field is encoded in acknowledgement
   options.  For example, the Ack Vector option comes in two forms, Ack
   Vector [Nonce 0] (option 38) and Ack Vector [Nonce 1] (option 39),
   corresponding to the two values for a one-bit ECN Nonce Echo.  The
   Nonce Echo for a given Ack Vector equals the one-bit sum (exclusive-
   or, or parity) of ECN nonces for packets reported by that Ack Vector
   as received and not ECN marked.  Thus, only packets marked as State 0
   matter for this calculation (that is, valid received packets that
   were not ECN marked).  Every Ack Vector option is detailed enough for
   the sender to determine what the Nonce Echo should have been.  It can
   check this calculation against the actual Nonce Echo and complain if
   there is a mismatch.  (The Ack Vector could conceivably report every
   packet's ECN Nonce state, but this would severely limit its
   compressibility without providing much extra protection.)

   Each DCCP sender SHOULD set ECN Nonces on its packets and remember
   which packets had nonces.  When a sender detects an ECN Nonce Echo



Kohler, et al.              Standards Track                    [Page 97]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   mismatch, it behaves as described in the next section.  Each DCCP
   receiver MUST calculate and use the correct value for ECN Nonce Echo
   when sending acknowledgement options.

   ECN incapability, as indicated by the ECN Incapable feature, is
   handled as follows: an endpoint sending packets to an ECN-incapable
   receiver MUST send its packets as ECN incapable, and an ECN-
   incapable receiver MUST use the value zero for all ECN Nonce Echoes.

12.3.  Aggression Penalties

   DCCP endpoints have several mechanisms for detecting congestion-
   related misbehavior.  For example:

   o  A sender can detect an ECN Nonce Echo mismatch, indicating
      possible receiver misbehavior.

   o  A receiver can detect whether the sender is responding to
      congestion feedback or Slow Receiver.

   o  An endpoint may be able to detect that its peer is reporting
      inappropriately small Elapsed Time values (Section 13.2).

   An endpoint that detects possible congestion-related misbehavior
   SHOULD try to verify that its peer is truly misbehaving.  For
   example, a sending endpoint might send a packet whose ECN header
   field is set to Congestion Experienced, 11; a receiver that doesn't
   report a corresponding mark is most likely misbehaving.

   Upon detecting possible misbehavior, a sender SHOULD respond as if
   the receiver had reported one or more recent packets as ECN-marked
   (instead of unmarked), while a receiver SHOULD report one or more
   recent non-marked packets as ECN-marked.  Alternately, a sender might
   act as if the receiver had sent a Slow Receiver option, and a
   receiver might send Slow Receiver options.  Other reactions that
   serve to slow the transfer rate are also acceptable.  An entity that
   detects particularly egregious and ongoing misbehavior MAY also reset
   the connection with Reset Code 11, ""Aggression Penalty"".

   However, ECN Nonce mismatches and other warning signs can result from
   innocent causes, such as implementation bugs or attack.  In
   particular, a successful DCCP-Data attack (Section 7.5.5) can cause
   the receiver to report an incorrect ECN Nonce Echo.  Therefore,
   connection reset and other heavyweight mechanisms SHOULD be used only
   as last resorts, after multiple round-trip times of verified
   aggression.





Kohler, et al.              Standards Track                    [Page 98]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


13.  Timing Options

   The Timestamp, Timestamp Echo, and Elapsed Time options help DCCP
   endpoints explicitly measure round-trip times.

13.1.  Timestamp Option

   This option is permitted in any DCCP packet.  The length of the
   option is 6 bytes.

   +--------+--------+--------+--------+--------+--------+
   |00101001|00000110|          Timestamp Value          |
   +--------+--------+--------+--------+--------+--------+
    Type=41  Length=6

   The four bytes of option data carry the timestamp of this packet.
   The timestamp is a 32-bit integer that increases monotonically with
   time, at a rate of 1 unit per 10 microseconds.  At this rate,
   Timestamp Value will wrap approximately every 11.9 hours.  Endpoints
   need not measure time at this fine granularity; for example, an
   endpoint that preferred to measure time at millisecond granularity
   might send Timestamp Values that were all multiples of 100.  The
   precise time corresponding to Timestamp Value zero is not specified:
   Timestamp Values are only meaningful relative to other Timestamp
   Values sent on the same connection.  A DCCP receiving a Timestamp
   option SHOULD respond with a Timestamp Echo option on the next packet
   it sends.

13.2.  Elapsed Time Option

   This option is permitted in any DCCP packet that contains an
   Acknowledgement Number; such options received on other packet types
   MUST be ignored.  It indicates how much time has elapsed since the
   packet being acknowledged -- the packet with the given
   Acknowledgement Number -- was received.  The option may take 4 or 6
   bytes, depending on the size of the Elapsed Time value.  Elapsed Time
   helps correct round-trip time estimates when the gap between
   receiving a packet and acknowledging that packet may be long -- in
   CCID 3, for example, where acknowledgements are sent infrequently.












Kohler, et al.              Standards Track                    [Page 99]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   +--------+--------+--------+--------+
   |00101011|00000100|   Elapsed Time  |
   +--------+--------+--------+--------+
    Type=43    Len=4

   +--------+--------+--------+--------+--------+--------+
   |00101011|00000110|            Elapsed Time           |
   +--------+--------+--------+--------+--------+--------+
    Type=43    Len=6

   The option data, Elapsed Time, represents an estimated lower bound on
   the amount of time elapsed since the packet being acknowledged was
   received, with units of hundredths of milliseconds.  If Elapsed Time
   is less than a half-second, the first, smaller form of the option
   SHOULD be used.  Elapsed Times of more than 0.65535 seconds MUST be
   sent using the second form of the option.  The special Elapsed Time
   value 4294967295, which corresponds to approximately 11.9 hours, is
   used to represent any Elapsed Time greater than 42949.67294 seconds.
   DCCP endpoints MUST NOT report Elapsed Times that are significantly
   larger than the true elapsed times.  A connection MAY be reset with
   Reset Code 11, ""Aggression Penalty"", if one endpoint determines that
   the other is reporting a much-too-large Elapsed Time.

   Elapsed Time is measured in hundredths of milliseconds as a
   compromise between two conflicting goals.  First, it provides enough
   granularity to reduce rounding error when measuring elapsed time over
   fast LANs; second, it allows many reasonable elapsed times to fit
   into two bytes of data.

13.3.  Timestamp Echo Option

   This option is permitted in any DCCP packet, as long as at least one
   packet carrying the Timestamp option has been received.  Generally, a
   DCCP endpoint should send one Timestamp Echo option for each
   Timestamp option it receives, and it should send that option as soon
   as is convenient.  The length of the option is between 6 and 10
   bytes, depending on whether Elapsed Time is included and how large it
   is.













Kohler, et al.              Standards Track                   [Page 100]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   +--------+--------+--------+--------+--------+--------+
   |00101010|00000110|           Timestamp Echo          |
   +--------+--------+--------+--------+--------+--------+
    Type=42    Len=6

   +--------+--------+------- ... -------+--------+--------+
   |00101010|00001000|  Timestamp Echo   |   Elapsed Time  |
   +--------+--------+------- ... -------+--------+--------+
    Type=42    Len=8       (4 bytes)

   +--------+--------+------- ... -------+------- ... -------+
   |00101010|00001010|  Timestamp Echo   |    Elapsed Time   |
   +--------+--------+------- ... -------+------- ... -------+
    Type=42   Len=10       (4 bytes)           (4 bytes)

   The first four bytes of option data, Timestamp Echo, carry a
   Timestamp Value taken from a preceding received Timestamp option.
   Usually, this will be the last packet that was received -- the packet
   indicated by the Acknowledgement Number, if any -- but it might be a
   preceding packet.  Each Timestamp received will generally result in
   exactly one Timestamp Echo transmitted.  If an endpoint has received
   multiple Timestamp options since the last time it sent a packet, then
   it MAY ignore all Timestamp options but the one included on the
   packet with the greatest sequence number.  Alternatively, it MAY
   include multiple Timestamp Echo options in its response, each
   corresponding to a different Timestamp option.

   The Elapsed Time value, similar to that in the Elapsed Time option,
   indicates the amount of time elapsed since receiving the packet whose
   timestamp is being echoed.  This time MUST have units of hundredths
   of milliseconds.  Elapsed Time is meant to help the Timestamp sender
   separate the network round-trip time from the Timestamp receiver's
   processing time.  This may be particularly important for CCIDs where
   acknowledgements are sent infrequently, so that there might be
   considerable delay between receiving a Timestamp option and sending
   the corresponding Timestamp Echo.  A missing Elapsed Time field is
   equivalent to an Elapsed Time of zero.  The smallest version of the
   option SHOULD be used that can hold the relevant Elapsed Time value.

14.  Maximum Packet Size

   A DCCP implementation MUST maintain the maximum packet size (MPS)
   allowed for each active DCCP session.  The MPS is influenced by the
   maximum packet size allowed by the current congestion control
   mechanism (CCMPS), the maximum packet size supported by the path's
   links (PMTU, the Path Maximum Transmission Unit) [RFC1191], and the
   lengths of the IP and DCCP headers.




Kohler, et al.              Standards Track                   [Page 101]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   A DCCP application interface SHOULD let the application discover
   DCCP's current MPS.  Generally, the DCCP implementation will refuse
   to send any packet bigger than the MPS, returning an appropriate
   error to the application.  A DCCP interface MAY allow applications to
   request fragmentation for packets larger than PMTU, but not larger
   than CCMPS.  (Packets larger than CCMPS MUST be rejected in any
   case.)  Fragmentation SHOULD NOT be the default, since it decreases
   robustness: an entire packet is discarded if even one of its
   fragments is lost.  Applications can usually get better error
   tolerance by producing packets smaller than the PMTU.

   The MPS reported to the application SHOULD be influenced by the size
   expected to be required for DCCP headers and options.  If the
   application provides data that, when combined with the options the
   DCCP implementation would like to include, would exceed the MPS, the
   implementation should either send the options on a separate packet
   (such as a DCCP-Ack) or lower the MPS, drop the data, and return an
   appropriate error to the application.

14.1.  Measuring PMTU

   Each DCCP endpoint MUST keep track of the current PMTU for each
   connection, except that this is not required for IPv4 connections
   whose applications have requested fragmentation.  The PMTU SHOULD be
   initialized from the interface MTU that will be used to send packets.
   The MPS will be initialized with the minimum of the PMTU and the
   CCMPS, if any.

   Classical PMTU discovery uses unfragmentable packets.  In IPv4, these
   packets have the IP Don't Fragment (DF) bit set; in IPv6, all packets
   are unfragmentable once emitted by an end host.  As specified in
   [RFC1191], when a router receives a packet with DF set that is larger
   than the next link's MTU, it sends an ICMP Destination Unreachable
   message back to the source whose Code indicates that an
   unfragmentable packet was too large to forward (a ""Datagram Too Big""
   message).  When a DCCP implementation receives a Datagram Too Big
   message, it decreases its PMTU to the Next-Hop MTU value given in the
   ICMP message.  If the MTU given in the message is zero, the sender
   chooses a value for PMTU using the algorithm described in [RFC1191],
   Section 7.  If the MTU given in the message is greater than the
   current PMTU, the Datagram Too Big message is ignored, as described
   in [RFC1191].  (We are aware that this may cause problems for DCCP
   endpoints behind certain firewalls.)

   A DCCP implementation may allow the application occasionally to
   request that PMTU discovery be performed again.  This will reset the
   PMTU to the outgoing interface's MTU.  Such requests SHOULD be rate
   limited, to one per two seconds, for example.



Kohler, et al.              Standards Track                   [Page 102]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   A DCCP sender MAY treat the reception of an ICMP Datagram Too Big
   message as an indication that the packet being reported was not lost
   due to congestion, and so for the purposes of congestion control it
   MAY ignore the DCCP receiver's indication that this packet did not
   arrive.  However, if this is done, then the DCCP sender MUST check
   the ECN bits of the IP header echoed in the ICMP message and only
   perform this optimization if these ECN bits indicate that the packet
   did not experience congestion prior to reaching the router whose link
   MTU it exceeded.

   A DCCP implementation SHOULD ensure, as far as possible, that ICMP
   Datagram Too Big messages were actually generated by routers, so that
   attackers cannot drive the PMTU down to a falsely small value.  The
   simplest way to do this is to verify that the Sequence Number on the
   ICMP error's encapsulated header corresponds to a Sequence Number
   that the implementation recently sent.  (According to current
   specifications, routers should return the full DCCP header and
   payload up to a maximum of 576 bytes [RFC1812] or the minimum IPv6
   MTU [RFC2463], although they are not required to return more than 64
   bits [RFC792].  Any amount greater than 128 bits will include the
   Sequence Number.)  ICMP Datagram Too Big messages with incorrect or
   missing Sequence Numbers may be ignored, or the DCCP implementation
   may lower the PMTU only temporarily in response.  If more than three
   odd Datagram Too Big messages are received and the other DCCP
   endpoint reports more than three lost packets, however, the DCCP
   implementation SHOULD assume the presence of a confused router and
   either obey the ICMP messages' PMTU or (on IPv4 networks) switch to
   allowing fragmentation.

   DCCP also allows upward probing of the PMTU [PMTUD], where the DCCP
   endpoint begins by sending small packets with DF set and then
   gradually increases the packet size until a packet is lost.  This
   mechanism does not require any ICMP error processing.  DCCP-Sync
   packets are the best choice for upward probing, since DCCP-Sync
   probes do not risk application data loss.  The DCCP implementation
   inserts arbitrary data into the DCCP-Sync application area, padding
   the packet to the right length.  Since every valid DCCP-Sync
   generates an immediate DCCP-SyncAck in response, the endpoint will
   have a pretty good idea of when a probe is lost.

14.2.  Sender Behavior

   A DCCP sender SHOULD send every packet as unfragmentable, as
   described above, with the following exceptions.

   o  On IPv4 connections whose applications have requested
      fragmentation, the sender SHOULD send packets with the DF bit not
      set.



Kohler, et al.              Standards Track                   [Page 103]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   o  On IPv6 connections whose applications have requested
      fragmentation, the sender SHOULD use fragmentation extension
      headers to fragment packets larger than PMTU into suitably-sized
      chunks.  (Those chunks are, of course, unfragmentable.)

   o  It is undesirable for PMTU discovery to occur on the initial
      connection setup handshake, as the connection setup process may
      not be representative of packet sizes used during the connection,
      and performing MTU discovery on the initial handshake might
      unnecessarily delay connection establishment.  Thus, DCCP-Request
      and DCCP-Response packets SHOULD be sent as fragmentable.  In
      addition, DCCP-Reset packets SHOULD be sent as fragmentable,
      although typically these would be small enough to not be a
      problem.  For IPv4 connections, these packets SHOULD be sent with
      the DF bit not set; for IPv6 connections, they SHOULD be
      preemptively fragmented to a size not larger than the relevant
      interface MTU.

   If the DCCP implementation has decreased the PMTU, the sending
   application has not requested fragmentation, and the sending
   application attempts to send a packet larger than the new MPS, the
   API MUST refuse to send the packet and return an appropriate error to
   the application.  The application should then use the API to query
   the new value of MPS.  The kernel might have some packets buffered
   for transmission that are smaller than the old MPS but larger than
   the new MPS.  It MAY send these packets as fragmentable, or it MAY
   discard these packets; it MUST NOT send them as unfragmentable.

15.  Forward Compatibility

   Future versions of DCCP may add new options and features.  A few
   simple guidelines will let extended DCCPs interoperate with normal
   DCCPs.

   o  DCCP processors MUST NOT act punitively towards options and
      features they do not understand.  For example, DCCP processors
      MUST NOT reset the connection if some field marked Reserved in
      this specification is non-zero; if some unknown option is present;
      or if some feature negotiation option mentions an unknown feature.
      Instead, DCCP processors MUST ignore these events.  The Mandatory
      option is the single exception: if Mandatory precedes some unknown
      option or feature, the connection MUST be reset.

   o  DCCP processors MUST anticipate the possibility of unknown feature
      values, which might occur as part of a negotiation for a known
      feature.  For server-priority features, unknown values are handled
      as a matter of course: since the non-extended DCCP's priority list
      will not contain unknown values, the result of the negotiation



Kohler, et al.              Standards Track                   [Page 104]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


      cannot be an unknown value.  A DCCP MUST respond with an empty
      Confirm option if it is assigned an unacceptable value for some
      non-negotiable feature.

   o  Each DCCP extension SHOULD be controlled by some feature.  The
      default value of this feature SHOULD correspond to ""extension not
      available"".  If an extended DCCP wants to use the extension, it
      SHOULD attempt to change the feature's value using a Change L or
      Change R option.  Any non-extended DCCP will ignore the option,
      thus leaving the feature value at its default, ""extension not
      available"".

   Section 19 lists DCCP assigned numbers reserved for experimental and
   testing purposes.

16.  Middlebox Considerations

   This section describes properties of DCCP that firewalls, network
   address translators, and other middleboxes should consider, including
   parts of the packet that middleboxes should not change.  The intent
   is to draw attention to aspects of DCCP that may be useful, or
   dangerous, for middleboxes, or that differ significantly from TCP.

   The Service Code field in DCCP-Request packets provides information
   that may be useful for stateful middleboxes.  With Service Code, a
   middlebox can tell what protocol a connection will use without
   relying on port numbers.  Middleboxes can disallow connections that
   attempt to access unexpected services by sending a DCCP-Reset with
   Reset Code 8, ""Bad Service Code"".  Middleboxes should not modify the
   Service Code unless they are really changing the service a connection
   is accessing.

   The Source and Destination Port fields are in the same packet
   locations as the corresponding fields in TCP and UDP, which may
   simplify some middlebox implementations.

   The forward compatibility considerations in Section 15 apply to
   middleboxes as well.  In particular, middleboxes generally shouldn't
   act punitively towards options and features they do not understand.

   Modifying DCCP Sequence Numbers and Acknowledgement Numbers is more
   tedious and dangerous than modifying TCP sequence numbers.  A
   middlebox that added packets to or removed packets from a DCCP
   connection would have to modify acknowledgement options, such as Ack
   Vector, and CCID-specific options, such as TFRC's Loss Intervals, at
   minimum.  On ECN-capable connections, the middlebox would have to
   keep track of ECN Nonce information for packets it introduced or
   removed, so that the relevant acknowledgement options continued to



Kohler, et al.              Standards Track                   [Page 105]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   have correct ECN Nonce Echoes, or risk the connection being reset for
   ""Aggression Penalty"".  We therefore recommend that middleboxes not
   modify packet streams by adding or removing packets.

   Note that there is less need to modify DCCP's per-packet sequence
   numbers than to modify TCP's per-byte sequence numbers; for example,
   a middlebox can change the contents of a packet without changing its
   sequence number.  (In TCP, sequence number modification is required
   to support protocols like FTP that carry variable-length addresses in
   the data stream.  If such an application were deployed over DCCP,
   middleboxes would simply grow or shrink the relevant packets as
   necessary without changing their sequence numbers.  This might
   involve fragmenting the packet.)

   Middleboxes may, of course, reset connections in progress.  Clearly,
   this requires inserting a packet into one or both packet streams, but
   the difficult issues do not arise.

   DCCP is somewhat unfriendly to ""connection splicing"" [SHHP00], in
   which clients' connection attempts are intercepted, but possibly
   later ""spliced in"" to external server connections via sequence number
   manipulations.  A connection splicer at minimum would have to ensure
   that the spliced connections agreed on all relevant feature values,
   which might take some renegotiation.

   The contents of this section should not be interpreted as a wholesale
   endorsement of stateful middleboxes.

17.  Relations to Other Specifications

17.1.  RTP

   The Real-Time Transport Protocol, RTP [RFC3550], is currently used
   over UDP by many of DCCP's target applications (for instance,
   streaming media).  Therefore, it is important to examine the
   relationship between DCCP and RTP and, in particular, the question of
   whether any changes in RTP are necessary or desirable when it is
   layered over DCCP instead of UDP.

   There are two potential sources of overhead in the RTP-over-DCCP
   combination: duplicated acknowledgement information and duplicated
   sequence numbers.  Together, these sources of overhead add slightly
   more than 4 bytes per packet relative to RTP-over-UDP, and
   eliminating the redundancy would not reduce the overhead.

   First, consider acknowledgements.  Both RTP and DCCP report feedback
   about loss rates to data senders, via RTP Control Protocol Sender and
   Receiver Reports (RTCP SR/RR packets) and via DCCP acknowledgement



Kohler, et al.              Standards Track                   [Page 106]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   options.  These feedback mechanisms are potentially redundant.
   However, RTCP SR/RR packets contain information not present in DCCP
   acknowledgements, such as ""interarrival jitter"", and DCCP's
   acknowledgements contain information not transmitted by RTCP, such as
   the ECN Nonce Echo.  Neither feedback mechanism makes the other
   redundant.

   Sending both types of feedback need not be particularly costly
   either.  RTCP reports may be sent relatively infrequently: once every
   5 seconds on average, for low-bandwidth flows.  In DCCP, some
   feedback mechanisms are expensive -- Ack Vector, for example, is
   frequent and verbose -- but others are relatively cheap: CCID 3
   (TFRC) acknowledgements take between 16 and 32 bytes of options sent
   once per round-trip time.  (Reporting less frequently than once per
   RTT would make congestion control less responsive to loss.)  We
   therefore conclude that acknowledgement overhead in RTP-over-DCCP
   need not be significantly higher than for RTP-over-UDP, at least for
   CCID 3.

   One clear redundancy can be addressed at the application level.  The
   verbose packet-by-packet loss reports sent in RTCP Extended Reports
   Loss RLE Blocks [RFC3611] can be derived from DCCP's Ack Vector
   options.  (The converse is not true, since Loss RLE Blocks contain no
   ECN information.)  Since DCCP implementations should provide an API
   for application access to Ack Vector information, RTP-over-DCCP
   applications might request either DCCP Ack Vectors or RTCP Extended
   Report Loss RLE Blocks, but not both.

   Now consider sequence number redundancy on data packets.  The
   embedded RTP header contains a 16-bit RTP sequence number.  Most data
   packets will use the DCCP-Data type; DCCP-DataAck and DCCP-Ack
   packets need not usually be sent.  The DCCP-Data header is 12 bytes
   long without options, including a 24-bit sequence number.  This is 4
   bytes more than a UDP header.  Any options required on data packets
   would add further overhead, although many CCIDs (for instance, CCID
   3, TFRC) don't require options on most data packets.

   The DCCP sequence number cannot be inferred from the RTP sequence
   number since it increments on non-data packets as well as data
   packets.  The RTP sequence number cannot be inferred from the DCCP
   sequence number either [RFC3550].  Furthermore, removing RTP's
   sequence number would not save any header space because of alignment
   issues.  We therefore recommend that RTP transmitted over DCCP use
   the same headers currently defined.  The 4 byte header cost is a
   reasonable tradeoff for DCCP's congestion control features and access
   to ECN.  Truly bandwidth-starved endpoints should use some header
   compression scheme.




Kohler, et al.              Standards Track                   [Page 107]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


17.2.  Congestion Manager and Multiplexing

   Since DCCP doesn't provide reliable, ordered delivery, multiple
   application sub-flows may be multiplexed over a single DCCP
   connection with no inherent performance penalty.  Thus, there is no
   need for DCCP to provide built-in support for multiple sub-flows.
   This differs from SCTP [RFC2960].

   Some applications might want to share congestion control state among
   multiple DCCP flows that share the same source and destination
   addresses.  This functionality could be provided by the Congestion
   Manager [RFC3124], a generic multiplexing facility.  However, the CM
   would not fully support DCCP without change; it does not gracefully
   handle multiple congestion control mechanisms, for example.

18.  Security Considerations

   DCCP does not provide cryptographic security guarantees.
   Applications desiring cryptographic security services (integrity,
   authentication, confidentiality, access control, and anti-replay
   protection) should use IPsec or end-to-end security of some kind;
   Secure RTP is one candidate protocol [RFC3711].

   Nevertheless, DCCP is intended to protect against some classes of
   attackers: Attackers cannot hijack a DCCP connection (close the
   connection unexpectedly, or cause attacker data to be accepted by an
   endpoint as if it came from the sender) unless they can guess valid
   sequence numbers.  Thus, as long as endpoints choose initial sequence
   numbers well, a DCCP attacker must snoop on data packets to get any
   reasonable probability of success.  Sequence number validity checks
   provide this guarantee.  Section 7.5.5 describes sequence number
   security further.  This security property only holds assuming that
   DCCP's random numbers are chosen according to the guidelines in
   [RFC4086].

   DCCP also provides mechanisms to limit the potential impact of some
   denial-of-service attacks.  These mechanisms include Init Cookie
   (Section 8.1.4), the DCCP-CloseReq packet (Section 5.5), the
   Application Not Listening Drop Code (Section 11.7.2), limitations on
   the processing of options that might cause connection reset (Section
   7.5.5), limitations on the processing of some ICMP messages (Section
   14.1), and various rate limits, which let servers avoid extensive
   computation or packet generation (Sections 7.5.3, 8.1.3, and others).

   DCCP provides no protection against attackers that can snoop on data
   packets.





Kohler, et al.              Standards Track                   [Page 108]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


18.1.  Security Considerations for Partial Checksums

   The partial checksum facility has a separate security impact,
   particularly in its interaction with authentication and encryption
   mechanisms.  The impact is the same in DCCP as in the UDP-Lite
   protocol, and what follows was adapted from the corresponding text in
   the UDP-Lite specification [RFC3828].

   When a DCCP packet's Checksum Coverage field is not zero, the
   uncovered portion of a packet may change in transit.  This is
   contrary to the idea behind most authentication mechanisms:
   authentication succeeds if the packet has not changed in transit.
   Unless authentication mechanisms that operate only on the sensitive
   part of packets are developed and used, authentication will always
   fail for partially-checksummed DCCP packets whose uncovered part has
   been damaged.

   The IPsec integrity check (Encapsulation Security Protocol, ESP, or
   Authentication Header, AH) is applied (at least) to the entire IP
   packet payload.  Corruption of any bit within that area will then
   result in the IP receiver's discarding a DCCP packet, even if the
   corruption happened in an uncovered part of the DCCP application
   data.

   When IPsec is used with ESP payload encryption, a link can not
   determine the specific transport protocol of a packet being forwarded
   by inspecting the IP packet payload.  In this case, the link MUST
   provide a standard integrity check covering the entire IP packet and
   payload.  DCCP partial checksums provide no benefit in this case.

   Encryption (e.g., at the transport or application levels) may be
   used.  Note that omitting an integrity check can, under certain
   circumstances, compromise confidentiality [B98].

   If a few bits of an encrypted packet are damaged, the decryption
   transform will typically spread errors so that the packet becomes too
   damaged to be of use.  Many encryption transforms today exhibit this
   behavior.  There exist encryption transforms, stream ciphers, that do
   not cause error propagation.  Proper use of stream ciphers can be
   quite difficult, especially when authentication checking is omitted
   [BB01].  In particular, an attacker can cause predictable changes to
   the ultimate plaintext, even without being able to decrypt the
   ciphertext.








Kohler, et al.              Standards Track                   [Page 109]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


19.  IANA Considerations

   IANA has assigned IP Protocol Number 33 to DCCP.

   DCCP introduces eight sets of numbers whose values should be
   allocated by IANA.  We refer to allocation policies, such as
   Standards Action, outlined in [RFC2434], and most registries reserve
   some values for experimental and testing use [RFC3692].  In addition,
   DCCP requires that the IANA Port Numbers registry be opened for DCCP
   port registrations; Section 19.9 describes how.  The IANA should feel
   free to contact the DCCP Expert Reviewer with questions on any
   registry, regardless of the registry policy, for clarification or if
   there is a problem with a request.

19.1.  Packet Types Registry

   Each entry in the DCCP Packet Types registry contains a packet type,
   which is a number in the range 0-15; a packet type name, such as
   DCCP-Request; and a reference to the RFC defining the packet type.
   The registry is initially populated using the values in Table 1
   (Section 5.1).  This document allocates packet types 0-9, and packet
   type 14 is permanently reserved for experimental and testing use.
   Packet types 10-13 and 15 are currently reserved and should be
   allocated with the Standards Action policy, which requires IESG
   review and approval and standards-track IETF RFC publication.

19.2.  Reset Codes Registry

   Each entry in the DCCP Reset Codes registry contains a Reset Code,
   which is a number in the range 0-255; a short description of the
   Reset Code, such as ""No Connection""; and a reference to the RFC
   defining the Reset Code.  The registry is initially populated using
   the values in Table 2 (Section 5.6).  This document allocates Reset
   Codes 0-11, and Reset Codes 120-126 are permanently reserved for
   experimental and testing use.  Reset Codes 12-119 and 127 are
   currently reserved and should be allocated with the IETF Consensus
   policy, requiring an IETF RFC publication (standards track or not)
   with IESG review and approval.  Reset Codes 128-255 are permanently
   reserved for CCID-specific registries; each CCID Profile document
   describes how the corresponding registry is managed.

19.3.  Option Types Registry

   Each entry in the DCCP option types registry contains an option type,
   which is a number in the range 0-255; the name of the option, such as
   ""Slow Receiver""; and a reference to the RFC defining the option type.
   The registry is initially populated using the values in Table 3
   (Section 5.8).  This document allocates option types 0-2 and 32-44,



Kohler, et al.              Standards Track                   [Page 110]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   and option types 31 and 120-126 are permanently reserved for
   experimental and testing use.  Option types 3-30, 45-119, and 127 are
   currently reserved and should be allocated with the IETF Consensus
   policy, requiring an IETF RFC publication (standards track or not)
   with IESG review and approval.  Option types 128-255 are permanently
   reserved for CCID-specific registries; each CCID Profile document
   describes how the corresponding registry is managed.

19.4.  Feature Numbers Registry

   Each entry in the DCCP feature numbers registry contains a feature
   number, which is a number in the range 0-255; the name of the
   feature, such as ""ECN Incapable""; and a reference to the RFC defining
   the feature number.  The registry is initially populated using the
   values in Table 4 (Section 6).  This document allocates feature
   numbers 0-9, and feature numbers 120-126 are permanently reserved for
   experimental and testing use.  Feature numbers 10-119 and 127 are
   currently reserved and should be allocated with the IETF Consensus
   policy, requiring an IETF RFC publication (standards track or not)
   with IESG review and approval.  Feature numbers 128-255 are
   permanently reserved for CCID-specific registries; each CCID Profile
   document describes how the corresponding registry is managed.

19.5.  Congestion Control Identifiers Registry

   Each entry in the DCCP Congestion Control Identifiers (CCIDs)
   registry contains a CCID, which is a number in the range 0-255; the
   name of the CCID, such as ""TCP-like Congestion Control""; and a
   reference to the RFC defining the CCID.  The registry is initially
   populated using the values in Table 5 (Section 10).  CCIDs 2 and 3
   are allocated by concurrently published profiles, and CCIDs 248-254
   are permanently reserved for experimental and testing use.  CCIDs 0,
   1, 4-247, and 255 are currently reserved and should be allocated with
   the IETF Consensus policy, requiring an IETF RFC publication
   (standards track or not) with IESG review and approval.

19.6.  Ack Vector States Registry

   Each entry in the DCCP Ack Vector States registry contains an Ack
   Vector State, which is a number in the range 0-3; the name of the
   State, such as ""Received ECN Marked""; and a reference to the RFC
   defining the State.  The registry is initially populated using the
   values in Table 6 (Section 11.4).  This document allocates States 0,
   1, and 3.  State 2 is currently reserved and should be allocated with
   the Standards Action policy, which requires IESG review and approval
   and standards-track IETF RFC publication.





Kohler, et al.              Standards Track                   [Page 111]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


19.7.  Drop Codes Registry

   Each entry in the DCCP Drop Codes registry contains a Data Dropped
   Drop Code, which is a number in the range 0-7; the name of the Drop
   Code, such as ""Application Not Listening""; and a reference to the RFC
   defining the Drop Code.  The registry is initially populated using
   the values in Table 7 (Section 11.7).  This document allocates Drop
   Codes 0-3 and 7.  Drop Codes 4-6 are currently reserved, and should
   be allocated with the Standards Action policy, which requires IESG
   review and approval and standards-track IETF RFC publication.

19.8.  Service Codes Registry

   Each entry in the Service Codes registry contains a Service Code,
   which is a number in the range 0-4294967294; a short English
   description of the intended service; and an optional reference to an
   RFC or other publicly available specification defining the Service
   Code.  The registry should list the Service Code's numeric value as a
   decimal number.  When the Service Code may be represented in ""SC:""
   format according to the rules in Section 8.1.2, the registry should
   also show the corresponding ASCII interpretation of the Service Code
   minus the ""SC:"" prefix.  Thus, the number 1717858426 would
   additionally appear as ""fdpz"".  Service Codes are not DCCP-specific.
   Service Code 0 is permanently reserved (it represents the absence of
   a meaningful Service Code), and Service Codes 1056964608-1073741823
   (high byte ASCII ""?"") are reserved for Private Use.  Note that
   4294967295 is not a valid Service Code.  Most of the remaining
   Service Codes are allocated First Come First Served, with no RFC
   publication required; exceptions are listed in Section 8.1.2.  This
   document allocates a single Service Code, 1145656131 (""DISC"").  This
   corresponds to the discard service, which discards all data sent to
   the service and sends no data in reply.

19.9.  Port Numbers Registry

   DCCP services may use contact port numbers to provide service to
   unknown callers, as in TCP and UDP.  IANA is therefore requested to
   open the existing Port Numbers registry for DCCP using the following
   rules, which we intend to mesh well with existing Port Numbers
   registration procedures.

   Port numbers are divided into three ranges.  The Well Known Ports are
   those from 0 through 1023, the Registered Ports are those from 1024
   through 49151, and the Dynamic and/or Private Ports are those from
   49152 through 65535.  Well Known and Registered Ports are intended
   for use by server applications that desire a default contact point on
   a system.  On most systems, Well Known Ports can only be used by
   system (or root) processes or by programs executed by privileged



Kohler, et al.              Standards Track                   [Page 112]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   users, while Registered Ports can be used by ordinary user processes
   or programs executed by ordinary users.  Dynamic and/or Private Ports
   are intended for temporary use, including client-side ports, out-of-
   band negotiated ports, and application testing prior to registration
   of a dedicated port; they MUST NOT be registered.

   The Port Numbers registry should accept registrations for DCCP ports
   in the Well Known Ports and Registered Ports ranges.  Well Known and
   Registered Ports SHOULD NOT be used without registration.  Although
   in some cases -- such as porting an application from UDP to DCCP --
   it may seem natural to use a DCCP port before registration completes,
   we emphasize that IANA will not guarantee registration of particular
   Well Known and Registered Ports.  Registrations should be requested
   as early as possible.

   Each port registration SHALL include the following information:

   o  A short port name, consisting entirely of letters (A-Z and a-z),
      digits (0-9), and punctuation characters from ""-_+./*"" (not
      including the quotes).

   o  The port number that is requested to be registered.

   o  A short English phrase describing the port's purpose.  This MUST
      include one or more space-separated textual Service Code
      descriptors naming the port's corresponding Service Codes (see
      Section 8.1.2).

   o  Name and contact information for the person or entity performing
      the registration, and possibly a reference to a document defining
      the port's use.  Registrations coming from IETF working groups
      need only name the working group, but indicating a contact person
      is recommended.

   Registrants are encouraged to follow these guidelines when submitting
   a registration.

   o  A port name SHOULD NOT be registered for more than one DCCP port
      number.

   o  A port name registered for UDP MAY be registered for DCCP as well.
      Any such registration SHOULD use the same port number as the
      existing UDP registration.

   o  Concrete intent to use a port SHOULD precede port registration.
      For example, existing UDP ports SHOULD NOT be registered in
      advance of any intent to use those ports for DCCP.




Kohler, et al.              Standards Track                   [Page 113]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   o  A port name generally associated with TCP and/or SCTP SHOULD NOT
      be registered for DCCP, since that port name implies reliable
      transport.  For example, we discourage registration of any ""http""
      port for DCCP.  However, if such a registration makes sense (that
      is, if there is concrete intent to use such a port), the DCCP
      registration SHOULD use the same port number as the existing
      registration.

   o  Multiple DCCP registrations for the same port number are allowed
      as long as the registrations' Service Codes do not overlap.

   This document registers the following port.  (This should be
   considered a model registration.)

   discard    9/dccp    Discard SC:DISC
   # IETF dccp WG, Eddie Kohler <kohler@cs.ucla.edu>, [RFC4340]

   The discard service, which accepts DCCP connections on port 9,
   discards all incoming application data and sends no data in response.
   Thus, DCCP's discard port is analogous to TCP's discard port, and
   might be used to check the health of a DCCP stack.

20.  Thanks

   Thanks to Jitendra Padhye for his help with early versions of this
   specification.

   Thanks to Junwen Lai and Arun Venkataramani, who, as interns at ICIR,
   built a prototype DCCP implementation.  In particular, Junwen Lai
   recommended that the old feature negotiation mechanism be scrapped
   and co-designed the current mechanism.  Arun Venkataramani's feedback
   improved Appendix A.

   We thank the staff and interns of ICIR and, formerly, ACIRI, the
   members of the End-to-End Research Group, and the members of the
   Transport Area Working Group for their feedback on DCCP.  We
   especially thank the DCCP expert reviewers Greg Minshall, Eric
   Rescorla, and Magnus Westerlund for detailed written comments and
   problem spotting, and Rob Austein and Steve Bellovin for verbal
   comments and written notes.  We also especially thank Aaron Falk, the
   working group chair during the development of this specification.

   We also thank those who provided comments and suggestions via the
   DCCP BOF, Working Group, and mailing lists, including Damon Lanphear,
   Patrick McManus, Colin Perkins, Sara Karlberg, Kevin Lai, Bernard
   Aboba, Youngsoo Choi, Pengfei Di, Dan Duchamp, Lars Eggert, Gorry
   Fairhurst, Derek Fawcus, David Timothy Fleeman, John Loughney,
   Ghyslain Pelletier, Hagen Paul Pfeifer, Tom Phelan, Stanislav



Kohler, et al.              Standards Track                   [Page 114]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   Shalunov, Somsak Vanit-Anunchai, David Vos, Yufei Wang, and Michael
   Welzl.  In particular, Colin Perkins provided extensive, detailed
   feedback, Michael Welzl suggested the Data Checksum option, Gorry
   Fairhurst provided extensive feedback on various checksum issues, and
   Somsak Vanit-Anunchai, Jonathan Billington, and Tul Kongprakaiwoot's
   Colored Petri Net model [VBK05] discovered several problems with
   message exchange.












































Kohler, et al.              Standards Track                   [Page 115]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


A.  Appendix: Ack Vector Implementation Notes

   This appendix discusses particulars of DCCP acknowledgement handling
   in the context of an abstract implementation for Ack Vector.  It is
   informative and not normative.

   The first part of our implementation runs at the HC-Receiver, and
   therefore acknowledges data packets.  It generates Ack Vector
   options.  The implementation has the following characteristics:

   o  At most one byte of state per acknowledged packet.

   o  O(1) time to update that state when a new packet arrives (normal
      case).

   o  Cumulative acknowledgements.

   o  Quick removal of old state.

   The basic data structure is a circular buffer containing information
   about acknowledged packets.  Each byte in this buffer contains a
   state and run length; the state can be 0 (packet received), 1 (packet
   ECN marked), or 3 (packet not yet received).  The buffer grows from
   right to left.  The implementation maintains five variables, aside
   from the buffer contents:

   o  ""buf_head"" and ""buf_tail"", which mark the live portion of the
      buffer.

   o  ""buf_ackno"", the Acknowledgement Number of the most recent packet
      acknowledged in the buffer.  This corresponds to the ""head""
      pointer.

   o  ""buf_nonce"", the one-bit sum (exclusive-or, or parity) of the ECN
      Nonces received on all packets acknowledged by the buffer with
      State 0.

   We draw acknowledgement buffers like this:

      +---------------------------------------------------------------+
      |S,L|S,L|S,L|S,L|   |   |   |   |S,L|S,L|S,L|S,L|S,L|S,L|S,L|S,L|
      +---------------------------------------------------------------+
                    ^                   ^
                 buf_tail     buf_head, buf_ackno = A     buf_nonce = E

                <=== buf_head and buf_tail move this way <===





Kohler, et al.              Standards Track                   [Page 116]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   Each ""S,L"" represents a State/Run length byte.  We will draw these
   buffers showing only their live portion and will add an annotation
   showing the Acknowledgement Number for the last live byte in the
   buffer.  For example:

        +-----------------------------------------------+
      A |S,L|S,L|S,L|S,L|S,L|S,L|S,L|S,L|S,L|S,L|S,L|S,L| T    BN[E]
        +-----------------------------------------------+

   Here, buf_nonce equals E and buf_ackno equals A.

   We will use this buffer as a running example.

         +---------------------------+
      10 |0,0|3,0|3,0|3,0|0,4|1,0|0,0| 0    BN[1]   [Example Buffer]
         +---------------------------+

   In concrete terms, its meaning is as follows:

      Packet 10 was received.  (The head of the buffer has sequence
      number 10, state 0, and run length 0.)

      Packets 9, 8, and 7 have not yet been received.  (The three bytes
      preceding the head each have state 3 and run length 0.)

      Packets 6, 5, 4, 3, and 2 were received.

      Packet 1 was ECN marked.

      Packet 0 was received.

      The one-bit sum of the ECN Nonces on packets 10, 6, 5, 4, 3, 2,
      and 0 equals 1.

   Additionally, the HC-Receiver must keep some information about the
   Ack Vectors it has recently sent.  For each packet sent carrying an
   Ack Vector, it remembers four variables:

   o  ""ack_seqno"", the Sequence Number used for the packet.  This is an
      HC-Receiver sequence number.

   o  ""ack_ptr"", the value of buf_head at the time of acknowledgement.

   o  ""ack_runlen"", the run length stored in the byte of buffer data at
      buf_head at the time of acknowledgement.






Kohler, et al.              Standards Track                   [Page 117]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   o  ""ack_ackno"", the Acknowledgement Number used for the packet.  This
      is an HC-Sender sequence number.  Since acknowledgements are
      cumulative, this single number completely specifies all necessary
      information about the packets acknowledged by this Ack Vector.

   o  ""ack_nonce"", the one-bit sum of the ECN Nonces for all State 0
      packets in the buffer from buf_head to ack_ackno, inclusive.
      Initially, this equals the Nonce Echo of the acknowledgement's Ack
      Vector (or, if the ack packet contained more than one Ack Vector,
      the exclusive-or of all the acknowledgement's Ack Vectors).  It
      changes as information about old acknowledgements is removed (so
      ack_ptr and buf_head diverge) and as old packets arrive (so they
      change from State 3 or State 1 to State 0).

A.1.  Packet Arrival

   This section describes how the HC-Receiver updates its
   acknowledgement buffer as packets arrive from the HC-Sender.

A.1.1.  New Packets

   When a packet with Sequence Number greater than buf_ackno arrives,
   the HC-Receiver updates buf_head (by moving it to the left
   appropriately), buf_ackno (which is set to the new packet's Sequence
   Number), and possibly buf_nonce (if the packet arrived unmarked with
   ECN Nonce 1), in addition to the buffer itself.  For example, if
   HC-Sender packet 11 arrived ECN marked, the Example Buffer above
   would enter this new state (changes are marked with stars):

         ** +***----------------------------+
         11 |1,0|0,0|3,0|3,0|3,0|0,4|1,0|0,0| 0    BN[1]
         ** +***----------------------------+

   If the packet's state equals the state at the head of the buffer, the
   HC-Receiver may choose to increment its run length (up to the
   maximum).  For example, if HC-Sender packet 11 arrived without ECN
   marking and with ECN Nonce 0, the Example Buffer might enter this
   state instead:

             ** +--*------------------------+
             11 |0,1|3,0|3,0|3,0|0,4|1,0|0,0| 0    BN[1]
             ** +--*------------------------+









Kohler, et al.              Standards Track                   [Page 118]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   Of course, the new packet's sequence number might not equal the
   expected sequence number.  In this case, the HC-Receiver will enter
   the intervening packets as State 3.  If several packets are missing,
   the HC-Receiver may prefer to enter multiple bytes with run length 0,
   rather than a single byte with a larger run length; this simplifies
   table updates if one of the missing packets arrives.  For example, if
   HC-Sender packet 12 arrived with ECN Nonce 1, the Example Buffer
   would enter this state:

      ** +*******----------------------------+         *
      12 |0,0|3,0|0,1|3,0|3,0|3,0|0,4|1,0|0,0| 0    BN[0]
      ** +*******----------------------------+         *

   Of course, the circular buffer may overflow when the HC-Sender is
   sending data at a very high rate, when the HC-Receiver's
   acknowledgements are not reaching the HC-Sender, or when the
   HC-Sender is forgetting to acknowledge those acks (so the HC-Receiver
   is unable to clean up old state).  In this case, the HC-Receiver
   should either compress the buffer (by increasing run lengths when
   possible), transfer its state to a larger buffer, or, as a last
   resort, drop all received packets, without processing them at all,
   until its buffer shrinks again.

A.1.2.  Old Packets

   When a packet with Sequence Number S <= buf_ackno arrives, the
   HC-Receiver will scan the table for the byte corresponding to S.
   (Indexing structures could reduce the complexity of this scan.)  If S
   was previously lost (State 3), and it was stored in a byte with run
   length 0, the HC-Receiver can simply change the byte's state.  For
   example, if HC-Sender packet 8 was received with ECN Nonce 0, the
   Example Buffer would enter this state:

               +--------*------------------+
            10 |0,0|3,0|0,0|3,0|0,4|1,0|0,0| 0    BN[1]
               +--------*------------------+

   If S was not marked as lost, or if it was not contained in the table,
   the packet is probably a duplicate and should be ignored.  (The new
   packet's ECN marking state might differ from the state in the buffer;
   Section 11.4.1 describes what is allowed then.)  If S's buffer byte
   has a non-zero run length, then the buffer might need to be
   reshuffled to make space for one or two new bytes.

   The ack_nonce fields may also need manipulation when old packets
   arrive.  In particular, when S transitions from State 3 or State 1 to
   State 0, and S had ECN Nonce 1, then the implementation should flip
   the value of ack_nonce for every acknowledgement with ack_ackno >= S.



Kohler, et al.              Standards Track                   [Page 119]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   It is impossible with this data structure to shift packets from State
   0 to State 1, since the buffer doesn't store individual packets' ECN
   Nonces.

A.2.  Sending Acknowledgements

   Whenever the HC-Receiver needs to generate an acknowledgement, the
   buffer's contents can simply be copied into one or more Ack Vector
   options.  Copied Ack Vectors might not be maximally compressed; for
   example, the Example Buffer above contains three adjacent 3,0 bytes
   that could be combined into a single 3,2 byte.  The HC-Receiver
   might, therefore, choose to compress the buffer in place before
   sending the option, or to compress the buffer while copying it;
   either operation is simple.

   Every acknowledgement sent by the HC-Receiver SHOULD include the
   entire state of the buffer.  That is, acknowledgements are
   cumulative.

   If the acknowledgement fits in one Ack Vector, that Ack Vector's
   Nonce Echo simply equals buf_nonce.  For multiple Ack Vectors, more
   care is required.  The Ack Vectors should be split at points
   corresponding to previous acknowledgements, since the stored
   ack_nonce fields provide enough information to calculate correct
   Nonce Echoes.  The implementation should therefore acknowledge data
   at least once per 253 bytes of buffer state.  (Otherwise, there'd be
   no way to calculate a Nonce Echo.)

   For each acknowledgement it sends, the HC-Receiver will add an
   acknowledgement record.  ack_seqno will equal the HC-Receiver
   sequence number it used for the ack packet; ack_ptr will equal
   buf_head; ack_runlen will equal the run length stored in the buffer's
   buf_head byte; ack_ackno will equal buf_ackno; and ack_nonce will
   equal buf_nonce.

A.3.  Clearing State

   Some of the HC-Sender's packets will include acknowledgement numbers,
   which ack the HC-Receiver's acknowledgements.  When such an ack is
   received, the HC-Receiver finds the acknowledgement record R with the
   appropriate ack_seqno and then does the following:

   o  If the run length in the buffer's R.ack_ptr byte is greater than
      R.ack_runlen, then it decrements that run length by
      R.ack_runlen + 1 and sets buf_tail to R.ack_ptr.  Otherwise, it
      sets buf_tail to R.ack_ptr + 1.





Kohler, et al.              Standards Track                   [Page 120]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   o  If R.ack_nonce is 1, it flips buf_nonce, and the value of
      ack_nonce for every later ack record.

   o  It throws away R and every preceding ack record.

   (The HC-Receiver may choose to keep some older information, in case a
   lost packet shows up late.)  For example, say that the HC-Receiver
   storing the Example Buffer had sent two acknowledgements already:

   1. ack_seqno = 59, ack_runlen = 1, ack_ackno = 3, ack_nonce = 1.

   2. ack_seqno = 60, ack_runlen = 0, ack_ackno = 10, ack_nonce = 0.

   Say the HC-Receiver then received a DCCP-DataAck packet with
   Acknowledgement Number 59 from the HC-Sender.  This informs the
   HC-Receiver that the HC-Sender received, and processed, all the
   information in HC-Receiver packet 59.  This packet acknowledged
   HC-Sender packet 3, so the HC-Sender has now received HC-Receiver's
   acknowledgements for packets 0, 1, 2, and 3.  The Example Buffer
   should enter this state:

               +------------------*+ *       *
            10 |0,0|3,0|3,0|3,0|0,2| 4    BN[0]
               +------------------*+ *       *

   The tail byte's run length was adjusted, since packet 3 was in the
   middle of that byte.  Since R.ack_nonce was 1, the buf_nonce field
   was flipped, as were the ack_nonce fields for later acknowledgements
   (here, the HC-Receiver Ack 60 record, not shown, has its ack_nonce
   flipped to 1).  The HC-Receiver can also throw away stored
   information about HC-Receiver Ack 59 and any earlier
   acknowledgements.

   A careful implementation might try to ensure reasonable robustness to
   reordering.  Suppose that the Example Buffer is as before, but that
   packet 9 now arrives, out of sequence.  The buffer would enter this
   state:

                +----*----------------------+
             10 |0,0|0,0|3,0|3,0|0,4|1,0|0,0| 0     BN[1]
                +----*----------------------+

   The danger is that the HC-Sender might acknowledge the HC-Receiver's
   previous acknowledgement (with sequence number 60), which says that
   Packet 9 was not received, before the HC-Receiver has a chance to
   send a new acknowledgement saying that Packet 9 actually was
   received.  Therefore, when packet 9 arrived, the HC-Receiver might
   modify its acknowledgement record as follows:



Kohler, et al.              Standards Track                   [Page 121]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   1. ack_seqno = 59, ack_ackno = 3, ack_nonce = 1.

   2. ack_seqno = 60, ack_ackno = 3, ack_nonce = 1.

   That is, Ack 60 is now treated like a duplicate of Ack 59.  This
   would prevent the Tail pointer from moving past packet 9 until the
   HC-Receiver knows that the HC-Sender has seen an Ack Vector
   indicating that packet's arrival.

A.4.  Processing Acknowledgements

   When the HC-Sender receives an acknowledgement, it generally cares
   about the number of packets that were dropped and/or ECN marked.  It
   simply reads this off the Ack Vector.  Additionally, it should check
   the ECN Nonce for correctness.  (As described in Section 11.4.1, it
   may want to keep more detailed information about acknowledged packets
   in case packets change states between acknowledgements, or in case
   the application queries whether a packet arrived.)

   The HC-Sender must also acknowledge the HC-Receiver's
   acknowledgements so that the HC-Receiver can free old Ack Vector
   state.  (Since Ack Vector acknowledgements are reliable, the
   HC-Receiver must maintain and resend Ack Vector information until it
   is sure that the HC-Sender has received that information.)  A simple
   algorithm suffices: since Ack Vector acknowledgements are cumulative,
   a single acknowledgement number tells HC-Receiver how much ack
   information has arrived.  Assuming that the HC-Receiver sends no
   data, the HC-Sender can ensure that at least once a round-trip time,
   it sends a DCCP-DataAck packet acknowledging the latest DCCP-Ack
   packet it has received.  Of course, the HC-Sender only needs to
   acknowledge the HC-Receiver's acknowledgements if the HC-Sender is
   also sending data.  If the HC-Sender is not sending data, then the
   HC-Receiver's Ack Vector state is stable, and there is no need to
   shrink it.  The HC-Sender must watch for drops and ECN marks on
   received DCCP-Ack packets so that it can adjust the HC-Receiver's
   ack-sending rate in response to congestion, for example, with Ack
   Ratio.

   If the other half-connection is not quiescent -- that is, the
   HC-Receiver is sending data to the HC-Sender, possibly using another
   CCID -- then the acknowledgements on that half-connection are
   sufficient for the HC-Receiver to free its state.









Kohler, et al.              Standards Track                   [Page 122]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


B.  Appendix: Partial Checksumming Design Motivation

   A great deal of discussion has taken place regarding the utility of
   allowing a DCCP sender to restrict the checksum so that it does not
   cover the complete packet.  This section attempts to capture some of
   the rationale behind specific details of DCCP design.

   Many of the applications that we envisage using DCCP are resilient to
   some degree of data loss, or they would typically have chosen a
   reliable transport.  Some of these applications may also be resilient
   to data corruption -- some audio payloads, for example.  These
   resilient applications might rather receive corrupted data than have
   DCCP drop corrupted packets.  This is particularly because of
   congestion control: DCCP cannot tell the difference between packets
   dropped due to corruption and packets dropped due to congestion, and
   so it must reduce the transmission rate accordingly.  This response
   may cause the connection to receive less bandwidth than it is due;
   corruption in some networking technologies is independent of, or at
   least not always correlated to, congestion.  Therefore, corrupted
   packets do not need to cause as strong a reduction in transmission
   rate as the congestion response would dictate (as long as the DCCP
   header and options are not corrupt).

   Thus DCCP allows the checksum to cover all of the packet, just the
   DCCP header, or both the DCCP header and some number of bytes from
   the application data.  If the application cannot tolerate any data
   corruption, then the checksum must cover the whole packet.  If the
   application would prefer to tolerate some corruption rather than have
   the packet dropped, then it can set the checksum to cover only part
   of the packet (but always the DCCP header).  In addition, if the
   application wishes to decouple checksumming of the DCCP header from
   checksumming of the application data, it may do so by including the
   Data Checksum option.  This would allow DCCP to discard corrupted
   application data without mistaking the corruption for network
   congestion.

   Thus, from the application point of view, partial checksums seem to
   be a desirable feature.  However, the usefulness of partial checksums
   depends on partially corrupted packets being delivered to the
   receiver.  If the link-layer CRC always discards corrupted packets,
   then this will not happen, and so the usefulness of partial checksums
   would be restricted to corruption that occurred in routers and other
   places not covered by link CRCs.  There does not appear to be
   consensus on how likely it is that future network links that suffer
   significant corruption will not cover the entire packet with a single
   strong CRC.  DCCP makes it possible to tailor such links to the
   application, but it is difficult to predict if this will be
   compelling for future link technologies.



Kohler, et al.              Standards Track                   [Page 123]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   In addition, partial checksums do not co-exist well with IP-level
   authentication mechanisms such as IPsec AH, which cover the entire
   packet with a cryptographic hash.  Thus, if cryptographic
   authentication mechanisms are required to co-exist with partial
   checksums, the authentication must be carried in the application
   data.  A possible mode of usage would appear to be similar to that of
   Secure RTP.  However, such ""application-level"" authentication does
   not protect the DCCP option negotiation and state machine from forged
   packets.  An alternative would be to use IPsec ESP, and to use
   encryption to protect the DCCP headers against attack, while using
   the DCCP header validity checks to authenticate that the header is
   from someone who possessed the correct key.  While this is resistant
   to replay (due to the DCCP sequence number), it is not by itself
   resistant to some forms of man-in-the-middle attacks because the
   application data is not tightly coupled to the packet header.  Thus,
   an application-level authentication probably needs to be coupled with
   IPsec ESP or a similar mechanism to provide a reasonably complete
   security solution.  The overhead of such a solution might be
   unacceptable for some applications that would otherwise wish to use
   partial checksums.

   On balance, the authors believe that DCCP partial checksums have the
   potential to enable some future uses that would otherwise be
   difficult.  As the cost and complexity of supporting them is small,
   it seems worth including them at this time.  It remains to be seen
   whether they are useful in practice.

Normative References

   [RFC793]       Postel, J., ""Transmission Control Protocol"", STD 7,
                  RFC 793, September 1981.

   [RFC1191]      Mogul, J. and S. Deering, ""Path MTU discovery"", RFC
                  1191, November 1990.

   [RFC2119]      Bradner, S., ""Key words for use in RFCs to Indicate
                  Requirement Levels"", BCP 14, RFC 2119, March 1997.

   [RFC2434]      Narten, T. and H. Alvestrand, ""Guidelines for Writing
                  an IANA Considerations Section in RFCs"", BCP 26, RFC
                  2434, October 1998.

   [RFC2460]      Deering, S. and R. Hinden, ""Internet Protocol, Version
                  6 (IPv6) Specification"", RFC 2460, December 1998.

   [RFC3168]      Ramakrishnan, K., Floyd, S., and D. Black, ""The
                  Addition of Explicit Congestion Notification (ECN) to
                  IP"", RFC 3168, September 2001.



Kohler, et al.              Standards Track                   [Page 124]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   [RFC3309]      Stone, J., Stewart, R., and D. Otis, ""Stream Control
                  Transmission Protocol (SCTP) Checksum Change"", RFC
                  3309, September 2002.

   [RFC3692]      Narten, T., ""Assigning Experimental and Testing
                  Numbers Considered Useful"", BCP 82, RFC 3692, January
                  2004.

   [RFC3775]      Johnson, D., Perkins, C., and J. Arkko, ""Mobility
                  Support in IPv6"", RFC 3775, June 2004.

   [RFC3828]      Larzon, L-A., Degermark, M., Pink, S., Jonsson, L-E.,
                  and G. Fairhurst, ""The Lightweight User Datagram
                  Protocol (UDP-Lite)"", RFC 3828, July 2004.

Informative References

   [B98]          Bellovin, S.M., ""Cryptography and the Internet"",
                  CRYPTO '98 (LNCS 1462), pp 46-55, August 1988.

   [BB01]         Bellovin, S.M. and M. Blaze, ""Cryptographic Modes of
                  Operation for the Internet"", 2nd NIST Workshop on
                  Modes of Operation, August 2001.

   [M85]          Morris, R.T., ""A Weakness in the 4.2BSD Unix TCP/IP
                  Software"", Computer Science Technical Report 117, AT&T
                  Bell Laboratories, Murray Hill, NJ, February 1985.

   [PMTUD]        Mathis, M. and J. Heffner, ""Path MTU Discovery"", Work
                  in Progress, March 2006.

   [RFC792]       Postel, J., ""Internet Control Message Protocol"", STD
                  5, RFC 792, September 1981.

   [RFC1812]      Baker, F., ""Requirements for IP Version 4 Routers"",
                  RFC 1812, June 1995.

   [RFC1948]      Bellovin, S., ""Defending Against Sequence Number
                  Attacks"", RFC 1948, May 1996.

   [RFC1982]      Elz, R. and R. Bush, ""Serial Number Arithmetic"", RFC
                  1982, August 1996.

   [RFC2018]      Mathis, M., Mahdavi, J., Floyd, S., and A. Romanow,
                  ""TCP Selective Acknowledgement Options"", RFC 2018,
                  October 1996.





Kohler, et al.              Standards Track                   [Page 125]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   [RFC2401]      Kent, S. and R. Atkinson, ""Security Architecture for
                  the Internet Protocol"", RFC 2401, November 1998.

   [RFC2463]      Conta, A. and S. Deering, ""Internet Control Message
                  Protocol (ICMPv6) for the Internet Protocol Version 6
                  (IPv6) Specification"", RFC 2463, December 1998.

   [RFC2581]      Allman, M., Paxson, V., and W. Stevens, ""TCP
                  Congestion Control"", RFC 2581, April 1999.

   [RFC2960]      Stewart, R., Xie, Q., Morneault, K., Sharp, C.,
                  Schwarzbauer, H., Taylor, T., Rytina, I., Kalla, M.,
                  Zhang, L., and V. Paxson, ""Stream Control Transmission
                  Protocol"", RFC 2960, October 2000.

   [RFC3124]      Balakrishnan, H. and S. Seshan, ""The Congestion
                  Manager"", RFC 3124, June 2001.

   [RFC3360]      Floyd, S., ""Inappropriate TCP Resets Considered
                  Harmful"", BCP 60, RFC 3360, August 2002.

   [RFC3448]      Handley, M., Floyd, S., Padhye, J., and J. Widmer,
                  ""TCP Friendly Rate Control (TFRC): Protocol
                  Specification"", RFC 3448, January 2003.

   [RFC3540]      Spring, N., Wetherall, D., and D. Ely, ""Robust
                  Explicit Congestion Notification (ECN) Signaling with
                  Nonces"", RFC 3540, June 2003.

   [RFC3550]      Schulzrinne, H., Casner, S., Frederick, R., and V.
                  Jacobson, ""RTP: A Transport Protocol for Real-Time
                  Applications"", STD 64, RFC 3550, July 2003.

   [RFC3611]      Friedman, T., Caceres, R., and A. Clark, ""RTP Control
                  Protocol Extended Reports (RTCP XR)"", RFC 3611,
                  November 2003.

   [RFC3711]      Baugher, M., McGrew, D., Naslund, M., Carrara, E., and
                  K. Norrman, ""The Secure Real-time Transport Protocol
                  (SRTP)"", RFC 3711, March 2004.

   [RFC3819]      Karn, P., Bormann, C., Fairhurst, G., Grossman, D.,
                  Ludwig, R., Mahdavi, J., Montenegro, G., Touch, J.,
                  and L. Wood, ""Advice for Internet Subnetwork
                  Designers"", BCP 89, RFC 3819, July 2004.






Kohler, et al.              Standards Track                   [Page 126]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


   [RFC4086]      Eastlake, D., 3rd, Schiller, J., and S. Crocker,
                  ""Randomness Requirements for Security"", BCP 106, RFC
                  4086, June 2005.

   [RFC4341]      Floyd, S. and E. Kohler, ""Profile for Datagram
                  Congestion Control Protocol (DCCP) Congestion Control
                  ID 2: TCP-like Congestion Control"", RFC 4341, March
                  2006.

   [RFC4342]      Floyd, S., Kohler, E., and J. Padhye, ""Profile for
                  Datagram Congestion Control Protocol (DCCP) Congestion
                  Control ID 3: TCP-Friendly Rate Control (TFRC)"", RFC
                  4342, March 2006.

   [SHHP00]       Spatscheck, O., Hansen, J.S., Hartman, J.H., and L.L.
                  Peterson, ""Optimizing TCP Forwarder Performance"",
                  IEEE/ACM Transactions on Networking 8(2):146-157,
                  April 2000.

   [SYNCOOKIES]   Bernstein, D.J., ""SYN Cookies"",
                  http://cr.yp.to/syncookies.html, as of March 2006.

   [VBK05]        Vanit-Anunchai, S., Billington, J., and T.
                  Kongprakaiwoot, ""Discovering Chatter and
                  Incompleteness in the Datagram Congestion Control
                  Protocol"", FORTE 2005, pp 143-158, October 2005.

























Kohler, et al.              Standards Track                   [Page 127]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


Authors' Addresses

   Eddie Kohler
   4531C Boelter Hall
   UCLA Computer Science Department
   Los Angeles, CA 90095
   USA

   EMail: kohler@cs.ucla.edu


   Mark Handley
   Department of Computer Science
   University College London
   Gower Street
   London WC1E 6BT
   UK

   EMail: M.Handley@cs.ucl.ac.uk


   Sally Floyd
   ICSI Center for Internet Research
   1947 Center Street, Suite 600
   Berkeley, CA 94704
   USA

   EMail: floyd@icir.org























Kohler, et al.              Standards Track                   [Page 128]

RFC 4340      Datagram Congestion Control Protocol (DCCP)     March 2006


Full Copyright Statement

   Copyright (C) The Internet Society (2006).

   This document is subject to the rights, licenses and restrictions
   contained in BCP 78, and except as set forth therein, the authors
   retain all their rights.

   This document and the information contained herein are provided on an
   ""AS IS"" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET
   ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,
   INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
   INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

Intellectual Property

   The IETF takes no position regarding the validity or scope of any
   Intellectual Property Rights or other rights that might be claimed to
   pertain to the implementation or use of the technology described in
   this document or the extent to which any license under such rights
   might or might not be available; nor does it represent that it has
   made any independent effort to identify any such rights.  Information
   on the procedures with respect to rights in RFC documents can be
   found in BCP 78 and BCP 79.

   Copies of IPR disclosures made to the IETF Secretariat and any
   assurances of licenses to be made available, or the result of an
   attempt made to obtain a general license or permission for the use of
   such proprietary rights by implementers or users of this
   specification can be obtained from the IETF on-line IPR repository at
   http://www.ietf.org/ipr.

   The IETF invites any interested party to bring to its attention any
   copyrights, patents or patent applications, or other proprietary
   rights that may cover technology that may be required to implement
   this standard.  Please address the information to the IETF at ietf-
   ipr@ietf.org.

Acknowledgement

   Funding for the RFC Editor function is provided by the IETF
   Administrative Support Activity (IASA).







Kohler, et al.              Standards Track                   [Page 129]

"
RFC867,"
[RFC Home] [TEXT|PDF|HTML] [Tracker] [IPR] [Info page]                                                                          INTERNET STANDARD Network Working Group                                          J. Postel
Request for Comments: 867                                            ISI
                                                                May 1983



                            Daytime Protocol




This RFC specifies a standard for the ARPA Internet community.  Hosts on
the ARPA Internet that choose to implement a Daytime Protocol are
expected to adopt and implement this standard.

A useful debugging and measurement tool is a daytime service.  A daytime
service simply sends a the current date and time as a character string
without regard to the input.

TCP Based Daytime Service

   One daytime service is defined as a connection based application on
   TCP.  A server listens for TCP connections on TCP port 13.  Once a
   connection is established the current date and time is sent out the
   connection as a ascii character string (and any data received is
   thrown away).  The service closes the connection after sending the
   quote.

UDP Based Daytime Service

   Another daytime service service is defined as a datagram based
   application on UDP.  A server listens for UDP datagrams on UDP port
   13.  When a datagram is received, an answering datagram is sent
   containing the current date and time as a ASCII character string (the
   data in the received datagram is ignored).

Daytime Syntax

   There is no specific syntax for the daytime.  It is recommended that
   it be limited to the ASCII printing characters, space, carriage
   return, and line feed.  The daytime should be just one line.

      One popular syntax is:

         Weekday, Month Day, Year Time-Zone

         Example:

            Tuesday, February 22, 1982 17:37:43-PST





Postel                                                          [Page 1]

RFC 867                                                         May 1983
Daytime Protocol


      Another popular syntax is that used in SMTP:

         dd mmm yy hh:mm:ss zzz

         Example:

            02 FEB 82 07:59:01 PST

NOTE:  For machine useful time use the Time Protocol (RFC-868).









































Postel                                                          [Page 2]

"
RFC959,"
[RFC Home] [TEXT|PDF|HTML] [Tracker] [IPR] [Errata] [Info page]                                                                 INTERNET STANDARDUpdated by: 2228, 2640, 2773, 3659, 5797, 7151 Errata ExistNetwork Working Group                                          J. Postel
Request for Comments: 959                                    J. Reynolds
                                                                     ISI
Obsoletes RFC: 765 (IEN 149)                                October 1985

                      FILE TRANSFER PROTOCOL (FTP)


Status of this Memo

   This memo is the official specification of the File Transfer
   Protocol (FTP).  Distribution of this memo is unlimited.

   The following new optional commands are included in this edition of
   the specification:

      CDUP (Change to Parent Directory), SMNT (Structure Mount), STOU
      (Store Unique), RMD (Remove Directory), MKD (Make Directory), PWD
      (Print Directory), and SYST (System).

   Note that this specification is compatible with the previous edition.

1.  INTRODUCTION

   The objectives of FTP are 1) to promote sharing of files (computer
   programs and/or data), 2) to encourage indirect or implicit (via
   programs) use of remote computers, 3) to shield a user from
   variations in file storage systems among hosts, and 4) to transfer
   data reliably and efficiently.  FTP, though usable directly by a user
   at a terminal, is designed mainly for use by programs.

   The attempt in this specification is to satisfy the diverse needs of
   users of maxi-hosts, mini-hosts, personal workstations, and TACs,
   with a simple, and easily implemented protocol design.

   This paper assumes knowledge of the Transmission Control Protocol
   (TCP) [2] and the Telnet Protocol [3].  These documents are contained
   in the ARPA-Internet protocol handbook [1].

2.  OVERVIEW

   In this section, the history, the terminology, and the FTP model are
   discussed.  The terms defined in this section are only those that
   have special significance in FTP.  Some of the terminology is very
   specific to the FTP model; some readers may wish to turn to the
   section on the FTP model while reviewing the terminology.







Postel & Reynolds                                               [Page 1]

RFC 959                                                     October 1985
File Transfer Protocol


   2.1.  HISTORY

      FTP has had a long evolution over the years.  Appendix III is a
      chronological compilation of Request for Comments documents
      relating to FTP.  These include the first proposed file transfer
      mechanisms in 1971 that were developed for implementation on hosts
      at M.I.T. (RFC 114), plus comments and discussion in RFC 141.

      RFC 172 provided a user-level oriented protocol for file transfer
      between host computers (including terminal IMPs).  A revision of
      this as RFC 265, restated FTP for additional review, while RFC 281
      suggested further changes.  The use of a ""Set Data Type""
      transaction was proposed in RFC 294 in January 1982.

      RFC 354 obsoleted RFCs 264 and 265.  The File Transfer Protocol
      was now defined as a protocol for file transfer between HOSTs on
      the ARPANET, with the primary function of FTP defined as
      transfering files efficiently and reliably among hosts and
      allowing the convenient use of remote file storage capabilities.
      RFC 385 further commented on errors, emphasis points, and
      additions to the protocol, while RFC 414 provided a status report
      on the working server and user FTPs.  RFC 430, issued in 1973,
      (among other RFCs too numerous to mention) presented further
      comments on FTP.  Finally, an ""official"" FTP document was
      published as RFC 454.

      By July 1973, considerable changes from the last versions of FTP
      were made, but the general structure remained the same.  RFC 542
      was published as a new ""official"" specification to reflect these
      changes.  However, many implementations based on the older
      specification were not updated.

      In 1974, RFCs 607 and 614 continued comments on FTP.  RFC 624
      proposed further design changes and minor modifications.  In 1975,
      RFC 686 entitled, ""Leaving Well Enough Alone"", discussed the
      differences between all of the early and later versions of FTP.
      RFC 691 presented a minor revision of RFC 686, regarding the
      subject of print files.

      Motivated by the transition from the NCP to the TCP as the
      underlying protocol, a phoenix was born out of all of the above
      efforts in RFC 765 as the specification of FTP for use on TCP.

      This current edition of the FTP specification is intended to
      correct some minor documentation errors, to improve the
      explanation of some protocol features, and to add some new
      optional commands.


Postel & Reynolds                                               [Page 2]

RFC 959                                                     October 1985
File Transfer Protocol


      In particular, the following new optional commands are included in
      this edition of the specification:

         CDUP - Change to Parent Directory

         SMNT - Structure Mount

         STOU - Store Unique

         RMD - Remove Directory

         MKD - Make Directory

         PWD - Print Directory

         SYST - System

      This specification is compatible with the previous edition.  A
      program implemented in conformance to the previous specification
      should automatically be in conformance to this specification.

   2.2.  TERMINOLOGY

      ASCII

         The ASCII character set is as defined in the ARPA-Internet
         Protocol Handbook.  In FTP, ASCII characters are defined to be
         the lower half of an eight-bit code set (i.e., the most
         significant bit is zero).

      access controls

         Access controls define users' access privileges to the use of a
         system, and to the files in that system.  Access controls are
         necessary to prevent unauthorized or accidental use of files.
         It is the prerogative of a server-FTP process to invoke access
         controls.

      byte size

         There are two byte sizes of interest in FTP:  the logical byte
         size of the file, and the transfer byte size used for the
         transmission of the data.  The transfer byte size is always 8
         bits.  The transfer byte size is not necessarily the byte size
         in which data is to be stored in a system, nor the logical byte
         size for interpretation of the structure of the data.



Postel & Reynolds                                               [Page 3]

RFC 959                                                     October 1985
File Transfer Protocol


      control connection

         The communication path between the USER-PI and SERVER-PI for
         the exchange of commands and replies.  This connection follows
         the Telnet Protocol.

      data connection

         A full duplex connection over which data is transferred, in a
         specified mode and type. The data transferred may be a part of
         a file, an entire file or a number of files.  The path may be
         between a server-DTP and a user-DTP, or between two
         server-DTPs.

      data port

         The passive data transfer process ""listens"" on the data port
         for a connection from the active transfer process in order to
         open the data connection.

      DTP

         The data transfer process establishes and manages the data
         connection.  The DTP can be passive or active.

      End-of-Line

         The end-of-line sequence defines the separation of printing
         lines.  The sequence is Carriage Return, followed by Line Feed.

      EOF

         The end-of-file condition that defines the end of a file being
         transferred.

      EOR

         The end-of-record condition that defines the end of a record
         being transferred.

      error recovery

         A procedure that allows a user to recover from certain errors
         such as failure of either host system or transfer process.  In
         FTP, error recovery may involve restarting a file transfer at a
         given checkpoint.



Postel & Reynolds                                               [Page 4]

RFC 959                                                     October 1985
File Transfer Protocol


      FTP commands

         A set of commands that comprise the control information flowing
         from the user-FTP to the server-FTP process.

      file

         An ordered set of computer data (including programs), of
         arbitrary length, uniquely identified by a pathname.

      mode

         The mode in which data is to be transferred via the data
         connection.  The mode defines the data format during transfer
         including EOR and EOF.  The transfer modes defined in FTP are
         described in the Section on Transmission Modes.

      NVT

         The Network Virtual Terminal as defined in the Telnet Protocol.

      NVFS

         The Network Virtual File System.  A concept which defines a
         standard network file system with standard commands and
         pathname conventions.

      page

         A file may be structured as a set of independent parts called
         pages.  FTP supports the transmission of discontinuous files as
         independent indexed pages.

      pathname

         Pathname is defined to be the character string which must be
         input to a file system by a user in order to identify a file.
         Pathname normally contains device and/or directory names, and
         file name specification.  FTP does not yet specify a standard
         pathname convention.  Each user must follow the file naming
         conventions of the file systems involved in the transfer.

      PI

         The protocol interpreter.  The user and server sides of the
         protocol have distinct roles implemented in a user-PI and a
         server-PI.


Postel & Reynolds                                               [Page 5]

RFC 959                                                     October 1985
File Transfer Protocol


      record

         A sequential file may be structured as a number of contiguous
         parts called records.  Record structures are supported by FTP
         but a file need not have record structure.

      reply

         A reply is an acknowledgment (positive or negative) sent from
         server to user via the control connection in response to FTP
         commands.  The general form of a reply is a completion code
         (including error codes) followed by a text string.  The codes
         are for use by programs and the text is usually intended for
         human users.

      server-DTP

         The data transfer process, in its normal ""active"" state,
         establishes the data connection with the ""listening"" data port.
         It sets up parameters for transfer and storage, and transfers
         data on command from its PI.  The DTP can be placed in a
         ""passive"" state to listen for, rather than initiate a
         connection on the data port.

      server-FTP process

         A process or set of processes which perform the function of
         file transfer in cooperation with a user-FTP process and,
         possibly, another server.  The functions consist of a protocol
         interpreter (PI) and a data transfer process (DTP).

      server-PI

         The server protocol interpreter ""listens"" on Port L for a
         connection from a user-PI and establishes a control
         communication connection.  It receives standard FTP commands
         from the user-PI, sends replies, and governs the server-DTP.

      type

         The data representation type used for data transfer and
         storage.  Type implies certain transformations between the time
         of data storage and data transfer.  The representation types
         defined in FTP are described in the Section on Establishing
         Data Connections.




Postel & Reynolds                                               [Page 6]

RFC 959                                                     October 1985
File Transfer Protocol


      user

         A person or a process on behalf of a person wishing to obtain
         file transfer service.  The human user may interact directly
         with a server-FTP process, but use of a user-FTP process is
         preferred since the protocol design is weighted towards
         automata.

      user-DTP

         The data transfer process ""listens"" on the data port for a
         connection from a server-FTP process.  If two servers are
         transferring data between them, the user-DTP is inactive.

      user-FTP process

         A set of functions including a protocol interpreter, a data
         transfer process and a user interface which together perform
         the function of file transfer in cooperation with one or more
         server-FTP processes.  The user interface allows a local
         language to be used in the command-reply dialogue with the
         user.

      user-PI

         The user protocol interpreter initiates the control connection
         from its port U to the server-FTP process, initiates FTP
         commands, and governs the user-DTP if that process is part of
         the file transfer.




















Postel & Reynolds                                               [Page 7]

RFC 959                                                     October 1985
File Transfer Protocol


   2.3.  THE FTP MODEL

      With the above definitions in mind, the following model (shown in
      Figure 1) may be diagrammed for an FTP service.

                                            -------------
                                            |/---------\|
                                            ||   User  ||    --------
                                            ||Interface|<--->| User |
                                            |\----^----/|    --------
                  ----------                |     |     |
                  |/------\|  FTP Commands  |/----V----\|
                  ||Server|<---------------->|   User  ||
                  ||  PI  ||   FTP Replies  ||    PI   ||
                  |\--^---/|                |\----^----/|
                  |   |    |                |     |     |
      --------    |/--V---\|      Data      |/----V----\|    --------
      | File |<--->|Server|<---------------->|  User   |<--->| File |
      |System|    || DTP  ||   Connection   ||   DTP   ||    |System|
      --------    |\------/|                |\---------/|    --------
                  ----------                -------------

                  Server-FTP                   USER-FTP

      NOTES: 1. The data connection may be used in either direction.
             2. The data connection need not exist all of the time.

                      Figure 1  Model for FTP Use

      In the model described in Figure 1, the user-protocol interpreter
      initiates the control connection.  The control connection follows
      the Telnet protocol.  At the initiation of the user, standard FTP
      commands are generated by the user-PI and transmitted to the
      server process via the control connection.  (The user may
      establish a direct control connection to the server-FTP, from a
      TAC terminal for example, and generate standard FTP commands
      independently, bypassing the user-FTP process.) Standard replies
      are sent from the server-PI to the user-PI over the control
      connection in response to the commands.

      The FTP commands specify the parameters for the data connection
      (data port, transfer mode, representation type, and structure) and
      the nature of file system operation (store, retrieve, append,
      delete, etc.).  The user-DTP or its designate should ""listen"" on
      the specified data port, and the server initiate the data
      connection and data transfer in accordance with the specified
      parameters.  It should be noted that the data port need not be in


Postel & Reynolds                                               [Page 8]

RFC 959                                                     October 1985
File Transfer Protocol


      the same host that initiates the FTP commands via the control
      connection, but the user or the user-FTP process must ensure a
      ""listen"" on the specified data port.  It ought to also be noted
      that the data connection may be used for simultaneous sending and
      receiving.

      In another situation a user might wish to transfer files between
      two hosts, neither of which is a local host. The user sets up
      control connections to the two servers and then arranges for a
      data connection between them.  In this manner, control information
      is passed to the user-PI but data is transferred between the
      server data transfer processes.  Following is a model of this
      server-server interaction.


                    Control     ------------   Control
                    ---------->| User-FTP |<-----------
                    |          | User-PI  |           |
                    |          |   ""C""    |           |
                    V          ------------           V
            --------------                        --------------
            | Server-FTP |   Data Connection      | Server-FTP |
            |    ""A""     |<---------------------->|    ""B""     |
            -------------- Port (A)      Port (B) --------------


                                 Figure 2

      The protocol requires that the control connections be open while
      data transfer is in progress.  It is the responsibility of the
      user to request the closing of the control connections when
      finished using the FTP service, while it is the server who takes
      the action.  The server may abort data transfer if the control
      connections are closed without command.

      The Relationship between FTP and Telnet:

         The FTP uses the Telnet protocol on the control connection.
         This can be achieved in two ways: first, the user-PI or the
         server-PI may implement the rules of the Telnet Protocol
         directly in their own procedures; or, second, the user-PI or
         the server-PI may make use of the existing Telnet module in the
         system.

         Ease of implementaion, sharing code, and modular programming
         argue for the second approach.  Efficiency and independence



Postel & Reynolds                                               [Page 9]

RFC 959                                                     October 1985
File Transfer Protocol


         argue for the first approach.  In practice, FTP relies on very
         little of the Telnet Protocol, so the first approach does not
         necessarily involve a large amount of code.

3.  DATA TRANSFER FUNCTIONS

   Files are transferred only via the data connection.  The control
   connection is used for the transfer of commands, which describe the
   functions to be performed, and the replies to these commands (see the
   Section on FTP Replies).  Several commands are concerned with the
   transfer of data between hosts.  These data transfer commands include
   the MODE command which specify how the bits of the data are to be
   transmitted, and the STRUcture and TYPE commands, which are used to
   define the way in which the data are to be represented.  The
   transmission and representation are basically independent but the
   ""Stream"" transmission mode is dependent on the file structure
   attribute and if ""Compressed"" transmission mode is used, the nature
   of the filler byte depends on the representation type.

   3.1.  DATA REPRESENTATION AND STORAGE

      Data is transferred from a storage device in the sending host to a
      storage device in the receiving host.  Often it is necessary to
      perform certain transformations on the data because data storage
      representations in the two systems are different.  For example,
      NVT-ASCII has different data storage representations in different
      systems.  DEC TOPS-20s's generally store NVT-ASCII as five 7-bit
      ASCII characters, left-justified in a 36-bit word. IBM Mainframe's
      store NVT-ASCII as 8-bit EBCDIC codes.  Multics stores NVT-ASCII
      as four 9-bit characters in a 36-bit word.  It is desirable to
      convert characters into the standard NVT-ASCII representation when
      transmitting text between dissimilar systems.  The sending and
      receiving sites would have to perform the necessary
      transformations between the standard representation and their
      internal representations.

      A different problem in representation arises when transmitting
      binary data (not character codes) between host systems with
      different word lengths.  It is not always clear how the sender
      should send data, and the receiver store it.  For example, when
      transmitting 32-bit bytes from a 32-bit word-length system to a
      36-bit word-length system, it may be desirable (for reasons of
      efficiency and usefulness) to store the 32-bit bytes
      right-justified in a 36-bit word in the latter system.  In any
      case, the user should have the option of specifying data
      representation and transformation functions.  It should be noted



Postel & Reynolds                                              [Page 10]

RFC 959                                                     October 1985
File Transfer Protocol


      that FTP provides for very limited data type representations.
      Transformations desired beyond this limited capability should be
      performed by the user directly.

      3.1.1.  DATA TYPES

         Data representations are handled in FTP by a user specifying a
         representation type.  This type may implicitly (as in ASCII or
         EBCDIC) or explicitly (as in Local byte) define a byte size for
         interpretation which is referred to as the ""logical byte size.""
         Note that this has nothing to do with the byte size used for
         transmission over the data connection, called the ""transfer
         byte size"", and the two should not be confused.  For example,
         NVT-ASCII has a logical byte size of 8 bits.  If the type is
         Local byte, then the TYPE command has an obligatory second
         parameter specifying the logical byte size.  The transfer byte
         size is always 8 bits.

         3.1.1.1.  ASCII TYPE

            This is the default type and must be accepted by all FTP
            implementations.  It is intended primarily for the transfer
            of text files, except when both hosts would find the EBCDIC
            type more convenient.

            The sender converts the data from an internal character
            representation to the standard 8-bit NVT-ASCII
            representation (see the Telnet specification).  The receiver
            will convert the data from the standard form to his own
            internal form.

            In accordance with the NVT standard, the <CRLF> sequence
            should be used where necessary to denote the end of a line
            of text.  (See the discussion of file structure at the end
            of the Section on Data Representation and Storage.)

            Using the standard NVT-ASCII representation means that data
            must be interpreted as 8-bit bytes.

            The Format parameter for ASCII and EBCDIC types is discussed
            below.








Postel & Reynolds                                              [Page 11]

RFC 959                                                     October 1985
File Transfer Protocol


         3.1.1.2.  EBCDIC TYPE

            This type is intended for efficient transfer between hosts
            which use EBCDIC for their internal character
            representation.

            For transmission, the data are represented as 8-bit EBCDIC
            characters.  The character code is the only difference
            between the functional specifications of EBCDIC and ASCII
            types.

            End-of-line (as opposed to end-of-record--see the discussion
            of structure) will probably be rarely used with EBCDIC type
            for purposes of denoting structure, but where it is
            necessary the <NL> character should be used.

         3.1.1.3.  IMAGE TYPE

            The data are sent as contiguous bits which, for transfer,
            are packed into the 8-bit transfer bytes.  The receiving
            site must store the data as contiguous bits.  The structure
            of the storage system might necessitate the padding of the
            file (or of each record, for a record-structured file) to
            some convenient boundary (byte, word or block).  This
            padding, which must be all zeros, may occur only at the end
            of the file (or at the end of each record) and there must be
            a way of identifying the padding bits so that they may be
            stripped off if the file is retrieved.  The padding
            transformation should be well publicized to enable a user to
            process a file at the storage site.

            Image type is intended for the efficient storage and
            retrieval of files and for the transfer of binary data.  It
            is recommended that this type be accepted by all FTP
            implementations.

         3.1.1.4.  LOCAL TYPE

            The data is transferred in logical bytes of the size
            specified by the obligatory second parameter, Byte size.
            The value of Byte size must be a decimal integer; there is
            no default value.  The logical byte size is not necessarily
            the same as the transfer byte size.  If there is a
            difference in byte sizes, then the logical bytes should be
            packed contiguously, disregarding transfer byte boundaries
            and with any necessary padding at the end.



Postel & Reynolds                                              [Page 12]

RFC 959                                                     October 1985
File Transfer Protocol


            When the data reaches the receiving host, it will be
            transformed in a manner dependent on the logical byte size
            and the particular host.  This transformation must be
            invertible (i.e., an identical file can be retrieved if the
            same parameters are used) and should be well publicized by
            the FTP implementors.

            For example, a user sending 36-bit floating-point numbers to
            a host with a 32-bit word could send that data as Local byte
            with a logical byte size of 36.  The receiving host would
            then be expected to store the logical bytes so that they
            could be easily manipulated; in this example putting the
            36-bit logical bytes into 64-bit double words should
            suffice.

            In another example, a pair of hosts with a 36-bit word size
            may send data to one another in words by using TYPE L 36.
            The data would be sent in the 8-bit transmission bytes
            packed so that 9 transmission bytes carried two host words.

         3.1.1.5.  FORMAT CONTROL

            The types ASCII and EBCDIC also take a second (optional)
            parameter; this is to indicate what kind of vertical format
            control, if any, is associated with a file.  The following
            data representation types are defined in FTP:

            A character file may be transferred to a host for one of
            three purposes: for printing, for storage and later
            retrieval, or for processing.  If a file is sent for
            printing, the receiving host must know how the vertical
            format control is represented.  In the second case, it must
            be possible to store a file at a host and then retrieve it
            later in exactly the same form.  Finally, it should be
            possible to move a file from one host to another and process
            the file at the second host without undue trouble.  A single
            ASCII or EBCDIC format does not satisfy all these
            conditions.  Therefore, these types have a second parameter
            specifying one of the following three formats:

            3.1.1.5.1.  NON PRINT

               This is the default format to be used if the second
               (format) parameter is omitted.  Non-print format must be
               accepted by all FTP implementations.




Postel & Reynolds                                              [Page 13]

RFC 959                                                     October 1985
File Transfer Protocol


               The file need contain no vertical format information.  If
               it is passed to a printer process, this process may
               assume standard values for spacing and margins.

               Normally, this format will be used with files destined
               for processing or just storage.

            3.1.1.5.2.  TELNET FORMAT CONTROLS

               The file contains ASCII/EBCDIC vertical format controls
               (i.e., <CR>, <LF>, <NL>, <VT>, <FF>) which the printer
               process will interpret appropriately.  <CRLF>, in exactly
               this sequence, also denotes end-of-line.

            3.1.1.5.2.  CARRIAGE CONTROL (ASA)

               The file contains ASA (FORTRAN) vertical format control
               characters.  (See RFC 740 Appendix C; and Communications
               of the ACM, Vol. 7, No. 10, p. 606, October 1964.)  In a
               line or a record formatted according to the ASA Standard,
               the first character is not to be printed.  Instead, it
               should be used to determine the vertical movement of the
               paper which should take place before the rest of the
               record is printed.

               The ASA Standard specifies the following control
               characters:

                  Character     Vertical Spacing

                  blank         Move paper up one line
                  0             Move paper up two lines
                  1             Move paper to top of next page
                  +             No movement, i.e., overprint

               Clearly there must be some way for a printer process to
               distinguish the end of the structural entity.  If a file
               has record structure (see below) this is no problem;
               records will be explicitly marked during transfer and
               storage.  If the file has no record structure, the <CRLF>
               end-of-line sequence is used to separate printing lines,
               but these format effectors are overridden by the ASA
               controls.






Postel & Reynolds                                              [Page 14]

RFC 959                                                     October 1985
File Transfer Protocol


      3.1.2.  DATA STRUCTURES

         In addition to different representation types, FTP allows the
         structure of a file to be specified.  Three file structures are
         defined in FTP:

            file-structure,     where there is no internal structure and
                                the file is considered to be a
                                continuous sequence of data bytes,

            record-structure,   where the file is made up of sequential
                                records,

            and page-structure, where the file is made up of independent
                                indexed pages.

         File-structure is the default to be assumed if the STRUcture
         command has not been used but both file and record structures
         must be accepted for ""text"" files (i.e., files with TYPE ASCII
         or EBCDIC) by all FTP implementations.  The structure of a file
         will affect both the transfer mode of a file (see the Section
         on Transmission Modes) and the interpretation and storage of
         the file.

         The ""natural"" structure of a file will depend on which host
         stores the file.  A source-code file will usually be stored on
         an IBM Mainframe in fixed length records but on a DEC TOPS-20
         as a stream of characters partitioned into lines, for example
         by <CRLF>.  If the transfer of files between such disparate
         sites is to be useful, there must be some way for one site to
         recognize the other's assumptions about the file.

         With some sites being naturally file-oriented and others
         naturally record-oriented there may be problems if a file with
         one structure is sent to a host oriented to the other.  If a
         text file is sent with record-structure to a host which is file
         oriented, then that host should apply an internal
         transformation to the file based on the record structure.
         Obviously, this transformation should be useful, but it must
         also be invertible so that an identical file may be retrieved
         using record structure.

         In the case of a file being sent with file-structure to a
         record-oriented host, there exists the question of what
         criteria the host should use to divide the file into records
         which can be processed locally.  If this division is necessary,
         the FTP implementation should use the end-of-line sequence,


Postel & Reynolds                                              [Page 15]

RFC 959                                                     October 1985
File Transfer Protocol


         <CRLF> for ASCII, or <NL> for EBCDIC text files, as the
         delimiter.  If an FTP implementation adopts this technique, it
         must be prepared to reverse the transformation if the file is
         retrieved with file-structure.

         3.1.2.1.  FILE STRUCTURE

            File structure is the default to be assumed if the STRUcture
            command has not been used.

            In file-structure there is no internal structure and the
            file is considered to be a continuous sequence of data
            bytes.

         3.1.2.2.  RECORD STRUCTURE

            Record structures must be accepted for ""text"" files (i.e.,
            files with TYPE ASCII or EBCDIC) by all FTP implementations.

            In record-structure the file is made up of sequential
            records.

         3.1.2.3.  PAGE STRUCTURE

            To transmit files that are discontinuous, FTP defines a page
            structure.  Files of this type are sometimes known as
            ""random access files"" or even as ""holey files"".  In these
            files there is sometimes other information associated with
            the file as a whole (e.g., a file descriptor), or with a
            section of the file (e.g., page access controls), or both.
            In FTP, the sections of the file are called pages.

            To provide for various page sizes and associated
            information, each page is sent with a page header.  The page
            header has the following defined fields:

               Header Length

                  The number of logical bytes in the page header
                  including this byte.  The minimum header length is 4.

               Page Index

                  The logical page number of this section of the file.
                  This is not the transmission sequence number of this
                  page, but the index used to identify this page of the
                  file.


Postel & Reynolds                                              [Page 16]

RFC 959                                                     October 1985
File Transfer Protocol


               Data Length

                  The number of logical bytes in the page data.  The
                  minimum data length is 0.

               Page Type

                  The type of page this is.  The following page types
                  are defined:

                     0 = Last Page

                        This is used to indicate the end of a paged
                        structured transmission.  The header length must
                        be 4, and the data length must be 0.

                     1 = Simple Page

                        This is the normal type for simple paged files
                        with no page level associated control
                        information.  The header length must be 4.

                     2 = Descriptor Page

                        This type is used to transmit the descriptive
                        information for the file as a whole.

                     3 = Access Controlled Page

                        This type includes an additional header field
                        for paged files with page level access control
                        information.  The header length must be 5.

               Optional Fields

                  Further header fields may be used to supply per page
                  control information, for example, per page access
                  control.

            All fields are one logical byte in length.  The logical byte
            size is specified by the TYPE command.  See Appendix I for
            further details and a specific case at the page structure.

      A note of caution about parameters:  a file must be stored and
      retrieved with the same parameters if the retrieved version is to




Postel & Reynolds                                              [Page 17]

RFC 959                                                     October 1985
File Transfer Protocol


      be identical to the version originally transmitted.  Conversely,
      FTP implementations must return a file identical to the original
      if the parameters used to store and retrieve a file are the same.

   3.2.  ESTABLISHING DATA CONNECTIONS

      The mechanics of transferring data consists of setting up the data
      connection to the appropriate ports and choosing the parameters
      for transfer.  Both the user and the server-DTPs have a default
      data port.  The user-process default data port is the same as the
      control connection port (i.e., U).  The server-process default
      data port is the port adjacent to the control connection port
      (i.e., L-1).

      The transfer byte size is 8-bit bytes.  This byte size is relevant
      only for the actual transfer of the data; it has no bearing on
      representation of the data within a host's file system.

      The passive data transfer process (this may be a user-DTP or a
      second server-DTP) shall ""listen"" on the data port prior to
      sending a transfer request command.  The FTP request command
      determines the direction of the data transfer.  The server, upon
      receiving the transfer request, will initiate the data connection
      to the port.  When the connection is established, the data
      transfer begins between DTP's, and the server-PI sends a
      confirming reply to the user-PI.

      Every FTP implementation must support the use of the default data
      ports, and only the USER-PI can initiate a change to non-default
      ports.

      It is possible for the user to specify an alternate data port by
      use of the PORT command.  The user may want a file dumped on a TAC
      line printer or retrieved from a third party host.  In the latter
      case, the user-PI sets up control connections with both
      server-PI's.  One server is then told (by an FTP command) to
      ""listen"" for a connection which the other will initiate.  The
      user-PI sends one server-PI a PORT command indicating the data
      port of the other.  Finally, both are sent the appropriate
      transfer commands.  The exact sequence of commands and replies
      sent between the user-controller and the servers is defined in the
      Section on FTP Replies.

      In general, it is the server's responsibility to maintain the data
      connection--to initiate it and to close it.  The exception to this




Postel & Reynolds                                              [Page 18]

RFC 959                                                     October 1985
File Transfer Protocol


      is when the user-DTP is sending the data in a transfer mode that
      requires the connection to be closed to indicate EOF.  The server
      MUST close the data connection under the following conditions:

         1. The server has completed sending data in a transfer mode
            that requires a close to indicate EOF.

         2. The server receives an ABORT command from the user.

         3. The port specification is changed by a command from the
            user.

         4. The control connection is closed legally or otherwise.

         5. An irrecoverable error condition occurs.

      Otherwise the close is a server option, the exercise of which the
      server must indicate to the user-process by either a 250 or 226
      reply only.

   3.3.  DATA CONNECTION MANAGEMENT

      Default Data Connection Ports:  All FTP implementations must
      support use of the default data connection ports, and only the
      User-PI may initiate the use of non-default ports.

      Negotiating Non-Default Data Ports:   The User-PI may specify a
      non-default user side data port with the PORT command.  The
      User-PI may request the server side to identify a non-default
      server side data port with the PASV command.  Since a connection
      is defined by the pair of addresses, either of these actions is
      enough to get a different data connection, still it is permitted
      to do both commands to use new ports on both ends of the data
      connection.

      Reuse of the Data Connection:  When using the stream mode of data
      transfer the end of the file must be indicated by closing the
      connection.  This causes a problem if multiple files are to be
      transfered in the session, due to need for TCP to hold the
      connection record for a time out period to guarantee the reliable
      communication.  Thus the connection can not be reopened at once.

         There are two solutions to this problem.  The first is to
         negotiate a non-default port.  The second is to use another
         transfer mode.

         A comment on transfer modes.  The stream transfer mode is


Postel & Reynolds                                              [Page 19]

RFC 959                                                     October 1985
File Transfer Protocol


         inherently unreliable, since one can not determine if the
         connection closed prematurely or not.  The other transfer modes
         (Block, Compressed) do not close the connection to indicate the
         end of file.  They have enough FTP encoding that the data
         connection can be parsed to determine the end of the file.
         Thus using these modes one can leave the data connection open
         for multiple file transfers.

   3.4.  TRANSMISSION MODES

      The next consideration in transferring data is choosing the
      appropriate transmission mode.  There are three modes: one which
      formats the data and allows for restart procedures; one which also
      compresses the data for efficient transfer; and one which passes
      the data with little or no processing.  In this last case the mode
      interacts with the structure attribute to determine the type of
      processing.  In the compressed mode, the representation type
      determines the filler byte.

      All data transfers must be completed with an end-of-file (EOF)
      which may be explicitly stated or implied by the closing of the
      data connection.  For files with record structure, all the
      end-of-record markers (EOR) are explicit, including the final one.
      For files transmitted in page structure a ""last-page"" page type is
      used.

      NOTE:  In the rest of this section, byte means ""transfer byte""
      except where explicitly stated otherwise.

      For the purpose of standardized transfer, the sending host will
      translate its internal end of line or end of record denotation
      into the representation prescribed by the transfer mode and file
      structure, and the receiving host will perform the inverse
      translation to its internal denotation.  An IBM Mainframe record
      count field may not be recognized at another host, so the
      end-of-record information may be transferred as a two byte control
      code in Stream mode or as a flagged bit in a Block or Compressed
      mode descriptor.  End-of-line in an ASCII or EBCDIC file with no
      record structure should be indicated by <CRLF> or <NL>,
      respectively.  Since these transformations imply extra work for
      some systems, identical systems transferring non-record structured
      text files might wish to use a binary representation and stream
      mode for the transfer.






Postel & Reynolds                                              [Page 20]

RFC 959                                                     October 1985
File Transfer Protocol


      The following transmission modes are defined in FTP:

      3.4.1.  STREAM MODE

         The data is transmitted as a stream of bytes.  There is no
         restriction on the representation type used; record structures
         are allowed.

         In a record structured file EOR and EOF will each be indicated
         by a two-byte control code.  The first byte of the control code
         will be all ones, the escape character.  The second byte will
         have the low order bit on and zeros elsewhere for EOR and the
         second low order bit on for EOF; that is, the byte will have
         value 1 for EOR and value 2 for EOF.  EOR and EOF may be
         indicated together on the last byte transmitted by turning both
         low order bits on (i.e., the value 3).  If a byte of all ones
         was intended to be sent as data, it should be repeated in the
         second byte of the control code.

         If the structure is a file structure, the EOF is indicated by
         the sending host closing the data connection and all bytes are
         data bytes.

      3.4.2.  BLOCK MODE

         The file is transmitted as a series of data blocks preceded by
         one or more header bytes.  The header bytes contain a count
         field, and descriptor code.  The count field indicates the
         total length of the data block in bytes, thus marking the
         beginning of the next data block (there are no filler bits).
         The descriptor code defines:  last block in the file (EOF) last
         block in the record (EOR), restart marker (see the Section on
         Error Recovery and Restart) or suspect data (i.e., the data
         being transferred is suspected of errors and is not reliable).
         This last code is NOT intended for error control within FTP.
         It is motivated by the desire of sites exchanging certain types
         of data (e.g., seismic or weather data) to send and receive all
         the data despite local errors (such as ""magnetic tape read
         errors""), but to indicate in the transmission that certain
         portions are suspect).  Record structures are allowed in this
         mode, and any representation type may be used.

         The header consists of the three bytes.  Of the 24 bits of
         header information, the 16 low order bits shall represent byte
         count, and the 8 high order bits shall represent descriptor
         codes as shown below.



Postel & Reynolds                                              [Page 21]

RFC 959                                                     October 1985
File Transfer Protocol


         Block Header

            +----------------+----------------+----------------+
            | Descriptor     |    Byte Count                   |
            |         8 bits |                      16 bits    |
            +----------------+----------------+----------------+


         The descriptor codes are indicated by bit flags in the
         descriptor byte.  Four codes have been assigned, where each
         code number is the decimal value of the corresponding bit in
         the byte.

            Code     Meaning

             128     End of data block is EOR
              64     End of data block is EOF
              32     Suspected errors in data block
              16     Data block is a restart marker

         With this encoding, more than one descriptor coded condition
         may exist for a particular block.  As many bits as necessary
         may be flagged.

         The restart marker is embedded in the data stream as an
         integral number of 8-bit bytes representing printable
         characters in the language being used over the control
         connection (e.g., default--NVT-ASCII).  <SP> (Space, in the
         appropriate language) must not be used WITHIN a restart marker.

         For example, to transmit a six-character marker, the following
         would be sent:

            +--------+--------+--------+
            |Descrptr|  Byte count     |
            |code= 16|             = 6 |
            +--------+--------+--------+

            +--------+--------+--------+
            | Marker | Marker | Marker |
            | 8 bits | 8 bits | 8 bits |
            +--------+--------+--------+

            +--------+--------+--------+
            | Marker | Marker | Marker |
            | 8 bits | 8 bits | 8 bits |
            +--------+--------+--------+


Postel & Reynolds                                              [Page 22]

RFC 959                                                     October 1985
File Transfer Protocol


      3.4.3.  COMPRESSED MODE

         There are three kinds of information to be sent:  regular data,
         sent in a byte string; compressed data, consisting of
         replications or filler; and control information, sent in a
         two-byte escape sequence.  If n>0 bytes (up to 127) of regular
         data are sent, these n bytes are preceded by a byte with the
         left-most bit set to 0 and the right-most 7 bits containing the
         number n.

         Byte string:

             1       7                8                     8
            +-+-+-+-+-+-+-+-+ +-+-+-+-+-+-+-+-+     +-+-+-+-+-+-+-+-+
            |0|       n     | |    d(1)       | ... |      d(n)     |
            +-+-+-+-+-+-+-+-+ +-+-+-+-+-+-+-+-+     +-+-+-+-+-+-+-+-+
                                          ^             ^
                                          |---n bytes---|
                                              of data

            String of n data bytes d(1),..., d(n)
            Count n must be positive.

         To compress a string of n replications of the data byte d, the
         following 2 bytes are sent:

         Replicated Byte:

              2       6               8
            +-+-+-+-+-+-+-+-+ +-+-+-+-+-+-+-+-+
            |1 0|     n     | |       d       |
            +-+-+-+-+-+-+-+-+ +-+-+-+-+-+-+-+-+

         A string of n filler bytes can be compressed into a single
         byte, where the filler byte varies with the representation
         type.  If the type is ASCII or EBCDIC the filler byte is <SP>
         (Space, ASCII code 32, EBCDIC code 64).  If the type is Image
         or Local byte the filler is a zero byte.

         Filler String:

              2       6
            +-+-+-+-+-+-+-+-+
            |1 1|     n     |
            +-+-+-+-+-+-+-+-+

         The escape sequence is a double byte, the first of which is the


Postel & Reynolds                                              [Page 23]

RFC 959                                                     October 1985
File Transfer Protocol


         escape byte (all zeros) and the second of which contains
         descriptor codes as defined in Block mode.  The descriptor
         codes have the same meaning as in Block mode and apply to the
         succeeding string of bytes.

         Compressed mode is useful for obtaining increased bandwidth on
         very large network transmissions at a little extra CPU cost.
         It can be most effectively used to reduce the size of printer
         files such as those generated by RJE hosts.

   3.5.  ERROR RECOVERY AND RESTART

      There is no provision for detecting bits lost or scrambled in data
      transfer; this level of error control is handled by the TCP.
      However, a restart procedure is provided to protect users from
      gross system failures (including failures of a host, an
      FTP-process, or the underlying network).

      The restart procedure is defined only for the block and compressed
      modes of data transfer.  It requires the sender of data to insert
      a special marker code in the data stream with some marker
      information.  The marker information has meaning only to the
      sender, but must consist of printable characters in the default or
      negotiated language of the control connection (ASCII or EBCDIC).
      The marker could represent a bit-count, a record-count, or any
      other information by which a system may identify a data
      checkpoint.  The receiver of data, if it implements the restart
      procedure, would then mark the corresponding position of this
      marker in the receiving system, and return this information to the
      user.

      In the event of a system failure, the user can restart the data
      transfer by identifying the marker point with the FTP restart
      procedure.  The following example illustrates the use of the
      restart procedure.

      The sender of the data inserts an appropriate marker block in the
      data stream at a convenient point.  The receiving host marks the
      corresponding data point in its file system and conveys the last
      known sender and receiver marker information to the user, either
      directly or over the control connection in a 110 reply (depending
      on who is the sender).  In the event of a system failure, the user
      or controller process restarts the server at the last server
      marker by sending a restart command with server's marker code as
      its argument.  The restart command is transmitted over the control




Postel & Reynolds                                              [Page 24]

RFC 959                                                     October 1985
File Transfer Protocol


      connection and is immediately followed by the command (such as
      RETR, STOR or LIST) which was being executed when the system
      failure occurred.

4.  FILE TRANSFER FUNCTIONS

   The communication channel from the user-PI to the server-PI is
   established as a TCP connection from the user to the standard server
   port.  The user protocol interpreter is responsible for sending FTP
   commands and interpreting the replies received; the server-PI
   interprets commands, sends replies and directs its DTP to set up the
   data connection and transfer the data.  If the second party to the
   data transfer (the passive transfer process) is the user-DTP, then it
   is governed through the internal protocol of the user-FTP host; if it
   is a second server-DTP, then it is governed by its PI on command from
   the user-PI.  The FTP replies are discussed in the next section.  In
   the description of a few of the commands in this section, it is
   helpful to be explicit about the possible replies.

   4.1.  FTP COMMANDS

      4.1.1.  ACCESS CONTROL COMMANDS

         The following commands specify access control identifiers
         (command codes are shown in parentheses).

         USER NAME (USER)

            The argument field is a Telnet string identifying the user.
            The user identification is that which is required by the
            server for access to its file system.  This command will
            normally be the first command transmitted by the user after
            the control connections are made (some servers may require
            this).  Additional identification information in the form of
            a password and/or an account command may also be required by
            some servers.  Servers may allow a new USER command to be
            entered at any point in order to change the access control
            and/or accounting information.  This has the effect of
            flushing any user, password, and account information already
            supplied and beginning the login sequence again.  All
            transfer parameters are unchanged and any file transfer in
            progress is completed under the old access control
            parameters.






Postel & Reynolds                                              [Page 25]

RFC 959                                                     October 1985
File Transfer Protocol


         PASSWORD (PASS)

            The argument field is a Telnet string specifying the user's
            password.  This command must be immediately preceded by the
            user name command, and, for some sites, completes the user's
            identification for access control.  Since password
            information is quite sensitive, it is desirable in general
            to ""mask"" it or suppress typeout.  It appears that the
            server has no foolproof way to achieve this.  It is
            therefore the responsibility of the user-FTP process to hide
            the sensitive password information.

         ACCOUNT (ACCT)

            The argument field is a Telnet string identifying the user's
            account.  The command is not necessarily related to the USER
            command, as some sites may require an account for login and
            others only for specific access, such as storing files.  In
            the latter case the command may arrive at any time.

            There are reply codes to differentiate these cases for the
            automation: when account information is required for login,
            the response to a successful PASSword command is reply code
            332.  On the other hand, if account information is NOT
            required for login, the reply to a successful PASSword
            command is 230; and if the account information is needed for
            a command issued later in the dialogue, the server should
            return a 332 or 532 reply depending on whether it stores
            (pending receipt of the ACCounT command) or discards the
            command, respectively.

         CHANGE WORKING DIRECTORY (CWD)

            This command allows the user to work with a different
            directory or dataset for file storage or retrieval without
            altering his login or accounting information.  Transfer
            parameters are similarly unchanged.  The argument is a
            pathname specifying a directory or other system dependent
            file group designator.

         CHANGE TO PARENT DIRECTORY (CDUP)

            This command is a special case of CWD, and is included to
            simplify the implementation of programs for transferring
            directory trees between operating systems having different




Postel & Reynolds                                              [Page 26]

RFC 959                                                     October 1985
File Transfer Protocol


            syntaxes for naming the parent directory.  The reply codes
            shall be identical to the reply codes of CWD.  See
            Appendix II for further details.

         STRUCTURE MOUNT (SMNT)

            This command allows the user to mount a different file
            system data structure without altering his login or
            accounting information.  Transfer parameters are similarly
            unchanged.  The argument is a pathname specifying a
            directory or other system dependent file group designator.

         REINITIALIZE (REIN)

            This command terminates a USER, flushing all I/O and account
            information, except to allow any transfer in progress to be
            completed.  All parameters are reset to the default settings
            and the control connection is left open.  This is identical
            to the state in which a user finds himself immediately after
            the control connection is opened.  A USER command may be
            expected to follow.

         LOGOUT (QUIT)

            This command terminates a USER and if file transfer is not
            in progress, the server closes the control connection.  If
            file transfer is in progress, the connection will remain
            open for result response and the server will then close it.
            If the user-process is transferring files for several USERs
            but does not wish to close and then reopen connections for
            each, then the REIN command should be used instead of QUIT.

            An unexpected close on the control connection will cause the
            server to take the effective action of an abort (ABOR) and a
            logout (QUIT).

      4.1.2.  TRANSFER PARAMETER COMMANDS

         All data transfer parameters have default values, and the
         commands specifying data transfer parameters are required only
         if the default parameter values are to be changed.  The default
         value is the last specified value, or if no value has been
         specified, the standard default value is as stated here.  This
         implies that the server must ""remember"" the applicable default
         values.  The commands may be in any order except that they must
         precede the FTP service request.  The following commands
         specify data transfer parameters:


Postel & Reynolds                                              [Page 27]

RFC 959                                                     October 1985
File Transfer Protocol


         DATA PORT (PORT)

            The argument is a HOST-PORT specification for the data port
            to be used in data connection.  There are defaults for both
            the user and server data ports, and under normal
            circumstances this command and its reply are not needed.  If
            this command is used, the argument is the concatenation of a
            32-bit internet host address and a 16-bit TCP port address.
            This address information is broken into 8-bit fields and the
            value of each field is transmitted as a decimal number (in
            character string representation).  The fields are separated
            by commas.  A port command would be:

               PORT h1,h2,h3,h4,p1,p2

            where h1 is the high order 8 bits of the internet host
            address.

         PASSIVE (PASV)

            This command requests the server-DTP to ""listen"" on a data
            port (which is not its default data port) and to wait for a
            connection rather than initiate one upon receipt of a
            transfer command.  The response to this command includes the
            host and port address this server is listening on.

         REPRESENTATION TYPE (TYPE)

            The argument specifies the representation type as described
            in the Section on Data Representation and Storage.  Several
            types take a second parameter.  The first parameter is
            denoted by a single Telnet character, as is the second
            Format parameter for ASCII and EBCDIC; the second parameter
            for local byte is a decimal integer to indicate Bytesize.
            The parameters are separated by a <SP> (Space, ASCII code
            32).

            The following codes are assigned for type:

                         \    /
               A - ASCII |    | N - Non-print
                         |-><-| T - Telnet format effectors
               E - EBCDIC|    | C - Carriage Control (ASA)
                         /    \
               I - Image

               L <byte size> - Local byte Byte size


Postel & Reynolds                                              [Page 28]

RFC 959                                                     October 1985
File Transfer Protocol


            The default representation type is ASCII Non-print.  If the
            Format parameter is changed, and later just the first
            argument is changed, Format then returns to the Non-print
            default.

         FILE STRUCTURE (STRU)

            The argument is a single Telnet character code specifying
            file structure described in the Section on Data
            Representation and Storage.

            The following codes are assigned for structure:

               F - File (no record structure)
               R - Record structure
               P - Page structure

            The default structure is File.

         TRANSFER MODE (MODE)

            The argument is a single Telnet character code specifying
            the data transfer modes described in the Section on
            Transmission Modes.

            The following codes are assigned for transfer modes:

               S - Stream
               B - Block
               C - Compressed

            The default transfer mode is Stream.

      4.1.3.  FTP SERVICE COMMANDS

         The FTP service commands define the file transfer or the file
         system function requested by the user.  The argument of an FTP
         service command will normally be a pathname.  The syntax of
         pathnames must conform to server site conventions (with
         standard defaults applicable), and the language conventions of
         the control connection.  The suggested default handling is to
         use the last specified device, directory or file name, or the
         standard default defined for local users.  The commands may be
         in any order except that a ""rename from"" command must be
         followed by a ""rename to"" command and the restart command must
         be followed by the interrupted service command (e.g., STOR or
         RETR).  The data, when transferred in response to FTP service


Postel & Reynolds                                              [Page 29]

RFC 959                                                     October 1985
File Transfer Protocol


         commands, shall always be sent over the data connection, except
         for certain informative replies.  The following commands
         specify FTP service requests:

         RETRIEVE (RETR)

            This command causes the server-DTP to transfer a copy of the
            file, specified in the pathname, to the server- or user-DTP
            at the other end of the data connection.  The status and
            contents of the file at the server site shall be unaffected.

         STORE (STOR)

            This command causes the server-DTP to accept the data
            transferred via the data connection and to store the data as
            a file at the server site.  If the file specified in the
            pathname exists at the server site, then its contents shall
            be replaced by the data being transferred.  A new file is
            created at the server site if the file specified in the
            pathname does not already exist.

         STORE UNIQUE (STOU)

            This command behaves like STOR except that the resultant
            file is to be created in the current directory under a name
            unique to that directory.  The 250 Transfer Started response
            must include the name generated.

         APPEND (with create) (APPE)

            This command causes the server-DTP to accept the data
            transferred via the data connection and to store the data in
            a file at the server site.  If the file specified in the
            pathname exists at the server site, then the data shall be
            appended to that file; otherwise the file specified in the
            pathname shall be created at the server site.

         ALLOCATE (ALLO)

            This command may be required by some servers to reserve
            sufficient storage to accommodate the new file to be
            transferred.  The argument shall be a decimal integer
            representing the number of bytes (using the logical byte
            size) of storage to be reserved for the file.  For files
            sent with record or page structure a maximum record or page
            size (in logical bytes) might also be necessary; this is
            indicated by a decimal integer in a second argument field of


Postel & Reynolds                                              [Page 30]

RFC 959                                                     October 1985
File Transfer Protocol


            the command.  This second argument is optional, but when
            present should be separated from the first by the three
            Telnet characters <SP> R <SP>.  This command shall be
            followed by a STORe or APPEnd command.  The ALLO command
            should be treated as a NOOP (no operation) by those servers
            which do not require that the maximum size of the file be
            declared beforehand, and those servers interested in only
            the maximum record or page size should accept a dummy value
            in the first argument and ignore it.

         RESTART (REST)

            The argument field represents the server marker at which
            file transfer is to be restarted.  This command does not
            cause file transfer but skips over the file to the specified
            data checkpoint.  This command shall be immediately followed
            by the appropriate FTP service command which shall cause
            file transfer to resume.

         RENAME FROM (RNFR)

            This command specifies the old pathname of the file which is
            to be renamed.  This command must be immediately followed by
            a ""rename to"" command specifying the new file pathname.

         RENAME TO (RNTO)

            This command specifies the new pathname of the file
            specified in the immediately preceding ""rename from""
            command.  Together the two commands cause a file to be
            renamed.

         ABORT (ABOR)

            This command tells the server to abort the previous FTP
            service command and any associated transfer of data.  The
            abort command may require ""special action"", as discussed in
            the Section on FTP Commands, to force recognition by the
            server.  No action is to be taken if the previous command
            has been completed (including data transfer).  The control
            connection is not to be closed by the server, but the data
            connection must be closed.

            There are two cases for the server upon receipt of this
            command: (1) the FTP service command was already completed,
            or (2) the FTP service command is still in progress.



Postel & Reynolds                                              [Page 31]

RFC 959                                                     October 1985
File Transfer Protocol


               In the first case, the server closes the data connection
               (if it is open) and responds with a 226 reply, indicating
               that the abort command was successfully processed.

               In the second case, the server aborts the FTP service in
               progress and closes the data connection, returning a 426
               reply to indicate that the service request terminated
               abnormally.  The server then sends a 226 reply,
               indicating that the abort command was successfully
               processed.

         DELETE (DELE)

            This command causes the file specified in the pathname to be
            deleted at the server site.  If an extra level of protection
            is desired (such as the query, ""Do you really wish to
            delete?""), it should be provided by the user-FTP process.

         REMOVE DIRECTORY (RMD)

            This command causes the directory specified in the pathname
            to be removed as a directory (if the pathname is absolute)
            or as a subdirectory of the current working directory (if
            the pathname is relative).  See Appendix II.

         MAKE DIRECTORY (MKD)

            This command causes the directory specified in the pathname
            to be created as a directory (if the pathname is absolute)
            or as a subdirectory of the current working directory (if
            the pathname is relative).  See Appendix II.

         PRINT WORKING DIRECTORY (PWD)

            This command causes the name of the current working
            directory to be returned in the reply.  See Appendix II.

         LIST (LIST)

            This command causes a list to be sent from the server to the
            passive DTP.  If the pathname specifies a directory or other
            group of files, the server should transfer a list of files
            in the specified directory.  If the pathname specifies a
            file then the server should send current information on the
            file.  A null argument implies the user's current working or
            default directory.  The data transfer is over the data
            connection in type ASCII or type EBCDIC.  (The user must


Postel & Reynolds                                              [Page 32]

RFC 959                                                     October 1985
File Transfer Protocol


            ensure that the TYPE is appropriately ASCII or EBCDIC).
            Since the information on a file may vary widely from system
            to system, this information may be hard to use automatically
            in a program, but may be quite useful to a human user.

         NAME LIST (NLST)

            This command causes a directory listing to be sent from
            server to user site.  The pathname should specify a
            directory or other system-specific file group descriptor; a
            null argument implies the current directory.  The server
            will return a stream of names of files and no other
            information.  The data will be transferred in ASCII or
            EBCDIC type over the data connection as valid pathname
            strings separated by <CRLF> or <NL>.  (Again the user must
            ensure that the TYPE is correct.)  This command is intended
            to return information that can be used by a program to
            further process the files automatically.  For example, in
            the implementation of a ""multiple get"" function.

         SITE PARAMETERS (SITE)

            This command is used by the server to provide services
            specific to his system that are essential to file transfer
            but not sufficiently universal to be included as commands in
            the protocol.  The nature of these services and the
            specification of their syntax can be stated in a reply to
            the HELP SITE command.

         SYSTEM (SYST)

            This command is used to find out the type of operating
            system at the server.  The reply shall have as its first
            word one of the system names listed in the current version
            of the Assigned Numbers document [4].

         STATUS (STAT)

            This command shall cause a status response to be sent over
            the control connection in the form of a reply.  The command
            may be sent during a file transfer (along with the Telnet IP
            and Synch signals--see the Section on FTP Commands) in which
            case the server will respond with the status of the
            operation in progress, or it may be sent between file
            transfers.  In the latter case, the command may have an
            argument field.  If the argument is a pathname, the command
            is analogous to the ""list"" command except that data shall be


Postel & Reynolds                                              [Page 33]

RFC 959                                                     October 1985
File Transfer Protocol


            transferred over the control connection.  If a partial
            pathname is given, the server may respond with a list of
            file names or attributes associated with that specification.
            If no argument is given, the server should return general
            status information about the server FTP process.  This
            should include current values of all transfer parameters and
            the status of connections.

         HELP (HELP)

            This command shall cause the server to send helpful
            information regarding its implementation status over the
            control connection to the user.  The command may take an
            argument (e.g., any command name) and return more specific
            information as a response.  The reply is type 211 or 214.
            It is suggested that HELP be allowed before entering a USER
            command. The server may use this reply to specify
            site-dependent parameters, e.g., in response to HELP SITE.

         NOOP (NOOP)

            This command does not affect any parameters or previously
            entered commands. It specifies no action other than that the
            server send an OK reply.

   The File Transfer Protocol follows the specifications of the Telnet
   protocol for all communications over the control connection.  Since
   the language used for Telnet communication may be a negotiated
   option, all references in the next two sections will be to the
   ""Telnet language"" and the corresponding ""Telnet end-of-line code"".
   Currently, one may take these to mean NVT-ASCII and <CRLF>.  No other
   specifications of the Telnet protocol will be cited.

   FTP commands are ""Telnet strings"" terminated by the ""Telnet end of
   line code"".  The command codes themselves are alphabetic characters
   terminated by the character <SP> (Space) if parameters follow and
   Telnet-EOL otherwise.  The command codes and the semantics of
   commands are described in this section; the detailed syntax of
   commands is specified in the Section on Commands, the reply sequences
   are discussed in the Section on Sequencing of Commands and Replies,
   and scenarios illustrating the use of commands are provided in the
   Section on Typical FTP Scenarios.

   FTP commands may be partitioned as those specifying access-control
   identifiers, data transfer parameters, or FTP service requests.
   Certain commands (such as ABOR, STAT, QUIT) may be sent over the
   control connection while a data transfer is in progress.  Some


Postel & Reynolds                                              [Page 34]

RFC 959                                                     October 1985
File Transfer Protocol


   servers may not be able to monitor the control and data connections
   simultaneously, in which case some special action will be necessary
   to get the server's attention.  The following ordered format is
   tentatively recommended:

      1. User system inserts the Telnet ""Interrupt Process"" (IP) signal
      in the Telnet stream.

      2. User system sends the Telnet ""Synch"" signal.

      3. User system inserts the command (e.g., ABOR) in the Telnet
      stream.

      4. Server PI, after receiving ""IP"", scans the Telnet stream for
      EXACTLY ONE FTP command.

   (For other servers this may not be necessary but the actions listed
   above should have no unusual effect.)

   4.2.  FTP REPLIES

      Replies to File Transfer Protocol commands are devised to ensure
      the synchronization of requests and actions in the process of file
      transfer, and to guarantee that the user process always knows the
      state of the Server.  Every command must generate at least one
      reply, although there may be more than one; in the latter case,
      the multiple replies must be easily distinguished.  In addition,
      some commands occur in sequential groups, such as USER, PASS and
      ACCT, or RNFR and RNTO.  The replies show the existence of an
      intermediate state if all preceding commands have been successful.
      A failure at any point in the sequence necessitates the repetition
      of the entire sequence from the beginning.

         The details of the command-reply sequence are made explicit in
         a set of state diagrams below.

      An FTP reply consists of a three digit number (transmitted as
      three alphanumeric characters) followed by some text.  The number
      is intended for use by automata to determine what state to enter
      next; the text is intended for the human user.  It is intended
      that the three digits contain enough encoded information that the
      user-process (the User-PI) will not need to examine the text and
      may either discard it or pass it on to the user, as appropriate.
      In particular, the text may be server-dependent, so there are
      likely to be varying texts for each reply code.

      A reply is defined to contain the 3-digit code, followed by Space


Postel & Reynolds                                              [Page 35]

RFC 959                                                     October 1985
File Transfer Protocol


      <SP>, followed by one line of text (where some maximum line length
      has been specified), and terminated by the Telnet end-of-line
      code.  There will be cases however, where the text is longer than
      a single line.  In these cases the complete text must be bracketed
      so the User-process knows when it may stop reading the reply (i.e.
      stop processing input on the control connection) and go do other
      things.  This requires a special format on the first line to
      indicate that more than one line is coming, and another on the
      last line to designate it as the last.  At least one of these must
      contain the appropriate reply code to indicate the state of the
      transaction.  To satisfy all factions, it was decided that both
      the first and last line codes should be the same.

         Thus the format for multi-line replies is that the first line
         will begin with the exact required reply code, followed
         immediately by a Hyphen, ""-"" (also known as Minus), followed by
         text.  The last line will begin with the same code, followed
         immediately by Space <SP>, optionally some text, and the Telnet
         end-of-line code.

            For example:
                                123-First line
                                Second line
                                  234 A line beginning with numbers
                                123 The last line

         The user-process then simply needs to search for the second
         occurrence of the same reply code, followed by <SP> (Space), at
         the beginning of a line, and ignore all intermediary lines.  If
         an intermediary line begins with a 3-digit number, the Server
         must pad the front  to avoid confusion.

            This scheme allows standard system routines to be used for
            reply information (such as for the STAT reply), with
            ""artificial"" first and last lines tacked on.  In rare cases
            where these routines are able to generate three digits and a
            Space at the beginning of any line, the beginning of each
            text line should be offset by some neutral text, like Space.

         This scheme assumes that multi-line replies may not be nested.

      The three digits of the reply each have a special significance.
      This is intended to allow a range of very simple to very
      sophisticated responses by the user-process.  The first digit
      denotes whether the response is good, bad or incomplete.
      (Referring to the state diagram), an unsophisticated user-process
      will be able to determine its next action (proceed as planned,


Postel & Reynolds                                              [Page 36]

RFC 959                                                     October 1985
File Transfer Protocol


      redo, retrench, etc.) by simply examining this first digit.  A
      user-process that wants to know approximately what kind of error
      occurred (e.g. file system error, command syntax error) may
      examine the second digit, reserving the third digit for the finest
      gradation of information (e.g., RNTO command without a preceding
      RNFR).

         There are five values for the first digit of the reply code:

            1yz   Positive Preliminary reply

               The requested action is being initiated; expect another
               reply before proceeding with a new command.  (The
               user-process sending another command before the
               completion reply would be in violation of protocol; but
               server-FTP processes should queue any commands that
               arrive while a preceding command is in progress.)  This
               type of reply can be used to indicate that the command
               was accepted and the user-process may now pay attention
               to the data connections, for implementations where
               simultaneous monitoring is difficult.  The server-FTP
               process may send at most, one 1yz reply per command.

            2yz   Positive Completion reply

               The requested action has been successfully completed.  A
               new request may be initiated.

            3yz   Positive Intermediate reply

               The command has been accepted, but the requested action
               is being held in abeyance, pending receipt of further
               information.  The user should send another command
               specifying this information.  This reply is used in
               command sequence groups.

            4yz   Transient Negative Completion reply

               The command was not accepted and the requested action did
               not take place, but the error condition is temporary and
               the action may be requested again.  The user should
               return to the beginning of the command sequence, if any.
               It is difficult to assign a meaning to ""transient"",
               particularly when two distinct sites (Server- and
               User-processes) have to agree on the interpretation.
               Each reply in the 4yz category might have a slightly
               different time value, but the intent is that the


Postel & Reynolds                                              [Page 37]

RFC 959                                                     October 1985
File Transfer Protocol


               user-process is encouraged to try again.  A rule of thumb
               in determining if a reply fits into the 4yz or the 5yz
               (Permanent Negative) category is that replies are 4yz if
               the commands can be repeated without any change in
               command form or in properties of the User or Server
               (e.g., the command is spelled the same with the same
               arguments used; the user does not change his file access
               or user name; the server does not put up a new
               implementation.)

            5yz   Permanent Negative Completion reply

               The command was not accepted and the requested action did
               not take place.  The User-process is discouraged from
               repeating the exact request (in the same sequence).  Even
               some ""permanent"" error conditions can be corrected, so
               the human user may want to direct his User-process to
               reinitiate the command sequence by direct action at some
               point in the future (e.g., after the spelling has been
               changed, or the user has altered his directory status.)

         The following function groupings are encoded in the second
         digit:

            x0z   Syntax - These replies refer to syntax errors,
                  syntactically correct commands that don't fit any
                  functional category, unimplemented or superfluous
                  commands.

            x1z   Information -  These are replies to requests for
                  information, such as status or help.

            x2z   Connections - Replies referring to the control and
                  data connections.

            x3z   Authentication and accounting - Replies for the login
                  process and accounting procedures.

            x4z   Unspecified as yet.

            x5z   File system - These replies indicate the status of the
                  Server file system vis-a-vis the requested transfer or
                  other file system action.

         The third digit gives a finer gradation of meaning in each of
         the function categories, specified by the second digit.  The
         list of replies below will illustrate this.  Note that the text


Postel & Reynolds                                              [Page 38]

RFC 959                                                     October 1985
File Transfer Protocol


         associated with each reply is recommended, rather than
         mandatory, and may even change according to the command with
         which it is associated.  The reply codes, on the other hand,
         must strictly follow the specifications in the last section;
         that is, Server implementations should not invent new codes for
         situations that are only slightly different from the ones
         described here, but rather should adapt codes already defined.

            A command such as TYPE or ALLO whose successful execution
            does not offer the user-process any new information will
            cause a 200 reply to be returned.  If the command is not
            implemented by a particular Server-FTP process because it
            has no relevance to that computer system, for example ALLO
            at a TOPS20 site, a Positive Completion reply is still
            desired so that the simple User-process knows it can proceed
            with its course of action.  A 202 reply is used in this case
            with, for example, the reply text:  ""No storage allocation
            necessary.""  If, on the other hand, the command requests a
            non-site-specific action and is unimplemented, the response
            is 502.  A refinement of that is the 504 reply for a command
            that is implemented, but that requests an unimplemented
            parameter.

      4.2.1  Reply Codes by Function Groups

         200 Command okay.
         500 Syntax error, command unrecognized.
             This may include errors such as command line too long.
         501 Syntax error in parameters or arguments.
         202 Command not implemented, superfluous at this site.
         502 Command not implemented.
         503 Bad sequence of commands.
         504 Command not implemented for that parameter.
















Postel & Reynolds                                              [Page 39]

RFC 959                                                     October 1985
File Transfer Protocol


         110 Restart marker reply.
             In this case, the text is exact and not left to the
             particular implementation; it must read:
                  MARK yyyy = mmmm
             Where yyyy is User-process data stream marker, and mmmm
             server's equivalent marker (note the spaces between markers
             and ""="").
         211 System status, or system help reply.
         212 Directory status.
         213 File status.
         214 Help message.
             On how to use the server or the meaning of a particular
             non-standard command.  This reply is useful only to the
             human user.
         215 NAME system type.
             Where NAME is an official system name from the list in the
             Assigned Numbers document.

         120 Service ready in nnn minutes.
         220 Service ready for new user.
         221 Service closing control connection.
             Logged out if appropriate.
         421 Service not available, closing control connection.
             This may be a reply to any command if the service knows it
             must shut down.
         125 Data connection already open; transfer starting.
         225 Data connection open; no transfer in progress.
         425 Can't open data connection.
         226 Closing data connection.
             Requested file action successful (for example, file
             transfer or file abort).
         426 Connection closed; transfer aborted.
         227 Entering Passive Mode (h1,h2,h3,h4,p1,p2).

         230 User logged in, proceed.
         530 Not logged in.
         331 User name okay, need password.
         332 Need account for login.
         532 Need account for storing files.










Postel & Reynolds                                              [Page 40]

RFC 959                                                     October 1985
File Transfer Protocol


         150 File status okay; about to open data connection.
         250 Requested file action okay, completed.
         257 ""PATHNAME"" created.
         350 Requested file action pending further information.
         450 Requested file action not taken.
             File unavailable (e.g., file busy).
         550 Requested action not taken.
             File unavailable (e.g., file not found, no access).
         451 Requested action aborted. Local error in processing.
         551 Requested action aborted. Page type unknown.
         452 Requested action not taken.
             Insufficient storage space in system.
         552 Requested file action aborted.
             Exceeded storage allocation (for current directory or
             dataset).
         553 Requested action not taken.
             File name not allowed.


      4.2.2 Numeric  Order List of Reply Codes

         110 Restart marker reply.
             In this case, the text is exact and not left to the
             particular implementation; it must read:
                  MARK yyyy = mmmm
             Where yyyy is User-process data stream marker, and mmmm
             server's equivalent marker (note the spaces between markers
             and ""="").
         120 Service ready in nnn minutes.
         125 Data connection already open; transfer starting.
         150 File status okay; about to open data connection.


















Postel & Reynolds                                              [Page 41]

RFC 959                                                     October 1985
File Transfer Protocol


         200 Command okay.
         202 Command not implemented, superfluous at this site.
         211 System status, or system help reply.
         212 Directory status.
         213 File status.
         214 Help message.
             On how to use the server or the meaning of a particular
             non-standard command.  This reply is useful only to the
             human user.
         215 NAME system type.
             Where NAME is an official system name from the list in the
             Assigned Numbers document.
         220 Service ready for new user.
         221 Service closing control connection.
             Logged out if appropriate.
         225 Data connection open; no transfer in progress.
         226 Closing data connection.
             Requested file action successful (for example, file
             transfer or file abort).
         227 Entering Passive Mode (h1,h2,h3,h4,p1,p2).
         230 User logged in, proceed.
         250 Requested file action okay, completed.
         257 ""PATHNAME"" created.

         331 User name okay, need password.
         332 Need account for login.
         350 Requested file action pending further information.

         421 Service not available, closing control connection.
             This may be a reply to any command if the service knows it
             must shut down.
         425 Can't open data connection.
         426 Connection closed; transfer aborted.
         450 Requested file action not taken.
             File unavailable (e.g., file busy).
         451 Requested action aborted: local error in processing.
         452 Requested action not taken.
             Insufficient storage space in system.











Postel & Reynolds                                              [Page 42]

RFC 959                                                     October 1985
File Transfer Protocol


         500 Syntax error, command unrecognized.
             This may include errors such as command line too long.
         501 Syntax error in parameters or arguments.
         502 Command not implemented.
         503 Bad sequence of commands.
         504 Command not implemented for that parameter.
         530 Not logged in.
         532 Need account for storing files.
         550 Requested action not taken.
             File unavailable (e.g., file not found, no access).
         551 Requested action aborted: page type unknown.
         552 Requested file action aborted.
             Exceeded storage allocation (for current directory or
             dataset).
         553 Requested action not taken.
             File name not allowed.


5.  DECLARATIVE SPECIFICATIONS

   5.1.  MINIMUM IMPLEMENTATION

      In order to make FTP workable without needless error messages, the
      following minimum implementation is required for all servers:

         TYPE - ASCII Non-print
         MODE - Stream
         STRUCTURE - File, Record
         COMMANDS - USER, QUIT, PORT,
                    TYPE, MODE, STRU,
                      for the default values
                    RETR, STOR,
                    NOOP.

      The default values for transfer parameters are:

         TYPE - ASCII Non-print
         MODE - Stream
         STRU - File

      All hosts must accept the above as the standard defaults.








Postel & Reynolds                                              [Page 43]

RFC 959                                                     October 1985
File Transfer Protocol


   5.2.  CONNECTIONS

      The server protocol interpreter shall ""listen"" on Port L.  The
      user or user protocol interpreter shall initiate the full-duplex
      control connection.  Server- and user- processes should follow the
      conventions of the Telnet protocol as specified in the
      ARPA-Internet Protocol Handbook [1].  Servers are under no
      obligation to provide for editing of command lines and may require
      that it be done in the user host.  The control connection shall be
      closed by the server at the user's request after all transfers and
      replies are completed.

      The user-DTP must ""listen"" on the specified data port; this may be
      the default user port (U) or a port specified in the PORT command.
      The server shall initiate the data connection from his own default
      data port (L-1) using the specified user data port.  The direction
      of the transfer and the port used will be determined by the FTP
      service command.

      Note that all FTP implementation must support data transfer using
      the default port, and that only the USER-PI may initiate the use
      of non-default ports.

      When data is to be transferred between two servers, A and B (refer
      to Figure 2), the user-PI, C, sets up control connections with
      both server-PI's.  One of the servers, say A, is then sent a PASV
      command telling him to ""listen"" on his data port rather than
      initiate a connection when he receives a transfer service command.
      When the user-PI receives an acknowledgment to the PASV command,
      which includes the identity of the host and port being listened
      on, the user-PI then sends A's port, a, to B in a PORT command; a
      reply is returned.  The user-PI may then send the corresponding
      service commands to A and B.  Server B initiates the connection
      and the transfer proceeds.  The command-reply sequence is listed
      below where the messages are vertically synchronous but
      horizontally asynchronous:













Postel & Reynolds                                              [Page 44]

RFC 959                                                     October 1985
File Transfer Protocol


         User-PI - Server A                User-PI - Server B
         ------------------                ------------------

         C->A : Connect                    C->B : Connect
         C->A : PASV
         A->C : 227 Entering Passive Mode. A1,A2,A3,A4,a1,a2
                                           C->B : PORT A1,A2,A3,A4,a1,a2
                                           B->C : 200 Okay
         C->A : STOR                       C->B : RETR
                    B->A : Connect to HOST-A, PORT-a

                                Figure 3

      The data connection shall be closed by the server under the
      conditions described in the Section on Establishing Data
      Connections.  If the data connection is to be closed following a
      data transfer where closing the connection is not required to
      indicate the end-of-file, the server must do so immediately.
      Waiting until after a new transfer command is not permitted
      because the user-process will have already tested the data
      connection to see if it needs to do a ""listen""; (remember that the
      user must ""listen"" on a closed data port BEFORE sending the
      transfer request).  To prevent a race condition here, the server
      sends a reply (226) after closing the data connection (or if the
      connection is left open, a ""file transfer completed"" reply (250)
      and the user-PI should wait for one of these replies before
      issuing a new transfer command).

      Any time either the user or server see that the connection is
      being closed by the other side, it should promptly read any
      remaining data queued on the connection and issue the close on its
      own side.

   5.3.  COMMANDS

      The commands are Telnet character strings transmitted over the
      control connections as described in the Section on FTP Commands.
      The command functions and semantics are described in the Section
      on Access Control Commands, Transfer Parameter Commands, FTP
      Service Commands, and Miscellaneous Commands.  The command syntax
      is specified here.

      The commands begin with a command code followed by an argument
      field.  The command codes are four or fewer alphabetic characters.
      Upper and lower case alphabetic characters are to be treated
      identically.  Thus, any of the following may represent the
      retrieve command:


Postel & Reynolds                                              [Page 45]

RFC 959                                                     October 1985
File Transfer Protocol


                  RETR    Retr    retr    ReTr    rETr

      This also applies to any symbols representing parameter values,
      such as A or a for ASCII TYPE.  The command codes and the argument
      fields are separated by one or more spaces.

      The argument field consists of a variable length character string
      ending with the character sequence <CRLF> (Carriage Return, Line
      Feed) for NVT-ASCII representation; for other negotiated languages
      a different end of line character might be used.  It should be
      noted that the server is to take no action until the end of line
      code is received.

      The syntax is specified below in NVT-ASCII.  All characters in the
      argument field are ASCII characters including any ASCII
      represented decimal integers.  Square brackets denote an optional
      argument field.  If the option is not taken, the appropriate
      default is implied.































Postel & Reynolds                                              [Page 46]

RFC 959                                                     October 1985
File Transfer Protocol


      5.3.1.  FTP COMMANDS

         The following are the FTP commands:

            USER <SP> <username> <CRLF>
            PASS <SP> <password> <CRLF>
            ACCT <SP> <account-information> <CRLF>
            CWD  <SP> <pathname> <CRLF>
            CDUP <CRLF>
            SMNT <SP> <pathname> <CRLF>
            QUIT <CRLF>
            REIN <CRLF>
            PORT <SP> <host-port> <CRLF>
            PASV <CRLF>
            TYPE <SP> <type-code> <CRLF>
            STRU <SP> <structure-code> <CRLF>
            MODE <SP> <mode-code> <CRLF>
            RETR <SP> <pathname> <CRLF>
            STOR <SP> <pathname> <CRLF>
            STOU <CRLF>
            APPE <SP> <pathname> <CRLF>
            ALLO <SP> <decimal-integer>
                [<SP> R <SP> <decimal-integer>] <CRLF>
            REST <SP> <marker> <CRLF>
            RNFR <SP> <pathname> <CRLF>
            RNTO <SP> <pathname> <CRLF>
            ABOR <CRLF>
            DELE <SP> <pathname> <CRLF>
            RMD  <SP> <pathname> <CRLF>
            MKD  <SP> <pathname> <CRLF>
            PWD  <CRLF>
            LIST [<SP> <pathname>] <CRLF>
            NLST [<SP> <pathname>] <CRLF>
            SITE <SP> <string> <CRLF>
            SYST <CRLF>
            STAT [<SP> <pathname>] <CRLF>
            HELP [<SP> <string>] <CRLF>
            NOOP <CRLF>











Postel & Reynolds                                              [Page 47]

RFC 959                                                     October 1985
File Transfer Protocol


      5.3.2.  FTP COMMAND ARGUMENTS

         The syntax of the above argument fields (using BNF notation
         where applicable) is:

            <username> ::= <string>
            <password> ::= <string>
            <account-information> ::= <string>
            <string> ::= <char> | <char><string>
            <char> ::= any of the 128 ASCII characters except <CR> and
            <LF>
            <marker> ::= <pr-string>
            <pr-string> ::= <pr-char> | <pr-char><pr-string>
            <pr-char> ::= printable characters, any
                          ASCII code 33 through 126
            <byte-size> ::= <number>
            <host-port> ::= <host-number>,<port-number>
            <host-number> ::= <number>,<number>,<number>,<number>
            <port-number> ::= <number>,<number>
            <number> ::= any decimal integer 1 through 255
            <form-code> ::= N | T | C
            <type-code> ::= A [<sp> <form-code>]
                          | E [<sp> <form-code>]
                          | I
                          | L <sp> <byte-size>
            <structure-code> ::= F | R | P
            <mode-code> ::= S | B | C
            <pathname> ::= <string>
            <decimal-integer> ::= any decimal integer




















Postel & Reynolds                                              [Page 48]

RFC 959                                                     October 1985
File Transfer Protocol


   5.4.  SEQUENCING OF COMMANDS AND REPLIES

      The communication between the user and server is intended to be an
      alternating dialogue.  As such, the user issues an FTP command and
      the server responds with a prompt primary reply.  The user should
      wait for this initial primary success or failure response before
      sending further commands.

      Certain commands require a second reply for which the user should
      also wait.  These replies may, for example, report on the progress
      or completion of file transfer or the closing of the data
      connection.  They are secondary replies to file transfer commands.

      One important group of informational replies is the connection
      greetings.  Under normal circumstances, a server will send a 220
      reply, ""awaiting input"", when the connection is completed.  The
      user should wait for this greeting message before sending any
      commands.  If the server is unable to accept input right away, a
      120 ""expected delay"" reply should be sent immediately and a 220
      reply when ready.  The user will then know not to hang up if there
      is a delay.

      Spontaneous Replies

         Sometimes ""the system"" spontaneously has a message to be sent
         to a user (usually all users).  For example, ""System going down
         in 15 minutes"".  There is no provision in FTP for such
         spontaneous information to be sent from the server to the user.
         It is recommended that such information be queued in the
         server-PI and delivered to the user-PI in the next reply
         (possibly making it a multi-line reply).

      The table below lists alternative success and failure replies for
      each command.  These must be strictly adhered to; a server may
      substitute text in the replies, but the meaning and action implied
      by the code numbers and by the specific command reply sequence
      cannot be altered.

      Command-Reply Sequences

         In this section, the command-reply sequence is presented.  Each
         command is listed with its possible replies; command groups are
         listed together.  Preliminary replies are listed first (with
         their succeeding replies indented and under them), then
         positive and negative completion, and finally intermediary




Postel & Reynolds                                              [Page 49]

RFC 959                                                     October 1985
File Transfer Protocol


         replies with the remaining commands from the sequence
         following.  This listing forms the basis for the state
         diagrams, which will be presented separately.

            Connection Establishment
               120
                  220
               220
               421
            Login
               USER
                  230
                  530
                  500, 501, 421
                  331, 332
               PASS
                  230
                  202
                  530
                  500, 501, 503, 421
                  332
               ACCT
                  230
                  202
                  530
                  500, 501, 503, 421
               CWD
                  250
                  500, 501, 502, 421, 530, 550
               CDUP
                  200
                  500, 501, 502, 421, 530, 550
               SMNT
                  202, 250
                  500, 501, 502, 421, 530, 550
            Logout
               REIN
                  120
                     220
                  220
                  421
                  500, 502
               QUIT
                  221
                  500




Postel & Reynolds                                              [Page 50]

RFC 959                                                     October 1985
File Transfer Protocol


            Transfer parameters
               PORT
                  200
                  500, 501, 421, 530
               PASV
                  227
                  500, 501, 502, 421, 530
               MODE
                  200
                  500, 501, 504, 421, 530
               TYPE
                  200
                  500, 501, 504, 421, 530
               STRU
                  200
                  500, 501, 504, 421, 530
            File action commands
               ALLO
                  200
                  202
                  500, 501, 504, 421, 530
               REST
                  500, 501, 502, 421, 530
                  350
               STOR
                  125, 150
                     (110)
                     226, 250
                     425, 426, 451, 551, 552
                  532, 450, 452, 553
                  500, 501, 421, 530
               STOU
                  125, 150
                     (110)
                     226, 250
                     425, 426, 451, 551, 552
                  532, 450, 452, 553
                  500, 501, 421, 530
               RETR
                  125, 150
                     (110)
                     226, 250
                     425, 426, 451
                  450, 550
                  500, 501, 421, 530




Postel & Reynolds                                              [Page 51]

RFC 959                                                     October 1985
File Transfer Protocol


               LIST
                  125, 150
                     226, 250
                     425, 426, 451
                  450
                  500, 501, 502, 421, 530
               NLST
                  125, 150
                     226, 250
                     425, 426, 451
                  450
                  500, 501, 502, 421, 530
               APPE
                  125, 150
                     (110)
                     226, 250
                     425, 426, 451, 551, 552
                  532, 450, 550, 452, 553
                  500, 501, 502, 421, 530
               RNFR
                  450, 550
                  500, 501, 502, 421, 530
                  350
               RNTO
                  250
                  532, 553
                  500, 501, 502, 503, 421, 530
               DELE
                  250
                  450, 550
                  500, 501, 502, 421, 530
               RMD
                  250
                  500, 501, 502, 421, 530, 550
               MKD
                  257
                  500, 501, 502, 421, 530, 550
               PWD
                  257
                  500, 501, 502, 421, 550
               ABOR
                  225, 226
                  500, 501, 502, 421






Postel & Reynolds                                              [Page 52]

RFC 959                                                     October 1985
File Transfer Protocol


            Informational commands
               SYST
                  215
                  500, 501, 502, 421
               STAT
                  211, 212, 213
                  450
                  500, 501, 502, 421, 530
               HELP
                  211, 214
                  500, 501, 502, 421
            Miscellaneous commands
               SITE
                  200
                  202
                  500, 501, 530
               NOOP
                  200
                  500 421






























Postel & Reynolds                                              [Page 53]

RFC 959                                                     October 1985
File Transfer Protocol


6.  STATE DIAGRAMS

   Here we present state diagrams for a very simple minded FTP
   implementation.  Only the first digit of the reply codes is used.
   There is one state diagram for each group of FTP commands or command
   sequences.

   The command groupings were determined by constructing a model for
   each command then collecting together the commands with structurally
   identical models.

   For each command or command sequence there are three possible
   outcomes: success (S), failure (F), and error (E).  In the state
   diagrams below we use the symbol B for ""begin"", and the symbol W for
   ""wait for reply"".

   We first present the diagram that represents the largest group of FTP
   commands:


                               1,3    +---+
                          ----------->| E |
                         |            +---+
                         |
      +---+    cmd    +---+    2      +---+
      | B |---------->| W |---------->| S |
      +---+           +---+           +---+
                         |
                         |     4,5    +---+
                          ----------->| F |
                                      +---+


      This diagram models the commands:

         ABOR, ALLO, DELE, CWD, CDUP, SMNT, HELP, MODE, NOOP, PASV,
         QUIT, SITE, PORT, SYST, STAT, RMD, MKD, PWD, STRU, and TYPE.












Postel & Reynolds                                              [Page 54]

RFC 959                                                     October 1985
File Transfer Protocol


   The other large group of commands is represented by a very similar
   diagram:


                               3      +---+
                          ----------->| E |
                         |            +---+
                         |
      +---+    cmd    +---+    2      +---+
      | B |---------->| W |---------->| S |
      +---+       --->+---+           +---+
                 |     | |
                 |     | |     4,5    +---+
                 |  1  |  ----------->| F |
                  -----               +---+


      This diagram models the commands:

         APPE, LIST, NLST, REIN, RETR, STOR, and STOU.

   Note that this second model could also be used to represent the first
   group of commands, the only difference being that in the first group
   the 100 series replies are unexpected and therefore treated as error,
   while the second group expects (some may require) 100 series replies.
   Remember that at most, one 100 series reply is allowed per command.

   The remaining diagrams model command sequences, perhaps the simplest
   of these is the rename sequence:


      +---+   RNFR    +---+    1,2    +---+
      | B |---------->| W |---------->| E |
      +---+           +---+        -->+---+
                       | |        |
                3      | | 4,5    |
         --------------  ------   |
        |                      |  |   +---+
        |               ------------->| S |
        |              |   1,3 |  |   +---+
        |             2|  --------
        |              | |     |
        V              | |     |
      +---+   RNTO    +---+ 4,5 ----->+---+
      |   |---------->| W |---------->| F |
      +---+           +---+           +---+



Postel & Reynolds                                              [Page 55]

RFC 959                                                     October 1985
File Transfer Protocol


   The next diagram is a simple model of the Restart command:


      +---+   REST    +---+    1,2    +---+
      | B |---------->| W |---------->| E |
      +---+           +---+        -->+---+
                       | |        |
                3      | | 4,5    |
         --------------  ------   |
        |                      |  |   +---+
        |               ------------->| S |
        |              |   3   |  |   +---+
        |             2|  --------
        |              | |     |
        V              | |     |
      +---+   cmd     +---+ 4,5 ----->+---+
      |   |---------->| W |---------->| F |
      +---+        -->+---+           +---+
                  |      |
                  |  1   |
                   ------


         Where ""cmd"" is APPE, STOR, or RETR.

   We note that the above three models are similar.  The Restart differs
   from the Rename two only in the treatment of 100 series replies at
   the second stage, while the second group expects (some may require)
   100 series replies.  Remember that at most, one 100 series reply is
   allowed per command.



















Postel & Reynolds                                              [Page 56]

RFC 959                                                     October 1985
File Transfer Protocol


   The most complicated diagram is for the Login sequence:


                            1
      +---+   USER    +---+------------->+---+
      | B |---------->| W | 2       ---->| E |
      +---+           +---+------  |  -->+---+
                       | |       | | |
                     3 | | 4,5   | | |
         --------------   -----  | | |
        |                      | | | |
        |                      | | | |
        |                 ---------  |
        |               1|     | |   |
        V                |     | |   |
      +---+   PASS    +---+ 2  |  ------>+---+
      |   |---------->| W |------------->| S |
      +---+           +---+   ---------->+---+
                       | |   | |     |
                     3 | |4,5| |     |
         --------------   --------   |
        |                    | |  |  |
        |                    | |  |  |
        |                 -----------
        |             1,3|   | |  |
        V                |  2| |  |
      +---+   ACCT    +---+--  |   ----->+---+
      |   |---------->| W | 4,5 -------->| F |
      +---+           +---+------------->+---+




















Postel & Reynolds                                              [Page 57]

RFC 959                                                     October 1985
File Transfer Protocol


   Finally, we present a generalized diagram that could be used to model
   the command and reply interchange:


               ------------------------------------
              |                                    |
      Begin   |                                    |
        |     V                                    |
        |   +---+  cmd   +---+ 2         +---+     |
         -->|   |------->|   |---------->|   |     |
            |   |        | W |           | S |-----|
         -->|   |     -->|   |-----      |   |     |
        |   +---+    |   +---+ 4,5 |     +---+     |
        |     |      |    | |      |               |
        |     |      |   1| |3     |     +---+     |
        |     |      |    | |      |     |   |     |
        |     |       ----  |       ---->| F |-----
        |     |             |            |   |
        |     |             |            +---+
         -------------------
              |
              |
              V
             End

























Postel & Reynolds                                              [Page 58]

RFC 959                                                     October 1985
File Transfer Protocol


7.  TYPICAL FTP SCENARIO

   User at host U wanting to transfer files to/from host S:

   In general, the user will communicate to the server via a mediating
   user-FTP process.  The following may be a typical scenario.  The
   user-FTP prompts are shown in parentheses, '---->' represents
   commands from host U to host S, and '<----' represents replies from
   host S to host U.

      LOCAL COMMANDS BY USER              ACTION INVOLVED

      ftp (host) multics<CR>         Connect to host S, port L,
                                     establishing control connections.
                                     <---- 220 Service ready <CRLF>.
      username Doe <CR>              USER Doe<CRLF>---->
                                     <---- 331 User name ok,
                                               need password<CRLF>.
      password mumble <CR>           PASS mumble<CRLF>---->
                                     <---- 230 User logged in<CRLF>.
      retrieve (local type) ASCII<CR>
      (local pathname) test 1 <CR>   User-FTP opens local file in ASCII.
      (for. pathname) test.pl1<CR>   RETR test.pl1<CRLF> ---->
                                     <---- 150 File status okay;
                                           about to open data
                                           connection<CRLF>.
                                     Server makes data connection
                                     to port U.

                                     <---- 226 Closing data connection,
                                         file transfer successful<CRLF>.
      type Image<CR>                 TYPE I<CRLF> ---->
                                     <---- 200 Command OK<CRLF>
      store (local type) image<CR>
      (local pathname) file dump<CR> User-FTP opens local file in Image.
      (for.pathname) >udd>cn>fd<CR>  STOR >udd>cn>fd<CRLF> ---->
                                     <---- 550 Access denied<CRLF>
      terminate                      QUIT <CRLF> ---->
                                     Server closes all
                                     connections.

8.  CONNECTION ESTABLISHMENT

   The FTP control connection is established via TCP between the user
   process port U and the server process port L.  This protocol is
   assigned the service port 21 (25 octal), that is L=21.



Postel & Reynolds                                              [Page 59]

RFC 959                                                     October 1985
File Transfer Protocol


APPENDIX I -  PAGE STRUCTURE

   The need for FTP to support page structure derives principally from
   the  need to support efficient transmission of files between TOPS-20
   systems, particularly the files used by NLS.

   The file system of TOPS-20 is based on the concept of pages.  The
   operating system is most efficient at manipulating files as pages.
   The operating system provides an interface to the file system so that
   many applications view files as sequential streams of characters.
   However, a few applications use the underlying page structures
   directly, and some of these create holey files.

   A TOPS-20 disk file consists of four things: a pathname, a page
   table, a (possibly empty) set of pages, and a set of attributes.

   The pathname is specified in the RETR or STOR command.  It includes
   the directory name, file name, file name extension, and generation
   number.

   The page table contains up to 2**18 entries.  Each entry may be
   EMPTY, or may point to a page.  If it is not empty, there are also
   some page-specific access bits; not all pages of a file need have the
   same access protection.

      A page is a contiguous set of 512 words of 36 bits each.

   The attributes of the file, in the File Descriptor Block (FDB),
   contain such things as creation time, write time, read time, writer's
   byte-size, end-of-file pointer, count of reads and writes, backup
   system tape numbers, etc.

   Note that there is NO requirement that entries in the page table be
   contiguous.  There may be empty page table slots between occupied
   ones.  Also, the end of file pointer is simply a number.  There is no
   requirement that it in fact point at the ""last"" datum in the file.
   Ordinary sequential I/O calls in TOPS-20 will cause the end of file
   pointer to be left after the last datum written, but other operations
   may cause it not to be so, if a particular programming system so
   requires.

   In fact, in both of these special cases, ""holey"" files and
   end-of-file pointers NOT at the end of the file, occur with NLS data
   files.





Postel & Reynolds                                              [Page 60]

RFC 959                                                     October 1985
File Transfer Protocol


   The TOPS-20 paged files can be sent with the FTP transfer parameters:
   TYPE L 36, STRU P, and MODE S (in fact, any mode could be used).

   Each page of information has a header.  Each header field, which is a
   logical byte, is a TOPS-20 word, since the TYPE is L 36.

   The header fields are:

      Word 0: Header Length.

         The header length is 5.

      Word 1: Page Index.

         If the data is a disk file page, this is the number of that
         page in the file's page map.  Empty pages (holes) in the file
         are simply not sent.  Note that a hole is NOT the same as a
         page of zeros.

      Word 2: Data Length.

         The number of data words in this page, following the header.
         Thus, the total length of the transmission unit is the Header
         Length plus the Data Length.

      Word 3: Page Type.

         A code for what type of chunk this is.  A data page is type 3,
         the FDB page is type 2.

      Word 4: Page Access Control.

         The access bits associated with the page in the file's page
         map.  (This full word quantity is put into AC2 of an SPACS by
         the program reading from net to disk.)

   After the header are Data Length data words.  Data Length is
   currently either 512 for a data page or 31 for an FDB.  Trailing
   zeros in a disk file page may be discarded, making Data Length less
   than 512 in that case.









Postel & Reynolds                                              [Page 61]

RFC 959                                                     October 1985
File Transfer Protocol


APPENDIX II -  DIRECTORY COMMANDS

   Since UNIX has a tree-like directory structure in which directories
   are as easy to manipulate as ordinary files, it is useful to expand
   the FTP servers on these machines to include commands which deal with
   the creation of directories.  Since there are other hosts on the
   ARPA-Internet which have tree-like directories (including TOPS-20 and
   Multics), these commands are as general as possible.

      Four directory commands have been added to FTP:

         MKD pathname

            Make a directory with the name ""pathname"".

         RMD pathname

            Remove the directory with the name ""pathname"".

         PWD

            Print the current working directory name.

         CDUP

            Change to the parent of the current working directory.

   The  ""pathname""  argument should be created (removed) as a
   subdirectory of the current working directory, unless the ""pathname""
   string contains sufficient information to specify otherwise to the
   server, e.g., ""pathname"" is an absolute pathname (in UNIX and
   Multics), or pathname is something like ""<abso.lute.path>"" to
   TOPS-20.

   REPLY CODES

      The CDUP command is a special case of CWD, and is included to
      simplify the implementation of programs for transferring directory
      trees between operating systems having different syntaxes for
      naming the parent directory.  The reply codes for CDUP be
      identical to the reply codes of CWD.

      The reply codes for RMD be identical to the reply codes for its
      file analogue, DELE.

      The reply codes for MKD, however, are a bit more complicated.  A
      freshly created directory will probably be the object of a future


Postel & Reynolds                                              [Page 62]

RFC 959                                                     October 1985
File Transfer Protocol


      CWD command.  Unfortunately, the argument to MKD may not always be
      a suitable argument for CWD.  This is the case, for example, when
      a TOPS-20 subdirectory is created by giving just the subdirectory
      name.  That is, with a TOPS-20 server FTP, the command sequence

         MKD MYDIR
         CWD MYDIR

      will fail.  The new directory may only be referred to by its
      ""absolute"" name; e.g., if the MKD command above were issued while
      connected to the directory <DFRANKLIN>, the new subdirectory
      could only be referred to by the name <DFRANKLIN.MYDIR>.

      Even on UNIX and Multics, however, the argument given to MKD may
      not be suitable.  If it is a ""relative"" pathname (i.e., a pathname
      which is interpreted relative to the current directory), the user
      would need to be in the same current directory in order to reach
      the subdirectory.  Depending on the application, this may be
      inconvenient.  It is not very robust in any case.

      To solve these problems, upon successful completion of an MKD
      command, the server should return a line of the form:

         257<space>""<directory-name>""<space><commentary>

      That is, the server will tell the user what string to use when
      referring to the created  directory.  The directory name can
      contain any character; embedded double-quotes should be escaped by
      double-quotes (the ""quote-doubling"" convention).

      For example, a user connects to the directory /usr/dm, and creates
      a subdirectory, named pathname:

         CWD /usr/dm
         200 directory changed to /usr/dm
         MKD pathname
         257 ""/usr/dm/pathname"" directory created

      An example with an embedded double quote:

         MKD foo""bar
         257 ""/usr/dm/foo""""bar"" directory created
         CWD /usr/dm/foo""bar
         200 directory changed to /usr/dm/foo""bar





Postel & Reynolds                                              [Page 63]

RFC 959                                                     October 1985
File Transfer Protocol


      The prior existence of a subdirectory with the same name is an
      error, and the server must return an ""access denied"" error reply
      in that case.

         CWD /usr/dm
         200 directory changed to /usr/dm
         MKD pathname
         521-""/usr/dm/pathname"" directory already exists;
         521 taking no action.

      The failure replies for MKD are analogous to its file  creating
      cousin, STOR.  Also, an ""access denied"" return is given if a file
      name with the same name as the subdirectory will conflict with the
      creation of the subdirectory (this is a problem on UNIX, but
      shouldn't be one on TOPS-20).

      Essentially because the PWD command returns the same type of
      information as the successful MKD command, the successful PWD
      command uses the 257 reply code as well.

   SUBTLETIES

      Because these commands will be most useful in transferring
      subtrees from one machine to another, carefully observe that the
      argument to MKD is to be interpreted as a sub-directory of  the
      current working directory, unless it contains enough information
      for the destination host to tell otherwise.  A hypothetical
      example of its use in the TOPS-20 world:

         CWD <some.where>
         200 Working directory changed
         MKD overrainbow
         257 ""<some.where.overrainbow>"" directory created
         CWD overrainbow
         431 No such directory
         CWD <some.where.overrainbow>
         200 Working directory changed

         CWD <some.where>
         200 Working directory changed to <some.where>
         MKD <unambiguous>
         257 ""<unambiguous>"" directory created
         CWD <unambiguous>

      Note that the first example results in a subdirectory of the
      connected directory.  In contrast, the argument in the second
      example contains enough information for TOPS-20 to tell that  the


Postel & Reynolds                                              [Page 64]

RFC 959                                                     October 1985
File Transfer Protocol


      <unambiguous> directory is a top-level directory.  Note also that
      in the first example the user ""violated"" the protocol by
      attempting to access the freshly created directory with a name
      other than the one returned by TOPS-20.  Problems could have
      resulted in this case had there been an <overrainbow> directory;
      this is an ambiguity inherent in some TOPS-20 implementations.
      Similar considerations apply to the RMD command.  The point is
      this: except where to do so would violate a host's conventions for
      denoting relative versus absolute pathnames, the host should treat
      the operands of the MKD and RMD commands as subdirectories.  The
      257 reply to the MKD command must always contain the absolute
      pathname of the created directory.





































Postel & Reynolds                                              [Page 65]

RFC 959                                                     October 1985
File Transfer Protocol


APPENDIX III - RFCs on FTP

   Bhushan, Abhay, ""A File Transfer Protocol"", RFC 114 (NIC 5823),
   MIT-Project MAC, 16 April 1971.

   Harslem, Eric, and John Heafner, ""Comments on RFC 114 (A File
   Transfer Protocol)"", RFC 141 (NIC 6726), RAND, 29 April 1971.

   Bhushan, Abhay, et al, ""The File Transfer Protocol"", RFC 172
   (NIC 6794), MIT-Project MAC, 23 June 1971.

   Braden, Bob, ""Comments on DTP and FTP Proposals"", RFC 238 (NIC 7663),
   UCLA/CCN, 29 September 1971.

   Bhushan, Abhay, et al, ""The File Transfer Protocol"", RFC 265
   (NIC 7813), MIT-Project MAC, 17 November 1971.

   McKenzie, Alex, ""A Suggested Addition to File Transfer Protocol"",
   RFC 281 (NIC 8163), BBN, 8 December 1971.

   Bhushan, Abhay, ""The Use of ""Set Data Type"" Transaction in File
   Transfer Protocol"", RFC 294 (NIC 8304), MIT-Project MAC,
   25 January 1972.

   Bhushan, Abhay, ""The File Transfer Protocol"", RFC 354 (NIC 10596),
   MIT-Project MAC, 8 July 1972.

   Bhushan, Abhay, ""Comments on the File Transfer Protocol (RFC 354)"",
   RFC 385 (NIC 11357), MIT-Project MAC, 18 August 1972.

   Hicks, Greg, ""User FTP Documentation"", RFC 412 (NIC 12404), Utah,
   27 November 1972.

   Bhushan, Abhay, ""File Transfer Protocol (FTP) Status and Further
   Comments"", RFC 414 (NIC 12406), MIT-Project MAC, 20 November 1972.

   Braden, Bob, ""Comments on File Transfer Protocol"", RFC 430
   (NIC 13299), UCLA/CCN, 7 February 1973.

   Thomas, Bob, and Bob Clements, ""FTP Server-Server Interaction"",
   RFC 438 (NIC 13770), BBN, 15 January 1973.

   Braden, Bob, ""Print Files in FTP"", RFC 448 (NIC 13299), UCLA/CCN,
   27 February 1973.

   McKenzie, Alex, ""File Transfer Protocol"", RFC 454 (NIC 14333), BBN,
   16 February 1973.


Postel & Reynolds                                              [Page 66]

RFC 959                                                     October 1985
File Transfer Protocol


   Bressler, Bob, and Bob Thomas, ""Mail Retrieval via FTP"", RFC 458
   (NIC 14378), BBN-NET and BBN-TENEX, 20 February 1973.

   Neigus, Nancy, ""File Transfer Protocol"", RFC 542 (NIC 17759), BBN,
   12 July 1973.

   Krilanovich, Mark, and George Gregg, ""Comments on the File Transfer
   Protocol"", RFC 607 (NIC 21255), UCSB, 7 January 1974.

   Pogran, Ken, and Nancy Neigus, ""Response to RFC 607 - Comments on the
   File Transfer Protocol"", RFC 614 (NIC 21530), BBN, 28 January 1974.

   Krilanovich, Mark, George Gregg, Wayne Hathaway, and Jim White,
   ""Comments on the File Transfer Protocol"", RFC 624 (NIC 22054), UCSB,
   Ames Research Center, SRI-ARC, 28 February 1974.

   Bhushan, Abhay, ""FTP Comments and Response to RFC 430"", RFC 463
   (NIC 14573), MIT-DMCG, 21 February 1973.

   Braden, Bob, ""FTP Data Compression"", RFC 468 (NIC 14742), UCLA/CCN,
   8 March 1973.

   Bhushan, Abhay, ""FTP and Network Mail System"", RFC 475 (NIC 14919),
   MIT-DMCG, 6 March 1973.

   Bressler, Bob, and Bob Thomas ""FTP Server-Server Interaction - II"",
   RFC 478 (NIC 14947), BBN-NET and BBN-TENEX, 26 March 1973.

   White, Jim, ""Use of FTP by the NIC Journal"", RFC 479 (NIC 14948),
   SRI-ARC, 8 March 1973.

   White, Jim, ""Host-Dependent FTP Parameters"", RFC 480 (NIC 14949),
   SRI-ARC, 8 March 1973.

   Padlipsky, Mike, ""An FTP Command-Naming Problem"", RFC 506
   (NIC 16157), MIT-Multics, 26 June 1973.

   Day, John, ""Memo to FTP Group (Proposal for File Access Protocol)"",
   RFC 520 (NIC 16819), Illinois, 25 June 1973.

   Merryman, Robert, ""The UCSD-CC Server-FTP Facility"", RFC 532
   (NIC 17451), UCSD-CC, 22 June 1973.

   Braden, Bob, ""TENEX FTP Problem"", RFC 571 (NIC 18974), UCLA/CCN,
   15 November 1973.




Postel & Reynolds                                              [Page 67]

RFC 959                                                     October 1985
File Transfer Protocol


   McKenzie, Alex, and Jon Postel, ""Telnet and FTP Implementation -
   Schedule Change"", RFC 593 (NIC 20615), BBN and MITRE,
   29 November 1973.

   Sussman, Julie, ""FTP Error Code Usage for More Reliable Mail
   Service"", RFC 630 (NIC 30237), BBN, 10 April 1974.

   Postel, Jon, ""Revised FTP Reply Codes"", RFC 640 (NIC 30843),
   UCLA/NMC, 5 June 1974.

   Harvey, Brian, ""Leaving Well Enough Alone"", RFC 686 (NIC 32481),
   SU-AI, 10 May 1975.

   Harvey, Brian, ""One More Try on the FTP"", RFC 691 (NIC 32700), SU-AI,
   28 May 1975.

   Lieb, J., ""CWD Command of FTP"", RFC 697 (NIC 32963), 14 July 1975.

   Harrenstien, Ken, ""FTP Extension: XSEN"", RFC 737 (NIC 42217), SRI-KL,
   31 October 1977.

   Harrenstien, Ken, ""FTP Extension: XRSQ/XRCP"", RFC 743 (NIC 42758),
   SRI-KL, 30 December 1977.

   Lebling, P. David, ""Survey of FTP Mail and MLFL"", RFC 751, MIT,
   10 December 1978.

   Postel, Jon, ""File Transfer Protocol Specification"", RFC 765, ISI,
   June 1980.

   Mankins, David, Dan Franklin, and Buzz Owen, ""Directory Oriented FTP
   Commands"", RFC 776, BBN, December 1980.

   Padlipsky, Michael, ""FTP Unique-Named Store Command"", RFC 949, MITRE,
   July 1985.














Postel & Reynolds                                              [Page 68]

RFC 959                                                     October 1985
File Transfer Protocol


REFERENCES

   [1]  Feinler, Elizabeth, ""Internet Protocol Transition Workbook"",
        Network Information Center, SRI International, March 1982.

   [2]  Postel, Jon, ""Transmission Control Protocol - DARPA Internet
        Program Protocol Specification"", RFC 793, DARPA, September 1981.

   [3]  Postel, Jon, and Joyce Reynolds, ""Telnet Protocol
        Specification"", RFC 854, ISI, May 1983.

   [4]  Reynolds, Joyce, and Jon Postel, ""Assigned Numbers"", RFC 943,
        ISI, April 1985.




































Postel & Reynolds                                              [Page 69]

"
RFC4251,"
[RFC Home] [TEXT|PDF|HTML] [Tracker] [IPR] [Info page]                                                                          PROPOSED STANDARDUpdated by: 8308, 9141 Network Working Group                                          T. Ylonen
Request for Comments: 4251              SSH Communications Security Corp
Category: Standards Track                                C. Lonvick, Ed.
                                                     Cisco Systems, Inc.
                                                            January 2006


              The Secure Shell (SSH) Protocol Architecture

Status of This Memo

   This document specifies an Internet standards track protocol for the
   Internet community, and requests discussion and suggestions for
   improvements.  Please refer to the current edition of the ""Internet
   Official Protocol Standards"" (STD 1) for the standardization state
   and status of this protocol.  Distribution of this memo is unlimited.

Copyright Notice

   Copyright (C) The Internet Society (2006).

Abstract

   The Secure Shell (SSH) Protocol is a protocol for secure remote login
   and other secure network services over an insecure network.  This
   document describes the architecture of the SSH protocol, as well as
   the notation and terminology used in SSH protocol documents.  It also
   discusses the SSH algorithm naming system that allows local
   extensions.  The SSH protocol consists of three major components: The
   Transport Layer Protocol provides server authentication,
   confidentiality, and integrity with perfect forward secrecy.  The
   User Authentication Protocol authenticates the client to the server.
   The Connection Protocol multiplexes the encrypted tunnel into several
   logical channels.  Details of these protocols are described in
   separate documents.
















Ylonen & Lonvick            Standards Track                     [Page 1]

RFC 4251               SSH Protocol Architecture            January 2006


Table of Contents

   1. Introduction ....................................................3
   2. Contributors ....................................................3
   3. Conventions Used in This Document ...............................4
   4. Architecture ....................................................4
      4.1. Host Keys ..................................................4
      4.2. Extensibility ..............................................6
      4.3. Policy Issues ..............................................6
      4.4. Security Properties ........................................7
      4.5. Localization and Character Set Support .....................7
   5. Data Type Representations Used in the SSH Protocols .............8
   6. Algorithm and Method Naming ....................................10
   7. Message Numbers ................................................11
   8. IANA Considerations ............................................12
   9. Security Considerations ........................................13
      9.1. Pseudo-Random Number Generation ...........................13
      9.2. Control Character Filtering ...............................14
      9.3. Transport .................................................14
           9.3.1. Confidentiality ....................................14
           9.3.2. Data Integrity .....................................16
           9.3.3. Replay .............................................16
           9.3.4. Man-in-the-middle ..................................17
           9.3.5. Denial of Service ..................................19
           9.3.6. Covert Channels ....................................20
           9.3.7. Forward Secrecy ....................................20
           9.3.8. Ordering of Key Exchange Methods ...................20
           9.3.9. Traffic Analysis ...................................21
      9.4. Authentication Protocol ...................................21
           9.4.1. Weak Transport .....................................21
           9.4.2. Debug Messages .....................................22
           9.4.3. Local Security Policy ..............................22
           9.4.4. Public Key Authentication ..........................23
           9.4.5. Password Authentication ............................23
           9.4.6. Host-Based Authentication ..........................23
      9.5. Connection Protocol .......................................24
           9.5.1. End Point Security .................................24
           9.5.2. Proxy Forwarding ...................................24
           9.5.3. X11 Forwarding .....................................24
   10. References ....................................................26
      10.1. Normative References .....................................26
      10.2. Informative References ...................................26
   Authors' Addresses ................................................29
   Trademark Notice ..................................................29







Ylonen & Lonvick            Standards Track                     [Page 2]

RFC 4251               SSH Protocol Architecture            January 2006


1.  Introduction

   Secure Shell (SSH) is a protocol for secure remote login and other
   secure network services over an insecure network.  It consists of
   three major components:

   o  The Transport Layer Protocol [SSH-TRANS] provides server
      authentication, confidentiality, and integrity.  It may optionally
      also provide compression.  The transport layer will typically be
      run over a TCP/IP connection, but might also be used on top of any
      other reliable data stream.

   o  The User Authentication Protocol [SSH-USERAUTH] authenticates the
      client-side user to the server.  It runs over the transport layer
      protocol.

   o  The Connection Protocol [SSH-CONNECT] multiplexes the encrypted
      tunnel into several logical channels.  It runs over the user
      authentication protocol.

   The client sends a service request once a secure transport layer
   connection has been established.  A second service request is sent
   after user authentication is complete.  This allows new protocols to
   be defined and coexist with the protocols listed above.

   The connection protocol provides channels that can be used for a wide
   range of purposes.  Standard methods are provided for setting up
   secure interactive shell sessions and for forwarding (""tunneling"")
   arbitrary TCP/IP ports and X11 connections.

2.  Contributors

   The major original contributors of this set of documents have been:
   Tatu Ylonen, Tero Kivinen, Timo J. Rinne, Sami Lehtinen (all of SSH
   Communications Security Corp), and Markku-Juhani O. Saarinen
   (University of Jyvaskyla).  Darren Moffat was the original editor of
   this set of documents and also made very substantial contributions.

   Many people contributed to the development of this document over the
   years.  People who should be acknowledged include Mats Andersson, Ben
   Harris, Bill Sommerfeld, Brent McClure, Niels Moller, Damien Miller,
   Derek Fawcus, Frank Cusack, Heikki Nousiainen, Jakob Schlyter, Jeff
   Van Dyke, Jeffrey Altman, Jeffrey Hutzelman, Jon Bright, Joseph
   Galbraith, Ken Hornstein, Markus Friedl, Martin Forssen, Nicolas
   Williams, Niels Provos, Perry Metzger, Peter Gutmann, Simon
   Josefsson, Simon Tatham, Wei Dai, Denis Bider, der Mouse, and
   Tadayoshi Kohno.  Listing their names here does not mean that they
   endorse this document, but that they have contributed to it.



Ylonen & Lonvick            Standards Track                     [Page 3]

RFC 4251               SSH Protocol Architecture            January 2006


3.  Conventions Used in This Document

   All documents related to the SSH protocols shall use the keywords
   ""MUST"", ""MUST NOT"", ""REQUIRED"", ""SHALL"", ""SHALL NOT"", ""SHOULD"",
   ""SHOULD NOT"", ""RECOMMENDED"", ""MAY"", and ""OPTIONAL"" to describe
   requirements.  These keywords are to be interpreted as described in
   [RFC2119].

   The keywords ""PRIVATE USE"", ""HIERARCHICAL ALLOCATION"", ""FIRST COME
   FIRST SERVED"", ""EXPERT REVIEW"", ""SPECIFICATION REQUIRED"", ""IESG
   APPROVAL"", ""IETF CONSENSUS"", and ""STANDARDS ACTION"" that appear in
   this document when used to describe namespace allocation are to be
   interpreted as described in [RFC2434].

   Protocol fields and possible values to fill them are defined in this
   set of documents.  Protocol fields will be defined in the message
   definitions.  As an example, SSH_MSG_CHANNEL_DATA is defined as
   follows.

      byte      SSH_MSG_CHANNEL_DATA
      uint32    recipient channel
      string    data

   Throughout these documents, when the fields are referenced, they will
   appear within single quotes.  When values to fill those fields are
   referenced, they will appear within double quotes.  Using the above
   example, possible values for 'data' are ""foo"" and ""bar"".

4.  Architecture

4.1.  Host Keys

   Each server host SHOULD have a host key.  Hosts MAY have multiple
   host keys using multiple different algorithms.  Multiple hosts MAY
   share the same host key.  If a host has keys at all, it MUST have at
   least one key that uses each REQUIRED public key algorithm (DSS
   [FIPS-186-2]).

   The server host key is used during key exchange to verify that the
   client is really talking to the correct server.  For this to be
   possible, the client must have a priori knowledge of the server's
   public host key.

   Two different trust models can be used:

   o  The client has a local database that associates each host name (as
      typed by the user) with the corresponding public host key.  This
      method requires no centrally administered infrastructure, and no



Ylonen & Lonvick            Standards Track                     [Page 4]

RFC 4251               SSH Protocol Architecture            January 2006


      third-party coordination.  The downside is that the database of
      name-to-key associations may become burdensome to maintain.

   o  The host name-to-key association is certified by a trusted
      certification authority (CA).  The client only knows the CA root
      key, and can verify the validity of all host keys certified by
      accepted CAs.

   The second alternative eases the maintenance problem, since ideally
   only a single CA key needs to be securely stored on the client.  On
   the other hand, each host key must be appropriately certified by a
   central authority before authorization is possible.  Also, a lot of
   trust is placed on the central infrastructure.

   The protocol provides the option that the server name - host key
   association is not checked when connecting to the host for the first
   time.  This allows communication without prior communication of host
   keys or certification.  The connection still provides protection
   against passive listening; however, it becomes vulnerable to active
   man-in-the-middle attacks.  Implementations SHOULD NOT normally allow
   such connections by default, as they pose a potential security
   problem.  However, as there is no widely deployed key infrastructure
   available on the Internet at the time of this writing, this option
   makes the protocol much more usable during the transition time until
   such an infrastructure emerges, while still providing a much higher
   level of security than that offered by older solutions (e.g., telnet
   [RFC0854] and rlogin [RFC1282]).

   Implementations SHOULD try to make the best effort to check host
   keys.  An example of a possible strategy is to only accept a host key
   without checking the first time a host is connected, save the key in
   a local database, and compare against that key on all future
   connections to that host.

   Implementations MAY provide additional methods for verifying the
   correctness of host keys, e.g., a hexadecimal fingerprint derived
   from the SHA-1 hash [FIPS-180-2] of the public key.  Such
   fingerprints can easily be verified by using telephone or other
   external communication channels.

   All implementations SHOULD provide an option not to accept host keys
   that cannot be verified.

   The members of this Working Group believe that 'ease of use' is
   critical to end-user acceptance of security solutions, and no
   improvement in security is gained if the new solutions are not used.
   Thus, providing the option not to check the server host key is




Ylonen & Lonvick            Standards Track                     [Page 5]

RFC 4251               SSH Protocol Architecture            January 2006


   believed to improve the overall security of the Internet, even though
   it reduces the security of the protocol in configurations where it is
   allowed.

4.2.  Extensibility

   We believe that the protocol will evolve over time, and some
   organizations will want to use their own encryption, authentication,
   and/or key exchange methods.  Central registration of all extensions
   is cumbersome, especially for experimental or classified features.
   On the other hand, having no central registration leads to conflicts
   in method identifiers, making interoperability difficult.

   We have chosen to identify algorithms, methods, formats, and
   extension protocols with textual names that are of a specific format.
   DNS names are used to create local namespaces where experimental or
   classified extensions can be defined without fear of conflicts with
   other implementations.

   One design goal has been to keep the base protocol as simple as
   possible, and to require as few algorithms as possible.  However, all
   implementations MUST support a minimal set of algorithms to ensure
   interoperability (this does not imply that the local policy on all
   hosts would necessarily allow these algorithms).  The mandatory
   algorithms are specified in the relevant protocol documents.

   Additional algorithms, methods, formats, and extension protocols can
   be defined in separate documents.  See Section 6, Algorithm Naming,
   for more information.

4.3.  Policy Issues

   The protocol allows full negotiation of encryption, integrity, key
   exchange, compression, and public key algorithms and formats.
   Encryption, integrity, public key, and compression algorithms can be
   different for each direction.

   The following policy issues SHOULD be addressed in the configuration
   mechanisms of each implementation:

   o  Encryption, integrity, and compression algorithms, separately for
      each direction.  The policy MUST specify which is the preferred
      algorithm (e.g., the first algorithm listed in each category).

   o  Public key algorithms and key exchange method to be used for host
      authentication.  The existence of trusted host keys for different
      public key algorithms also affects this choice.




Ylonen & Lonvick            Standards Track                     [Page 6]

RFC 4251               SSH Protocol Architecture            January 2006


   o  The authentication methods that are to be required by the server
      for each user.  The server's policy MAY require multiple
      authentication for some or all users.  The required algorithms MAY
      depend on the location from where the user is trying to gain
      access.

   o  The operations that the user is allowed to perform using the
      connection protocol.  Some issues are related to security; for
      example, the policy SHOULD NOT allow the server to start sessions
      or run commands on the client machine, and MUST NOT allow
      connections to the authentication agent unless forwarding such
      connections has been requested.  Other issues, such as which
      TCP/IP ports can be forwarded and by whom, are clearly issues of
      local policy.  Many of these issues may involve traversing or
      bypassing firewalls, and are interrelated with the local security
      policy.

4.4.  Security Properties

   The primary goal of the SSH protocol is to improve security on the
   Internet.  It attempts to do this in a way that is easy to deploy,
   even at the cost of absolute security.

   o  All encryption, integrity, and public key algorithms used are
      well-known, well-established algorithms.

   o  All algorithms are used with cryptographically sound key sizes
      that are believed to provide protection against even the strongest
      cryptanalytic attacks for decades.

   o  All algorithms are negotiated, and in case some algorithm is
      broken, it is easy to switch to some other algorithm without
      modifying the base protocol.

   Specific concessions were made to make widespread, fast deployment
   easier.  The particular case where this comes up is verifying that
   the server host key really belongs to the desired host; the protocol
   allows the verification to be left out, but this is NOT RECOMMENDED.
   This is believed to significantly improve usability in the short
   term, until widespread Internet public key infrastructures emerge.

4.5.  Localization and Character Set Support

   For the most part, the SSH protocols do not directly pass text that
   would be displayed to the user.  However, there are some places where
   such data might be passed.  When applicable, the character set for





Ylonen & Lonvick            Standards Track                     [Page 7]

RFC 4251               SSH Protocol Architecture            January 2006


   the data MUST be explicitly specified.  In most places, ISO-10646
   UTF-8 encoding is used [RFC3629].  When applicable, a field is also
   provided for a language tag [RFC3066].

   One big issue is the character set of the interactive session.  There
   is no clear solution, as different applications may display data in
   different formats.  Different types of terminal emulation may also be
   employed in the client, and the character set to be used is
   effectively determined by the terminal emulation.  Thus, no place is
   provided for directly specifying the character set or encoding for
   terminal session data.  However, the terminal emulation type (e.g.,
   ""vt100"") is transmitted to the remote site, and it implicitly
   specifies the character set and encoding.  Applications typically use
   the terminal type to determine what character set they use, or the
   character set is determined using some external means.  The terminal
   emulation may also allow configuring the default character set.  In
   any case, the character set for the terminal session is considered
   primarily a client local issue.

   Internal names used to identify algorithms or protocols are normally
   never displayed to users, and must be in US-ASCII.

   The client and server user names are inherently constrained by what
   the server is prepared to accept.  They might, however, occasionally
   be displayed in logs, reports, etc.  They MUST be encoded using ISO
   10646 UTF-8, but other encodings may be required in some cases.  It
   is up to the server to decide how to map user names to accepted user
   names.  Straight bit-wise, binary comparison is RECOMMENDED.

   For localization purposes, the protocol attempts to minimize the
   number of textual messages transmitted.  When present, such messages
   typically relate to errors, debugging information, or some externally
   configured data.  For data that is normally displayed, it SHOULD be
   possible to fetch a localized message instead of the transmitted
   message by using a numerical code.  The remaining messages SHOULD be
   configurable.

5.  Data Type Representations Used in the SSH Protocols

   byte

      A byte represents an arbitrary 8-bit value (octet).  Fixed length
      data is sometimes represented as an array of bytes, written
      byte[n], where n is the number of bytes in the array.







Ylonen & Lonvick            Standards Track                     [Page 8]

RFC 4251               SSH Protocol Architecture            January 2006


   boolean

      A boolean value is stored as a single byte.  The value 0
      represents FALSE, and the value 1 represents TRUE.  All non-zero
      values MUST be interpreted as TRUE; however, applications MUST NOT
      store values other than 0 and 1.

   uint32

      Represents a 32-bit unsigned integer.  Stored as four bytes in the
      order of decreasing significance (network byte order).  For
      example: the value 699921578 (0x29b7f4aa) is stored as 29 b7 f4
      aa.

   uint64

      Represents a 64-bit unsigned integer.  Stored as eight bytes in
      the order of decreasing significance (network byte order).

   string

      Arbitrary length binary string.  Strings are allowed to contain
      arbitrary binary data, including null characters and 8-bit
      characters.  They are stored as a uint32 containing its length
      (number of bytes that follow) and zero (= empty string) or more
      bytes that are the value of the string.  Terminating null
      characters are not used.

      Strings are also used to store text.  In that case, US-ASCII is
      used for internal names, and ISO-10646 UTF-8 for text that might
      be displayed to the user.  The terminating null character SHOULD
      NOT normally be stored in the string.  For example: the US-ASCII
      string ""testing"" is represented as 00 00 00 07 t e s t i n g.  The
      UTF-8 mapping does not alter the encoding of US-ASCII characters.

   mpint

      Represents multiple precision integers in two's complement format,
      stored as a string, 8 bits per byte, MSB first.  Negative numbers
      have the value 1 as the most significant bit of the first byte of
      the data partition.  If the most significant bit would be set for
      a positive number, the number MUST be preceded by a zero byte.
      Unnecessary leading bytes with the value 0 or 255 MUST NOT be
      included.  The value zero MUST be stored as a string with zero
      bytes of data.

      By convention, a number that is used in modular computations in
      Z_n SHOULD be represented in the range 0 <= x < n.



Ylonen & Lonvick            Standards Track                     [Page 9]

RFC 4251               SSH Protocol Architecture            January 2006


         Examples:

         value (hex)        representation (hex)
         -----------        --------------------
         0                  00 00 00 00
         9a378f9b2e332a7    00 00 00 08 09 a3 78 f9 b2 e3 32 a7
         80                 00 00 00 02 00 80
         -1234              00 00 00 02 ed cc
         -deadbeef          00 00 00 05 ff 21 52 41 11

   name-list

      A string containing a comma-separated list of names.  A name-list
      is represented as a uint32 containing its length (number of bytes
      that follow) followed by a comma-separated list of zero or more
      names.  A name MUST have a non-zero length, and it MUST NOT
      contain a comma ("","").  As this is a list of names, all of the
      elements contained are names and MUST be in US-ASCII.  Context may
      impose additional restrictions on the names.  For example, the
      names in a name-list may have to be a list of valid algorithm
      identifiers (see Section 6 below), or a list of [RFC3066] language
      tags.  The order of the names in a name-list may or may not be
      significant.  Again, this depends on the context in which the list
      is used.  Terminating null characters MUST NOT be used, neither
      for the individual names, nor for the list as a whole.

       Examples:

       value                      representation (hex)
       -----                      --------------------
       (), the empty name-list    00 00 00 00
       (""zlib"")                   00 00 00 04 7a 6c 69 62
       (""zlib,none"")              00 00 00 09 7a 6c 69 62 2c 6e 6f 6e 65

6.  Algorithm and Method Naming

   The SSH protocols refer to particular hash, encryption, integrity,
   compression, and key exchange algorithms or methods by name.  There
   are some standard algorithms and methods that all implementations
   MUST support.  There are also algorithms and methods that are defined
   in the protocol specification, but are OPTIONAL.  Furthermore, it is
   expected that some organizations will want to use their own
   algorithms or methods.

   In this protocol, all algorithm and method identifiers MUST be
   printable US-ASCII, non-empty strings no longer than 64 characters.
   Names MUST be case-sensitive.




Ylonen & Lonvick            Standards Track                    [Page 10]

RFC 4251               SSH Protocol Architecture            January 2006


   There are two formats for algorithm and method names:

   o  Names that do not contain an at-sign (""@"") are reserved to be
      assigned by IETF CONSENSUS.  Examples include ""3des-cbc"", ""sha-1"",
      ""hmac-sha1"", and ""zlib"" (the doublequotes are not part of the
      name).  Names of this format are only valid if they are first
      registered with the IANA.  Registered names MUST NOT contain an
      at-sign (""@""), comma ("",""), whitespace, control characters (ASCII
      codes 32 or less), or the ASCII code 127 (DEL).  Names are case-
      sensitive, and MUST NOT be longer than 64 characters.

   o  Anyone can define additional algorithms or methods by using names
      in the format name@domainname, e.g., ""ourcipher-cbc@example.com"".
      The format of the part preceding the at-sign is not specified;
      however, these names MUST be printable US-ASCII strings, and MUST
      NOT contain the comma character ("",""), whitespace, control
      characters (ASCII codes 32 or less), or the ASCII code 127 (DEL).
      They MUST have only a single at-sign in them.  The part following
      the at-sign MUST be a valid, fully qualified domain name [RFC1034]
      controlled by the person or organization defining the name.  Names
      are case-sensitive, and MUST NOT be longer than 64 characters.  It
      is up to each domain how it manages its local namespace.  It
      should be noted that these names resemble STD 11 [RFC0822] email
      addresses.  This is purely coincidental and has nothing to do with
      STD 11 [RFC0822].

7.  Message Numbers

   SSH packets have message numbers in the range 1 to 255.  These
   numbers have been allocated as follows:

   Transport layer protocol:

      1 to 19    Transport layer generic (e.g., disconnect, ignore,
                 debug, etc.)
      20 to 29   Algorithm negotiation
      30 to 49   Key exchange method specific (numbers can be reused
                 for different authentication methods)

   User authentication protocol:

      50 to 59   User authentication generic
      60 to 79   User authentication method specific (numbers can be
                 reused for different authentication methods)







Ylonen & Lonvick            Standards Track                    [Page 11]

RFC 4251               SSH Protocol Architecture            January 2006


   Connection protocol:

      80 to 89   Connection protocol generic
      90 to 127  Channel related messages

   Reserved for client protocols:

      128 to 191 Reserved

   Local extensions:

      192 to 255 Local extensions

8.  IANA Considerations

   This document is part of a set.  The instructions for the IANA for
   the SSH protocol, as defined in this document, [SSH-USERAUTH],
   [SSH-TRANS], and [SSH-CONNECT], are detailed in [SSH-NUMBERS].  The
   following is a brief summary for convenience, but note well that
   [SSH-NUMBERS] contains the actual instructions to the IANA, which may
   be superseded in the future.

   Allocation of the following types of names in the SSH protocols is
   assigned by IETF consensus:

   o  Service Names
      *  Authentication Methods
      *  Connection Protocol Channel Names
      *  Connection Protocol Global Request Names
      *  Connection Protocol Channel Request Names

   o  Key Exchange Method Names

   o  Assigned Algorithm Names
      *  Encryption Algorithm Names
      *  MAC Algorithm Names
      *  Public Key Algorithm Names
      *  Compression Algorithm Names

   These names MUST be printable US-ASCII strings, and MUST NOT contain
   the characters at-sign (""@""), comma ("",""), whitespace, control
   characters (ASCII codes 32 or less), or the ASCII code 127 (DEL).
   Names are case-sensitive, and MUST NOT be longer than 64 characters.

   Names with the at-sign (""@"") are locally defined extensions and are
   not controlled by the IANA.





Ylonen & Lonvick            Standards Track                    [Page 12]

RFC 4251               SSH Protocol Architecture            January 2006


   Each category of names listed above has a separate namespace.
   However, using the same name in multiple categories SHOULD be avoided
   to minimize confusion.

   Message numbers (see Section 7) in the range of 0 to 191 are
   allocated via IETF CONSENSUS, as described in [RFC2434].  Message
   numbers in the 192 to 255 range (local extensions) are reserved for
   PRIVATE USE, also as described in [RFC2434].

9.  Security Considerations

   In order to make the entire body of Security Considerations more
   accessible, Security Considerations for the transport,
   authentication, and connection documents have been gathered here.

   The transport protocol [SSH-TRANS] provides a confidential channel
   over an insecure network.  It performs server host authentication,
   key exchange, encryption, and integrity protection.  It also derives
   a unique session id that may be used by higher-level protocols.

   The authentication protocol [SSH-USERAUTH] provides a suite of
   mechanisms that can be used to authenticate the client user to the
   server.  Individual mechanisms specified in the authentication
   protocol use the session id provided by the transport protocol and/or
   depend on the security and integrity guarantees of the transport
   protocol.

   The connection protocol [SSH-CONNECT] specifies a mechanism to
   multiplex multiple streams (channels) of data over the confidential
   and authenticated transport.  It also specifies channels for
   accessing an interactive shell, for proxy-forwarding various external
   protocols over the secure transport (including arbitrary TCP/IP
   protocols), and for accessing secure subsystems on the server host.

9.1.  Pseudo-Random Number Generation

   This protocol binds each session key to the session by including
   random, session specific data in the hash used to produce session
   keys.  Special care should be taken to ensure that all of the random
   numbers are of good quality.  If the random data here (e.g., Diffie-
   Hellman (DH) parameters) are pseudo-random, then the pseudo-random
   number generator should be cryptographically secure (i.e., its next
   output not easily guessed even when knowing all previous outputs)
   and, furthermore, proper entropy needs to be added to the pseudo-
   random number generator.  [RFC4086] offers suggestions for sources of
   random numbers and entropy.  Implementers should note the importance
   of entropy and the well-meant, anecdotal warning about the difficulty
   in properly implementing pseudo-random number generating functions.



Ylonen & Lonvick            Standards Track                    [Page 13]

RFC 4251               SSH Protocol Architecture            January 2006


   The amount of entropy available to a given client or server may
   sometimes be less than what is required.  In this case, one must
   either resort to pseudo-random number generation regardless of
   insufficient entropy or refuse to run the protocol.  The latter is
   preferable.

9.2.  Control Character Filtering

   When displaying text to a user, such as error or debug messages, the
   client software SHOULD replace any control characters (except tab,
   carriage return, and newline) with safe sequences to avoid attacks by
   sending terminal control characters.

9.3.  Transport

9.3.1.  Confidentiality

   It is beyond the scope of this document and the Secure Shell Working
   Group to analyze or recommend specific ciphers other than the ones
   that have been established and accepted within the industry.  At the
   time of this writing, commonly used ciphers include 3DES, ARCFOUR,
   twofish, serpent, and blowfish.  AES has been published by The US
   Federal Information Processing Standards as [FIPS-197], and the
   cryptographic community has accepted AES as well.  As always,
   implementers and users should check current literature to ensure that
   no recent vulnerabilities have been found in ciphers used within
   products.  Implementers should also check to see which ciphers are
   considered to be relatively stronger than others and should recommend
   their use to users over relatively weaker ciphers.  It would be
   considered good form for an implementation to politely and
   unobtrusively notify a user that a stronger cipher is available and
   should be used when a weaker one is actively chosen.

   The ""none"" cipher is provided for debugging and SHOULD NOT be used
   except for that purpose.  Its cryptographic properties are
   sufficiently described in [RFC2410], which will show that its use
   does not meet the intent of this protocol.

   The relative merits of these and other ciphers may also be found in
   current literature.  Two references that may provide information on
   the subject are [SCHNEIER] and [KAUFMAN].  Both of these describe the
   CBC mode of operation of certain ciphers and the weakness of this
   scheme.  Essentially, this mode is theoretically vulnerable to chosen
   cipher-text attacks because of the high predictability of the start
   of packet sequence.  However, this attack is deemed difficult and not
   considered fully practicable, especially if relatively long block
   sizes are used.




Ylonen & Lonvick            Standards Track                    [Page 14]

RFC 4251               SSH Protocol Architecture            January 2006


   Additionally, another CBC mode attack may be mitigated through the
   insertion of packets containing SSH_MSG_IGNORE.  Without this
   technique, a specific attack may be successful.  For this attack
   (commonly known as the Rogaway attack [ROGAWAY], [DAI], [BELLARE]) to
   work, the attacker would need to know the Initialization Vector (IV)
   of the next block that is going to be encrypted.  In CBC mode that is
   the output of the encryption of the previous block.  If the attacker
   does not have any way to see the packet yet (i.e., it is in the
   internal buffers of the SSH implementation or even in the kernel),
   then this attack will not work.  If the last packet has been sent out
   to the network (i.e., the attacker has access to it), then he can use
   the attack.

   In the optimal case, an implementer would need to add an extra packet
   only if the packet has been sent out onto the network and there are
   no other packets waiting for transmission.  Implementers may wish to
   check if there are any unsent packets awaiting transmission;
   unfortunately, it is not normally easy to obtain this information
   from the kernel or buffers.  If there are no unsent packets, then a
   packet containing SSH_MSG_IGNORE SHOULD be sent.  If a new packet is
   added to the stream every time the attacker knows the IV that is
   supposed to be used for the next packet, then the attacker will not
   be able to guess the correct IV, thus the attack will never be
   successful.

   As an example, consider the following case:

      Client                                                  Server
      ------                                                  ------
      TCP(seq=x, len=500)             ---->
       contains Record 1

                          [500 ms passes, no ACK]

      TCP(seq=x, len=1000)            ---->
       contains Records 1,2

                                                                ACK

   1. The Nagle algorithm + TCP retransmits mean that the two records
      get coalesced into a single TCP segment.

   2. Record 2 is not at the beginning of the TCP segment and never will
      be because it gets ACKed.

   3. Yet, the attack is possible because Record 1 has already been
      seen.




Ylonen & Lonvick            Standards Track                    [Page 15]

RFC 4251               SSH Protocol Architecture            January 2006


   As this example indicates, it is unsafe to use the existence of
   unflushed data in the TCP buffers proper as a guide to whether an
   empty packet is needed, since when the second write() is performed
   the buffers will contain the un-ACKed Record 1.

   On the other hand, it is perfectly safe to have the following
   situation:

      Client                                                  Server
      ------                                                  ------
      TCP(seq=x, len=500)             ---->
         contains SSH_MSG_IGNORE

      TCP(seq=y, len=500)             ---->
         contains Data

      Provided that the IV for the second SSH Record is fixed after the
      data for the Data packet is determined, then the following should
      be performed:

         read from user
         encrypt null packet
         encrypt data packet

9.3.2.  Data Integrity

   This protocol does allow the Data Integrity mechanism to be disabled.
   Implementers SHOULD be wary of exposing this feature for any purpose
   other than debugging.  Users and administrators SHOULD be explicitly
   warned anytime the ""none"" MAC is enabled.

   So long as the ""none"" MAC is not used, this protocol provides data
   integrity.

   Because MACs use a 32-bit sequence number, they might start to leak
   information after 2**32 packets have been sent.  However, following
   the rekeying recommendations should prevent this attack.  The
   transport protocol [SSH-TRANS] recommends rekeying after one gigabyte
   of data, and the smallest possible packet is 16 bytes.  Therefore,
   rekeying SHOULD happen after 2**28 packets at the very most.

9.3.3.  Replay

   The use of a MAC other than ""none"" provides integrity and
   authentication.  In addition, the transport protocol provides a
   unique session identifier (bound in part to pseudo-random data that
   is part of the algorithm and key exchange process) that can be used
   by higher level protocols to bind data to a given session and prevent



Ylonen & Lonvick            Standards Track                    [Page 16]

RFC 4251               SSH Protocol Architecture            January 2006


   replay of data from prior sessions.  For example, the authentication
   protocol ([SSH-USERAUTH]) uses this to prevent replay of signatures
   from previous sessions.  Because public key authentication exchanges
   are cryptographically bound to the session (i.e., to the initial key
   exchange), they cannot be successfully replayed in other sessions.
   Note that the session id can be made public without harming the
   security of the protocol.

   If two sessions have the same session id (hash of key exchanges),
   then packets from one can be replayed against the other.  It must be
   stressed that the chances of such an occurrence are, needless to say,
   minimal when using modern cryptographic methods.  This is all the
   more true when specifying larger hash function outputs and DH
   parameters.

   Replay detection using monotonically increasing sequence numbers as
   input to the MAC, or HMAC in some cases, is described in [RFC2085],
   [RFC2246], [RFC2743], [RFC1964], [RFC2025], and [RFC4120].  The
   underlying construct is discussed in [RFC2104].  Essentially, a
   different sequence number in each packet ensures that at least this
   one input to the MAC function will be unique and will provide a
   nonrecurring MAC output that is not predictable to an attacker.  If
   the session stays active long enough, however, this sequence number
   will wrap.  This event may provide an attacker an opportunity to
   replay a previously recorded packet with an identical sequence number
   but only if the peers have not rekeyed since the transmission of the
   first packet with that sequence number.  If the peers have rekeyed,
   then the replay will be detected since the MAC check will fail.  For
   this reason, it must be emphasized that peers MUST rekey before a
   wrap of the sequence numbers.  Naturally, if an attacker does attempt
   to replay a captured packet before the peers have rekeyed, then the
   receiver of the duplicate packet will not be able to validate the MAC
   and it will be discarded.  The reason that the MAC will fail is
   because the receiver will formulate a MAC based upon the packet
   contents, the shared secret, and the expected sequence number.  Since
   the replayed packet will not be using that expected sequence number
   (the sequence number of the replayed packet will have already been
   passed by the receiver), the calculated MAC will not match the MAC
   received with the packet.

9.3.4.  Man-in-the-middle

   This protocol makes no assumptions or provisions for an
   infrastructure or means for distributing the public keys of hosts.
   It is expected that this protocol will sometimes be used without
   first verifying the association between the server host key and the
   server host name.  Such usage is vulnerable to man-in-the-middle
   attacks.  This section describes this and encourages administrators



Ylonen & Lonvick            Standards Track                    [Page 17]

RFC 4251               SSH Protocol Architecture            January 2006


   and users to understand the importance of verifying this association
   before any session is initiated.

   There are three cases of man-in-the-middle attacks to consider.  The
   first is where an attacker places a device between the client and the
   server before the session is initiated.  In this case, the attack
   device is trying to mimic the legitimate server and will offer its
   public key to the client when the client initiates a session.  If it
   were to offer the public key of the server, then it would not be able
   to decrypt or sign the transmissions between the legitimate server
   and the client unless it also had access to the private key of the
   host.  The attack device will also, simultaneously to this, initiate
   a session to the legitimate server, masquerading itself as the
   client.  If the public key of the server had been securely
   distributed to the client prior to that session initiation, the key
   offered to the client by the attack device will not match the key
   stored on the client.  In that case, the user SHOULD be given a
   warning that the offered host key does not match the host key cached
   on the client.  As described in Section 4.1, the user may be free to
   accept the new key and continue the session.  It is RECOMMENDED that
   the warning provide sufficient information to the user of the client
   device so the user may make an informed decision.  If the user
   chooses to continue the session with the stored public key of the
   server (not the public key offered at the start of the session), then
   the session-specific data between the attacker and server will be
   different between the client-to-attacker session and the attacker-
   to-server sessions due to the randomness discussed above.  From this,
   the attacker will not be able to make this attack work since the
   attacker will not be able to correctly sign packets containing this
   session-specific data from the server, since he does not have the
   private key of that server.

   The second case that should be considered is similar to the first
   case in that it also happens at the time of connection, but this case
   points out the need for the secure distribution of server public
   keys.  If the server public keys are not securely distributed, then
   the client cannot know if it is talking to the intended server.  An
   attacker may use social engineering techniques to pass off server
   keys to unsuspecting users and may then place a man-in-the-middle
   attack device between the legitimate server and the clients.  If this
   is allowed to happen, then the clients will form client-to-attacker
   sessions, and the attacker will form attacker-to-server sessions and
   will be able to monitor and manipulate all of the traffic between the
   clients and the legitimate servers.  Server administrators are
   encouraged to make host key fingerprints available for checking by
   some means whose security does not rely on the integrity of the
   actual host keys.  Possible mechanisms are discussed in Section 4.1
   and may also include secured Web pages, physical pieces of paper,



Ylonen & Lonvick            Standards Track                    [Page 18]

RFC 4251               SSH Protocol Architecture            January 2006


   etc.  Implementers SHOULD provide recommendations on how best to do
   this with their implementation.  Because the protocol is extensible,
   future extensions to the protocol may provide better mechanisms for
   dealing with the need to know the server's host key before
   connecting.  For example, making the host key fingerprint available
   through a secure DNS lookup, or using Kerberos ([RFC4120]) over
   GSS-API ([RFC1964]) during key exchange to authenticate the server
   are possibilities.

   In the third man-in-the-middle case, attackers may attempt to
   manipulate packets in transit between peers after the session has
   been established.  As described in Section 9.3.3, a successful attack
   of this nature is very improbable.  As in Section 9.3.3, this
   reasoning does assume that the MAC is secure and that it is
   infeasible to construct inputs to a MAC algorithm to give a known
   output.  This is discussed in much greater detail in Section 6 of
   [RFC2104].  If the MAC algorithm has a vulnerability or is weak
   enough, then the attacker may be able to specify certain inputs to
   yield a known MAC.  With that, they may be able to alter the contents
   of a packet in transit.  Alternatively, the attacker may be able to
   exploit the algorithm vulnerability or weakness to find the shared
   secret by reviewing the MACs from captured packets.  In either of
   those cases, an attacker could construct a packet or packets that
   could be inserted into an SSH stream.  To prevent this, implementers
   are encouraged to utilize commonly accepted MAC algorithms, and
   administrators are encouraged to watch current literature and
   discussions of cryptography to ensure that they are not using a MAC
   algorithm that has a recently found vulnerability or weakness.

   In summary, the use of this protocol without a reliable association
   of the binding between a host and its host keys is inherently
   insecure and is NOT RECOMMENDED.  However, it may be necessary in
   non-security-critical environments, and will still provide protection
   against passive attacks.  Implementers of protocols and applications
   running on top of this protocol should keep this possibility in mind.

9.3.5.  Denial of Service

   This protocol is designed to be used over a reliable transport.  If
   transmission errors or message manipulation occur, the connection is
   closed.  The connection SHOULD be re-established if this occurs.
   Denial of service attacks of this type (wire cutter) are almost
   impossible to avoid.

   In addition, this protocol is vulnerable to denial of service attacks
   because an attacker can force the server to go through the CPU and
   memory intensive tasks of connection setup and key exchange without
   authenticating.  Implementers SHOULD provide features that make this



Ylonen & Lonvick            Standards Track                    [Page 19]

RFC 4251               SSH Protocol Architecture            January 2006


   more difficult, for example, only allowing connections from a subset
   of clients known to have valid users.

9.3.6.  Covert Channels

   The protocol was not designed to eliminate covert channels.  For
   example, the padding, SSH_MSG_IGNORE messages, and several other
   places in the protocol can be used to pass covert information, and
   the recipient has no reliable way of verifying whether such
   information is being sent.

9.3.7.  Forward Secrecy

   It should be noted that the Diffie-Hellman key exchanges may provide
   perfect forward secrecy (PFS).  PFS is essentially defined as the
   cryptographic property of a key-establishment protocol in which the
   compromise of a session key or long-term private key after a given
   session does not cause the compromise of any earlier session
   [ANSI-T1.523-2001].  SSH sessions resulting from a key exchange using
   the diffie-hellman methods described in the section Diffie-Hellman
   Key Exchange of [SSH-TRANS] (including ""diffie-hellman-group1-sha1""
   and ""diffie-hellman-group14-sha1"") are secure even if private
   keying/authentication material is later revealed, but not if the
   session keys are revealed.  So, given this definition of PFS, SSH
   does have PFS.  However, this property is not commuted to any of the
   applications or protocols using SSH as a transport.  The transport
   layer of SSH provides confidentiality for password authentication and
   other methods that rely on secret data.

   Of course, if the DH private parameters for the client and server are
   revealed, then the session key is revealed, but these items can be
   thrown away after the key exchange completes.  It's worth pointing
   out that these items should not be allowed to end up on swap space
   and that they should be erased from memory as soon as the key
   exchange completes.

9.3.8.  Ordering of Key Exchange Methods

   As stated in the section on Algorithm Negotiation of [SSH-TRANS],
   each device will send a list of preferred methods for key exchange.
   The most-preferred method is the first in the list.  It is
   RECOMMENDED that the algorithms be sorted by cryptographic strength,
   strongest first.  Some additional guidance for this is given in
   [RFC3766].







Ylonen & Lonvick            Standards Track                    [Page 20]

RFC 4251               SSH Protocol Architecture            January 2006


9.3.9.  Traffic Analysis

   Passive monitoring of any protocol may give an attacker some
   information about the session, the user, or protocol specific
   information that they would otherwise not be able to garner.  For
   example, it has been shown that traffic analysis of an SSH session
   can yield information about the length of the password - [Openwall]
   and [USENIX].  Implementers should use the SSH_MSG_IGNORE packet,
   along with the inclusion of random lengths of padding, to thwart
   attempts at traffic analysis.  Other methods may also be found and
   implemented.

9.4.  Authentication Protocol

   The purpose of this protocol is to perform client user
   authentication.  It assumes that this runs over a secure transport
   layer protocol, which has already authenticated the server machine,
   established an encrypted communications channel, and computed a
   unique session identifier for this session.

   Several authentication methods with different security
   characteristics are allowed.  It is up to the server's local policy
   to decide which methods (or combinations of methods) it is willing to
   accept for each user.  Authentication is no stronger than the weakest
   combination allowed.

   The server may go into a sleep period after repeated unsuccessful
   authentication attempts to make key search more difficult for
   attackers.  Care should be taken so that this doesn't become a self-
   denial of service vector.

9.4.1.  Weak Transport

   If the transport layer does not provide confidentiality,
   authentication methods that rely on secret data SHOULD be disabled.
   If it does not provide strong integrity protection, requests to
   change authentication data (e.g., a password change) SHOULD be
   disabled to prevent an attacker from modifying the ciphertext without
   being noticed, or rendering the new authentication data unusable
   (denial of service).

   The assumption stated above, that the Authentication Protocol only
   runs over a secure transport that has previously authenticated the
   server, is very important to note.  People deploying SSH are reminded
   of the consequences of man-in-the-middle attacks if the client does
   not have a very strong a priori association of the server with the
   host key of that server.  Specifically, for the case of the
   Authentication Protocol, the client may form a session to a man-in-



Ylonen & Lonvick            Standards Track                    [Page 21]

RFC 4251               SSH Protocol Architecture            January 2006


   the-middle attack device and divulge user credentials such as their
   username and password.  Even in the cases of authentication where no
   user credentials are divulged, an attacker may still gain information
   they shouldn't have by capturing key-strokes in much the same way
   that a honeypot works.

9.4.2.  Debug Messages

   Special care should be taken when designing debug messages.  These
   messages may reveal surprising amounts of information about the host
   if not properly designed.  Debug messages can be disabled (during
   user authentication phase) if high security is required.
   Administrators of host machines should make all attempts to
   compartmentalize all event notification messages and protect them
   from unwarranted observation.  Developers should be aware of the
   sensitive nature of some of the normal event and debug messages, and
   may want to provide guidance to administrators on ways to keep this
   information away from unauthorized people.  Developers should
   consider minimizing the amount of sensitive information obtainable by
   users during the authentication phase, in accordance with the local
   policies.  For this reason, it is RECOMMENDED that debug messages be
   initially disabled at the time of deployment and require an active
   decision by an administrator to allow them to be enabled.  It is also
   RECOMMENDED that a message expressing this concern be presented to
   the administrator of a system when the action is taken to enable
   debugging messages.

9.4.3.  Local Security Policy

   The implementer MUST ensure that the credentials provided validate
   the professed user and also MUST ensure that the local policy of the
   server permits the user the access requested.  In particular, because
   of the flexible nature of the SSH connection protocol, it may not be
   possible to determine the local security policy, if any, that should
   apply at the time of authentication because the kind of service being
   requested is not clear at that instant.  For example, local policy
   might allow a user to access files on the server, but not start an
   interactive shell.  However, during the authentication protocol, it
   is not known whether the user will be accessing files, attempting to
   use an interactive shell, or even both.  In any event, where local
   security policy for the server host exists, it MUST be applied and
   enforced correctly.

   Implementers are encouraged to provide a default local policy and
   make its parameters known to administrators and users.  At the
   discretion of the implementers, this default policy may be along the
   lines of anything-goes where there are no restrictions placed upon
   users, or it may be along the lines of excessively-restrictive, in



Ylonen & Lonvick            Standards Track                    [Page 22]

RFC 4251               SSH Protocol Architecture            January 2006


   which case, the administrators will have to actively make changes to
   the initial default parameters to meet their needs.  Alternatively,
   it may be some attempt at providing something practical and
   immediately useful to the administrators of the system so they don't
   have to put in much effort to get SSH working.  Whatever choice is
   made must be applied and enforced as required above.

9.4.4  Public Key Authentication

   The use of public key authentication assumes that the client host has
   not been compromised.  It also assumes that the private key of the
   server host has not been compromised.

   This risk can be mitigated by the use of passphrases on private keys;
   however, this is not an enforceable policy.  The use of smartcards,
   or other technology to make passphrases an enforceable policy is
   suggested.

   The server could require both password and public key authentication;
   however, this requires the client to expose its password to the
   server (see the section on Password Authentication below.)

9.4.5.  Password Authentication

   The password mechanism, as specified in the authentication protocol,
   assumes that the server has not been compromised.  If the server has
   been compromised, using password authentication will reveal a valid
   username/password combination to the attacker, which may lead to
   further compromises.

   This vulnerability can be mitigated by using an alternative form of
   authentication.  For example, public key authentication makes no
   assumptions about security on the server.

9.4.6.  Host-Based Authentication

   Host-based authentication assumes that the client has not been
   compromised.  There are no mitigating strategies, other than to use
   host-based authentication in combination with another authentication
   method.











Ylonen & Lonvick            Standards Track                    [Page 23]

RFC 4251               SSH Protocol Architecture            January 2006


9.5.  Connection Protocol

9.5.1.  End Point Security

   End point security is assumed by the connection protocol.  If the
   server has been compromised, any terminal sessions, port forwarding,
   or systems accessed on the host are compromised.  There are no
   mitigating factors for this.

   If the client has been compromised, and the server fails to stop the
   attacker at the authentication protocol, all services exposed (either
   as subsystems or through forwarding) will be vulnerable to attack.
   Implementers SHOULD provide mechanisms for administrators to control
   which services are exposed to limit the vulnerability of other
   services.  These controls might include controlling which machines
   and ports can be targeted in port-forwarding operations, which users
   are allowed to use interactive shell facilities, or which users are
   allowed to use exposed subsystems.

9.5.2.  Proxy Forwarding

   The SSH connection protocol allows for proxy forwarding of other
   protocols such as SMTP, POP3, and HTTP.  This may be a concern for
   network administrators who wish to control the access of certain
   applications by users located outside of their physical location.
   Essentially, the forwarding of these protocols may violate site-
   specific security policies, as they may be undetectably tunneled
   through a firewall.  Implementers SHOULD provide an administrative
   mechanism to control the proxy forwarding functionality so that
   site-specific security policies may be upheld.

   In addition, a reverse proxy forwarding functionality is available,
   which, again, can be used to bypass firewall controls.

   As indicated above, end-point security is assumed during proxy
   forwarding operations.  Failure of end-point security will compromise
   all data passed over proxy forwarding.

9.5.3.  X11 Forwarding

   Another form of proxy forwarding provided by the SSH connection
   protocol is the forwarding of the X11 protocol.  If end-point
   security has been compromised, X11 forwarding may allow attacks
   against the X11 server.  Users and administrators should, as a matter
   of course, use appropriate X11 security mechanisms to prevent
   unauthorized use of the X11 server.  Implementers, administrators,
   and users who wish to further explore the security mechanisms of X11
   are invited to read [SCHEIFLER] and analyze previously reported



Ylonen & Lonvick            Standards Track                    [Page 24]

RFC 4251               SSH Protocol Architecture            January 2006


   problems with the interactions between SSH forwarding and X11 in CERT
   vulnerabilities VU#363181 and VU#118892 [CERT].

   X11 display forwarding with SSH, by itself, is not sufficient to
   correct well known problems with X11 security [VENEMA].  However, X11
   display forwarding in SSH (or other secure protocols), combined with
   actual and pseudo-displays that accept connections only over local
   IPC mechanisms authorized by permissions or access control lists
   (ACLs), does correct many X11 security problems, as long as the
   ""none"" MAC is not used.  It is RECOMMENDED that X11 display
   implementations default to allow the display to open only over local
   IPC.  It is RECOMMENDED that SSH server implementations that support
   X11 forwarding default to allow the display to open only over local
   IPC.  On single-user systems, it might be reasonable to default to
   allow the local display to open over TCP/IP.

   Implementers of the X11 forwarding protocol SHOULD implement the
   magic cookie access-checking spoofing mechanism, as described in
   [SSH-CONNECT], as an additional mechanism to prevent unauthorized use
   of the proxy.































Ylonen & Lonvick            Standards Track                    [Page 25]

RFC 4251               SSH Protocol Architecture            January 2006


10.  References

10.1.  Normative References

   [SSH-TRANS]        Ylonen, T. and C. Lonvick, Ed., ""The Secure Shell
                      (SSH) Transport Layer Protocol"", RFC 4253, January
                      2006.

   [SSH-USERAUTH]     Ylonen, T. and C. Lonvick, Ed., ""The Secure Shell
                      (SSH) Authentication Protocol"", RFC 4252, January
                      2006.

   [SSH-CONNECT]      Ylonen, T. and C. Lonvick, Ed., ""The Secure Shell
                      (SSH) Connection Protocol"", RFC 4254, January
                      2006.

   [SSH-NUMBERS]      Lehtinen, S. and C. Lonvick, Ed., ""The Secure
                      Shell (SSH) Protocol Assigned Numbers"", RFC 4250,
                      January 2006.

   [RFC2119]          Bradner, S., ""Key words for use in RFCs to
                      Indicate Requirement Levels"", BCP 14, RFC 2119,
                      March 1997.

   [RFC2434]          Narten, T. and H. Alvestrand, ""Guidelines for
                      Writing an IANA Considerations Section in RFCs"",
                      BCP 26, RFC 2434, October 1998.

   [RFC3066]          Alvestrand, H., ""Tags for the Identification of
                      Languages"", BCP 47, RFC 3066, January 2001.

   [RFC3629]          Yergeau, F., ""UTF-8, a transformation format of
                      ISO 10646"", STD 63, RFC 3629, November 2003.

10.2.  Informative References

   [RFC0822]          Crocker, D., ""Standard for the format of ARPA
                      Internet text messages"", STD 11, RFC 822, August
                      1982.

   [RFC0854]          Postel, J. and J. Reynolds, ""Telnet Protocol
                      Specification"", STD 8, RFC 854, May 1983.

   [RFC1034]          Mockapetris, P., ""Domain names - concepts and
                      facilities"", STD 13, RFC 1034, November 1987.






Ylonen & Lonvick            Standards Track                    [Page 26]

RFC 4251               SSH Protocol Architecture            January 2006


   [RFC1282]          Kantor, B., ""BSD Rlogin"", RFC 1282, December 1991.

   [RFC4120]          Neuman, C., Yu, T., Hartman, S., and K. Raeburn,
                      ""The Kerberos Network Authentication Service
                      (V5)"", RFC 4120, July 2005.

   [RFC1964]          Linn, J., ""The Kerberos Version 5 GSS-API
                      Mechanism"", RFC 1964, June 1996.

   [RFC2025]          Adams, C., ""The Simple Public-Key GSS-API
                      Mechanism (SPKM)"", RFC 2025, October 1996.

   [RFC2085]          Oehler, M. and R. Glenn, ""HMAC-MD5 IP
                      Authentication with Replay Prevention"", RFC 2085,
                      February 1997.

   [RFC2104]          Krawczyk, H., Bellare, M., and R. Canetti, ""HMAC:
                      Keyed-Hashing for Message Authentication"", RFC
                      2104, February 1997.

   [RFC2246]          Dierks, T. and C. Allen, ""The TLS Protocol Version
                      1.0"", RFC 2246, January 1999.

   [RFC2410]          Glenn, R. and S. Kent, ""The NULL Encryption
                      Algorithm and Its Use With IPsec"", RFC 2410,
                      November 1998.

   [RFC2743]          Linn, J., ""Generic Security Service Application
                      Program Interface Version 2, Update 1"", RFC 2743,
                      January 2000.

   [RFC3766]          Orman, H. and P. Hoffman, ""Determining Strengths
                      For Public Keys Used For Exchanging Symmetric
                      Keys"", BCP 86, RFC 3766, April 2004.

   [RFC4086]          Eastlake, D., 3rd, Schiller, J., and S. Crocker,
                      ""Randomness Requirements for Security"", BCP 106,
                      RFC 4086, June 2005.

   [FIPS-180-2]       US National Institute of Standards and Technology,
                      ""Secure Hash Standard (SHS)"", Federal Information
                      Processing Standards Publication 180-2, August
                      2002.

   [FIPS-186-2]       US National Institute of Standards and Technology,
                      ""Digital Signature Standard (DSS)"", Federal
                      Information Processing Standards Publication 186-
                      2, January 2000.



Ylonen & Lonvick            Standards Track                    [Page 27]

RFC 4251               SSH Protocol Architecture            January 2006


   [FIPS-197]         US National Institute of Standards and Technology,
                      ""Advanced Encryption Standard (AES)"", Federal
                      Information Processing Standards Publication 197,
                      November 2001.

   [ANSI-T1.523-2001] American National Standards Institute, Inc.,
                      ""Telecom Glossary 2000"", ANSI T1.523-2001,
                      February 2001.

   [SCHNEIER]         Schneier, B., ""Applied Cryptography Second
                      Edition:  protocols algorithms and source in code
                      in C"", John Wiley and Sons, New York, NY, 1996.

   [SCHEIFLER]        Scheifler, R., ""X Window System : The Complete
                      Reference to Xlib, X Protocol, Icccm, Xlfd, 3rd
                      edition."", Digital Press, ISBN 1555580882,
                      February 1992.

   [KAUFMAN]          Kaufman, C., Perlman, R., and M. Speciner,
                      ""Network Security: PRIVATE Communication in a
                      PUBLIC World"", Prentice Hall Publisher, 1995.

   [CERT]             CERT Coordination Center, The.,
                      ""http://www.cert.org/nav/index_red.html"".

   [VENEMA]           Venema, W., ""Murphy's Law and Computer Security"",
                      Proceedings of 6th USENIX Security Symposium, San
                      Jose CA
                      http://www.usenix.org/publications/library/
                      proceedings/sec96/venema.html, July 1996.

   [ROGAWAY]          Rogaway, P., ""Problems with Proposed IP
                      Cryptography"", Unpublished paper
                      http://www.cs.ucdavis.edu/~rogaway/ papers/draft-
                      rogaway-ipsec-comments-00.txt, 1996.

   [DAI]              Dai, W., ""An attack against SSH2 protocol"", Email
                      to the SECSH Working Group ietf-ssh@netbsd.org
                      ftp:// ftp.ietf.org/ietf-mail-archive/secsh/2002-
                      02.mail, Feb 2002.

   [BELLARE]          Bellaire, M., Kohno, T., and C. Namprempre,
                      ""Authenticated Encryption in SSH: Fixing the SSH
                      Binary Packet Protocol"", Proceedings of the 9th
                      ACM Conference on Computer and Communications
                      Security, Sept 2002.





Ylonen & Lonvick            Standards Track                    [Page 28]

RFC 4251               SSH Protocol Architecture            January 2006


   [Openwall]         Solar Designer and D. Song, ""SSH Traffic Analysis
                      Attacks"", Presentation given at HAL2001 and
                      NordU2002 Conferences, Sept 2001.

   [USENIX]           Song, X.D., Wagner, D., and X. Tian, ""Timing
                      Analysis of Keystrokes and SSH Timing Attacks"",
                      Paper given at 10th USENIX Security Symposium,
                      2001.

Authors' Addresses

   Tatu Ylonen
   SSH Communications Security Corp
   Valimotie 17
   00380 Helsinki
   Finland

   EMail: ylo@ssh.com


   Chris Lonvick (editor)
   Cisco Systems, Inc.
   12515 Research Blvd.
   Austin  78759
   USA

   EMail: clonvick@cisco.com

Trademark Notice

   ""ssh"" is a registered trademark in the United States and/or other
   countries.



















Ylonen & Lonvick            Standards Track                    [Page 29]

RFC 4251               SSH Protocol Architecture            January 2006


Full Copyright Statement

   Copyright (C) The Internet Society (2006).

   This document is subject to the rights, licenses and restrictions
   contained in BCP 78, and except as set forth therein, the authors
   retain all their rights.

   This document and the information contained herein are provided on an
   ""AS IS"" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET
   ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,
   INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
   INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

Intellectual Property

   The IETF takes no position regarding the validity or scope of any
   Intellectual Property Rights or other rights that might be claimed to
   pertain to the implementation or use of the technology described in
   this document or the extent to which any license under such rights
   might or might not be available; nor does it represent that it has
   made any independent effort to identify any such rights.  Information
   on the procedures with respect to rights in RFC documents can be
   found in BCP 78 and BCP 79.

   Copies of IPR disclosures made to the IETF Secretariat and any
   assurances of licenses to be made available, or the result of an
   attempt made to obtain a general license or permission for the use of
   such proprietary rights by implementers or users of this
   specification can be obtained from the IETF on-line IPR repository at
   http://www.ietf.org/ipr.

   The IETF invites any interested party to bring to its attention any
   copyrights, patents or patent applications, or other proprietary
   rights that may cover technology that may be required to implement
   this standard.  Please address the information to the IETF at
   ietf-ipr@ietf.org.

Acknowledgement

   Funding for the RFC Editor function is provided by the IETF
   Administrative Support Activity (IASA).







Ylonen & Lonvick            Standards Track                    [Page 30]

"
RFC854,"
[RFC Home] [TEXT|PDF|HTML] [Tracker] [IPR] [Errata] [Info page]                                                                 INTERNET STANDARDUpdated by: 5198 Errata ExistNetwork Working Group                                          J. Postel
Request for Comments: 854                                    J. Reynolds
                                                                     ISI
Obsoletes: NIC 18639                                            May 1983

                     TELNET PROTOCOL SPECIFICATION


This RFC specifies a standard for the ARPA Internet community.  Hosts on
the ARPA Internet are expected to adopt and implement this standard.

INTRODUCTION

   The purpose of the TELNET Protocol is to provide a fairly general,
   bi-directional, eight-bit byte oriented communications facility.  Its
   primary goal is to allow a standard method of interfacing terminal
   devices and terminal-oriented processes to each other.  It is
   envisioned that the protocol may also be used for terminal-terminal
   communication (""linking"") and process-process communication
   (distributed computation).

GENERAL CONSIDERATIONS

   A TELNET connection is a Transmission Control Protocol (TCP)
   connection used to transmit data with interspersed TELNET control
   information.

   The TELNET Protocol is built upon three main ideas:  first, the
   concept of a ""Network Virtual Terminal""; second, the principle of
   negotiated options; and third, a symmetric view of terminals and
   processes.

   1.  When a TELNET connection is first established, each end is
   assumed to originate and terminate at a ""Network Virtual Terminal"",
   or NVT.  An NVT is an imaginary device which provides a standard,
   network-wide, intermediate representation of a canonical terminal.
   This eliminates the need for ""server"" and ""user"" hosts to keep
   information about the characteristics of each other's terminals and
   terminal handling conventions.  All hosts, both user and server, map
   their local device characteristics and conventions so as to appear to
   be dealing with an NVT over the network, and each can assume a
   similar mapping by the other party.  The NVT is intended to strike a
   balance between being overly restricted (not providing hosts a rich
   enough vocabulary for mapping into their local character sets), and
   being overly inclusive (penalizing users with modest terminals).

      NOTE:  The ""user"" host is the host to which the physical terminal
      is normally attached, and the ""server"" host is the host which is
      normally providing some service.  As an alternate point of view,




Postel & Reynolds                                               [Page 1]

RFC 854                                                         May 1983


      applicable even in terminal-to-terminal or process-to-process
      communications, the ""user"" host is the host which initiated the
      communication.

   2.  The principle of negotiated options takes cognizance of the fact
   that many hosts will wish to provide additional services over and
   above those available within an NVT, and many users will have
   sophisticated terminals and would like to have elegant, rather than
   minimal, services.  Independent of, but structured within the TELNET
   Protocol are various ""options"" that will be sanctioned and may be
   used with the ""DO, DON'T, WILL, WON'T"" structure (discussed below) to
   allow a user and server to agree to use a more elaborate (or perhaps
   just different) set of conventions for their TELNET connection.  Such
   options could include changing the character set, the echo mode, etc.

   The basic strategy for setting up the use of options is to have
   either party (or both) initiate a request that some option take
   effect.  The other party may then either accept or reject the
   request.  If the request is accepted the option immediately takes
   effect; if it is rejected the associated aspect of the connection
   remains as specified for an NVT.  Clearly, a party may always refuse
   a request to enable, and must never refuse a request to disable some
   option since all parties must be prepared to support the NVT.

   The syntax of option negotiation has been set up so that if both
   parties request an option simultaneously, each will see the other's
   request as the positive acknowledgment of its own.

   3.  The symmetry of the negotiation syntax can potentially lead to
   nonterminating acknowledgment loops -- each party seeing the incoming
   commands not as acknowledgments but as new requests which must be
   acknowledged.  To prevent such loops, the following rules prevail:

      a. Parties may only request a change in option status; i.e., a
      party may not send out a ""request"" merely to announce what mode it
      is in.

      b. If a party receives what appears to be a request to enter some
      mode it is already in, the request should not be acknowledged.
      This non-response is essential to prevent endless loops in the
      negotiation.  It is required that a response be sent to requests
      for a change of mode -- even if the mode is not changed.

      c. Whenever one party sends an option command to a second party,
      whether as a request or an acknowledgment, and use of the option
      will have any effect on the processing of the data being sent from
      the first party to the second, then the command must be inserted
      in the data stream at the point where it is desired that it take


Postel & Reynolds                                               [Page 2]

RFC 854                                                         May 1983


      effect.  (It should be noted that some time will elapse between
      the transmission of a request and the receipt of an
      acknowledgment, which may be negative.  Thus, a host may wish to
      buffer data, after requesting an option, until it learns whether
      the request is accepted or rejected, in order to hide the
      ""uncertainty period"" from the user.)

   Option requests are likely to flurry back and forth when a TELNET
   connection is first established, as each party attempts to get the
   best possible service from the other party.  Beyond that, however,
   options can be used to dynamically modify the characteristics of the
   connection to suit changing local conditions.  For example, the NVT,
   as will be explained later, uses a transmission discipline well
   suited to the many ""line at a time"" applications such as BASIC, but
   poorly suited to the many ""character at a time"" applications such as
   NLS.  A server might elect to devote the extra processor overhead
   required for a ""character at a time"" discipline when it was suitable
   for the local process and would negotiate an appropriate option.
   However, rather than then being permanently burdened with the extra
   processing overhead, it could switch (i.e., negotiate) back to NVT
   when the detailed control was no longer necessary.

   It is possible for requests initiated by processes to stimulate a
   nonterminating request loop if the process responds to a rejection by
   merely re-requesting the option.  To prevent such loops from
   occurring, rejected requests should not be repeated until something
   changes.  Operationally, this can mean the process is running a
   different program, or the user has given another command, or whatever
   makes sense in the context of the given process and the given option.
   A good rule of thumb is that a re-request should only occur as a
   result of subsequent information from the other end of the connection
   or when demanded by local human intervention.

   Option designers should not feel constrained by the somewhat limited
   syntax available for option negotiation.  The intent of the simple
   syntax is to make it easy to have options -- since it is
   correspondingly easy to profess ignorance about them.  If some
   particular option requires a richer negotiation structure than
   possible within ""DO, DON'T, WILL, WON'T"", the proper tack is to use
   ""DO, DON'T, WILL, WON'T"" to establish that both parties understand
   the option, and once this is accomplished a more exotic syntax can be
   used freely.  For example, a party might send a request to alter
   (establish) line length.  If it is accepted, then a different syntax
   can be used for actually negotiating the line length -- such a
   ""sub-negotiation"" might include fields for minimum allowable, maximum
   allowable and desired line lengths.  The important concept is that




Postel & Reynolds                                               [Page 3]

RFC 854                                                         May 1983


   such expanded negotiations should never begin until some prior
   (standard) negotiation has established that both parties are capable
   of parsing the expanded syntax.

   In summary, WILL XXX is sent, by either party, to indicate that
   party's desire (offer) to begin performing option XXX, DO XXX and
   DON'T XXX being its positive and negative acknowledgments; similarly,
   DO XXX is sent to indicate a desire (request) that the other party
   (i.e., the recipient of the DO) begin performing option XXX, WILL XXX
   and WON'T XXX being the positive and negative acknowledgments.  Since
   the NVT is what is left when no options are enabled, the DON'T and
   WON'T responses are guaranteed to leave the connection in a state
   which both ends can handle.  Thus, all hosts may implement their
   TELNET processes to be totally unaware of options that are not
   supported, simply returning a rejection to (i.e., refusing) any
   option request that cannot be understood.

   As much as possible, the TELNET protocol has been made server-user
   symmetrical so that it easily and naturally covers the user-user
   (linking) and server-server (cooperating processes) cases.  It is
   hoped, but not absolutely required, that options will further this
   intent.  In any case, it is explicitly acknowledged that symmetry is
   an operating principle rather than an ironclad rule.

   A companion document, ""TELNET Option Specifications,"" should be
   consulted for information about the procedure for establishing new
   options.

THE NETWORK VIRTUAL TERMINAL

   The Network Virtual Terminal (NVT) is a bi-directional character
   device.  The NVT has a printer and a keyboard.  The printer responds
   to incoming data and the keyboard produces outgoing data which is
   sent over the TELNET connection and, if ""echoes"" are desired, to the
   NVT's printer as well.  ""Echoes"" will not be expected to traverse the
   network (although options exist to enable a ""remote"" echoing mode of
   operation, no host is required to implement this option).  The code
   set is seven-bit USASCII in an eight-bit field, except as modified
   herein.  Any code conversion and timing considerations are local
   problems and do not affect the NVT.

   TRANSMISSION OF DATA

      Although a TELNET connection through the network is intrinsically
      full duplex, the NVT is to be viewed as a half-duplex device
      operating in a line-buffered mode.  That is, unless and until




Postel & Reynolds                                               [Page 4]

RFC 854                                                         May 1983


      options are negotiated to the contrary, the following default
      conditions pertain to the transmission of data over the TELNET
      connection:

         1)  Insofar as the availability of local buffer space permits,
         data should be accumulated in the host where it is generated
         until a complete line of data is ready for transmission, or
         until some locally-defined explicit signal to transmit occurs.
         This signal could be generated either by a process or by a
         human user.

         The motivation for this rule is the high cost, to some hosts,
         of processing network input interrupts, coupled with the
         default NVT specification that ""echoes"" do not traverse the
         network.  Thus, it is reasonable to buffer some amount of data
         at its source.  Many systems take some processing action at the
         end of each input line (even line printers or card punches
         frequently tend to work this way), so the transmission should
         be triggered at the end of a line.  On the other hand, a user
         or process may sometimes find it necessary or desirable to
         provide data which does not terminate at the end of a line;
         therefore implementers are cautioned to provide methods of
         locally signaling that all buffered data should be transmitted
         immediately.

         2)  When a process has completed sending data to an NVT printer
         and has no queued input from the NVT keyboard for further
         processing (i.e., when a process at one end of a TELNET
         connection cannot proceed without input from the other end),
         the process must transmit the TELNET Go Ahead (GA) command.

         This rule is not intended to require that the TELNET GA command
         be sent from a terminal at the end of each line, since server
         hosts do not normally require a special signal (in addition to
         end-of-line or other locally-defined characters) in order to
         commence processing.  Rather, the TELNET GA is designed to help
         a user's local host operate a physically half duplex terminal
         which has a ""lockable"" keyboard such as the IBM 2741.  A
         description of this type of terminal may help to explain the
         proper use of the GA command.

         The terminal-computer connection is always under control of
         either the user or the computer.  Neither can unilaterally
         seize control from the other; rather the controlling end must
         relinguish its control explicitly.  At the terminal end, the
         hardware is constructed so as to relinquish control each time
         that a ""line"" is terminated (i.e., when the ""New Line"" key is
         typed by the user).  When this occurs, the attached (local)


Postel & Reynolds                                               [Page 5]

RFC 854                                                         May 1983


         computer processes the input data, decides if output should be
         generated, and if not returns control to the terminal.  If
         output should be generated, control is retained by the computer
         until all output has been transmitted.

         The difficulties of using this type of terminal through the
         network should be obvious.  The ""local"" computer is no longer
         able to decide whether to retain control after seeing an
         end-of-line signal or not; this decision can only be made by
         the ""remote"" computer which is processing the data.  Therefore,
         the TELNET GA command provides a mechanism whereby the ""remote""
         (server) computer can signal the ""local"" (user) computer that
         it is time to pass control to the user of the terminal.  It
         should be transmitted at those times, and only at those times,
         when the user should be given control of the terminal.  Note
         that premature transmission of the GA command may result in the
         blocking of output, since the user is likely to assume that the
         transmitting system has paused, and therefore he will fail to
         turn the line around manually.

      The foregoing, of course, does not apply to the user-to-server
      direction of communication.  In this direction, GAs may be sent at
      any time, but need not ever be sent.  Also, if the TELNET
      connection is being used for process-to-process communication, GAs
      need not be sent in either direction.  Finally, for
      terminal-to-terminal communication, GAs may be required in
      neither, one, or both directions.  If a host plans to support
      terminal-to-terminal communication it is suggested that the host
      provide the user with a means of manually signaling that it is
      time for a GA to be sent over the TELNET connection; this,
      however, is not a requirement on the implementer of a TELNET
      process.

      Note that the symmetry of the TELNET model requires that there is
      an NVT at each end of the TELNET connection, at least
      conceptually.

   STANDARD REPRESENTATION OF CONTROL FUNCTIONS

      As stated in the Introduction to this document, the primary goal
      of the TELNET protocol is the provision of a standard interfacing
      of terminal devices and terminal-oriented processes through the
      network.  Early experiences with this type of interconnection have
      shown that certain functions are implemented by most servers, but
      that the methods of invoking these functions differ widely.  For a
      human user who interacts with several server systems, these
      differences are highly frustrating.  TELNET, therefore, defines a
      standard representation for five of these functions, as described


Postel & Reynolds                                               [Page 6]

RFC 854                                                         May 1983


      below.  These standard representations have standard, but not
      required, meanings (with the exception that the Interrupt Process
      (IP) function may be required by other protocols which use
      TELNET); that is, a system which does not provide the function to
      local users need not provide it to network users and may treat the
      standard representation for the function as a No-operation.  On
      the other hand, a system which does provide the function to a
      local user is obliged to provide the same function to a network
      user who transmits the standard representation for the function.

      Interrupt Process (IP)

         Many systems provide a function which suspends, interrupts,
         aborts, or terminates the operation of a user process.  This
         function is frequently used when a user believes his process is
         in an unending loop, or when an unwanted process has been
         inadvertently activated.  IP is the standard representation for
         invoking this function.  It should be noted by implementers
         that IP may be required by other protocols which use TELNET,
         and therefore should be implemented if these other protocols
         are to be supported.

      Abort Output (AO)

         Many systems provide a function which allows a process, which
         is generating output, to run to completion (or to reach the
         same stopping point it would reach if running to completion)
         but without sending the output to the user's terminal.
         Further, this function typically clears any output already
         produced but not yet actually printed (or displayed) on the
         user's terminal.  AO is the standard representation for
         invoking this function.  For example, some subsystem might
         normally accept a user's command, send a long text string to
         the user's terminal in response, and finally signal readiness
         to accept the next command by sending a ""prompt"" character
         (preceded by <CR><LF>) to the user's terminal.  If the AO were
         received during the transmission of the text string, a
         reasonable implementation would be to suppress the remainder of
         the text string, but transmit the prompt character and the
         preceding <CR><LF>.  (This is possibly in distinction to the
         action which might be taken if an IP were received; the IP
         might cause suppression of the text string and an exit from the
         subsystem.)

         It should be noted, by server systems which provide this
         function, that there may be buffers external to the system (in




Postel & Reynolds                                               [Page 7]

RFC 854                                                         May 1983


         the network and the user's local host) which should be cleared;
         the appropriate way to do this is to transmit the ""Synch""
         signal (described below) to the user system.

      Are You There (AYT)

         Many systems provide a function which provides the user with
         some visible (e.g., printable) evidence that the system is
         still up and running.  This function may be invoked by the user
         when the system is unexpectedly ""silent"" for a long time,
         because of the unanticipated (by the user) length of a
         computation, an unusually heavy system load, etc.  AYT is the
         standard representation for invoking this function.

      Erase Character (EC)

         Many systems provide a function which deletes the last
         preceding undeleted character or ""print position""* from the
         stream of data being supplied by the user.  This function is
         typically used to edit keyboard input when typing mistakes are
         made.  EC is the standard representation for invoking this
         function.

            *NOTE:  A ""print position"" may contain several characters
            which are the result of overstrikes, or of sequences such as
            <char1> BS <char2>...

      Erase Line (EL)

         Many systems provide a function which deletes all the data in
         the current ""line"" of input.  This function is typically used
         to edit keyboard input.  EL is the standard representation for
         invoking this function.

   THE TELNET ""SYNCH"" SIGNAL

      Most time-sharing systems provide mechanisms which allow a
      terminal user to regain control of a ""runaway"" process; the IP and
      AO functions described above are examples of these mechanisms.
      Such systems, when used locally, have access to all of the signals
      supplied by the user, whether these are normal characters or
      special ""out of band"" signals such as those supplied by the
      teletype ""BREAK"" key or the IBM 2741 ""ATTN"" key.  This is not
      necessarily true when terminals are connected to the system
      through the network; the network's flow control mechanisms may
      cause such a signal to be buffered elsewhere, for example in the
      user's host.



Postel & Reynolds                                               [Page 8]

RFC 854                                                         May 1983


      To counter this problem, the TELNET ""Synch"" mechanism is
      introduced.  A Synch signal consists of a TCP Urgent notification,
      coupled with the TELNET command DATA MARK.  The Urgent
      notification, which is not subject to the flow control pertaining
      to the TELNET connection, is used to invoke special handling of
      the data stream by the process which receives it.  In this mode,
      the data stream is immediately scanned for ""interesting"" signals
      as defined below, discarding intervening data.  The TELNET command
      DATA MARK (DM) is the synchronizing mark in the data stream which
      indicates that any special signal has already occurred and the
      recipient can return to normal processing of the data stream.

         The Synch is sent via the TCP send operation with the Urgent
         flag set and the DM as the last (or only) data octet.

      When several Synchs are sent in rapid succession, the Urgent
      notifications may be merged.  It is not possible to count Urgents
      since the number received will be less than or equal the number
      sent.  When in normal mode, a DM is a no operation; when in urgent
      mode, it signals the end of the urgent processing.

         If TCP indicates the end of Urgent data before the DM is found,
         TELNET should continue the special handling of the data stream
         until the DM is found.

         If TCP indicates more Urgent data after the DM is found, it can
         only be because of a subsequent Synch.  TELNET should continue
         the special handling of the data stream until another DM is
         found.

      ""Interesting"" signals are defined to be:  the TELNET standard
      representations of IP, AO, and AYT (but not EC or EL); the local
      analogs of these standard representations (if any); all other
      TELNET commands; other site-defined signals which can be acted on
      without delaying the scan of the data stream.

      Since one effect of the SYNCH mechanism is the discarding of
      essentially all characters (except TELNET commands) between the
      sender of the Synch and its recipient, this mechanism is specified
      as the standard way to clear the data path when that is desired.
      For example, if a user at a terminal causes an AO to be
      transmitted, the server which receives the AO (if it provides that
      function at all) should return a Synch to the user.

      Finally, just as the TCP Urgent notification is needed at the
      TELNET level as an out-of-band signal, so other protocols which
      make use of TELNET may require a TELNET command which can be
      viewed as an out-of-band signal at a different level.


Postel & Reynolds                                               [Page 9]

RFC 854                                                         May 1983


      By convention the sequence [IP, Synch] is to be used as such a
      signal.  For example, suppose that some other protocol, which uses
      TELNET, defines the character string STOP analogously to the
      TELNET command AO.  Imagine that a user of this protocol wishes a
      server to process the STOP string, but the connection is blocked
      because the server is processing other commands.  The user should
      instruct his system to:

         1. Send the TELNET IP character;

         2. Send the TELNET SYNC sequence, that is:

            Send the Data Mark (DM) as the only character
            in a TCP urgent mode send operation.

         3. Send the character string STOP; and

         4. Send the other protocol's analog of the TELNET DM, if any.

      The user (or process acting on his behalf) must transmit the
      TELNET SYNCH sequence of step 2 above to ensure that the TELNET IP
      gets through to the server's TELNET interpreter.

         The Urgent should wake up the TELNET process; the IP should
         wake up the next higher level process.

   THE NVT PRINTER AND KEYBOARD

      The NVT printer has an unspecified carriage width and page length
      and can produce representations of all 95 USASCII graphics (codes
      32 through 126).  Of the 33 USASCII control codes (0 through 31
      and 127), and the 128 uncovered codes (128 through 255), the
      following have specified meaning to the NVT printer:

         NAME                  CODE         MEANING

         NULL (NUL)              0      No Operation
         Line Feed (LF)         10      Moves the printer to the
                                        next print line, keeping the
                                        same horizontal position.
         Carriage Return (CR)   13      Moves the printer to the left
                                        margin of the current line.








Postel & Reynolds                                              [Page 10]

RFC 854                                                         May 1983


         In addition, the following codes shall have defined, but not
         required, effects on the NVT printer.  Neither end of a TELNET
         connection may assume that the other party will take, or will
         have taken, any particular action upon receipt or transmission
         of these:

         BELL (BEL)              7      Produces an audible or
                                        visible signal (which does
                                        NOT move the print head).
         Back Space (BS)         8      Moves the print head one
                                        character position towards
                                        the left margin.
         Horizontal Tab (HT)     9      Moves the printer to the
                                        next horizontal tab stop.
                                        It remains unspecified how
                                        either party determines or
                                        establishes where such tab
                                        stops are located.
         Vertical Tab (VT)       11     Moves the printer to the
                                        next vertical tab stop.  It
                                        remains unspecified how
                                        either party determines or
                                        establishes where such tab
                                        stops are located.
         Form Feed (FF)          12     Moves the printer to the top
                                        of the next page, keeping
                                        the same horizontal position.

      All remaining codes do not cause the NVT printer to take any
      action.

      The sequence ""CR LF"", as defined, will cause the NVT to be
      positioned at the left margin of the next print line (as would,
      for example, the sequence ""LF CR"").  However, many systems and
      terminals do not treat CR and LF independently, and will have to
      go to some effort to simulate their effect.  (For example, some
      terminals do not have a CR independent of the LF, but on such
      terminals it may be possible to simulate a CR by backspacing.)
      Therefore, the sequence ""CR LF"" must be treated as a single ""new
      line"" character and used whenever their combined action is
      intended; the sequence ""CR NUL"" must be used where a carriage
      return alone is actually desired; and the CR character must be
      avoided in other contexts.  This rule gives assurance to systems
      which must decide whether to perform a ""new line"" function or a
      multiple-backspace that the TELNET stream contains a character
      following a CR that will allow a rational decision.

         Note that ""CR LF"" or ""CR NUL"" is required in both directions


Postel & Reynolds                                              [Page 11]

RFC 854                                                         May 1983


         (in the default ASCII mode), to preserve the symmetry of the
         NVT model.  Even though it may be known in some situations
         (e.g., with remote echo and suppress go ahead options in
         effect) that characters are not being sent to an actual
         printer, nonetheless, for the sake of consistency, the protocol
         requires that a NUL be inserted following a CR not followed by
         a LF in the data stream.  The converse of this is that a NUL
         received in the data stream after a CR (in the absence of
         options negotiations which explicitly specify otherwise) should
         be stripped out prior to applying the NVT to local character
         set mapping.

      The NVT keyboard has keys, or key combinations, or key sequences,
      for generating all 128 USASCII codes.  Note that although many
      have no effect on the NVT printer, the NVT keyboard is capable of
      generating them.

      In addition to these codes, the NVT keyboard shall be capable of
      generating the following additional codes which, except as noted,
      have defined, but not reguired, meanings.  The actual code
      assignments for these ""characters"" are in the TELNET Command
      section, because they are viewed as being, in some sense, generic
      and should be available even when the data stream is interpreted
      as being some other character set.

      Synch

         This key allows the user to clear his data path to the other
         party.  The activation of this key causes a DM (see command
         section) to be sent in the data stream and a TCP Urgent
         notification is associated with it.  The pair DM-Urgent is to
         have required meaning as defined previously.

      Break (BRK)

         This code is provided because it is a signal outside the
         USASCII set which is currently given local meaning within many
         systems.  It is intended to indicate that the Break Key or the
         Attention Key was hit.  Note, however, that this is intended to
         provide a 129th code for systems which require it, not as a
         synonym for the IP standard representation.

      Interrupt Process (IP)

         Suspend, interrupt, abort or terminate the process to which the
         NVT is connected.  Also, part of the out-of-band signal for
         other protocols which use TELNET.



Postel & Reynolds                                              [Page 12]

RFC 854                                                         May 1983


      Abort Output (AO)

         Allow the current process to (appear to) run to completion, but
         do not send its output to the user.  Also, send a Synch to the
         user.

      Are You There (AYT)

         Send back to the NVT some visible (i.e., printable) evidence
         that the AYT was received.

      Erase Character (EC)

         The recipient should delete the last preceding undeleted
         character or ""print position"" from the data stream.

      Erase Line (EL)

         The recipient should delete characters from the data stream
         back to, but not including, the last ""CR LF"" sequence sent over
         the TELNET connection.

      The spirit of these ""extra"" keys, and also the printer format
      effectors, is that they should represent a natural extension of
      the mapping that already must be done from ""NVT"" into ""local"".
      Just as the NVT data byte 68 (104 octal) should be mapped into
      whatever the local code for ""uppercase D"" is, so the EC character
      should be mapped into whatever the local ""Erase Character""
      function is.  Further, just as the mapping for 124 (174 octal) is
      somewhat arbitrary in an environment that has no ""vertical bar""
      character, the EL character may have a somewhat arbitrary mapping
      (or none at all) if there is no local ""Erase Line"" facility.
      Similarly for format effectors:  if the terminal actually does
      have a ""Vertical Tab"", then the mapping for VT is obvious, and
      only when the terminal does not have a vertical tab should the
      effect of VT be unpredictable.

TELNET COMMAND STRUCTURE

   All TELNET commands consist of at least a two byte sequence:  the
   ""Interpret as Command"" (IAC) escape character followed by the code
   for the command.  The commands dealing with option negotiation are
   three byte sequences, the third byte being the code for the option
   referenced.  This format was chosen so that as more comprehensive use
   of the ""data space"" is made -- by negotiations from the basic NVT, of
   course -- collisions of data bytes with reserved command values will
   be minimized, all such collisions requiring the inconvenience, and



Postel & Reynolds                                              [Page 13]

RFC 854                                                         May 1983


   inefficiency, of ""escaping"" the data bytes into the stream.  With the
   current set-up, only the IAC need be doubled to be sent as data, and
   the other 255 codes may be passed transparently.

   The following are the defined TELNET commands.  Note that these codes
   and code sequences have the indicated meaning only when immediately
   preceded by an IAC.

      NAME               CODE              MEANING

      SE                  240    End of subnegotiation parameters.
      NOP                 241    No operation.
      Data Mark           242    The data stream portion of a Synch.
                                 This should always be accompanied
                                 by a TCP Urgent notification.
      Break               243    NVT character BRK.
      Interrupt Process   244    The function IP.
      Abort output        245    The function AO.
      Are You There       246    The function AYT.
      Erase character     247    The function EC.
      Erase Line          248    The function EL.
      Go ahead            249    The GA signal.
      SB                  250    Indicates that what follows is
                                 subnegotiation of the indicated
                                 option.
      WILL (option code)  251    Indicates the desire to begin
                                 performing, or confirmation that
                                 you are now performing, the
                                 indicated option.
      WON'T (option code) 252    Indicates the refusal to perform,
                                 or continue performing, the
                                 indicated option.
      DO (option code)    253    Indicates the request that the
                                 other party perform, or
                                 confirmation that you are expecting
                                 the other party to perform, the
                                 indicated option.
      DON'T (option code) 254    Indicates the demand that the
                                 other party stop performing,
                                 or confirmation that you are no
                                 longer expecting the other party
                                 to perform, the indicated option.
      IAC                 255    Data Byte 255.







Postel & Reynolds                                              [Page 14]

RFC 854                                                         May 1983


CONNECTION ESTABLISHMENT

   The TELNET TCP connection is established between the user's port U
   and the server's port L.  The server listens on its well known port L
   for such connections.  Since a TCP connection is full duplex and
   identified by the pair of ports, the server can engage in many
   simultaneous connections involving its port L and different user
   ports U.

   Port Assignment

      When used for remote user access to service hosts (i.e., remote
      terminal access) this protocol is assigned server port 23
      (27 octal).  That is L=23.




































Postel & Reynolds                                              [Page 15]

"
RFC5321,"
[RFC Home] [TEXT|PDF|HTML] [Tracker] [IPR] [Errata] [Info page]                                                                    DRAFT STANDARDUpdated by: 7504 Errata ExistNetwork Working Group                                         J. Klensin
Request for Comments: 5321                                  October 2008
Obsoletes: 2821
Updates: 1123
Category: Standards Track


                     Simple Mail Transfer Protocol

Status of This Memo

   This document specifies an Internet standards track protocol for the
   Internet community, and requests discussion and suggestions for
   improvements.  Please refer to the current edition of the ""Internet
   Official Protocol Standards"" (STD 1) for the standardization state
   and status of this protocol.  Distribution of this memo is unlimited.

Abstract

   This document is a specification of the basic protocol for Internet
   electronic mail transport.  It consolidates, updates, and clarifies
   several previous documents, making all or parts of most of them
   obsolete.  It covers the SMTP extension mechanisms and best practices
   for the contemporary Internet, but does not provide details about
   particular extensions.  Although SMTP was designed as a mail
   transport and delivery protocol, this specification also contains
   information that is important to its use as a ""mail submission""
   protocol for ""split-UA"" (User Agent) mail reading systems and mobile
   environments.






















Klensin                     Standards Track                     [Page 1]

RFC 5321                          SMTP                      October 2008


Table of Contents

   1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  5
     1.1.  Transport of Electronic Mail . . . . . . . . . . . . . . .  5
     1.2.  History and Context for This Document  . . . . . . . . . .  5
     1.3.  Document Conventions . . . . . . . . . . . . . . . . . . .  6
   2.  The SMTP Model . . . . . . . . . . . . . . . . . . . . . . . .  7
     2.1.  Basic Structure  . . . . . . . . . . . . . . . . . . . . .  7
     2.2.  The Extension Model  . . . . . . . . . . . . . . . . . . .  9
       2.2.1.  Background . . . . . . . . . . . . . . . . . . . . . .  9
       2.2.2.  Definition and Registration of Extensions  . . . . . . 10
       2.2.3.  Special Issues with Extensions . . . . . . . . . . . . 11
     2.3.  SMTP Terminology . . . . . . . . . . . . . . . . . . . . . 11
       2.3.1.  Mail Objects . . . . . . . . . . . . . . . . . . . . . 11
       2.3.2.  Senders and Receivers  . . . . . . . . . . . . . . . . 12
       2.3.3.  Mail Agents and Message Stores . . . . . . . . . . . . 12
       2.3.4.  Host . . . . . . . . . . . . . . . . . . . . . . . . . 13
       2.3.5.  Domain Names . . . . . . . . . . . . . . . . . . . . . 13
       2.3.6.  Buffer and State Table . . . . . . . . . . . . . . . . 14
       2.3.7.  Commands and Replies . . . . . . . . . . . . . . . . . 14
       2.3.8.  Lines  . . . . . . . . . . . . . . . . . . . . . . . . 14
       2.3.9.  Message Content and Mail Data  . . . . . . . . . . . . 15
       2.3.10. Originator, Delivery, Relay, and Gateway Systems . . . 15
       2.3.11. Mailbox and Address  . . . . . . . . . . . . . . . . . 15
     2.4.  General Syntax Principles and Transaction Model  . . . . . 16
   3.  The SMTP Procedures: An Overview . . . . . . . . . . . . . . . 17
     3.1.  Session Initiation . . . . . . . . . . . . . . . . . . . . 18
     3.2.  Client Initiation  . . . . . . . . . . . . . . . . . . . . 18
     3.3.  Mail Transactions  . . . . . . . . . . . . . . . . . . . . 19
     3.4.  Forwarding for Address Correction or Updating  . . . . . . 21
     3.5.  Commands for Debugging Addresses . . . . . . . . . . . . . 22
       3.5.1.  Overview . . . . . . . . . . . . . . . . . . . . . . . 22
       3.5.2.  VRFY Normal Response . . . . . . . . . . . . . . . . . 24
       3.5.3.  Meaning of VRFY or EXPN Success Response . . . . . . . 25
       3.5.4.  Semantics and Applications of EXPN . . . . . . . . . . 26
     3.6.  Relaying and Mail Routing  . . . . . . . . . . . . . . . . 26
       3.6.1.  Source Routes and Relaying . . . . . . . . . . . . . . 26
       3.6.2.  Mail eXchange Records and Relaying . . . . . . . . . . 26
       3.6.3.  Message Submission Servers as Relays . . . . . . . . . 27
     3.7.  Mail Gatewaying  . . . . . . . . . . . . . . . . . . . . . 28
       3.7.1.  Header Fields in Gatewaying  . . . . . . . . . . . . . 28
       3.7.2.  Received Lines in Gatewaying . . . . . . . . . . . . . 29
       3.7.3.  Addresses in Gatewaying  . . . . . . . . . . . . . . . 29
       3.7.4.  Other Header Fields in Gatewaying  . . . . . . . . . . 29
       3.7.5.  Envelopes in Gatewaying  . . . . . . . . . . . . . . . 30
     3.8.  Terminating Sessions and Connections . . . . . . . . . . . 30
     3.9.  Mailing Lists and Aliases  . . . . . . . . . . . . . . . . 31
       3.9.1.  Alias  . . . . . . . . . . . . . . . . . . . . . . . . 31



Klensin                     Standards Track                     [Page 2]

RFC 5321                          SMTP                      October 2008


       3.9.2.  List . . . . . . . . . . . . . . . . . . . . . . . . . 31
   4.  The SMTP Specifications  . . . . . . . . . . . . . . . . . . . 32
     4.1.  SMTP Commands  . . . . . . . . . . . . . . . . . . . . . . 32
       4.1.1.  Command Semantics and Syntax . . . . . . . . . . . . . 32
       4.1.2.  Command Argument Syntax  . . . . . . . . . . . . . . . 41
       4.1.3.  Address Literals . . . . . . . . . . . . . . . . . . . 43
       4.1.4.  Order of Commands  . . . . . . . . . . . . . . . . . . 44
       4.1.5.  Private-Use Commands . . . . . . . . . . . . . . . . . 46
     4.2.  SMTP Replies . . . . . . . . . . . . . . . . . . . . . . . 46
       4.2.1.  Reply Code Severities and Theory . . . . . . . . . . . 48
       4.2.2.  Reply Codes by Function Groups . . . . . . . . . . . . 50
       4.2.3.  Reply Codes in Numeric Order . . . . . . . . . . . . . 52
       4.2.4.  Reply Code 502 . . . . . . . . . . . . . . . . . . . . 53
       4.2.5.  Reply Codes after DATA and the Subsequent
               <CRLF>.<CRLF>  . . . . . . . . . . . . . . . . . . . . 53
     4.3.  Sequencing of Commands and Replies . . . . . . . . . . . . 54
       4.3.1.  Sequencing Overview  . . . . . . . . . . . . . . . . . 54
       4.3.2.  Command-Reply Sequences  . . . . . . . . . . . . . . . 55
     4.4.  Trace Information  . . . . . . . . . . . . . . . . . . . . 57
     4.5.  Additional Implementation Issues . . . . . . . . . . . . . 61
       4.5.1.  Minimum Implementation . . . . . . . . . . . . . . . . 61
       4.5.2.  Transparency . . . . . . . . . . . . . . . . . . . . . 62
       4.5.3.  Sizes and Timeouts . . . . . . . . . . . . . . . . . . 62
         4.5.3.1.  Size Limits and Minimums . . . . . . . . . . . . . 62
           4.5.3.1.1.  Local-part . . . . . . . . . . . . . . . . . . 63
           4.5.3.1.2.  Domain . . . . . . . . . . . . . . . . . . . . 63
           4.5.3.1.3.  Path . . . . . . . . . . . . . . . . . . . . . 63
           4.5.3.1.4.  Command Line . . . . . . . . . . . . . . . . . 63
           4.5.3.1.5.  Reply Line . . . . . . . . . . . . . . . . . . 63
           4.5.3.1.6.  Text Line  . . . . . . . . . . . . . . . . . . 63
           4.5.3.1.7.  Message Content  . . . . . . . . . . . . . . . 63
           4.5.3.1.8.  Recipients Buffer  . . . . . . . . . . . . . . 64
           4.5.3.1.9.  Treatment When Limits Exceeded . . . . . . . . 64
           4.5.3.1.10. Too Many Recipients Code . . . . . . . . . . . 64
         4.5.3.2.  Timeouts . . . . . . . . . . . . . . . . . . . . . 65
           4.5.3.2.1.  Initial 220 Message: 5 Minutes . . . . . . . . 65
           4.5.3.2.2.  MAIL Command: 5 Minutes  . . . . . . . . . . . 65
           4.5.3.2.3.  RCPT Command: 5 Minutes  . . . . . . . . . . . 65
           4.5.3.2.4.  DATA Initiation: 2 Minutes . . . . . . . . . . 66
           4.5.3.2.5.  Data Block: 3 Minutes  . . . . . . . . . . . . 66
           4.5.3.2.6.  DATA Termination: 10 Minutes.  . . . . . . . . 66
           4.5.3.2.7.  Server Timeout: 5 Minutes. . . . . . . . . . . 66
       4.5.4.  Retry Strategies . . . . . . . . . . . . . . . . . . . 66
       4.5.5.  Messages with a Null Reverse-Path  . . . . . . . . . . 68
   5.  Address Resolution and Mail Handling . . . . . . . . . . . . . 69
     5.1.  Locating the Target Host . . . . . . . . . . . . . . . . . 69
     5.2.  IPv6 and MX Records  . . . . . . . . . . . . . . . . . . . 71
   6.  Problem Detection and Handling . . . . . . . . . . . . . . . . 71



Klensin                     Standards Track                     [Page 3]

RFC 5321                          SMTP                      October 2008


     6.1.  Reliable Delivery and Replies by Email . . . . . . . . . . 71
     6.2.  Unwanted, Unsolicited, and ""Attack"" Messages . . . . . . . 72
     6.3.  Loop Detection . . . . . . . . . . . . . . . . . . . . . . 73
     6.4.  Compensating for Irregularities  . . . . . . . . . . . . . 73
   7.  Security Considerations  . . . . . . . . . . . . . . . . . . . 75
     7.1.  Mail Security and Spoofing . . . . . . . . . . . . . . . . 75
     7.2.  ""Blind"" Copies . . . . . . . . . . . . . . . . . . . . . . 76
     7.3.  VRFY, EXPN, and Security . . . . . . . . . . . . . . . . . 76
     7.4.  Mail Rerouting Based on the 251 and 551 Response Codes . . 77
     7.5.  Information Disclosure in Announcements  . . . . . . . . . 77
     7.6.  Information Disclosure in Trace Fields . . . . . . . . . . 78
     7.7.  Information Disclosure in Message Forwarding . . . . . . . 78
     7.8.  Resistance to Attacks  . . . . . . . . . . . . . . . . . . 78
     7.9.  Scope of Operation of SMTP Servers . . . . . . . . . . . . 78
   8.  IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 79
   9.  Acknowledgments  . . . . . . . . . . . . . . . . . . . . . . . 80
   10. References . . . . . . . . . . . . . . . . . . . . . . . . . . 81
     10.1. Normative References . . . . . . . . . . . . . . . . . . . 81
     10.2. Informative References . . . . . . . . . . . . . . . . . . 82
   Appendix A.  TCP Transport Service . . . . . . . . . . . . . . . . 85
   Appendix B.  Generating SMTP Commands from RFC 822 Header
                Fields  . . . . . . . . . . . . . . . . . . . . . . . 85
   Appendix C.  Source Routes . . . . . . . . . . . . . . . . . . . . 86
   Appendix D.  Scenarios . . . . . . . . . . . . . . . . . . . . . . 87
     D.1.  A Typical SMTP Transaction Scenario  . . . . . . . . . . . 88
     D.2.  Aborted SMTP Transaction Scenario  . . . . . . . . . . . . 89
     D.3.  Relayed Mail Scenario  . . . . . . . . . . . . . . . . . . 90
     D.4.  Verifying and Sending Scenario . . . . . . . . . . . . . . 92
   Appendix E.  Other Gateway Issues  . . . . . . . . . . . . . . . . 92
   Appendix F.  Deprecated Features of RFC 821  . . . . . . . . . . . 93
     F.1.  TURN . . . . . . . . . . . . . . . . . . . . . . . . . . . 93
     F.2.  Source Routing . . . . . . . . . . . . . . . . . . . . . . 93
     F.3.  HELO . . . . . . . . . . . . . . . . . . . . . . . . . . . 93
     F.4.  #-literals . . . . . . . . . . . . . . . . . . . . . . . . 94
     F.5.  Dates and Years  . . . . . . . . . . . . . . . . . . . . . 94
     F.6.  Sending versus Mailing . . . . . . . . . . . . . . . . . . 94















Klensin                     Standards Track                     [Page 4]

RFC 5321                          SMTP                      October 2008


1.  Introduction

1.1.  Transport of Electronic Mail

   The objective of the Simple Mail Transfer Protocol (SMTP) is to
   transfer mail reliably and efficiently.

   SMTP is independent of the particular transmission subsystem and
   requires only a reliable ordered data stream channel.  While this
   document specifically discusses transport over TCP, other transports
   are possible.  Appendices to RFC 821 [1] describe some of them.

   An important feature of SMTP is its capability to transport mail
   across multiple networks, usually referred to as ""SMTP mail relaying""
   (see Section 3.6).  A network consists of the mutually-TCP-accessible
   hosts on the public Internet, the mutually-TCP-accessible hosts on a
   firewall-isolated TCP/IP Intranet, or hosts in some other LAN or WAN
   environment utilizing a non-TCP transport-level protocol.  Using
   SMTP, a process can transfer mail to another process on the same
   network or to some other network via a relay or gateway process
   accessible to both networks.

   In this way, a mail message may pass through a number of intermediate
   relay or gateway hosts on its path from sender to ultimate recipient.
   The Mail eXchanger mechanisms of the domain name system (RFC 1035
   [2], RFC 974 [12], and Section 5 of this document) are used to
   identify the appropriate next-hop destination for a message being
   transported.

1.2.  History and Context for This Document

   This document is a specification of the basic protocol for the
   Internet electronic mail transport.  It consolidates, updates and
   clarifies, but does not add new or change existing functionality of
   the following:

   o  the original SMTP (Simple Mail Transfer Protocol) specification of
      RFC 821 [1],

   o  domain name system requirements and implications for mail
      transport from RFC 1035 [2] and RFC 974 [12],

   o  the clarifications and applicability statements in RFC 1123 [3],
      and

   o  material drawn from the SMTP Extension mechanisms in RFC 1869
      [13].




Klensin                     Standards Track                     [Page 5]

RFC 5321                          SMTP                      October 2008


   o  Editorial and clarification changes to RFC 2821 [14] to bring that
      specification to Draft Standard.

   It obsoletes RFC 821, RFC 974, RFC 1869, and RFC 2821 and updates RFC
   1123 (replacing the mail transport materials of RFC 1123).  However,
   RFC 821 specifies some features that were not in significant use in
   the Internet by the mid-1990s and (in appendices) some additional
   transport models.  Those sections are omitted here in the interest of
   clarity and brevity; readers needing them should refer to RFC 821.

   It also includes some additional material from RFC 1123 that required
   amplification.  This material has been identified in multiple ways,
   mostly by tracking flaming on various lists and newsgroups and
   problems of unusual readings or interpretations that have appeared as
   the SMTP extensions have been deployed.  Where this specification
   moves beyond consolidation and actually differs from earlier
   documents, it supersedes them technically as well as textually.

   Although SMTP was designed as a mail transport and delivery protocol,
   this specification also contains information that is important to its
   use as a ""mail submission"" protocol, as recommended for Post Office
   Protocol (POP) (RFC 937 [15], RFC 1939 [16]) and IMAP (RFC 3501
   [17]).  In general, the separate mail submission protocol specified
   in RFC 4409 [18] is now preferred to direct use of SMTP; more
   discussion of that subject appears in that document.

   Section 2.3 provides definitions of terms specific to this document.
   Except when the historical terminology is necessary for clarity, this
   document uses the current 'client' and 'server' terminology to
   identify the sending and receiving SMTP processes, respectively.

   A companion document, RFC 5322 [4], discusses message header sections
   and bodies and specifies formats and structures for them.

1.3.  Document Conventions

   The key words ""MUST"", ""MUST NOT"", ""REQUIRED"", ""SHALL"", ""SHALL NOT"",
   ""SHOULD"", ""SHOULD NOT"", ""RECOMMENDED"", ""MAY"", and ""OPTIONAL"" in this
   document are to be interpreted as described in RFC 2119 [5].  As each
   of these terms was intentionally and carefully chosen to improve the
   interoperability of email, each use of these terms is to be treated
   as a conformance requirement.

   Because this document has a long history and to avoid the risk of
   various errors and of confusing readers and documents that point to
   this one, most examples and the domain names they contain are
   preserved from RFC 2821.  Readers are cautioned that these are




Klensin                     Standards Track                     [Page 6]

RFC 5321                          SMTP                      October 2008


   illustrative examples that should not actually be used in either code
   or configuration files.

2.  The SMTP Model

2.1.  Basic Structure

   The SMTP design can be pictured as:

                  +----------+                +----------+
      +------+    |          |                |          |
      | User |<-->|          |      SMTP      |          |
      +------+    |  Client- |Commands/Replies| Server-  |
      +------+    |   SMTP   |<-------------->|    SMTP  |    +------+
      | File |<-->|          |    and Mail    |          |<-->| File |
      |System|    |          |                |          |    |System|
      +------+    +----------+                +----------+    +------+
                   SMTP client                SMTP server

   When an SMTP client has a message to transmit, it establishes a two-
   way transmission channel to an SMTP server.  The responsibility of an
   SMTP client is to transfer mail messages to one or more SMTP servers,
   or report its failure to do so.

   The means by which a mail message is presented to an SMTP client, and
   how that client determines the identifier(s) (""names"") of the
   domain(s) to which mail messages are to be transferred, is a local
   matter, and is not addressed by this document.  In some cases, the
   designated domain(s), or those determined by an SMTP client, will
   identify the final destination(s) of the mail message.  In other
   cases, common with SMTP clients associated with implementations of
   the POP (RFC 937 [15], RFC 1939 [16]) or IMAP (RFC 3501 [17])
   protocols, or when the SMTP client is inside an isolated transport
   service environment, the domain determined will identify an
   intermediate destination through which all mail messages are to be
   relayed.  SMTP clients that transfer all traffic regardless of the
   target domains associated with the individual messages, or that do
   not maintain queues for retrying message transmissions that initially
   cannot be completed, may otherwise conform to this specification but
   are not considered fully-capable.  Fully-capable SMTP
   implementations, including the relays used by these less capable
   ones, and their destinations, are expected to support all of the
   queuing, retrying, and alternate address functions discussed in this
   specification.  In many situations and configurations, the less-
   capable clients discussed above SHOULD be using the message
   submission protocol (RFC 4409 [18]) rather than SMTP.





Klensin                     Standards Track                     [Page 7]

RFC 5321                          SMTP                      October 2008


   The means by which an SMTP client, once it has determined a target
   domain, determines the identity of an SMTP server to which a copy of
   a message is to be transferred, and then performs that transfer, is
   covered by this document.  To effect a mail transfer to an SMTP
   server, an SMTP client establishes a two-way transmission channel to
   that SMTP server.  An SMTP client determines the address of an
   appropriate host running an SMTP server by resolving a destination
   domain name to either an intermediate Mail eXchanger host or a final
   target host.

   An SMTP server may be either the ultimate destination or an
   intermediate ""relay"" (that is, it may assume the role of an SMTP
   client after receiving the message) or ""gateway"" (that is, it may
   transport the message further using some protocol other than SMTP).
   SMTP commands are generated by the SMTP client and sent to the SMTP
   server.  SMTP replies are sent from the SMTP server to the SMTP
   client in response to the commands.

   In other words, message transfer can occur in a single connection
   between the original SMTP-sender and the final SMTP-recipient, or can
   occur in a series of hops through intermediary systems.  In either
   case, once the server has issued a success response at the end of the
   mail data, a formal handoff of responsibility for the message occurs:
   the protocol requires that a server MUST accept responsibility for
   either delivering the message or properly reporting the failure to do
   so (see Sections 6.1, 6.2, and 7.8, below).

   Once the transmission channel is established and initial handshaking
   is completed, the SMTP client normally initiates a mail transaction.
   Such a transaction consists of a series of commands to specify the
   originator and destination of the mail and transmission of the
   message content (including any lines in the header section or other
   structure) itself.  When the same message is sent to multiple
   recipients, this protocol encourages the transmission of only one
   copy of the data for all recipients at the same destination (or
   intermediate relay) host.

   The server responds to each command with a reply; replies may
   indicate that the command was accepted, that additional commands are
   expected, or that a temporary or permanent error condition exists.
   Commands specifying the sender or recipients may include server-
   permitted SMTP service extension requests, as discussed in
   Section 2.2.  The dialog is purposely lock-step, one-at-a-time,
   although this can be modified by mutually agreed upon extension
   requests such as command pipelining (RFC 2920 [19]).

   Once a given mail message has been transmitted, the client may either
   request that the connection be shut down or may initiate other mail



Klensin                     Standards Track                     [Page 8]

RFC 5321                          SMTP                      October 2008


   transactions.  In addition, an SMTP client may use a connection to an
   SMTP server for ancillary services such as verification of email
   addresses or retrieval of mailing list subscriber addresses.

   As suggested above, this protocol provides mechanisms for the
   transmission of mail.  Historically, this transmission normally
   occurred directly from the sending user's host to the receiving
   user's host when the two hosts are connected to the same transport
   service.  When they are not connected to the same transport service,
   transmission occurs via one or more relay SMTP servers.  A very
   common case in the Internet today involves submission of the original
   message to an intermediate, ""message submission"" server, which is
   similar to a relay but has some additional properties; such servers
   are discussed in Section 2.3.10 and at some length in RFC 4409 [18].
   An intermediate host that acts as either an SMTP relay or as a
   gateway into some other transmission environment is usually selected
   through the use of the domain name service (DNS) Mail eXchanger
   mechanism.

   Usually, intermediate hosts are determined via the DNS MX record, not
   by explicit ""source"" routing (see Section 5 and Appendix C and
   Appendix F.2).

2.2.  The Extension Model

2.2.1.  Background

   In an effort that started in 1990, approximately a decade after RFC
   821 was completed, the protocol was modified with a ""service
   extensions"" model that permits the client and server to agree to
   utilize shared functionality beyond the original SMTP requirements.
   The SMTP extension mechanism defines a means whereby an extended SMTP
   client and server may recognize each other, and the server can inform
   the client as to the service extensions that it supports.

   Contemporary SMTP implementations MUST support the basic extension
   mechanisms.  For instance, servers MUST support the EHLO command even
   if they do not implement any specific extensions and clients SHOULD
   preferentially utilize EHLO rather than HELO.  (However, for
   compatibility with older conforming implementations, SMTP clients and
   servers MUST support the original HELO mechanisms as a fallback.)
   Unless the different characteristics of HELO must be identified for
   interoperability purposes, this document discusses only EHLO.

   SMTP is widely deployed and high-quality implementations have proven
   to be very robust.  However, the Internet community now considers
   some services to be important that were not anticipated when the
   protocol was first designed.  If support for those services is to be



Klensin                     Standards Track                     [Page 9]

RFC 5321                          SMTP                      October 2008


   added, it must be done in a way that permits older implementations to
   continue working acceptably.  The extension framework consists of:

   o  The SMTP command EHLO, superseding the earlier HELO,

   o  a registry of SMTP service extensions,

   o  additional parameters to the SMTP MAIL and RCPT commands, and

   o  optional replacements for commands defined in this protocol, such
      as for DATA in non-ASCII transmissions (RFC 3030 [20]).

   SMTP's strength comes primarily from its simplicity.  Experience with
   many protocols has shown that protocols with few options tend towards
   ubiquity, whereas protocols with many options tend towards obscurity.

   Each and every extension, regardless of its benefits, must be
   carefully scrutinized with respect to its implementation, deployment,
   and interoperability costs.  In many cases, the cost of extending the
   SMTP service will likely outweigh the benefit.

2.2.2.  Definition and Registration of Extensions

   The IANA maintains a registry of SMTP service extensions.  A
   corresponding EHLO keyword value is associated with each extension.
   Each service extension registered with the IANA must be defined in a
   formal Standards-Track or IESG-approved Experimental protocol
   document.  The definition must include:

   o  the textual name of the SMTP service extension;

   o  the EHLO keyword value associated with the extension;

   o  the syntax and possible values of parameters associated with the
      EHLO keyword value;

   o  any additional SMTP verbs associated with the extension
      (additional verbs will usually be, but are not required to be, the
      same as the EHLO keyword value);

   o  any new parameters the extension associates with the MAIL or RCPT
      verbs;

   o  a description of how support for the extension affects the
      behavior of a server and client SMTP; and






Klensin                     Standards Track                    [Page 10]

RFC 5321                          SMTP                      October 2008


   o  the increment by which the extension is increasing the maximum
      length of the commands MAIL and/or RCPT, over that specified in
      this Standard.

   In addition, any EHLO keyword value starting with an upper or lower
   case ""X"" refers to a local SMTP service extension used exclusively
   through bilateral agreement.  Keywords beginning with ""X"" MUST NOT be
   used in a registered service extension.  Conversely, keyword values
   presented in the EHLO response that do not begin with ""X"" MUST
   correspond to a Standard, Standards-Track, or IESG-approved
   Experimental SMTP service extension registered with IANA.  A
   conforming server MUST NOT offer non-""X""-prefixed keyword values that
   are not described in a registered extension.

   Additional verbs and parameter names are bound by the same rules as
   EHLO keywords; specifically, verbs beginning with ""X"" are local
   extensions that may not be registered or standardized.  Conversely,
   verbs not beginning with ""X"" must always be registered.

2.2.3.  Special Issues with Extensions

   Extensions that change fairly basic properties of SMTP operation are
   permitted.  The text in other sections of this document must be
   understood in that context.  In particular, extensions can change the
   minimum limits specified in Section 4.5.3, can change the ASCII
   character set requirement as mentioned above, or can introduce some
   optional modes of message handling.

   In particular, if an extension implies that the delivery path
   normally supports special features of that extension, and an
   intermediate SMTP system finds a next hop that does not support the
   required extension, it MAY choose, based on the specific extension
   and circumstances, to requeue the message and try later and/or try an
   alternate MX host.  If this strategy is employed, the timeout to fall
   back to an unextended format (if one is available) SHOULD be less
   than the normal timeout for bouncing as undeliverable (e.g., if
   normal timeout is three days, the requeue timeout before attempting
   to transmit the mail without the extension might be one day).

2.3.  SMTP Terminology

2.3.1.  Mail Objects

   SMTP transports a mail object.  A mail object contains an envelope
   and content.

   The SMTP envelope is sent as a series of SMTP protocol units
   (described in Section 3).  It consists of an originator address (to



Klensin                     Standards Track                    [Page 11]

RFC 5321                          SMTP                      October 2008


   which error reports should be directed), one or more recipient
   addresses, and optional protocol extension material.  Historically,
   variations on the reverse-path (originator) address specification
   command (MAIL) could be used to specify alternate delivery modes,
   such as immediate display; those variations have now been deprecated
   (see Appendix F and Appendix F.6).

   The SMTP content is sent in the SMTP DATA protocol unit and has two
   parts: the header section and the body.  If the content conforms to
   other contemporary standards, the header section consists of a
   collection of header fields, each consisting of a header name, a
   colon, and data, structured as in the message format specification
   (RFC 5322 [4]); the body, if structured, is defined according to MIME
   (RFC 2045 [21]).  The content is textual in nature, expressed using
   the US-ASCII repertoire [6].  Although SMTP extensions (such as
   ""8BITMIME"", RFC 1652 [22]) may relax this restriction for the content
   body, the content header fields are always encoded using the US-ASCII
   repertoire.  Two MIME extensions (RFC 2047 [23] and RFC 2231 [24])
   define an algorithm for representing header values outside the US-
   ASCII repertoire, while still encoding them using the US-ASCII
   repertoire.

2.3.2.  Senders and Receivers

   In RFC 821, the two hosts participating in an SMTP transaction were
   described as the ""SMTP-sender"" and ""SMTP-receiver"".  This document
   has been changed to reflect current industry terminology and hence
   refers to them as the ""SMTP client"" (or sometimes just ""the client"")
   and ""SMTP server"" (or just ""the server""), respectively.  Since a
   given host may act both as server and client in a relay situation,
   ""receiver"" and ""sender"" terminology is still used where needed for
   clarity.

2.3.3.  Mail Agents and Message Stores

   Additional mail system terminology became common after RFC 821 was
   published and, where convenient, is used in this specification.  In
   particular, SMTP servers and clients provide a mail transport service
   and therefore act as ""Mail Transfer Agents"" (MTAs).  ""Mail User
   Agents"" (MUAs or UAs) are normally thought of as the sources and
   targets of mail.  At the source, an MUA might collect mail to be
   transmitted from a user and hand it off to an MTA; the final
   (""delivery"") MTA would be thought of as handing the mail off to an
   MUA (or at least transferring responsibility to it, e.g., by
   depositing the message in a ""message store"").  However, while these
   terms are used with at least the appearance of great precision in
   other environments, the implied boundaries between MUAs and MTAs
   often do not accurately match common, and conforming, practices with



Klensin                     Standards Track                    [Page 12]

RFC 5321                          SMTP                      October 2008


   Internet mail.  Hence, the reader should be cautious about inferring
   the strong relationships and responsibilities that might be implied
   if these terms were used elsewhere.

2.3.4.  Host

   For the purposes of this specification, a host is a computer system
   attached to the Internet (or, in some cases, to a private TCP/IP
   network) and supporting the SMTP protocol.  Hosts are known by names
   (see the next section); they SHOULD NOT be identified by numerical
   addresses, i.e., by address literals as described in Section 4.1.2.

2.3.5.  Domain Names

   A domain name (or often just a ""domain"") consists of one or more
   components, separated by dots if more than one appears.  In the case
   of a top-level domain used by itself in an email address, a single
   string is used without any dots.  This makes the requirement,
   described in more detail below, that only fully-qualified domain
   names appear in SMTP transactions on the public Internet,
   particularly important where top-level domains are involved.  These
   components (""labels"" in DNS terminology, RFC 1035 [2]) are restricted
   for SMTP purposes to consist of a sequence of letters, digits, and
   hyphens drawn from the ASCII character set [6].  Domain names are
   used as names of hosts and of other entities in the domain name
   hierarchy.  For example, a domain may refer to an alias (label of a
   CNAME RR) or the label of Mail eXchanger records to be used to
   deliver mail instead of representing a host name.  See RFC 1035 [2]
   and Section 5 of this specification.

   The domain name, as described in this document and in RFC 1035 [2],
   is the entire, fully-qualified name (often referred to as an ""FQDN"").
   A domain name that is not in FQDN form is no more than a local alias.
   Local aliases MUST NOT appear in any SMTP transaction.

   Only resolvable, fully-qualified domain names (FQDNs) are permitted
   when domain names are used in SMTP.  In other words, names that can
   be resolved to MX RRs or address (i.e., A or AAAA) RRs (as discussed
   in Section 5) are permitted, as are CNAME RRs whose targets can be
   resolved, in turn, to MX or address RRs.  Local nicknames or
   unqualified names MUST NOT be used.  There are two exceptions to the
   rule requiring FQDNs:

   o  The domain name given in the EHLO command MUST be either a primary
      host name (a domain name that resolves to an address RR) or, if
      the host has no name, an address literal, as described in
      Section 4.1.3 and discussed further in the EHLO discussion of
      Section 4.1.4.



Klensin                     Standards Track                    [Page 13]

RFC 5321                          SMTP                      October 2008


   o  The reserved mailbox name ""postmaster"" may be used in a RCPT
      command without domain qualification (see Section 4.1.1.3) and
      MUST be accepted if so used.

2.3.6.  Buffer and State Table

   SMTP sessions are stateful, with both parties carefully maintaining a
   common view of the current state.  In this document, we model this
   state by a virtual ""buffer"" and a ""state table"" on the server that
   may be used by the client to, for example, ""clear the buffer"" or
   ""reset the state table"", causing the information in the buffer to be
   discarded and the state to be returned to some previous state.

2.3.7.  Commands and Replies

   SMTP commands and, unless altered by a service extension, message
   data, are transmitted from the sender to the receiver via the
   transmission channel in ""lines"".

   An SMTP reply is an acknowledgment (positive or negative) sent in
   ""lines"" from receiver to sender via the transmission channel in
   response to a command.  The general form of a reply is a numeric
   completion code (indicating failure or success) usually followed by a
   text string.  The codes are for use by programs and the text is
   usually intended for human users.  RFC 3463 [25], specifies further
   structuring of the reply strings, including the use of supplemental
   and more specific completion codes (see also RFC 5248 [26]).

2.3.8.  Lines

   Lines consist of zero or more data characters terminated by the
   sequence ASCII character ""CR"" (hex value 0D) followed immediately by
   ASCII character ""LF"" (hex value 0A).  This termination sequence is
   denoted as <CRLF> in this document.  Conforming implementations MUST
   NOT recognize or generate any other character or character sequence
   as a line terminator.  Limits MAY be imposed on line lengths by
   servers (see Section 4).

   In addition, the appearance of ""bare"" ""CR"" or ""LF"" characters in text
   (i.e., either without the other) has a long history of causing
   problems in mail implementations and applications that use the mail
   system as a tool.  SMTP client implementations MUST NOT transmit
   these characters except when they are intended as line terminators
   and then MUST, as indicated above, transmit them only as a <CRLF>
   sequence.






Klensin                     Standards Track                    [Page 14]

RFC 5321                          SMTP                      October 2008


2.3.9.  Message Content and Mail Data

   The terms ""message content"" and ""mail data"" are used interchangeably
   in this document to describe the material transmitted after the DATA
   command is accepted and before the end of data indication is
   transmitted.  Message content includes the message header section and
   the possibly structured message body.  The MIME specification (RFC
   2045 [21]) provides the standard mechanisms for structured message
   bodies.

2.3.10.  Originator, Delivery, Relay, and Gateway Systems

   This specification makes a distinction among four types of SMTP
   systems, based on the role those systems play in transmitting
   electronic mail.  An ""originating"" system (sometimes called an SMTP
   originator) introduces mail into the Internet or, more generally,
   into a transport service environment.  A ""delivery"" SMTP system is
   one that receives mail from a transport service environment and
   passes it to a mail user agent or deposits it in a message store that
   a mail user agent is expected to subsequently access.  A ""relay"" SMTP
   system (usually referred to just as a ""relay"") receives mail from an
   SMTP client and transmits it, without modification to the message
   data other than adding trace information, to another SMTP server for
   further relaying or for delivery.

   A ""gateway"" SMTP system (usually referred to just as a ""gateway"")
   receives mail from a client system in one transport environment and
   transmits it to a server system in another transport environment.
   Differences in protocols or message semantics between the transport
   environments on either side of a gateway may require that the gateway
   system perform transformations to the message that are not permitted
   to SMTP relay systems.  For the purposes of this specification,
   firewalls that rewrite addresses should be considered as gateways,
   even if SMTP is used on both sides of them (see RFC 2979 [27]).

2.3.11.  Mailbox and Address

   As used in this specification, an ""address"" is a character string
   that identifies a user to whom mail will be sent or a location into
   which mail will be deposited.  The term ""mailbox"" refers to that
   depository.  The two terms are typically used interchangeably unless
   the distinction between the location in which mail is placed (the
   mailbox) and a reference to it (the address) is important.  An
   address normally consists of user and domain specifications.  The
   standard mailbox naming convention is defined to be
   ""local-part@domain""; contemporary usage permits a much broader set of
   applications than simple ""user names"".  Consequently, and due to a
   long history of problems when intermediate hosts have attempted to



Klensin                     Standards Track                    [Page 15]

RFC 5321                          SMTP                      October 2008


   optimize transport by modifying them, the local-part MUST be
   interpreted and assigned semantics only by the host specified in the
   domain part of the address.

2.4.  General Syntax Principles and Transaction Model

   SMTP commands and replies have a rigid syntax.  All commands begin
   with a command verb.  All replies begin with a three digit numeric
   code.  In some commands and replies, arguments are required following
   the verb or reply code.  Some commands do not accept arguments (after
   the verb), and some reply codes are followed, sometimes optionally,
   by free form text.  In both cases, where text appears, it is
   separated from the verb or reply code by a space character.  Complete
   definitions of commands and replies appear in Section 4.

   Verbs and argument values (e.g., ""TO:"" or ""to:"" in the RCPT command
   and extension name keywords) are not case sensitive, with the sole
   exception in this specification of a mailbox local-part (SMTP
   Extensions may explicitly specify case-sensitive elements).  That is,
   a command verb, an argument value other than a mailbox local-part,
   and free form text MAY be encoded in upper case, lower case, or any
   mixture of upper and lower case with no impact on its meaning.  The
   local-part of a mailbox MUST BE treated as case sensitive.
   Therefore, SMTP implementations MUST take care to preserve the case
   of mailbox local-parts.  In particular, for some hosts, the user
   ""smith"" is different from the user ""Smith"".  However, exploiting the
   case sensitivity of mailbox local-parts impedes interoperability and
   is discouraged.  Mailbox domains follow normal DNS rules and are
   hence not case sensitive.

   A few SMTP servers, in violation of this specification (and RFC 821)
   require that command verbs be encoded by clients in upper case.
   Implementations MAY wish to employ this encoding to accommodate those
   servers.

   The argument clause consists of a variable-length character string
   ending with the end of the line, i.e., with the character sequence
   <CRLF>.  The receiver will take no action until this sequence is
   received.

   The syntax for each command is shown with the discussion of that
   command.  Common elements and parameters are shown in Section 4.1.2.

   Commands and replies are composed of characters from the ASCII
   character set [6].  When the transport service provides an 8-bit byte
   (octet) transmission channel, each 7-bit character is transmitted,
   right justified, in an octet with the high-order bit cleared to zero.
   More specifically, the unextended SMTP service provides 7-bit



Klensin                     Standards Track                    [Page 16]

RFC 5321                          SMTP                      October 2008


   transport only.  An originating SMTP client that has not successfully
   negotiated an appropriate extension with a particular server (see the
   next paragraph) MUST NOT transmit messages with information in the
   high-order bit of octets.  If such messages are transmitted in
   violation of this rule, receiving SMTP servers MAY clear the high-
   order bit or reject the message as invalid.  In general, a relay SMTP
   SHOULD assume that the message content it has received is valid and,
   assuming that the envelope permits doing so, relay it without
   inspecting that content.  Of course, if the content is mislabeled and
   the data path cannot accept the actual content, this may result in
   the ultimate delivery of a severely garbled message to the recipient.
   Delivery SMTP systems MAY reject such messages, or return them as
   undeliverable, rather than deliver them.  In the absence of a server-
   offered extension explicitly permitting it, a sending SMTP system is
   not permitted to send envelope commands in any character set other
   than US-ASCII.  Receiving systems SHOULD reject such commands,
   normally using ""500 syntax error - invalid character"" replies.

   8-bit message content transmission MAY be requested of the server by
   a client using extended SMTP facilities, notably the ""8BITMIME""
   extension, RFC 1652 [22]. 8BITMIME SHOULD be supported by SMTP
   servers.  However, it MUST NOT be construed as authorization to
   transmit unrestricted 8-bit material, nor does 8BITMIME authorize
   transmission of any envelope material in other than ASCII. 8BITMIME
   MUST NOT be requested by senders for material with the high bit on
   that is not in MIME format with an appropriate content-transfer
   encoding; servers MAY reject such messages.

   The metalinguistic notation used in this document corresponds to the
   ""Augmented BNF"" used in other Internet mail system documents.  The
   reader who is not familiar with that syntax should consult the ABNF
   specification in RFC 5234 [7].  Metalanguage terms used in running
   text are surrounded by pointed brackets (e.g., <CRLF>) for clarity.
   The reader is cautioned that the grammar expressed in the
   metalanguage is not comprehensive.  There are many instances in which
   provisions in the text constrain or otherwise modify the syntax or
   semantics implied by the grammar.

3.  The SMTP Procedures: An Overview

   This section contains descriptions of the procedures used in SMTP:
   session initiation, mail transaction, forwarding mail, verifying
   mailbox names and expanding mailing lists, and opening and closing
   exchanges.  Comments on relaying, a note on mail domains, and a
   discussion of changing roles are included at the end of this section.
   Several complete scenarios are presented in Appendix D.





Klensin                     Standards Track                    [Page 17]

RFC 5321                          SMTP                      October 2008


3.1.  Session Initiation

   An SMTP session is initiated when a client opens a connection to a
   server and the server responds with an opening message.

   SMTP server implementations MAY include identification of their
   software and version information in the connection greeting reply
   after the 220 code, a practice that permits more efficient isolation
   and repair of any problems.  Implementations MAY make provision for
   SMTP servers to disable the software and version announcement where
   it causes security concerns.  While some systems also identify their
   contact point for mail problems, this is not a substitute for
   maintaining the required ""postmaster"" address (see Section 4).

   The SMTP protocol allows a server to formally reject a mail session
   while still allowing the initial connection as follows: a 554
   response MAY be given in the initial connection opening message
   instead of the 220.  A server taking this approach MUST still wait
   for the client to send a QUIT (see Section 4.1.1.10) before closing
   the connection and SHOULD respond to any intervening commands with
   ""503 bad sequence of commands"".  Since an attempt to make an SMTP
   connection to such a system is probably in error, a server returning
   a 554 response on connection opening SHOULD provide enough
   information in the reply text to facilitate debugging of the sending
   system.

3.2.  Client Initiation

   Once the server has sent the greeting (welcoming) message and the
   client has received it, the client normally sends the EHLO command to
   the server, indicating the client's identity.  In addition to opening
   the session, use of EHLO indicates that the client is able to process
   service extensions and requests that the server provide a list of the
   extensions it supports.  Older SMTP systems that are unable to
   support service extensions, and contemporary clients that do not
   require service extensions in the mail session being initiated, MAY
   use HELO instead of EHLO.  Servers MUST NOT return the extended EHLO-
   style response to a HELO command.  For a particular connection
   attempt, if the server returns a ""command not recognized"" response to
   EHLO, the client SHOULD be able to fall back and send HELO.

   In the EHLO command, the host sending the command identifies itself;
   the command may be interpreted as saying ""Hello, I am <domain>"" (and,
   in the case of EHLO, ""and I support service extension requests"").







Klensin                     Standards Track                    [Page 18]

RFC 5321                          SMTP                      October 2008


3.3.  Mail Transactions

   There are three steps to SMTP mail transactions.  The transaction
   starts with a MAIL command that gives the sender identification.  (In
   general, the MAIL command may be sent only when no mail transaction
   is in progress; see Section 4.1.4.)  A series of one or more RCPT
   commands follows, giving the receiver information.  Then, a DATA
   command initiates transfer of the mail data and is terminated by the
   ""end of mail"" data indicator, which also confirms the transaction.

   The first step in the procedure is the MAIL command.

      MAIL FROM:<reverse-path> [SP <mail-parameters> ] <CRLF>

   This command tells the SMTP-receiver that a new mail transaction is
   starting and to reset all its state tables and buffers, including any
   recipients or mail data.  The <reverse-path> portion of the first or
   only argument contains the source mailbox (between ""<"" and "">""
   brackets), which can be used to report errors (see Section 4.2 for a
   discussion of error reporting).  If accepted, the SMTP server returns
   a ""250 OK"" reply.  If the mailbox specification is not acceptable for
   some reason, the server MUST return a reply indicating whether the
   failure is permanent (i.e., will occur again if the client tries to
   send the same address again) or temporary (i.e., the address might be
   accepted if the client tries again later).  Despite the apparent
   scope of this requirement, there are circumstances in which the
   acceptability of the reverse-path may not be determined until one or
   more forward-paths (in RCPT commands) can be examined.  In those
   cases, the server MAY reasonably accept the reverse-path (with a 250
   reply) and then report problems after the forward-paths are received
   and examined.  Normally, failures produce 550 or 553 replies.

   Historically, the <reverse-path> was permitted to contain more than
   just a mailbox; however, contemporary systems SHOULD NOT use source
   routing (see Appendix C).

   The optional <mail-parameters> are associated with negotiated SMTP
   service extensions (see Section 2.2).

   The second step in the procedure is the RCPT command.  This step of
   the procedure can be repeated any number of times.

      RCPT TO:<forward-path> [ SP <rcpt-parameters> ] <CRLF>

   The first or only argument to this command includes a forward-path
   (normally a mailbox and domain, always surrounded by ""<"" and "">""
   brackets) identifying one recipient.  If accepted, the SMTP server
   returns a ""250 OK"" reply and stores the forward-path.  If the



Klensin                     Standards Track                    [Page 19]

RFC 5321                          SMTP                      October 2008


   recipient is known not to be a deliverable address, the SMTP server
   returns a 550 reply, typically with a string such as ""no such user -
   "" and the mailbox name (other circumstances and reply codes are
   possible).

   The <forward-path> can contain more than just a mailbox.
   Historically, the <forward-path> was permitted to contain a source
   routing list of hosts and the destination mailbox; however,
   contemporary SMTP clients SHOULD NOT utilize source routes (see
   Appendix C).  Servers MUST be prepared to encounter a list of source
   routes in the forward-path, but they SHOULD ignore the routes or MAY
   decline to support the relaying they imply.  Similarly, servers MAY
   decline to accept mail that is destined for other hosts or systems.
   These restrictions make a server useless as a relay for clients that
   do not support full SMTP functionality.  Consequently, restricted-
   capability clients MUST NOT assume that any SMTP server on the
   Internet can be used as their mail processing (relaying) site.  If a
   RCPT command appears without a previous MAIL command, the server MUST
   return a 503 ""Bad sequence of commands"" response.  The optional
   <rcpt-parameters> are associated with negotiated SMTP service
   extensions (see Section 2.2).

   Since it has been a common source of errors, it is worth noting that
   spaces are not permitted on either side of the colon following FROM
   in the MAIL command or TO in the RCPT command.  The syntax is exactly
   as given above.

   The third step in the procedure is the DATA command (or some
   alternative specified in a service extension).

      DATA <CRLF>

   If accepted, the SMTP server returns a 354 Intermediate reply and
   considers all succeeding lines up to but not including the end of
   mail data indicator to be the message text.  When the end of text is
   successfully received and stored, the SMTP-receiver sends a ""250 OK""
   reply.

   Since the mail data is sent on the transmission channel, the end of
   mail data must be indicated so that the command and reply dialog can
   be resumed.  SMTP indicates the end of the mail data by sending a
   line containing only a ""."" (period or full stop).  A transparency
   procedure is used to prevent this from interfering with the user's
   text (see Section 4.5.2).

   The end of mail data indicator also confirms the mail transaction and
   tells the SMTP server to now process the stored recipients and mail




Klensin                     Standards Track                    [Page 20]

RFC 5321                          SMTP                      October 2008


   data.  If accepted, the SMTP server returns a ""250 OK"" reply.  The
   DATA command can fail at only two points in the protocol exchange:

   If there was no MAIL, or no RCPT, command, or all such commands were
   rejected, the server MAY return a ""command out of sequence"" (503) or
   ""no valid recipients"" (554) reply in response to the DATA command.
   If one of those replies (or any other 5yz reply) is received, the
   client MUST NOT send the message data; more generally, message data
   MUST NOT be sent unless a 354 reply is received.

   If the verb is initially accepted and the 354 reply issued, the DATA
   command should fail only if the mail transaction was incomplete (for
   example, no recipients), if resources were unavailable (including, of
   course, the server unexpectedly becoming unavailable), or if the
   server determines that the message should be rejected for policy or
   other reasons.

   However, in practice, some servers do not perform recipient
   verification until after the message text is received.  These servers
   SHOULD treat a failure for one or more recipients as a ""subsequent
   failure"" and return a mail message as discussed in Section 6 and, in
   particular, in Section 6.1.  Using a ""550 mailbox not found"" (or
   equivalent) reply code after the data are accepted makes it difficult
   or impossible for the client to determine which recipients failed.

   When the RFC 822 format ([28], [4]) is being used, the mail data
   include the header fields such as those named Date, Subject, To, Cc,
   and From.  Server SMTP systems SHOULD NOT reject messages based on
   perceived defects in the RFC 822 or MIME (RFC 2045 [21]) message
   header section or message body.  In particular, they MUST NOT reject
   messages in which the numbers of Resent-header fields do not match or
   Resent-to appears without Resent-from and/or Resent-date.

   Mail transaction commands MUST be used in the order discussed above.

3.4.  Forwarding for Address Correction or Updating

   Forwarding support is most often required to consolidate and simplify
   addresses within, or relative to, some enterprise and less frequently
   to establish addresses to link a person's prior address with a
   current one.  Silent forwarding of messages (without server
   notification to the sender), for security or non-disclosure purposes,
   is common in the contemporary Internet.

   In both the enterprise and the ""new address"" cases, information
   hiding (and sometimes security) considerations argue against exposure
   of the ""final"" address through the SMTP protocol as a side effect of
   the forwarding activity.  This may be especially important when the



Klensin                     Standards Track                    [Page 21]

RFC 5321                          SMTP                      October 2008


   final address may not even be reachable by the sender.  Consequently,
   the ""forwarding"" mechanisms described in Section 3.2 of RFC 821, and
   especially the 251 (corrected destination) and 551 reply codes from
   RCPT must be evaluated carefully by implementers and, when they are
   available, by those configuring systems (see also Section 7.4).

   In particular:

   o  Servers MAY forward messages when they are aware of an address
      change.  When they do so, they MAY either provide address-updating
      information with a 251 code, or may forward ""silently"" and return
      a 250 code.  However, if a 251 code is used, they MUST NOT assume
      that the client will actually update address information or even
      return that information to the user.

   Alternately,

   o  Servers MAY reject messages or return them as non-deliverable when
      they cannot be delivered precisely as addressed.  When they do so,
      they MAY either provide address-updating information with a 551
      code, or may reject the message as undeliverable with a 550 code
      and no address-specific information.  However, if a 551 code is
      used, they MUST NOT assume that the client will actually update
      address information or even return that information to the user.

   SMTP server implementations that support the 251 and/or 551 reply
   codes SHOULD provide configuration mechanisms so that sites that
   conclude that they would undesirably disclose information can disable
   or restrict their use.

3.5.  Commands for Debugging Addresses

3.5.1.  Overview

   SMTP provides commands to verify a user name or obtain the content of
   a mailing list.  This is done with the VRFY and EXPN commands, which
   have character string arguments.  Implementations SHOULD support VRFY
   and EXPN (however, see Section 3.5.2 and Section 7.3).

   For the VRFY command, the string is a user name or a user name and
   domain (see below).  If a normal (i.e., 250) response is returned,
   the response MAY include the full name of the user and MUST include
   the mailbox of the user.  It MUST be in either of the following
   forms:

      User Name <local-part@domain>
      local-part@domain




Klensin                     Standards Track                    [Page 22]

RFC 5321                          SMTP                      October 2008


   When a name that is the argument to VRFY could identify more than one
   mailbox, the server MAY either note the ambiguity or identify the
   alternatives.  In other words, any of the following are legitimate
   responses to VRFY:

      553 User ambiguous

   or

      553- Ambiguous; Possibilities are
      553-Joe Smith <jsmith@foo.com>
      553-Harry Smith <hsmith@foo.com>
      553 Melvin Smith <dweep@foo.com>

   or

      553-Ambiguous; Possibilities
      553- <jsmith@foo.com>
      553- <hsmith@foo.com>
      553 <dweep@foo.com>

   Under normal circumstances, a client receiving a 553 reply would be
   expected to expose the result to the user.  Use of exactly the forms
   given, and the ""user ambiguous"" or ""ambiguous"" keywords, possibly
   supplemented by extended reply codes, such as those described in RFC
   3463 [25], will facilitate automated translation into other languages
   as needed.  Of course, a client that was highly automated or that was
   operating in another language than English might choose to try to
   translate the response to return some other indication to the user
   than the literal text of the reply, or to take some automated action
   such as consulting a directory service for additional information
   before reporting to the user.

   For the EXPN command, the string identifies a mailing list, and the
   successful (i.e., 250) multiline response MAY include the full name
   of the users and MUST give the mailboxes on the mailing list.

   In some hosts, the distinction between a mailing list and an alias
   for a single mailbox is a bit fuzzy, since a common data structure
   may hold both types of entries, and it is possible to have mailing
   lists containing only one mailbox.  If a request is made to apply
   VRFY to a mailing list, a positive response MAY be given if a message
   so addressed would be delivered to everyone on the list, otherwise an
   error SHOULD be reported (e.g., ""550 That is a mailing list, not a
   user"" or ""252 Unable to verify members of mailing list"").  If a
   request is made to expand a user name, the server MAY return a





Klensin                     Standards Track                    [Page 23]

RFC 5321                          SMTP                      October 2008


   positive response consisting of a list containing one name, or an
   error MAY be reported (e.g., ""550 That is a user name, not a mailing
   list"").

   In the case of a successful multiline reply (normal for EXPN),
   exactly one mailbox is to be specified on each line of the reply.
   The case of an ambiguous request is discussed above.

   ""User name"" is a fuzzy term and has been used deliberately.  An
   implementation of the VRFY or EXPN commands MUST include at least
   recognition of local mailboxes as ""user names"".  However, since
   current Internet practice often results in a single host handling
   mail for multiple domains, hosts, especially hosts that provide this
   functionality, SHOULD accept the ""local-part@domain"" form as a ""user
   name""; hosts MAY also choose to recognize other strings as ""user
   names"".

   The case of expanding a mailbox list requires a multiline reply, such
   as:

      C: EXPN Example-People
      S: 250-Jon Postel <Postel@isi.edu>
      S: 250-Fred Fonebone <Fonebone@physics.foo-u.edu>
      S: 250 Sam Q. Smith <SQSmith@specific.generic.com>

   or

      C: EXPN Executive-Washroom-List
      S: 550 Access Denied to You.

   The character string arguments of the VRFY and EXPN commands cannot
   be further restricted due to the variety of implementations of the
   user name and mailbox list concepts.  On some systems, it may be
   appropriate for the argument of the EXPN command to be a file name
   for a file containing a mailing list, but again there are a variety
   of file naming conventions in the Internet.  Similarly, historical
   variations in what is returned by these commands are such that the
   response SHOULD be interpreted very carefully, if at all, and SHOULD
   generally only be used for diagnostic purposes.

3.5.2.  VRFY Normal Response

   When normal (2yz or 551) responses are returned from a VRFY or EXPN
   request, the reply MUST include the <Mailbox> name using a
   ""<local-part@domain>"" construction, where ""domain"" is a fully-
   qualified domain name.  In circumstances exceptional enough to
   justify violating the intent of this specification, free-form text
   MAY be returned.  In order to facilitate parsing by both computers



Klensin                     Standards Track                    [Page 24]

RFC 5321                          SMTP                      October 2008


   and people, addresses SHOULD appear in pointed brackets.  When
   addresses, rather than free-form debugging information, are returned,
   EXPN and VRFY MUST return only valid domain addresses that are usable
   in SMTP RCPT commands.  Consequently, if an address implies delivery
   to a program or other system, the mailbox name used to reach that
   target MUST be given.  Paths (explicit source routes) MUST NOT be
   returned by VRFY or EXPN.

   Server implementations SHOULD support both VRFY and EXPN.  For
   security reasons, implementations MAY provide local installations a
   way to disable either or both of these commands through configuration
   options or the equivalent (see Section 7.3).  When these commands are
   supported, they are not required to work across relays when relaying
   is supported.  Since they were both optional in RFC 821, but VRFY was
   made mandatory in RFC 1123 [3], if EXPN is supported, it MUST be
   listed as a service extension in an EHLO response.  VRFY MAY be
   listed as a convenience but, since support for it is required, SMTP
   clients are not required to check for its presence on the extension
   list before using it.

3.5.3.  Meaning of VRFY or EXPN Success Response

   A server MUST NOT return a 250 code in response to a VRFY or EXPN
   command unless it has actually verified the address.  In particular,
   a server MUST NOT return 250 if all it has done is to verify that the
   syntax given is valid.  In that case, 502 (Command not implemented)
   or 500 (Syntax error, command unrecognized) SHOULD be returned.  As
   stated elsewhere, implementation (in the sense of actually validating
   addresses and returning information) of VRFY and EXPN are strongly
   recommended.  Hence, implementations that return 500 or 502 for VRFY
   are not in full compliance with this specification.

   There may be circumstances where an address appears to be valid but
   cannot reasonably be verified in real time, particularly when a
   server is acting as a mail exchanger for another server or domain.
   ""Apparent validity"", in this case, would normally involve at least
   syntax checking and might involve verification that any domains
   specified were ones to which the host expected to be able to relay
   mail.  In these situations, reply code 252 SHOULD be returned.  These
   cases parallel the discussion of RCPT verification in Section 2.1.
   Similarly, the discussion in Section 3.4 applies to the use of reply
   codes 251 and 551 with VRFY (and EXPN) to indicate addresses that are
   recognized but that would be forwarded or rejected were mail received
   for them.  Implementations generally SHOULD be more aggressive about
   address verification in the case of VRFY than in the case of RCPT,
   even if it takes a little longer to do so.





Klensin                     Standards Track                    [Page 25]

RFC 5321                          SMTP                      October 2008


3.5.4.  Semantics and Applications of EXPN

   EXPN is often very useful in debugging and understanding problems
   with mailing lists and multiple-target-address aliases.  Some systems
   have attempted to use source expansion of mailing lists as a means of
   eliminating duplicates.  The propagation of aliasing systems with
   mail on the Internet for hosts (typically with MX and CNAME DNS
   records), for mailboxes (various types of local host aliases), and in
   various proxying arrangements has made it nearly impossible for these
   strategies to work consistently, and mail systems SHOULD NOT attempt
   them.

3.6.  Relaying and Mail Routing

3.6.1.  Source Routes and Relaying

   In general, the availability of Mail eXchanger records in the domain
   name system (RFC 1035 [2], RFC 974 [12]) makes the use of explicit
   source routes in the Internet mail system unnecessary.  Many
   historical problems with the interpretation of explicit source routes
   have made their use undesirable.  SMTP clients SHOULD NOT generate
   explicit source routes except under unusual circumstances.  SMTP
   servers MAY decline to act as mail relays or to accept addresses that
   specify source routes.  When route information is encountered, SMTP
   servers MAY ignore the route information and simply send to the final
   destination specified as the last element in the route and SHOULD do
   so.  There has been an invalid practice of using names that do not
   appear in the DNS as destination names, with the senders counting on
   the intermediate hosts specified in source routing to resolve any
   problems.  If source routes are stripped, this practice will cause
   failures.  This is one of several reasons why SMTP clients MUST NOT
   generate invalid source routes or depend on serial resolution of
   names.

   When source routes are not used, the process described in RFC 821 for
   constructing a reverse-path from the forward-path is not applicable
   and the reverse-path at the time of delivery will simply be the
   address that appeared in the MAIL command.

3.6.2.  Mail eXchange Records and Relaying

   A relay SMTP server is usually the target of a DNS MX record that
   designates it, rather than the final delivery system.  The relay
   server may accept or reject the task of relaying the mail in the same
   way it accepts or rejects mail for a local user.  If it accepts the
   task, it then becomes an SMTP client, establishes a transmission
   channel to the next SMTP server specified in the DNS (according to
   the rules in Section 5), and sends it the mail.  If it declines to



Klensin                     Standards Track                    [Page 26]

RFC 5321                          SMTP                      October 2008


   relay mail to a particular address for policy reasons, a 550 response
   SHOULD be returned.

   This specification does not deal with the verification of return
   paths for use in delivery notifications.  Recent work, such as that
   on SPF [29] and DKIM [30] [31], has been done to provide ways to
   ascertain that an address is valid or belongs to the person who
   actually sent the message.  A server MAY attempt to verify the return
   path before using its address for delivery notifications, but methods
   of doing so are not defined here nor is any particular method
   recommended at this time.

3.6.3.  Message Submission Servers as Relays

   Many mail-sending clients exist, especially in conjunction with
   facilities that receive mail via POP3 or IMAP, that have limited
   capability to support some of the requirements of this specification,
   such as the ability to queue messages for subsequent delivery
   attempts.  For these clients, it is common practice to make private
   arrangements to send all messages to a single server for processing
   and subsequent distribution.  SMTP, as specified here, is not ideally
   suited for this role.  A standardized mail submission protocol has
   been developed that is gradually superseding practices based on SMTP
   (see RFC 4409 [18]).  In any event, because these arrangements are
   private and fall outside the scope of this specification, they are
   not described here.

   It is important to note that MX records can point to SMTP servers
   that act as gateways into other environments, not just SMTP relays
   and final delivery systems; see Sections 3.7 and 5.

   If an SMTP server has accepted the task of relaying the mail and
   later finds that the destination is incorrect or that the mail cannot
   be delivered for some other reason, then it MUST construct an
   ""undeliverable mail"" notification message and send it to the
   originator of the undeliverable mail (as indicated by the reverse-
   path).  Formats specified for non-delivery reports by other standards
   (see, for example, RFC 3461 [32] and RFC 3464 [33]) SHOULD be used if
   possible.

   This notification message must be from the SMTP server at the relay
   host or the host that first determines that delivery cannot be
   accomplished.  Of course, SMTP servers MUST NOT send notification
   messages about problems transporting notification messages.  One way
   to prevent loops in error reporting is to specify a null reverse-path
   in the MAIL command of a notification message.  When such a message
   is transmitted, the reverse-path MUST be set to null (see




Klensin                     Standards Track                    [Page 27]

RFC 5321                          SMTP                      October 2008


   Section 4.5.5 for additional discussion).  A MAIL command with a null
   reverse-path appears as follows:

      MAIL FROM:<>

   As discussed in Section 6.4, a relay SMTP has no need to inspect or
   act upon the header section or body of the message data and MUST NOT
   do so except to add its own ""Received:"" header field (Section 4.4)
   and, optionally, to attempt to detect looping in the mail system (see
   Section 6.3).  Of course, this prohibition also applies to any
   modifications of these header fields or text (see also Section 7.9).

3.7.  Mail Gatewaying

   While the relay function discussed above operates within the Internet
   SMTP transport service environment, MX records or various forms of
   explicit routing may require that an intermediate SMTP server perform
   a translation function between one transport service and another.  As
   discussed in Section 2.3.10, when such a system is at the boundary
   between two transport service environments, we refer to it as a
   ""gateway"" or ""gateway SMTP"".

   Gatewaying mail between different mail environments, such as
   different mail formats and protocols, is complex and does not easily
   yield to standardization.  However, some general requirements may be
   given for a gateway between the Internet and another mail
   environment.

3.7.1.  Header Fields in Gatewaying

   Header fields MAY be rewritten when necessary as messages are
   gatewayed across mail environment boundaries.  This may involve
   inspecting the message body or interpreting the local-part of the
   destination address in spite of the prohibitions in Section 6.4.

   Other mail systems gatewayed to the Internet often use a subset of
   the RFC 822 header section or provide similar functionality with a
   different syntax, but some of these mail systems do not have an
   equivalent to the SMTP envelope.  Therefore, when a message leaves
   the Internet environment, it may be necessary to fold the SMTP
   envelope information into the message header section.  A possible
   solution would be to create new header fields to carry the envelope
   information (e.g., ""X-SMTP-MAIL:"" and ""X-SMTP-RCPT:""); however, this
   would require changes in mail programs in foreign environments and
   might risk disclosure of private information (see Section 7.2).






Klensin                     Standards Track                    [Page 28]

RFC 5321                          SMTP                      October 2008


3.7.2.  Received Lines in Gatewaying

   When forwarding a message into or out of the Internet environment, a
   gateway MUST prepend a Received: line, but it MUST NOT alter in any
   way a Received: line that is already in the header section.

   ""Received:"" header fields of messages originating from other
   environments may not conform exactly to this specification.  However,
   the most important use of Received: lines is for debugging mail
   faults, and this debugging can be severely hampered by well-meaning
   gateways that try to ""fix"" a Received: line.  As another consequence
   of trace header fields arising in non-SMTP environments, receiving
   systems MUST NOT reject mail based on the format of a trace header
   field and SHOULD be extremely robust in the light of unexpected
   information or formats in those header fields.

   The gateway SHOULD indicate the environment and protocol in the ""via""
   clauses of Received header field(s) that it supplies.

3.7.3.  Addresses in Gatewaying

   From the Internet side, the gateway SHOULD accept all valid address
   formats in SMTP commands and in the RFC 822 header section, and all
   valid RFC 822 messages.  Addresses and header fields generated by
   gateways MUST conform to applicable standards (including this one and
   RFC 5322 [4]).  Gateways are, of course, subject to the same rules
   for handling source routes as those described for other SMTP systems
   in Section 3.3.

3.7.4.  Other Header Fields in Gatewaying

   The gateway MUST ensure that all header fields of a message that it
   forwards into the Internet mail environment meet the requirements for
   Internet mail.  In particular, all addresses in ""From:"", ""To:"",
   ""Cc:"", etc., header fields MUST be transformed (if necessary) to
   satisfy the standard header syntax of RFC 5322 [4], MUST reference
   only fully-qualified domain names, and MUST be effective and useful
   for sending replies.  The translation algorithm used to convert mail
   from the Internet protocols to another environment's protocol SHOULD
   ensure that error messages from the foreign mail environment are
   delivered to the reverse-path from the SMTP envelope, not to an
   address in the ""From:"", ""Sender:"", or similar header fields of the
   message.








Klensin                     Standards Track                    [Page 29]

RFC 5321                          SMTP                      October 2008


3.7.5.  Envelopes in Gatewaying

   Similarly, when forwarding a message from another environment into
   the Internet, the gateway SHOULD set the envelope return path in
   accordance with an error message return address, if supplied by the
   foreign environment.  If the foreign environment has no equivalent
   concept, the gateway must select and use a best approximation, with
   the message originator's address as the default of last resort.

3.8.  Terminating Sessions and Connections

   An SMTP connection is terminated when the client sends a QUIT
   command.  The server responds with a positive reply code, after which
   it closes the connection.

   An SMTP server MUST NOT intentionally close the connection under
   normal operational circumstances (see Section 7.8) except:

   o  After receiving a QUIT command and responding with a 221 reply.

   o  After detecting the need to shut down the SMTP service and
      returning a 421 response code.  This response code can be issued
      after the server receives any command or, if necessary,
      asynchronously from command receipt (on the assumption that the
      client will receive it after the next command is issued).

   o  After a timeout, as specified in Section 4.5.3.2, occurs waiting
      for the client to send a command or data.

   In particular, a server that closes connections in response to
   commands that are not understood is in violation of this
   specification.  Servers are expected to be tolerant of unknown
   commands, issuing a 500 reply and awaiting further instructions from
   the client.

   An SMTP server that is forcibly shut down via external means SHOULD
   attempt to send a line containing a 421 response code to the SMTP
   client before exiting.  The SMTP client will normally read the 421
   response code after sending its next command.

   SMTP clients that experience a connection close, reset, or other
   communications failure due to circumstances not under their control
   (in violation of the intent of this specification but sometimes
   unavoidable) SHOULD, to maintain the robustness of the mail system,
   treat the mail transaction as if a 451 response had been received and
   act accordingly.





Klensin                     Standards Track                    [Page 30]

RFC 5321                          SMTP                      October 2008


3.9.  Mailing Lists and Aliases

   An SMTP-capable host SHOULD support both the alias and the list
   models of address expansion for multiple delivery.  When a message is
   delivered or forwarded to each address of an expanded list form, the
   return address in the envelope (""MAIL FROM:"") MUST be changed to be
   the address of a person or other entity who administers the list.
   However, in this case, the message header section (RFC 5322 [4]) MUST
   be left unchanged; in particular, the ""From"" field of the header
   section is unaffected.

   An important mail facility is a mechanism for multi-destination
   delivery of a single message, by transforming (or ""expanding"" or
   ""exploding"") a pseudo-mailbox address into a list of destination
   mailbox addresses.  When a message is sent to such a pseudo-mailbox
   (sometimes called an ""exploder""), copies are forwarded or
   redistributed to each mailbox in the expanded list.  Servers SHOULD
   simply utilize the addresses on the list; application of heuristics
   or other matching rules to eliminate some addresses, such as that of
   the originator, is strongly discouraged.  We classify such a pseudo-
   mailbox as an ""alias"" or a ""list"", depending upon the expansion
   rules.

3.9.1.  Alias

   To expand an alias, the recipient mailer simply replaces the pseudo-
   mailbox address in the envelope with each of the expanded addresses
   in turn; the rest of the envelope and the message body are left
   unchanged.  The message is then delivered or forwarded to each
   expanded address.

3.9.2.  List

   A mailing list may be said to operate by ""redistribution"" rather than
   by ""forwarding"".  To expand a list, the recipient mailer replaces the
   pseudo-mailbox address in the envelope with each of the expanded
   addresses in turn.  The return (backward-pointing) address in the
   envelope is changed so that all error messages generated by the final
   deliveries will be returned to a list administrator, not to the
   message originator, who generally has no control over the contents of
   the list and will typically find error messages annoying.  Note that
   the key difference between handling aliases (Section 3.9.1) and
   forwarding (this subsection) is the change to the backward-pointing
   address in this case.  When a list constrains its processing to the
   very limited set of modifications and actions described here, it is
   attempting to emulate an MTA; such lists can be treated as a
   continuation in email transit.




Klensin                     Standards Track                    [Page 31]

RFC 5321                          SMTP                      October 2008


   There exist mailing lists that perform additional, sometimes
   extensive, modifications to a message and its envelope.  Such mailing
   lists need to be viewed as full MUAs, which accept a delivery and
   post a new message.

4.  The SMTP Specifications

4.1.  SMTP Commands

4.1.1.  Command Semantics and Syntax

   The SMTP commands define the mail transfer or the mail system
   function requested by the user.  SMTP commands are character strings
   terminated by <CRLF>.  The commands themselves are alphabetic
   characters terminated by <SP> if parameters follow and <CRLF>
   otherwise.  (In the interest of improved interoperability, SMTP
   receivers SHOULD tolerate trailing white space before the terminating
   <CRLF>.)  The syntax of the local part of a mailbox MUST conform to
   receiver site conventions and the syntax specified in Section 4.1.2.
   The SMTP commands are discussed below.  The SMTP replies are
   discussed in Section 4.2.

   A mail transaction involves several data objects that are
   communicated as arguments to different commands.  The reverse-path is
   the argument of the MAIL command, the forward-path is the argument of
   the RCPT command, and the mail data is the argument of the DATA
   command.  These arguments or data objects must be transmitted and
   held, pending the confirmation communicated by the end of mail data
   indication that finalizes the transaction.  The model for this is
   that distinct buffers are provided to hold the types of data objects;
   that is, there is a reverse-path buffer, a forward-path buffer, and a
   mail data buffer.  Specific commands cause information to be appended
   to a specific buffer, or cause one or more buffers to be cleared.

   Several commands (RSET, DATA, QUIT) are specified as not permitting
   parameters.  In the absence of specific extensions offered by the
   server and accepted by the client, clients MUST NOT send such
   parameters and servers SHOULD reject commands containing them as
   having invalid syntax.

4.1.1.1.  Extended HELLO (EHLO) or HELLO (HELO)

   These commands are used to identify the SMTP client to the SMTP
   server.  The argument clause contains the fully-qualified domain name
   of the SMTP client, if one is available.  In situations in which the
   SMTP client system does not have a meaningful domain name (e.g., when
   its address is dynamically allocated and no reverse mapping record is




Klensin                     Standards Track                    [Page 32]

RFC 5321                          SMTP                      October 2008


   available), the client SHOULD send an address literal (see
   Section 4.1.3).

   RFC 2821, and some earlier informal practices, encouraged following
   the literal by information that would help to identify the client
   system.  That convention was not widely supported, and many SMTP
   servers considered it an error.  In the interest of interoperability,
   it is probably wise for servers to be prepared for this string to
   occur, but SMTP clients SHOULD NOT send it.

   The SMTP server identifies itself to the SMTP client in the
   connection greeting reply and in the response to this command.

   A client SMTP SHOULD start an SMTP session by issuing the EHLO
   command.  If the SMTP server supports the SMTP service extensions, it
   will give a successful response, a failure response, or an error
   response.  If the SMTP server, in violation of this specification,
   does not support any SMTP service extensions, it will generate an
   error response.  Older client SMTP systems MAY, as discussed above,
   use HELO (as specified in RFC 821) instead of EHLO, and servers MUST
   support the HELO command and reply properly to it.  In any event, a
   client MUST issue HELO or EHLO before starting a mail transaction.

   These commands, and a ""250 OK"" reply to one of them, confirm that
   both the SMTP client and the SMTP server are in the initial state,
   that is, there is no transaction in progress and all state tables and
   buffers are cleared.

   Syntax:

   ehlo           = ""EHLO"" SP ( Domain / address-literal ) CRLF

   helo           = ""HELO"" SP Domain CRLF

   Normally, the response to EHLO will be a multiline reply.  Each line
   of the response contains a keyword and, optionally, one or more
   parameters.  Following the normal syntax for multiline replies, these
   keywords follow the code (250) and a hyphen for all but the last
   line, and the code and a space for the last line.  The syntax for a
   positive response, using the ABNF notation and terminal symbols of
   RFC 5234 [7], is:

   ehlo-ok-rsp    = ( ""250"" SP Domain [ SP ehlo-greet ] CRLF )
                    / ( ""250-"" Domain [ SP ehlo-greet ] CRLF
                    *( ""250-"" ehlo-line CRLF )
                    ""250"" SP ehlo-line CRLF )





Klensin                     Standards Track                    [Page 33]

RFC 5321                          SMTP                      October 2008


   ehlo-greet     = 1*(%d0-9 / %d11-12 / %d14-127)
                    ; string of any characters other than CR or LF

   ehlo-line      = ehlo-keyword *( SP ehlo-param )

   ehlo-keyword   = (ALPHA / DIGIT) *(ALPHA / DIGIT / ""-"")
                    ; additional syntax of ehlo-params depends on
                    ; ehlo-keyword

   ehlo-param     = 1*(%d33-126)
                    ; any CHAR excluding <SP> and all
                    ; control characters (US-ASCII 0-31 and 127
                    ; inclusive)

   Although EHLO keywords may be specified in upper, lower, or mixed
   case, they MUST always be recognized and processed in a case-
   insensitive manner.  This is simply an extension of practices
   specified in RFC 821 and Section 2.4.

   The EHLO response MUST contain keywords (and associated parameters if
   required) for all commands not listed as ""required"" in Section 4.5.1
   excepting only private-use commands as described in Section 4.1.5.
   Private-use commands MAY be listed.

4.1.1.2.  MAIL (MAIL)

   This command is used to initiate a mail transaction in which the mail
   data is delivered to an SMTP server that may, in turn, deliver it to
   one or more mailboxes or pass it on to another system (possibly using
   SMTP).  The argument clause contains a reverse-path and may contain
   optional parameters.  In general, the MAIL command may be sent only
   when no mail transaction is in progress, see Section 4.1.4.

   The reverse-path consists of the sender mailbox.  Historically, that
   mailbox might optionally have been preceded by a list of hosts, but
   that behavior is now deprecated (see Appendix C).  In some types of
   reporting messages for which a reply is likely to cause a mail loop
   (for example, mail delivery and non-delivery notifications), the
   reverse-path may be null (see Section 3.6).

   This command clears the reverse-path buffer, the forward-path buffer,
   and the mail data buffer, and it inserts the reverse-path information
   from its argument clause into the reverse-path buffer.

   If service extensions were negotiated, the MAIL command may also
   carry parameters associated with a particular service extension.





Klensin                     Standards Track                    [Page 34]

RFC 5321                          SMTP                      October 2008


   Syntax:

   mail = ""MAIL FROM:"" Reverse-path
                                       [SP Mail-parameters] CRLF

4.1.1.3.  RECIPIENT (RCPT)

   This command is used to identify an individual recipient of the mail
   data; multiple recipients are specified by multiple uses of this
   command.  The argument clause contains a forward-path and may contain
   optional parameters.

   The forward-path normally consists of the required destination
   mailbox.  Sending systems SHOULD NOT generate the optional list of
   hosts known as a source route.  Receiving systems MUST recognize
   source route syntax but SHOULD strip off the source route
   specification and utilize the domain name associated with the mailbox
   as if the source route had not been provided.

   Similarly, relay hosts SHOULD strip or ignore source routes, and
   names MUST NOT be copied into the reverse-path.  When mail reaches
   its ultimate destination (the forward-path contains only a
   destination mailbox), the SMTP server inserts it into the destination
   mailbox in accordance with its host mail conventions.

   This command appends its forward-path argument to the forward-path
   buffer; it does not change the reverse-path buffer nor the mail data
   buffer.

   For example, mail received at relay host xyz.com with envelope
   commands

      MAIL FROM:<userx@y.foo.org>
      RCPT TO:<@hosta.int,@jkl.org:userc@d.bar.org>

   will normally be sent directly on to host d.bar.org with envelope
   commands

      MAIL FROM:<userx@y.foo.org>
      RCPT TO:<userc@d.bar.org>

   As provided in Appendix C, xyz.com MAY also choose to relay the
   message to hosta.int, using the envelope commands

      MAIL FROM:<userx@y.foo.org>
      RCPT TO:<@hosta.int,@jkl.org:userc@d.bar.org>





Klensin                     Standards Track                    [Page 35]

RFC 5321                          SMTP                      October 2008


   or to jkl.org, using the envelope commands

      MAIL FROM:<userx@y.foo.org>
      RCPT TO:<@jkl.org:userc@d.bar.org>

   Attempting to use relaying this way is now strongly discouraged.
   Since hosts are not required to relay mail at all, xyz.com MAY also
   reject the message entirely when the RCPT command is received, using
   a 550 code (since this is a ""policy reason"").

   If service extensions were negotiated, the RCPT command may also
   carry parameters associated with a particular service extension
   offered by the server.  The client MUST NOT transmit parameters other
   than those associated with a service extension offered by the server
   in its EHLO response.

   Syntax:

      rcpt = ""RCPT TO:"" ( ""<Postmaster@"" Domain "">"" / ""<Postmaster>"" /
                  Forward-path ) [SP Rcpt-parameters] CRLF

                  Note that, in a departure from the usual rules for
                  local-parts, the ""Postmaster"" string shown above is
                  treated as case-insensitive.

4.1.1.4.  DATA (DATA)

   The receiver normally sends a 354 response to DATA, and then treats
   the lines (strings ending in <CRLF> sequences, as described in
   Section 2.3.7) following the command as mail data from the sender.
   This command causes the mail data to be appended to the mail data
   buffer.  The mail data may contain any of the 128 ASCII character
   codes, although experience has indicated that use of control
   characters other than SP, HT, CR, and LF may cause problems and
   SHOULD be avoided when possible.

   The mail data are terminated by a line containing only a period, that
   is, the character sequence ""<CRLF>.<CRLF>"", where the first <CRLF> is
   actually the terminator of the previous line (see Section 4.5.2).
   This is the end of mail data indication.  The first <CRLF> of this
   terminating sequence is also the <CRLF> that ends the final line of
   the data (message text) or, if there was no mail data, ends the DATA
   command itself (the ""no mail data"" case does not conform to this
   specification since it would require that neither the trace header
   fields required by this specification nor the message header section
   required by RFC 5322 [4] be transmitted).  An extra <CRLF> MUST NOT
   be added, as that would cause an empty line to be added to the
   message.  The only exception to this rule would arise if the message



Klensin                     Standards Track                    [Page 36]

RFC 5321                          SMTP                      October 2008


   body were passed to the originating SMTP-sender with a final ""line""
   that did not end in <CRLF>; in that case, the originating SMTP system
   MUST either reject the message as invalid or add <CRLF> in order to
   have the receiving SMTP server recognize the ""end of data"" condition.

   The custom of accepting lines ending only in <LF>, as a concession to
   non-conforming behavior on the part of some UNIX systems, has proven
   to cause more interoperability problems than it solves, and SMTP
   server systems MUST NOT do this, even in the name of improved
   robustness.  In particular, the sequence ""<LF>.<LF>"" (bare line
   feeds, without carriage returns) MUST NOT be treated as equivalent to
   <CRLF>.<CRLF> as the end of mail data indication.

   Receipt of the end of mail data indication requires the server to
   process the stored mail transaction information.  This processing
   consumes the information in the reverse-path buffer, the forward-path
   buffer, and the mail data buffer, and on the completion of this
   command these buffers are cleared.  If the processing is successful,
   the receiver MUST send an OK reply.  If the processing fails, the
   receiver MUST send a failure reply.  The SMTP model does not allow
   for partial failures at this point: either the message is accepted by
   the server for delivery and a positive response is returned or it is
   not accepted and a failure reply is returned.  In sending a positive
   ""250 OK"" completion reply to the end of data indication, the receiver
   takes full responsibility for the message (see Section 6.1).  Errors
   that are diagnosed subsequently MUST be reported in a mail message,
   as discussed in Section 4.4.

   When the SMTP server accepts a message either for relaying or for
   final delivery, it inserts a trace record (also referred to
   interchangeably as a ""time stamp line"" or ""Received"" line) at the top
   of the mail data.  This trace record indicates the identity of the
   host that sent the message, the identity of the host that received
   the message (and is inserting this time stamp), and the date and time
   the message was received.  Relayed messages will have multiple time
   stamp lines.  Details for formation of these lines, including their
   syntax, is specified in Section 4.4.

   Additional discussion about the operation of the DATA command appears
   in Section 3.3.

   Syntax:

      data = ""DATA"" CRLF







Klensin                     Standards Track                    [Page 37]

RFC 5321                          SMTP                      October 2008


4.1.1.5.  RESET (RSET)

   This command specifies that the current mail transaction will be
   aborted.  Any stored sender, recipients, and mail data MUST be
   discarded, and all buffers and state tables cleared.  The receiver
   MUST send a ""250 OK"" reply to a RSET command with no arguments.  A
   reset command may be issued by the client at any time.  It is
   effectively equivalent to a NOOP (i.e., it has no effect) if issued
   immediately after EHLO, before EHLO is issued in the session, after
   an end of data indicator has been sent and acknowledged, or
   immediately before a QUIT.  An SMTP server MUST NOT close the
   connection as the result of receiving a RSET; that action is reserved
   for QUIT (see Section 4.1.1.10).

   Since EHLO implies some additional processing and response by the
   server, RSET will normally be more efficient than reissuing that
   command, even though the formal semantics are the same.

   There are circumstances, contrary to the intent of this
   specification, in which an SMTP server may receive an indication that
   the underlying TCP connection has been closed or reset.  To preserve
   the robustness of the mail system, SMTP servers SHOULD be prepared
   for this condition and SHOULD treat it as if a QUIT had been received
   before the connection disappeared.

   Syntax:

      rset = ""RSET"" CRLF

4.1.1.6.  VERIFY (VRFY)

   This command asks the receiver to confirm that the argument
   identifies a user or mailbox.  If it is a user name, information is
   returned as specified in Section 3.5.

   This command has no effect on the reverse-path buffer, the forward-
   path buffer, or the mail data buffer.

   Syntax:

      vrfy = ""VRFY"" SP String CRLF










Klensin                     Standards Track                    [Page 38]

RFC 5321                          SMTP                      October 2008


4.1.1.7.  EXPAND (EXPN)

   This command asks the receiver to confirm that the argument
   identifies a mailing list, and if so, to return the membership of
   that list.  If the command is successful, a reply is returned
   containing information as described in Section 3.5.  This reply will
   have multiple lines except in the trivial case of a one-member list.

   This command has no effect on the reverse-path buffer, the forward-
   path buffer, or the mail data buffer, and it may be issued at any
   time.

   Syntax:

      expn = ""EXPN"" SP String CRLF

4.1.1.8.  HELP (HELP)

   This command causes the server to send helpful information to the
   client.  The command MAY take an argument (e.g., any command name)
   and return more specific information as a response.

   This command has no effect on the reverse-path buffer, the forward-
   path buffer, or the mail data buffer, and it may be issued at any
   time.

   SMTP servers SHOULD support HELP without arguments and MAY support it
   with arguments.

   Syntax:

      help = ""HELP"" [ SP String ] CRLF



















Klensin                     Standards Track                    [Page 39]

RFC 5321                          SMTP                      October 2008


4.1.1.9.  NOOP (NOOP)

   This command does not affect any parameters or previously entered
   commands.  It specifies no action other than that the receiver send a
   ""250 OK"" reply.

   This command has no effect on the reverse-path buffer, the forward-
   path buffer, or the mail data buffer, and it may be issued at any
   time.  If a parameter string is specified, servers SHOULD ignore it.

   Syntax:

      noop = ""NOOP"" [ SP String ] CRLF

4.1.1.10.  QUIT (QUIT)

   This command specifies that the receiver MUST send a ""221 OK"" reply,
   and then close the transmission channel.

   The receiver MUST NOT intentionally close the transmission channel
   until it receives and replies to a QUIT command (even if there was an
   error).  The sender MUST NOT intentionally close the transmission
   channel until it sends a QUIT command, and it SHOULD wait until it
   receives the reply (even if there was an error response to a previous
   command).  If the connection is closed prematurely due to violations
   of the above or system or network failure, the server MUST cancel any
   pending transaction, but not undo any previously completed
   transaction, and generally MUST act as if the command or transaction
   in progress had received a temporary error (i.e., a 4yz response).

   The QUIT command may be issued at any time.  Any current uncompleted
   mail transaction will be aborted.

   Syntax:

      quit = ""QUIT"" CRLF

4.1.1.11.  Mail-Parameter and Rcpt-Parameter Error Responses

   If the server SMTP does not recognize or cannot implement one or more
   of the parameters associated with a particular MAIL FROM or RCPT TO
   command, it will return code 555.

   If, for some reason, the server is temporarily unable to accommodate
   one or more of the parameters associated with a MAIL FROM or RCPT TO
   command, and if the definition of the specific parameter does not
   mandate the use of another code, it should return code 455.




Klensin                     Standards Track                    [Page 40]

RFC 5321                          SMTP                      October 2008


   Errors specific to particular parameters and their values will be
   specified in the parameter's defining RFC.

4.1.2.  Command Argument Syntax

   The syntax of the argument clauses of the above commands (using the
   syntax specified in RFC 5234 [7] where applicable) is given below.
   Some of the productions given below are used only in conjunction with
   source routes as described in Appendix C.  Terminals not defined in
   this document, such as ALPHA, DIGIT, SP, CR, LF, CRLF, are as defined
   in the ""core"" syntax in Section 6 of RFC 5234 [7] or in the message
   format syntax in RFC 5322 [4].

   Reverse-path   = Path / ""<>""

   Forward-path   = Path

   Path           = ""<"" [ A-d-l "":"" ] Mailbox "">""

   A-d-l          = At-domain *( "","" At-domain )
                  ; Note that this form, the so-called ""source
                  ; route"", MUST BE accepted, SHOULD NOT be
                  ; generated, and SHOULD be ignored.

   At-domain      = ""@"" Domain

   Mail-parameters  = esmtp-param *(SP esmtp-param)

   Rcpt-parameters  = esmtp-param *(SP esmtp-param)

   esmtp-param    = esmtp-keyword [""="" esmtp-value]

   esmtp-keyword  = (ALPHA / DIGIT) *(ALPHA / DIGIT / ""-"")

   esmtp-value    = 1*(%d33-60 / %d62-126)
                  ; any CHAR excluding ""="", SP, and control
                  ; characters.  If this string is an email address,
                  ; i.e., a Mailbox, then the ""xtext"" syntax [32]
                  ; SHOULD be used.

   Keyword        = Ldh-str

   Argument       = Atom

   Domain         = sub-domain *(""."" sub-domain)






Klensin                     Standards Track                    [Page 41]

RFC 5321                          SMTP                      October 2008


   sub-domain     = Let-dig [Ldh-str]

   Let-dig        = ALPHA / DIGIT

   Ldh-str        = *( ALPHA / DIGIT / ""-"" ) Let-dig

   address-literal  = ""["" ( IPv4-address-literal /
                    IPv6-address-literal /
                    General-address-literal ) ""]""
                    ; See Section 4.1.3

   Mailbox        = Local-part ""@"" ( Domain / address-literal )

   Local-part     = Dot-string / Quoted-string
                  ; MAY be case-sensitive


   Dot-string     = Atom *("".""  Atom)

   Atom           = 1*atext

   Quoted-string  = DQUOTE *QcontentSMTP DQUOTE

   QcontentSMTP   = qtextSMTP / quoted-pairSMTP

   quoted-pairSMTP  = %d92 %d32-126
                    ; i.e., backslash followed by any ASCII
                    ; graphic (including itself) or SPace

   qtextSMTP      = %d32-33 / %d35-91 / %d93-126
                  ; i.e., within a quoted string, any
                  ; ASCII graphic or space is permitted
                  ; without blackslash-quoting except
                  ; double-quote and the backslash itself.

   String         = Atom / Quoted-string

   While the above definition for Local-part is relatively permissive,
   for maximum interoperability, a host that expects to receive mail
   SHOULD avoid defining mailboxes where the Local-part requires (or
   uses) the Quoted-string form or where the Local-part is case-
   sensitive.  For any purposes that require generating or comparing
   Local-parts (e.g., to specific mailbox names), all quoted forms MUST
   be treated as equivalent, and the sending system SHOULD transmit the
   form that uses the minimum quoting possible.

   Systems MUST NOT define mailboxes in such a way as to require the use
   in SMTP of non-ASCII characters (octets with the high order bit set



Klensin                     Standards Track                    [Page 42]

RFC 5321                          SMTP                      October 2008


   to one) or ASCII ""control characters"" (decimal value 0-31 and 127).
   These characters MUST NOT be used in MAIL or RCPT commands or other
   commands that require mailbox names.

   Note that the backslash, ""\"", is a quote character, which is used to
   indicate that the next character is to be used literally (instead of
   its normal interpretation).  For example, ""Joe\,Smith"" indicates a
   single nine-character user name string with the comma being the
   fourth character of that string.

   To promote interoperability and consistent with long-standing
   guidance about conservative use of the DNS in naming and applications
   (e.g., see Section 2.3.1 of the base DNS document, RFC 1035 [2]),
   characters outside the set of alphabetic characters, digits, and
   hyphen MUST NOT appear in domain name labels for SMTP clients or
   servers.  In particular, the underscore character is not permitted.
   SMTP servers that receive a command in which invalid character codes
   have been employed, and for which there are no other reasons for
   rejection, MUST reject that command with a 501 response (this rule,
   like others, could be overridden by appropriate SMTP extensions).

4.1.3.  Address Literals

   Sometimes a host is not known to the domain name system and
   communication (and, in particular, communication to report and repair
   the error) is blocked.  To bypass this barrier, a special literal
   form of the address is allowed as an alternative to a domain name.
   For IPv4 addresses, this form uses four small decimal integers
   separated by dots and enclosed by brackets such as [123.255.37.2],
   which indicates an (IPv4) Internet Address in sequence-of-octets
   form.  For IPv6 and other forms of addressing that might eventually
   be standardized, the form consists of a standardized ""tag"" that
   identifies the address syntax, a colon, and the address itself, in a
   format specified as part of the relevant standards (i.e., RFC 4291
   [8] for IPv6).

   Specifically:

   IPv4-address-literal  = Snum 3("".""  Snum)

   IPv6-address-literal  = ""IPv6:"" IPv6-addr

   General-address-literal  = Standardized-tag "":"" 1*dcontent

   Standardized-tag  = Ldh-str
                     ; Standardized-tag MUST be specified in a
                     ; Standards-Track RFC and registered with IANA




Klensin                     Standards Track                    [Page 43]

RFC 5321                          SMTP                      October 2008


   dcontent       = %d33-90 / ; Printable US-ASCII
                  %d94-126 ; excl. ""["", ""\"", ""]""

   Snum           = 1*3DIGIT
                  ; representing a decimal integer
                  ; value in the range 0 through 255

   IPv6-addr      = IPv6-full / IPv6-comp / IPv6v4-full / IPv6v4-comp

   IPv6-hex       = 1*4HEXDIG

   IPv6-full      = IPv6-hex 7("":"" IPv6-hex)

   IPv6-comp      = [IPv6-hex *5("":"" IPv6-hex)] ""::""
                  [IPv6-hex *5("":"" IPv6-hex)]
                  ; The ""::"" represents at least 2 16-bit groups of
                  ; zeros.  No more than 6 groups in addition to the
                  ; ""::"" may be present.

   IPv6v4-full    = IPv6-hex 5("":"" IPv6-hex) "":"" IPv4-address-literal

   IPv6v4-comp    = [IPv6-hex *3("":"" IPv6-hex)] ""::""
                  [IPv6-hex *3("":"" IPv6-hex) "":""]
                  IPv4-address-literal
                  ; The ""::"" represents at least 2 16-bit groups of
                  ; zeros.  No more than 4 groups in addition to the
                  ; ""::"" and IPv4-address-literal may be present.

4.1.4.  Order of Commands

   There are restrictions on the order in which these commands may be
   used.

   A session that will contain mail transactions MUST first be
   initialized by the use of the EHLO command.  An SMTP server SHOULD
   accept commands for non-mail transactions (e.g., VRFY or EXPN)
   without this initialization.

   An EHLO command MAY be issued by a client later in the session.  If
   it is issued after the session begins and the EHLO command is
   acceptable to the SMTP server, the SMTP server MUST clear all buffers
   and reset the state exactly as if a RSET command had been issued.  In
   other words, the sequence of RSET followed immediately by EHLO is
   redundant, but not harmful other than in the performance cost of
   executing unnecessary commands.

   If the EHLO command is not acceptable to the SMTP server, 501, 500,
   502, or 550 failure replies MUST be returned as appropriate.  The



Klensin                     Standards Track                    [Page 44]

RFC 5321                          SMTP                      October 2008


   SMTP server MUST stay in the same state after transmitting these
   replies that it was in before the EHLO was received.

   The SMTP client MUST, if possible, ensure that the domain parameter
   to the EHLO command is a primary host name as specified for this
   command in Section 2.3.5.  If this is not possible (e.g., when the
   client's address is dynamically assigned and the client does not have
   an obvious name), an address literal SHOULD be substituted for the
   domain name.

   An SMTP server MAY verify that the domain name argument in the EHLO
   command actually corresponds to the IP address of the client.
   However, if the verification fails, the server MUST NOT refuse to
   accept a message on that basis.  Information captured in the
   verification attempt is for logging and tracing purposes.  Note that
   this prohibition applies to the matching of the parameter to its IP
   address only; see Section 7.9 for a more extensive discussion of
   rejecting incoming connections or mail messages.

   The NOOP, HELP, EXPN, VRFY, and RSET commands can be used at any time
   during a session, or without previously initializing a session.  SMTP
   servers SHOULD process these normally (that is, not return a 503
   code) even if no EHLO command has yet been received; clients SHOULD
   open a session with EHLO before sending these commands.

   If these rules are followed, the example in RFC 821 that shows ""550
   access denied to you"" in response to an EXPN command is incorrect
   unless an EHLO command precedes the EXPN or the denial of access is
   based on the client's IP address or other authentication or
   authorization-determining mechanisms.

   The MAIL command (or the obsolete SEND, SOML, or SAML commands)
   begins a mail transaction.  Once started, a mail transaction consists
   of a transaction beginning command, one or more RCPT commands, and a
   DATA command, in that order.  A mail transaction may be aborted by
   the RSET, a new EHLO, or the QUIT command.  There may be zero or more
   transactions in a session.  MAIL (or SEND, SOML, or SAML) MUST NOT be
   sent if a mail transaction is already open, i.e., it should be sent
   only if no mail transaction had been started in the session, or if
   the previous one successfully concluded with a successful DATA
   command, or if the previous one was aborted, e.g., with a RSET or new
   EHLO.

   If the transaction beginning command argument is not acceptable, a
   501 failure reply MUST be returned and the SMTP server MUST stay in
   the same state.  If the commands in a transaction are out of order to
   the degree that they cannot be processed by the server, a 503 failure




Klensin                     Standards Track                    [Page 45]

RFC 5321                          SMTP                      October 2008


   reply MUST be returned and the SMTP server MUST stay in the same
   state.

   The last command in a session MUST be the QUIT command.  The QUIT
   command SHOULD be used by the client SMTP to request connection
   closure, even when no session opening command was sent and accepted.

4.1.5.  Private-Use Commands

   As specified in Section 2.2.2, commands starting in ""X"" may be used
   by bilateral agreement between the client (sending) and server
   (receiving) SMTP agents.  An SMTP server that does not recognize such
   a command is expected to reply with ""500 Command not recognized"".  An
   extended SMTP server MAY list the feature names associated with these
   private commands in the response to the EHLO command.

   Commands sent or accepted by SMTP systems that do not start with ""X""
   MUST conform to the requirements of Section 2.2.2.

4.2.  SMTP Replies

   Replies to SMTP commands serve to ensure the synchronization of
   requests and actions in the process of mail transfer and to guarantee
   that the SMTP client always knows the state of the SMTP server.
   Every command MUST generate exactly one reply.

   The details of the command-reply sequence are described in
   Section 4.3.

   An SMTP reply consists of a three digit number (transmitted as three
   numeric characters) followed by some text unless specified otherwise
   in this document.  The number is for use by automata to determine
   what state to enter next; the text is for the human user.  The three
   digits contain enough encoded information that the SMTP client need
   not examine the text and may either discard it or pass it on to the
   user, as appropriate.  Exceptions are as noted elsewhere in this
   document.  In particular, the 220, 221, 251, 421, and 551 reply codes
   are associated with message text that must be parsed and interpreted
   by machines.  In the general case, the text may be receiver dependent
   and context dependent, so there are likely to be varying texts for
   each reply code.  A discussion of the theory of reply codes is given
   in Section 4.2.1.  Formally, a reply is defined to be the sequence: a
   three-digit code, <SP>, one line of text, and <CRLF>, or a multiline
   reply (as defined in the same section).  Since, in violation of this
   specification, the text is sometimes not sent, clients that do not
   receive it SHOULD be prepared to process the code alone (with or
   without a trailing space character).  Only the EHLO, EXPN, and HELP
   commands are expected to result in multiline replies in normal



Klensin                     Standards Track                    [Page 46]

RFC 5321                          SMTP                      October 2008


   circumstances; however, multiline replies are allowed for any
   command.

   In ABNF, server responses are:

   Greeting       = ( ""220 "" (Domain / address-literal)
                  [ SP textstring ] CRLF ) /
                  ( ""220-"" (Domain / address-literal)
                  [ SP textstring ] CRLF
                  *( ""220-"" [ textstring ] CRLF )
                  ""220"" [ SP textstring ] CRLF )

   textstring     = 1*(%d09 / %d32-126) ; HT, SP, Printable US-ASCII

   Reply-line     = *( Reply-code ""-"" [ textstring ] CRLF )
                  Reply-code [ SP textstring ] CRLF

   Reply-code     = %x32-35 %x30-35 %x30-39

   where ""Greeting"" appears only in the 220 response that announces that
   the server is opening its part of the connection.  (Other possible
   server responses upon connection follow the syntax of Reply-line.)

   An SMTP server SHOULD send only the reply codes listed in this
   document.  An SMTP server SHOULD use the text shown in the examples
   whenever appropriate.

   An SMTP client MUST determine its actions only by the reply code, not
   by the text (except for the ""change of address"" 251 and 551 and, if
   necessary, 220, 221, and 421 replies); in the general case, any text,
   including no text at all (although senders SHOULD NOT send bare
   codes), MUST be acceptable.  The space (blank) following the reply
   code is considered part of the text.  Whenever possible, a receiver-
   SMTP SHOULD test the first digit (severity indication) of the reply
   code.

   The list of codes that appears below MUST NOT be construed as
   permanent.  While the addition of new codes should be a rare and
   significant activity, with supplemental information in the textual
   part of the response being preferred, new codes may be added as the
   result of new Standards or Standards-Track specifications.
   Consequently, a sender-SMTP MUST be prepared to handle codes not
   specified in this document and MUST do so by interpreting the first
   digit only.

   In the absence of extensions negotiated with the client, SMTP servers
   MUST NOT send reply codes whose first digits are other than 2, 3, 4,




Klensin                     Standards Track                    [Page 47]

RFC 5321                          SMTP                      October 2008


   or 5.  Clients that receive such out-of-range codes SHOULD normally
   treat them as fatal errors and terminate the mail transaction.

4.2.1.  Reply Code Severities and Theory

   The three digits of the reply each have a special significance.  The
   first digit denotes whether the response is good, bad, or incomplete.
   An unsophisticated SMTP client, or one that receives an unexpected
   code, will be able to determine its next action (proceed as planned,
   redo, retrench, etc.) by examining this first digit.  An SMTP client
   that wants to know approximately what kind of error occurred (e.g.,
   mail system error, command syntax error) may examine the second
   digit.  The third digit and any supplemental information that may be
   present is reserved for the finest gradation of information.

   There are four values for the first digit of the reply code:

   2yz  Positive Completion reply
      The requested action has been successfully completed.  A new
      request may be initiated.

   3yz  Positive Intermediate reply
      The command has been accepted, but the requested action is being
      held in abeyance, pending receipt of further information.  The
      SMTP client should send another command specifying this
      information.  This reply is used in command sequence groups (i.e.,
      in DATA).

   4yz  Transient Negative Completion reply
      The command was not accepted, and the requested action did not
      occur.  However, the error condition is temporary, and the action
      may be requested again.  The sender should return to the beginning
      of the command sequence (if any).  It is difficult to assign a
      meaning to ""transient"" when two different sites (receiver- and
      sender-SMTP agents) must agree on the interpretation.  Each reply
      in this category might have a different time value, but the SMTP
      client SHOULD try again.  A rule of thumb to determine whether a
      reply fits into the 4yz or the 5yz category (see below) is that
      replies are 4yz if they can be successful if repeated without any
      change in command form or in properties of the sender or receiver
      (that is, the command is repeated identically and the receiver
      does not put up a new implementation).

   5yz  Permanent Negative Completion reply
      The command was not accepted and the requested action did not
      occur.  The SMTP client SHOULD NOT repeat the exact request (in
      the same sequence).  Even some ""permanent"" error conditions can be
      corrected, so the human user may want to direct the SMTP client to



Klensin                     Standards Track                    [Page 48]

RFC 5321                          SMTP                      October 2008


      reinitiate the command sequence by direct action at some point in
      the future (e.g., after the spelling has been changed, or the user
      has altered the account status).

   It is worth noting that the file transfer protocol (FTP) [34] uses a
   very similar code architecture and that the SMTP codes are based on
   the FTP model.  However, SMTP uses a one-command, one-response model
   (while FTP is asynchronous) and FTP's 1yz codes are not part of the
   SMTP model.

   The second digit encodes responses in specific categories:

   x0z  Syntax: These replies refer to syntax errors, syntactically
      correct commands that do not fit any functional category, and
      unimplemented or superfluous commands.

   x1z  Information: These are replies to requests for information, such
      as status or help.

   x2z  Connections: These are replies referring to the transmission
      channel.

   x3z  Unspecified.

   x4z  Unspecified.

   x5z  Mail system: These replies indicate the status of the receiver
      mail system vis-a-vis the requested transfer or other mail system
      action.

   The third digit gives a finer gradation of meaning in each category
   specified by the second digit.  The list of replies illustrates this.
   Each reply text is recommended rather than mandatory, and may even
   change according to the command with which it is associated.  On the
   other hand, the reply codes must strictly follow the specifications
   in this section.  Receiver implementations should not invent new
   codes for slightly different situations from the ones described here,
   but rather adapt codes already defined.

   For example, a command such as NOOP, whose successful execution does
   not offer the SMTP client any new information, will return a 250
   reply.  The reply is 502 when the command requests an unimplemented
   non-site-specific action.  A refinement of that is the 504 reply for
   a command that is implemented, but that requests an unimplemented
   parameter.






Klensin                     Standards Track                    [Page 49]

RFC 5321                          SMTP                      October 2008


   The reply text may be longer than a single line; in these cases the
   complete text must be marked so the SMTP client knows when it can
   stop reading the reply.  This requires a special format to indicate a
   multiple line reply.

   The format for multiline replies requires that every line, except the
   last, begin with the reply code, followed immediately by a hyphen,
   ""-"" (also known as minus), followed by text.  The last line will
   begin with the reply code, followed immediately by <SP>, optionally
   some text, and <CRLF>.  As noted above, servers SHOULD send the <SP>
   if subsequent text is not sent, but clients MUST be prepared for it
   to be omitted.

   For example:

      250-First line
      250-Second line
      250-234 Text beginning with numbers
      250 The last line

   In a multiline reply, the reply code on each of the lines MUST be the
   same.  It is reasonable for the client to rely on this, so it can
   make processing decisions based on the code in any line, assuming
   that all others will be the same.  In a few cases, there is important
   data for the client in the reply ""text"".  The client will be able to
   identify these cases from the current context.

4.2.2.  Reply Codes by Function Groups

   500  Syntax error, command unrecognized (This may include errors such
      as command line too long)

   501  Syntax error in parameters or arguments

   502  Command not implemented (see Section 4.2.4)

   503  Bad sequence of commands

   504  Command parameter not implemented


   211  System status, or system help reply

   214  Help message (Information on how to use the receiver or the
      meaning of a particular non-standard command; this reply is useful
      only to the human user)





Klensin                     Standards Track                    [Page 50]

RFC 5321                          SMTP                      October 2008


   220  <domain> Service ready

   221  <domain> Service closing transmission channel

   421  <domain> Service not available, closing transmission channel
      (This may be a reply to any command if the service knows it must
      shut down)


   250  Requested mail action okay, completed

   251  User not local; will forward to <forward-path> (See Section 3.4)

   252  Cannot VRFY user, but will accept message and attempt delivery
      (See Section 3.5.3)

   455  Server unable to accommodate parameters

   555  MAIL FROM/RCPT TO parameters not recognized or not implemented

   450  Requested mail action not taken: mailbox unavailable (e.g.,
      mailbox busy or temporarily blocked for policy reasons)

   550  Requested action not taken: mailbox unavailable (e.g., mailbox
      not found, no access, or command rejected for policy reasons)

   451  Requested action aborted: error in processing

   551  User not local; please try <forward-path> (See Section 3.4)

   452  Requested action not taken: insufficient system storage

   552  Requested mail action aborted: exceeded storage allocation

   553  Requested action not taken: mailbox name not allowed (e.g.,
      mailbox syntax incorrect)

   354  Start mail input; end with <CRLF>.<CRLF>

   554  Transaction failed (Or, in the case of a connection-opening
      response, ""No SMTP service here"")










Klensin                     Standards Track                    [Page 51]

RFC 5321                          SMTP                      October 2008


4.2.3.  Reply Codes in Numeric Order

   211  System status, or system help reply

   214  Help message (Information on how to use the receiver or the
      meaning of a particular non-standard command; this reply is useful
      only to the human user)

   220  <domain> Service ready

   221  <domain> Service closing transmission channel

   250  Requested mail action okay, completed

   251  User not local; will forward to <forward-path> (See Section 3.4)

   252  Cannot VRFY user, but will accept message and attempt delivery
      (See Section 3.5.3)

   354  Start mail input; end with <CRLF>.<CRLF>

   421  <domain> Service not available, closing transmission channel
      (This may be a reply to any command if the service knows it must
      shut down)

   450  Requested mail action not taken: mailbox unavailable (e.g.,
      mailbox busy or temporarily blocked for policy reasons)

   451  Requested action aborted: local error in processing

   452  Requested action not taken: insufficient system storage

   455  Server unable to accommodate parameters

   500  Syntax error, command unrecognized (This may include errors such
      as command line too long)

   501  Syntax error in parameters or arguments

   502  Command not implemented (see Section 4.2.4)

   503  Bad sequence of commands

   504  Command parameter not implemented

   550  Requested action not taken: mailbox unavailable (e.g., mailbox
      not found, no access, or command rejected for policy reasons)




Klensin                     Standards Track                    [Page 52]

RFC 5321                          SMTP                      October 2008


   551  User not local; please try <forward-path> (See Section 3.4)

   552  Requested mail action aborted: exceeded storage allocation

   553  Requested action not taken: mailbox name not allowed (e.g.,
      mailbox syntax incorrect)

   554  Transaction failed (Or, in the case of a connection-opening
      response, ""No SMTP service here"")

   555  MAIL FROM/RCPT TO parameters not recognized or not implemented

4.2.4.  Reply Code 502

   Questions have been raised as to when reply code 502 (Command not
   implemented) SHOULD be returned in preference to other codes. 502
   SHOULD be used when the command is actually recognized by the SMTP
   server, but not implemented.  If the command is not recognized, code
   500 SHOULD be returned.  Extended SMTP systems MUST NOT list
   capabilities in response to EHLO for which they will return 502 (or
   500) replies.

4.2.5.  Reply Codes after DATA and the Subsequent <CRLF>.<CRLF>

   When an SMTP server returns a positive completion status (2yz code)
   after the DATA command is completed with <CRLF>.<CRLF>, it accepts
   responsibility for:

   o  delivering the message (if the recipient mailbox exists), or

   o  if attempts to deliver the message fail due to transient
      conditions, retrying delivery some reasonable number of times at
      intervals as specified in Section 4.5.4.

   o  if attempts to deliver the message fail due to permanent
      conditions, or if repeated attempts to deliver the message fail
      due to transient conditions, returning appropriate notification to
      the sender of the original message (using the address in the SMTP
      MAIL command).

   When an SMTP server returns a temporary error status (4yz) code after
   the DATA command is completed with <CRLF>.<CRLF>, it MUST NOT make a
   subsequent attempt to deliver that message.  The SMTP client retains
   responsibility for the delivery of that message and may either return
   it to the user or requeue it for a subsequent attempt (see
   Section 4.5.4.1).





Klensin                     Standards Track                    [Page 53]

RFC 5321                          SMTP                      October 2008


   The user who originated the message SHOULD be able to interpret the
   return of a transient failure status (by mail message or otherwise)
   as a non-delivery indication, just as a permanent failure would be
   interpreted.  If the client SMTP successfully handles these
   conditions, the user will not receive such a reply.

   When an SMTP server returns a permanent error status (5yz) code after
   the DATA command is completed with <CRLF>.<CRLF>, it MUST NOT make
   any subsequent attempt to deliver the message.  As with temporary
   error status codes, the SMTP client retains responsibility for the
   message, but SHOULD not again attempt delivery to the same server
   without user review of the message and response and appropriate
   intervention.

4.3.  Sequencing of Commands and Replies

4.3.1.  Sequencing Overview

   The communication between the sender and receiver is an alternating
   dialogue, controlled by the sender.  As such, the sender issues a
   command and the receiver responds with a reply.  Unless other
   arrangements are negotiated through service extensions, the sender
   MUST wait for this response before sending further commands.  One
   important reply is the connection greeting.  Normally, a receiver
   will send a 220 ""Service ready"" reply when the connection is
   completed.  The sender SHOULD wait for this greeting message before
   sending any commands.

   Note: all the greeting-type replies have the official name (the
   fully-qualified primary domain name) of the server host as the first
   word following the reply code.  Sometimes the host will have no
   meaningful name.  See Section 4.1.3 for a discussion of alternatives
   in these situations.

   For example,

      220 ISIF.USC.EDU Service ready

   or

      220 mail.example.com SuperSMTP v 6.1.2 Service ready

   or

      220 [10.0.0.1] Clueless host service ready

   The table below lists alternative success and failure replies for
   each command.  These SHOULD be strictly adhered to.  A receiver MAY



Klensin                     Standards Track                    [Page 54]

RFC 5321                          SMTP                      October 2008


   substitute text in the replies, but the meanings and actions implied
   by the code numbers and by the specific command reply sequence MUST
   be preserved.

4.3.2.  Command-Reply Sequences

   Each command is listed with its usual possible replies.  The prefixes
   used before the possible replies are ""I"" for intermediate, ""S"" for
   success, and ""E"" for error.  Since some servers may generate other
   replies under special circumstances, and to allow for future
   extension, SMTP clients SHOULD, when possible, interpret only the
   first digit of the reply and MUST be prepared to deal with
   unrecognized reply codes by interpreting the first digit only.
   Unless extended using the mechanisms described in Section 2.2, SMTP
   servers MUST NOT transmit reply codes to an SMTP client that are
   other than three digits or that do not start in a digit between 2 and
   5 inclusive.

   These sequencing rules and, in principle, the codes themselves, can
   be extended or modified by SMTP extensions offered by the server and
   accepted (requested) by the client.  However, if the target is more
   precise granularity in the codes, rather than codes for completely
   new purposes, the system described in RFC 3463 [25] SHOULD be used in
   preference to the invention of new codes.

   In addition to the codes listed below, any SMTP command can return
   any of the following codes if the corresponding unusual circumstances
   are encountered:

   500  For the ""command line too long"" case or if the command name was
      not recognized.  Note that producing a ""command not recognized""
      error in response to the required subset of these commands is a
      violation of this specification.  Similarly, producing a ""command
      too long"" message for a command line shorter than 512 characters
      would violate the provisions of Section 4.5.3.1.4.

   501  Syntax error in command or arguments.  In order to provide for
      future extensions, commands that are specified in this document as
      not accepting arguments (DATA, RSET, QUIT) SHOULD return a 501
      message if arguments are supplied in the absence of EHLO-
      advertised extensions.

   421  Service shutting down and closing transmission channel








Klensin                     Standards Track                    [Page 55]

RFC 5321                          SMTP                      October 2008


   Specific sequences are:

      CONNECTION ESTABLISHMENT

         S: 220
         E: 554

      EHLO or HELO

         S: 250
         E: 504 (a conforming implementation could return this code only
         in fairly obscure cases), 550, 502 (permitted only with an old-
         style server that does not support EHLO)

      MAIL

         S: 250
         E: 552, 451, 452, 550, 553, 503, 455, 555

      RCPT

         S: 250, 251 (but see Section 3.4 for discussion of 251 and 551)
         E: 550, 551, 552, 553, 450, 451, 452, 503, 455, 555

      DATA

         I: 354 -> data -> S: 250

                           E: 552, 554, 451, 452

                           E: 450, 550 (rejections for policy reasons)

         E: 503, 554

      RSET

         S: 250

      VRFY

         S: 250, 251, 252
         E: 550, 551, 553, 502, 504

      EXPN

         S: 250, 252
         E: 550, 500, 502, 504




Klensin                     Standards Track                    [Page 56]

RFC 5321                          SMTP                      October 2008


      HELP

         S: 211, 214
         E: 502, 504

      NOOP

         S: 250

      QUIT

         S: 221

4.4.  Trace Information

   When an SMTP server receives a message for delivery or further
   processing, it MUST insert trace (""time stamp"" or ""Received"")
   information at the beginning of the message content, as discussed in
   Section 4.1.1.4.

   This line MUST be structured as follows:

   o  The FROM clause, which MUST be supplied in an SMTP environment,
      SHOULD contain both (1) the name of the source host as presented
      in the EHLO command and (2) an address literal containing the IP
      address of the source, determined from the TCP connection.

   o  The ID clause MAY contain an ""@"" as suggested in RFC 822, but this
      is not required.

   o  If the FOR clause appears, it MUST contain exactly one <path>
      entry, even when multiple RCPT commands have been given.  Multiple
      <path>s raise some security issues and have been deprecated, see
      Section 7.2.

   An Internet mail program MUST NOT change or delete a Received: line
   that was previously added to the message header section.  SMTP
   servers MUST prepend Received lines to messages; they MUST NOT change
   the order of existing lines or insert Received lines in any other
   location.

   As the Internet grows, comparability of Received header fields is
   important for detecting problems, especially slow relays.  SMTP
   servers that create Received header fields SHOULD use explicit
   offsets in the dates (e.g., -0800), rather than time zone names of
   any type.  Local time (with an offset) SHOULD be used rather than UT
   when feasible.  This formulation allows slightly more information
   about local circumstances to be specified.  If UT is needed, the



Klensin                     Standards Track                    [Page 57]

RFC 5321                          SMTP                      October 2008


   receiver need merely do some simple arithmetic to convert the values.
   Use of UT loses information about the time zone-location of the
   server.  If it is desired to supply a time zone name, it SHOULD be
   included in a comment.

   When the delivery SMTP server makes the ""final delivery"" of a
   message, it inserts a return-path line at the beginning of the mail
   data.  This use of return-path is required; mail systems MUST support
   it.  The return-path line preserves the information in the <reverse-
   path> from the MAIL command.  Here, final delivery means the message
   has left the SMTP environment.  Normally, this would mean it had been
   delivered to the destination user or an associated mail drop, but in
   some cases it may be further processed and transmitted by another
   mail system.

   It is possible for the mailbox in the return path to be different
   from the actual sender's mailbox, for example, if error responses are
   to be delivered to a special error handling mailbox rather than to
   the message sender.  When mailing lists are involved, this
   arrangement is common and useful as a means of directing errors to
   the list maintainer rather than the message originator.

   The text above implies that the final mail data will begin with a
   return path line, followed by one or more time stamp lines.  These
   lines will be followed by the rest of the mail data: first the
   balance of the mail header section and then the body (RFC 5322 [4]).

   It is sometimes difficult for an SMTP server to determine whether or
   not it is making final delivery since forwarding or other operations
   may occur after the message is accepted for delivery.  Consequently,
   any further (forwarding, gateway, or relay) systems MAY remove the
   return path and rebuild the MAIL command as needed to ensure that
   exactly one such line appears in a delivered message.

   A message-originating SMTP system SHOULD NOT send a message that
   already contains a Return-path header field.  SMTP servers performing
   a relay function MUST NOT inspect the message data, and especially
   not to the extent needed to determine if Return-path header fields
   are present.  SMTP servers making final delivery MAY remove Return-
   path header fields before adding their own.

   The primary purpose of the Return-path is to designate the address to
   which messages indicating non-delivery or other mail system failures
   are to be sent.  For this to be unambiguous, exactly one return path
   SHOULD be present when the message is delivered.  Systems using RFC
   822 syntax with non-SMTP transports SHOULD designate an unambiguous
   address, associated with the transport envelope, to which error
   reports (e.g., non-delivery messages) should be sent.



Klensin                     Standards Track                    [Page 58]

RFC 5321                          SMTP                      October 2008


   Historical note: Text in RFC 822 that appears to contradict the use
   of the Return-path header field (or the envelope reverse-path address
   from the MAIL command) as the destination for error messages is not
   applicable on the Internet.  The reverse-path address (as copied into
   the Return-path) MUST be used as the target of any mail containing
   delivery error messages.

   In particular:
   o  a gateway from SMTP -> elsewhere SHOULD insert a return-path
      header field, unless it is known that the ""elsewhere"" transport
      also uses Internet domain addresses and maintains the envelope
      sender address separately.

   o  a gateway from elsewhere -> SMTP SHOULD delete any return-path
      header field present in the message, and either copy that
      information to the SMTP envelope or combine it with information
      present in the envelope of the other transport system to construct
      the reverse-path argument to the MAIL command in the SMTP
      envelope.

   The server must give special treatment to cases in which the
   processing following the end of mail data indication is only
   partially successful.  This could happen if, after accepting several
   recipients and the mail data, the SMTP server finds that the mail
   data could be successfully delivered to some, but not all, of the
   recipients.  In such cases, the response to the DATA command MUST be
   an OK reply.  However, the SMTP server MUST compose and send an
   ""undeliverable mail"" notification message to the originator of the
   message.

   A single notification listing all of the failed recipients or
   separate notification messages MUST be sent for each failed
   recipient.  For economy of processing by the sender, the former
   SHOULD be used when possible.  Note that the key difference between
   handling aliases (Section 3.9.1) and forwarding (this subsection) is
   the change to the backward-pointing address in this case.  All
   notification messages about undeliverable mail MUST be sent using the
   MAIL command (even if they result from processing the obsolete SEND,
   SOML, or SAML commands) and MUST use a null return path as discussed
   in Section 3.6.

   The time stamp line and the return path line are formally defined as
   follows (the definitions for ""FWS"" and ""CFWS"" appear in RFC 5322
   [4]):

   Return-path-line  = ""Return-Path:"" FWS Reverse-path <CRLF>

   Time-stamp-line  = ""Received:"" FWS Stamp <CRLF>



Klensin                     Standards Track                    [Page 59]

RFC 5321                          SMTP                      October 2008


   Stamp          = From-domain By-domain Opt-info [CFWS] "";""
                  FWS date-time
                  ; where ""date-time"" is as defined in RFC 5322 [4]
                  ; but the ""obs-"" forms, especially two-digit
                  ; years, are prohibited in SMTP and MUST NOT be used.

   From-domain    = ""FROM"" FWS Extended-Domain

   By-domain      = CFWS ""BY"" FWS Extended-Domain

   Extended-Domain  = Domain /
                    ( Domain FWS ""("" TCP-info "")"" ) /
                    ( address-literal FWS ""("" TCP-info "")"" )

   TCP-info       = address-literal / ( Domain FWS address-literal )
                  ; Information derived by server from TCP connection
                  ; not client EHLO.

   Opt-info       = [Via] [With] [ID] [For]
                  [Additional-Registered-Clauses]

   Via            = CFWS ""VIA"" FWS Link

   With           = CFWS ""WITH"" FWS Protocol

   ID             = CFWS ""ID"" FWS ( Atom / msg-id )
                  ; msg-id is defined in RFC 5322 [4]

   For            = CFWS ""FOR"" FWS ( Path / Mailbox )

   Additional-Registered-Clauses  = CFWS Atom FWS String
                                  ; Additional standard clauses may be
                                  added in this
                                  ; location by future standards and
                                  registration with
                                  ; IANA.  SMTP servers SHOULD NOT use
                                  unregistered
                                  ; names.  See Section 8.

   Link           = ""TCP"" / Addtl-Link

   Addtl-Link     = Atom
                  ; Additional standard names for links are
                  ; registered with the Internet Assigned Numbers
                  ; Authority (IANA).  ""Via"" is primarily of value
                  ; with non-Internet transports.  SMTP servers
                  ; SHOULD NOT use unregistered names.




Klensin                     Standards Track                    [Page 60]

RFC 5321                          SMTP                      October 2008


   Protocol       = ""ESMTP"" / ""SMTP"" / Attdl-Protocol

   Attdl-Protocol = Atom
                  ; Additional standard names for protocols are
                  ; registered with the Internet Assigned Numbers
                  ; Authority (IANA) in the ""mail parameters""
                  ; registry [9].  SMTP servers SHOULD NOT
                  ; use unregistered names.

4.5.  Additional Implementation Issues

4.5.1.  Minimum Implementation

   In order to make SMTP workable, the following minimum implementation
   MUST be provided by all receivers.  The following commands MUST be
   supported to conform to this specification:

      EHLO
      HELO
      MAIL
      RCPT
      DATA
      RSET
      NOOP
      QUIT
      VRFY

   Any system that includes an SMTP server supporting mail relaying or
   delivery MUST support the reserved mailbox ""postmaster"" as a case-
   insensitive local name.  This postmaster address is not strictly
   necessary if the server always returns 554 on connection opening (as
   described in Section 3.1).  The requirement to accept mail for
   postmaster implies that RCPT commands that specify a mailbox for
   postmaster at any of the domains for which the SMTP server provides
   mail service, as well as the special case of ""RCPT TO:<Postmaster>""
   (with no domain specification), MUST be supported.

   SMTP systems are expected to make every reasonable effort to accept
   mail directed to Postmaster from any other system on the Internet.
   In extreme cases -- such as to contain a denial of service attack or
   other breach of security -- an SMTP server may block mail directed to
   Postmaster.  However, such arrangements SHOULD be narrowly tailored
   so as to avoid blocking messages that are not part of such attacks.








Klensin                     Standards Track                    [Page 61]

RFC 5321                          SMTP                      October 2008


4.5.2.  Transparency

   Without some provision for data transparency, the character sequence
   ""<CRLF>.<CRLF>"" ends the mail text and cannot be sent by the user.
   In general, users are not aware of such ""forbidden"" sequences.  To
   allow all user composed text to be transmitted transparently, the
   following procedures are used:

   o  Before sending a line of mail text, the SMTP client checks the
      first character of the line.  If it is a period, one additional
      period is inserted at the beginning of the line.

   o  When a line of mail text is received by the SMTP server, it checks
      the line.  If the line is composed of a single period, it is
      treated as the end of mail indicator.  If the first character is a
      period and there are other characters on the line, the first
      character is deleted.

   The mail data may contain any of the 128 ASCII characters.  All
   characters are to be delivered to the recipient's mailbox, including
   spaces, vertical and horizontal tabs, and other control characters.
   If the transmission channel provides an 8-bit byte (octet) data
   stream, the 7-bit ASCII codes are transmitted, right justified, in
   the octets, with the high-order bits cleared to zero.  See
   Section 3.6 for special treatment of these conditions in SMTP systems
   serving a relay function.

   In some systems, it may be necessary to transform the data as it is
   received and stored.  This may be necessary for hosts that use a
   different character set than ASCII as their local character set, that
   store data in records rather than strings, or which use special
   character sequences as delimiters inside mailboxes.  If such
   transformations are necessary, they MUST be reversible, especially if
   they are applied to mail being relayed.

4.5.3.  Sizes and Timeouts

4.5.3.1.  Size Limits and Minimums

   There are several objects that have required minimum/maximum sizes.
   Every implementation MUST be able to receive objects of at least
   these sizes.  Objects larger than these sizes SHOULD be avoided when
   possible.  However, some Internet mail constructs such as encoded
   X.400 addresses (RFC 2156 [35]) will often require larger objects.
   Clients MAY attempt to transmit these, but MUST be prepared for a
   server to reject them if they cannot be handled by it.  To the
   maximum extent possible, implementation techniques that impose no
   limits on the length of these objects should be used.



Klensin                     Standards Track                    [Page 62]

RFC 5321                          SMTP                      October 2008


   Extensions to SMTP may involve the use of characters that occupy more
   than a single octet each.  This section therefore specifies lengths
   in octets where absolute lengths, rather than character counts, are
   intended.

4.5.3.1.1.  Local-part

   The maximum total length of a user name or other local-part is 64
   octets.

4.5.3.1.2.  Domain

   The maximum total length of a domain name or number is 255 octets.

4.5.3.1.3.  Path

   The maximum total length of a reverse-path or forward-path is 256
   octets (including the punctuation and element separators).

4.5.3.1.4.  Command Line

   The maximum total length of a command line including the command word
   and the <CRLF> is 512 octets.  SMTP extensions may be used to
   increase this limit.

4.5.3.1.5.  Reply Line

   The maximum total length of a reply line including the reply code and
   the <CRLF> is 512 octets.  More information may be conveyed through
   multiple-line replies.

4.5.3.1.6.  Text Line

   The maximum total length of a text line including the <CRLF> is 1000
   octets (not counting the leading dot duplicated for transparency).
   This number may be increased by the use of SMTP Service Extensions.

4.5.3.1.7.  Message Content

   The maximum total length of a message content (including any message
   header section as well as the message body) MUST BE at least 64K
   octets.  Since the introduction of Internet Standards for multimedia
   mail (RFC 2045 [21]), message lengths on the Internet have grown
   dramatically, and message size restrictions should be avoided if at
   all possible.  SMTP server systems that must impose restrictions
   SHOULD implement the ""SIZE"" service extension of RFC 1870 [10], and
   SMTP client systems that will send large messages SHOULD utilize it
   when possible.



Klensin                     Standards Track                    [Page 63]

RFC 5321                          SMTP                      October 2008


4.5.3.1.8.  Recipients Buffer

   The minimum total number of recipients that MUST be buffered is 100
   recipients.  Rejection of messages (for excessive recipients) with
   fewer than 100 RCPT commands is a violation of this specification.
   The general principle that relaying SMTP server MUST NOT, and
   delivery SMTP servers SHOULD NOT, perform validation tests on message
   header fields suggests that messages SHOULD NOT be rejected based on
   the total number of recipients shown in header fields.  A server that
   imposes a limit on the number of recipients MUST behave in an orderly
   fashion, such as rejecting additional addresses over its limit rather
   than silently discarding addresses previously accepted.  A client
   that needs to deliver a message containing over 100 RCPT commands
   SHOULD be prepared to transmit in 100-recipient ""chunks"" if the
   server declines to accept more than 100 recipients in a single
   message.

4.5.3.1.9.  Treatment When Limits Exceeded

   Errors due to exceeding these limits may be reported by using the
   reply codes.  Some examples of reply codes are:

      500 Line too long.

   or

      501 Path too long

   or

      452 Too many recipients (see below)

   or

      552 Too much mail data.

4.5.3.1.10.  Too Many Recipients Code

   RFC 821 [1] incorrectly listed the error where an SMTP server
   exhausts its implementation limit on the number of RCPT commands
   (""too many recipients"") as having reply code 552.  The correct reply
   code for this condition is 452.  Clients SHOULD treat a 552 code in
   this case as a temporary, rather than permanent, failure so the logic
   below works.

   When a conforming SMTP server encounters this condition, it has at
   least 100 successful RCPT commands in its recipients buffer.  If the
   server is able to accept the message, then at least these 100



Klensin                     Standards Track                    [Page 64]

RFC 5321                          SMTP                      October 2008


   addresses will be removed from the SMTP client's queue.  When the
   client attempts retransmission of those addresses that received 452
   responses, at least 100 of these will be able to fit in the SMTP
   server's recipients buffer.  Each retransmission attempt that is able
   to deliver anything will be able to dispose of at least 100 of these
   recipients.

   If an SMTP server has an implementation limit on the number of RCPT
   commands and this limit is exhausted, it MUST use a response code of
   452 (but the client SHOULD also be prepared for a 552, as noted
   above).  If the server has a configured site-policy limitation on the
   number of RCPT commands, it MAY instead use a 5yz response code.  In
   particular, if the intent is to prohibit messages with more than a
   site-specified number of recipients, rather than merely limit the
   number of recipients in a given mail transaction, it would be
   reasonable to return a 503 response to any DATA command received
   subsequent to the 452 (or 552) code or to simply return the 503 after
   DATA without returning any previous negative response.

4.5.3.2.  Timeouts

   An SMTP client MUST provide a timeout mechanism.  It MUST use per-
   command timeouts rather than somehow trying to time the entire mail
   transaction.  Timeouts SHOULD be easily reconfigurable, preferably
   without recompiling the SMTP code.  To implement this, a timer is set
   for each SMTP command and for each buffer of the data transfer.  The
   latter means that the overall timeout is inherently proportional to
   the size of the message.

   Based on extensive experience with busy mail-relay hosts, the minimum
   per-command timeout values SHOULD be as follows:

4.5.3.2.1.  Initial 220 Message: 5 Minutes

   An SMTP client process needs to distinguish between a failed TCP
   connection and a delay in receiving the initial 220 greeting message.
   Many SMTP servers accept a TCP connection but delay delivery of the
   220 message until their system load permits more mail to be
   processed.

4.5.3.2.2.  MAIL Command: 5 Minutes

4.5.3.2.3.  RCPT Command: 5 Minutes

   A longer timeout is required if processing of mailing lists and
   aliases is not deferred until after the message was accepted.





Klensin                     Standards Track                    [Page 65]

RFC 5321                          SMTP                      October 2008


4.5.3.2.4.  DATA Initiation: 2 Minutes

   This is while awaiting the ""354 Start Input"" reply to a DATA command.

4.5.3.2.5.  Data Block: 3 Minutes

   This is while awaiting the completion of each TCP SEND call
   transmitting a chunk of data.

4.5.3.2.6.  DATA Termination: 10 Minutes.

   This is while awaiting the ""250 OK"" reply.  When the receiver gets
   the final period terminating the message data, it typically performs
   processing to deliver the message to a user mailbox.  A spurious
   timeout at this point would be very wasteful and would typically
   result in delivery of multiple copies of the message, since it has
   been successfully sent and the server has accepted responsibility for
   delivery.  See Section 6.1 for additional discussion.

4.5.3.2.7.  Server Timeout: 5 Minutes.

   An SMTP server SHOULD have a timeout of at least 5 minutes while it
   is awaiting the next command from the sender.

4.5.4.  Retry Strategies

   The common structure of a host SMTP implementation includes user
   mailboxes, one or more areas for queuing messages in transit, and one
   or more daemon processes for sending and receiving mail.  The exact
   structure will vary depending on the needs of the users on the host
   and the number and size of mailing lists supported by the host.  We
   describe several optimizations that have proved helpful, particularly
   for mailers supporting high traffic levels.

   Any queuing strategy MUST include timeouts on all activities on a
   per-command basis.  A queuing strategy MUST NOT send error messages
   in response to error messages under any circumstances.

4.5.4.1.  Sending Strategy

   The general model for an SMTP client is one or more processes that
   periodically attempt to transmit outgoing mail.  In a typical system,
   the program that composes a message has some method for requesting
   immediate attention for a new piece of outgoing mail, while mail that
   cannot be transmitted immediately MUST be queued and periodically
   retried by the sender.  A mail queue entry will include not only the
   message itself but also the envelope information.




Klensin                     Standards Track                    [Page 66]

RFC 5321                          SMTP                      October 2008


   The sender MUST delay retrying a particular destination after one
   attempt has failed.  In general, the retry interval SHOULD be at
   least 30 minutes; however, more sophisticated and variable strategies
   will be beneficial when the SMTP client can determine the reason for
   non-delivery.

   Retries continue until the message is transmitted or the sender gives
   up; the give-up time generally needs to be at least 4-5 days.  It MAY
   be appropriate to set a shorter maximum number of retries for non-
   delivery notifications and equivalent error messages than for
   standard messages.  The parameters to the retry algorithm MUST be
   configurable.

   A client SHOULD keep a list of hosts it cannot reach and
   corresponding connection timeouts, rather than just retrying queued
   mail items.

   Experience suggests that failures are typically transient (the target
   system or its connection has crashed), favoring a policy of two
   connection attempts in the first hour the message is in the queue,
   and then backing off to one every two or three hours.

   The SMTP client can shorten the queuing delay in cooperation with the
   SMTP server.  For example, if mail is received from a particular
   address, it is likely that mail queued for that host can now be sent.
   Application of this principle may, in many cases, eliminate the
   requirement for an explicit ""send queues now"" function such as ETRN,
   RFC 1985 [36].

   The strategy may be further modified as a result of multiple
   addresses per host (see below) to optimize delivery time versus
   resource usage.

   An SMTP client may have a large queue of messages for each
   unavailable destination host.  If all of these messages were retried
   in every retry cycle, there would be excessive Internet overhead and
   the sending system would be blocked for a long period.  Note that an
   SMTP client can generally determine that a delivery attempt has
   failed only after a timeout of several minutes, and even a one-minute
   timeout per connection will result in a very large delay if retries
   are repeated for dozens, or even hundreds, of queued messages to the
   same host.

   At the same time, SMTP clients SHOULD use great care in caching
   negative responses from servers.  In an extreme case, if EHLO is
   issued multiple times during the same SMTP connection, different
   answers may be returned by the server.  More significantly, 5yz
   responses to the MAIL command MUST NOT be cached.



Klensin                     Standards Track                    [Page 67]

RFC 5321                          SMTP                      October 2008


   When a mail message is to be delivered to multiple recipients, and
   the SMTP server to which a copy of the message is to be sent is the
   same for multiple recipients, then only one copy of the message
   SHOULD be transmitted.  That is, the SMTP client SHOULD use the
   command sequence: MAIL, RCPT, RCPT, ..., RCPT, DATA instead of the
   sequence: MAIL, RCPT, DATA, ..., MAIL, RCPT, DATA.  However, if there
   are very many addresses, a limit on the number of RCPT commands per
   MAIL command MAY be imposed.  This efficiency feature SHOULD be
   implemented.

   Similarly, to achieve timely delivery, the SMTP client MAY support
   multiple concurrent outgoing mail transactions.  However, some limit
   may be appropriate to protect the host from devoting all its
   resources to mail.

4.5.4.2.  Receiving Strategy

   The SMTP server SHOULD attempt to keep a pending listen on the SMTP
   port (specified by IANA as port 25) at all times.  This requires the
   support of multiple incoming TCP connections for SMTP.  Some limit
   MAY be imposed, but servers that cannot handle more than one SMTP
   transaction at a time are not in conformance with the intent of this
   specification.

   As discussed above, when the SMTP server receives mail from a
   particular host address, it could activate its own SMTP queuing
   mechanisms to retry any mail pending for that host address.

4.5.5.  Messages with a Null Reverse-Path

   There are several types of notification messages that are required by
   existing and proposed Standards to be sent with a null reverse-path,
   namely non-delivery notifications as discussed in Section 3.7, other
   kinds of Delivery Status Notifications (DSNs, RFC 3461 [32]), and
   Message Disposition Notifications (MDNs, RFC 3798 [37]).  All of
   these kinds of messages are notifications about a previous message,
   and they are sent to the reverse-path of the previous mail message.
   (If the delivery of such a notification message fails, that usually
   indicates a problem with the mail system of the host to which the
   notification message is addressed.  For this reason, at some hosts
   the MTA is set up to forward such failed notification messages to
   someone who is able to fix problems with the mail system, e.g., via
   the postmaster alias.)

   All other types of messages (i.e., any message which is not required
   by a Standards-Track RFC to have a null reverse-path) SHOULD be sent
   with a valid, non-null reverse-path.




Klensin                     Standards Track                    [Page 68]

RFC 5321                          SMTP                      October 2008


   Implementers of automated email processors should be careful to make
   sure that the various kinds of messages with a null reverse-path are
   handled correctly.  In particular, such systems SHOULD NOT reply to
   messages with a null reverse-path, and they SHOULD NOT add a non-null
   reverse-path, or change a null reverse-path to a non-null one, to
   such messages when forwarding.

5.  Address Resolution and Mail Handling

5.1.  Locating the Target Host

   Once an SMTP client lexically identifies a domain to which mail will
   be delivered for processing (as described in Sections 2.3.5 and 3.6),
   a DNS lookup MUST be performed to resolve the domain name (RFC 1035
   [2]).  The names are expected to be fully-qualified domain names
   (FQDNs): mechanisms for inferring FQDNs from partial names or local
   aliases are outside of this specification.  Due to a history of
   problems, SMTP servers used for initial submission of messages SHOULD
   NOT make such inferences (Message Submission Servers [18] have
   somewhat more flexibility) and intermediate (relay) SMTP servers MUST
   NOT make them.

   The lookup first attempts to locate an MX record associated with the
   name.  If a CNAME record is found, the resulting name is processed as
   if it were the initial name.  If a non-existent domain error is
   returned, this situation MUST be reported as an error.  If a
   temporary error is returned, the message MUST be queued and retried
   later (see Section 4.5.4.1).  If an empty list of MXs is returned,
   the address is treated as if it was associated with an implicit MX
   RR, with a preference of 0, pointing to that host.  If MX records are
   present, but none of them are usable, or the implicit MX is unusable,
   this situation MUST be reported as an error.

   If one or more MX RRs are found for a given name, SMTP systems MUST
   NOT utilize any address RRs associated with that name unless they are
   located using the MX RRs; the ""implicit MX"" rule above applies only
   if there are no MX records present.  If MX records are present, but
   none of them are usable, this situation MUST be reported as an error.

   When a domain name associated with an MX RR is looked up and the
   associated data field obtained, the data field of that response MUST
   contain a domain name.  That domain name, when queried, MUST return
   at least one address record (e.g., A or AAAA RR) that gives the IP
   address of the SMTP server to which the message should be directed.
   Any other response, specifically including a value that will return a
   CNAME record when queried, lies outside the scope of this Standard.
   The prohibition on labels in the data that resolve to CNAMEs is
   discussed in more detail in RFC 2181, Section 10.3 [38].



Klensin                     Standards Track                    [Page 69]

RFC 5321                          SMTP                      October 2008


   When the lookup succeeds, the mapping can result in a list of
   alternative delivery addresses rather than a single address, because
   of multiple MX records, multihoming, or both.  To provide reliable
   mail transmission, the SMTP client MUST be able to try (and retry)
   each of the relevant addresses in this list in order, until a
   delivery attempt succeeds.  However, there MAY also be a configurable
   limit on the number of alternate addresses that can be tried.  In any
   case, the SMTP client SHOULD try at least two addresses.

   Two types of information are used to rank the host addresses:
   multiple MX records, and multihomed hosts.

   MX records contain a preference indication that MUST be used in
   sorting if more than one such record appears (see below).  Lower
   numbers are more preferred than higher ones.  If there are multiple
   destinations with the same preference and there is no clear reason to
   favor one (e.g., by recognition of an easily reached address), then
   the sender-SMTP MUST randomize them to spread the load across
   multiple mail exchangers for a specific organization.

   The destination host (perhaps taken from the preferred MX record) may
   be multihomed, in which case the domain name resolver will return a
   list of alternative IP addresses.  It is the responsibility of the
   domain name resolver interface to have ordered this list by
   decreasing preference if necessary, and the SMTP sender MUST try them
   in the order presented.

   Although the capability to try multiple alternative addresses is
   required, specific installations may want to limit or disable the use
   of alternative addresses.  The question of whether a sender should
   attempt retries using the different addresses of a multihomed host
   has been controversial.  The main argument for using the multiple
   addresses is that it maximizes the probability of timely delivery,
   and indeed sometimes the probability of any delivery; the counter-
   argument is that it may result in unnecessary resource use.  Note
   that resource use is also strongly determined by the sending strategy
   discussed in Section 4.5.4.1.

   If an SMTP server receives a message with a destination for which it
   is a designated Mail eXchanger, it MAY relay the message (potentially
   after having rewritten the MAIL FROM and/or RCPT TO addresses), make
   final delivery of the message, or hand it off using some mechanism
   outside the SMTP-provided transport environment.  Of course, neither
   of the latter require that the list of MX records be examined
   further.

   If it determines that it should relay the message without rewriting
   the address, it MUST sort the MX records to determine candidates for



Klensin                     Standards Track                    [Page 70]

RFC 5321                          SMTP                      October 2008


   delivery.  The records are first ordered by preference, with the
   lowest-numbered records being most preferred.  The relay host MUST
   then inspect the list for any of the names or addresses by which it
   might be known in mail transactions.  If a matching record is found,
   all records at that preference level and higher-numbered ones MUST be
   discarded from consideration.  If there are no records left at that
   point, it is an error condition, and the message MUST be returned as
   undeliverable.  If records do remain, they SHOULD be tried, best
   preference first, as described above.

5.2.  IPv6 and MX Records

   In the contemporary Internet, SMTP clients and servers may be hosted
   on IPv4 systems, IPv6 systems, or dual-stack systems that are
   compatible with either version of the Internet Protocol.  The host
   domains to which MX records point may, consequently, contain ""A RR""s
   (IPv4), ""AAAA RR""s (IPv6), or any combination of them.  While RFC
   3974 [39] discusses some operational experience in mixed
   environments, it was not comprehensive enough to justify
   standardization, and some of its recommendations appear to be
   inconsistent with this specification.  The appropriate actions to be
   taken either will depend on local circumstances, such as performance
   of the relevant networks and any conversions that might be necessary,
   or will be obvious (e.g., an IPv6-only client need not attempt to
   look up A RRs or attempt to reach IPv4-only servers).  Designers of
   SMTP implementations that might run in IPv6 or dual-stack
   environments should study the procedures above, especially the
   comments about multihomed hosts, and, preferably, provide mechanisms
   to facilitate operational tuning and mail interoperability between
   IPv4 and IPv6 systems while considering local circumstances.

6.  Problem Detection and Handling

6.1.  Reliable Delivery and Replies by Email

   When the receiver-SMTP accepts a piece of mail (by sending a ""250 OK""
   message in response to DATA), it is accepting responsibility for
   delivering or relaying the message.  It must take this responsibility
   seriously.  It MUST NOT lose the message for frivolous reasons, such
   as because the host later crashes or because of a predictable
   resource shortage.  Some reasons that are not considered frivolous
   are discussed in the next subsection and in Section 7.8.

   If there is a delivery failure after acceptance of a message, the
   receiver-SMTP MUST formulate and mail a notification message.  This
   notification MUST be sent using a null (""<>"") reverse-path in the
   envelope.  The recipient of this notification MUST be the address
   from the envelope return path (or the Return-Path: line).  However,



Klensin                     Standards Track                    [Page 71]

RFC 5321                          SMTP                      October 2008


   if this address is null (""<>""), the receiver-SMTP MUST NOT send a
   notification.  Obviously, nothing in this section can or should
   prohibit local decisions (i.e., as part of the same system
   environment as the receiver-SMTP) to log or otherwise transmit
   information about null address events locally if that is desired.  If
   the address is an explicit source route, it MUST be stripped down to
   its final hop.

   For example, suppose that an error notification must be sent for a
   message that arrived with:

      MAIL FROM:<@a,@b:user@d>

   The notification message MUST be sent using:

      RCPT TO:<user@d>

   Some delivery failures after the message is accepted by SMTP will be
   unavoidable.  For example, it may be impossible for the receiving
   SMTP server to validate all the delivery addresses in RCPT command(s)
   due to a ""soft"" domain system error, because the target is a mailing
   list (see earlier discussion of RCPT), or because the server is
   acting as a relay and has no immediate access to the delivering
   system.

   To avoid receiving duplicate messages as the result of timeouts, a
   receiver-SMTP MUST seek to minimize the time required to respond to
   the final <CRLF>.<CRLF> end of data indicator.  See RFC 1047 [40] for
   a discussion of this problem.

6.2.  Unwanted, Unsolicited, and ""Attack"" Messages

   Utility and predictability of the Internet mail system requires that
   messages that can be delivered should be delivered, regardless of any
   syntax or other faults associated with those messages and regardless
   of their content.  If they cannot be delivered, and cannot be
   rejected by the SMTP server during the SMTP transaction, they should
   be ""bounced"" (returned with non-delivery notification messages) as
   described above.  In today's world, in which many SMTP server
   operators have discovered that the quantity of undesirable bulk email
   vastly exceeds the quantity of desired mail and in which accepting a
   message may trigger additional undesirable traffic by providing
   verification of the address, those principles may not be practical.

   As discussed in Section 7.8 and Section 7.9 below, dropping mail
   without notification of the sender is permitted in practice.
   However, it is extremely dangerous and violates a long tradition and
   community expectations that mail is either delivered or returned.  If



Klensin                     Standards Track                    [Page 72]

RFC 5321                          SMTP                      October 2008


   silent message-dropping is misused, it could easily undermine
   confidence in the reliability of the Internet's mail systems.  So
   silent dropping of messages should be considered only in those cases
   where there is very high confidence that the messages are seriously
   fraudulent or otherwise inappropriate.

   To stretch the principle of delivery if possible even further, it may
   be a rational policy to not deliver mail that has an invalid return
   address, although the history of the network is that users are
   typically better served by delivering any message that can be
   delivered.  Reliably determining that a return address is invalid can
   be a difficult and time-consuming process, especially if the putative
   sending system is not directly accessible or does not fully and
   accurately support VRFY and, even if a ""drop messages with invalid
   return addresses"" policy is adopted, it SHOULD be applied only when
   there is near-certainty that the return addresses are, in fact,
   invalid.

   Conversely, if a message is rejected because it is found to contain
   hostile content (a decision that is outside the scope of an SMTP
   server as defined in this document), rejection (""bounce"") messages
   SHOULD NOT be sent unless the receiving site is confident that those
   messages will be usefully delivered.  The preference and default in
   these cases is to avoid sending non-delivery messages when the
   incoming message is determined to contain hostile content.

6.3.  Loop Detection

   Simple counting of the number of ""Received:"" header fields in a
   message has proven to be an effective, although rarely optimal,
   method of detecting loops in mail systems.  SMTP servers using this
   technique SHOULD use a large rejection threshold, normally at least
   100 Received entries.  Whatever mechanisms are used, servers MUST
   contain provisions for detecting and stopping trivial loops.

6.4.  Compensating for Irregularities

   Unfortunately, variations, creative interpretations, and outright
   violations of Internet mail protocols do occur; some would suggest
   that they occur quite frequently.  The debate as to whether a well-
   behaved SMTP receiver or relay should reject a malformed message,
   attempt to pass it on unchanged, or attempt to repair it to increase
   the odds of successful delivery (or subsequent reply) began almost
   with the dawn of structured network mail and shows no signs of
   abating.  Advocates of rejection claim that attempted repairs are
   rarely completely adequate and that rejection of bad messages is the
   only way to get the offending software repaired.  Advocates of
   ""repair"" or ""deliver no matter what"" argue that users prefer that



Klensin                     Standards Track                    [Page 73]

RFC 5321                          SMTP                      October 2008


   mail go through it if at all possible and that there are significant
   market pressures in that direction.  In practice, these market
   pressures may be more important to particular vendors than strict
   conformance to the standards, regardless of the preference of the
   actual developers.

   The problems associated with ill-formed messages were exacerbated by
   the introduction of the split-UA mail reading protocols (Post Office
   Protocol (POP) version 2 [15], Post Office Protocol (POP) version 3
   [16], IMAP version 2 [41], and PCMAIL [42]).  These protocols
   encouraged the use of SMTP as a posting (message submission)
   protocol, and SMTP servers as relay systems for these client hosts
   (which are often only intermittently connected to the Internet).
   Historically, many of those client machines lacked some of the
   mechanisms and information assumed by SMTP (and indeed, by the mail
   format protocol, RFC 822 [28]).  Some could not keep adequate track
   of time; others had no concept of time zones; still others could not
   identify their own names or addresses; and, of course, none could
   satisfy the assumptions that underlay RFC 822's conception of
   authenticated addresses.

   In response to these weak SMTP clients, many SMTP systems now
   complete messages that are delivered to them in incomplete or
   incorrect form.  This strategy is generally considered appropriate
   when the server can identify or authenticate the client, and there
   are prior agreements between them.  By contrast, there is at best
   great concern about fixes applied by a relay or delivery SMTP server
   that has little or no knowledge of the user or client machine.  Many
   of these issues are addressed by using a separate protocol, such as
   that defined in RFC 4409 [18], for message submission, rather than
   using originating SMTP servers for that purpose.

   The following changes to a message being processed MAY be applied
   when necessary by an originating SMTP server, or one used as the
   target of SMTP as an initial posting (message submission) protocol:

   o  Addition of a message-id field when none appears

   o  Addition of a date, time, or time zone when none appears

   o  Correction of addresses to proper FQDN format

   The less information the server has about the client, the less likely
   these changes are to be correct and the more caution and conservatism
   should be applied when considering whether or not to perform fixes
   and how.  These changes MUST NOT be applied by an SMTP server that
   provides an intermediate relay function.




Klensin                     Standards Track                    [Page 74]

RFC 5321                          SMTP                      October 2008


   In all cases, properly operating clients supplying correct
   information are preferred to corrections by the SMTP server.  In all
   cases, documentation SHOULD be provided in trace header fields and/or
   header field comments for actions performed by the servers.

7.  Security Considerations

7.1.  Mail Security and Spoofing

   SMTP mail is inherently insecure in that it is feasible for even
   fairly casual users to negotiate directly with receiving and relaying
   SMTP servers and create messages that will trick a naive recipient
   into believing that they came from somewhere else.  Constructing such
   a message so that the ""spoofed"" behavior cannot be detected by an
   expert is somewhat more difficult, but not sufficiently so as to be a
   deterrent to someone who is determined and knowledgeable.
   Consequently, as knowledge of Internet mail increases, so does the
   knowledge that SMTP mail inherently cannot be authenticated, or
   integrity checks provided, at the transport level.  Real mail
   security lies only in end-to-end methods involving the message
   bodies, such as those that use digital signatures (see RFC 1847 [43]
   and, e.g., Pretty Good Privacy (PGP) in RFC 4880 [44] or Secure/
   Multipurpose Internet Mail Extensions (S/MIME) in RFC 3851 [45]).

   Various protocol extensions and configuration options that provide
   authentication at the transport level (e.g., from an SMTP client to
   an SMTP server) improve somewhat on the traditional situation
   described above.  However, in general, they only authenticate one
   server to another rather than a chain of relays and servers, much
   less authenticating users or user machines.  Consequently, unless
   they are accompanied by careful handoffs of responsibility in a
   carefully designed trust environment, they remain inherently weaker
   than end-to-end mechanisms that use digitally signed messages rather
   than depending on the integrity of the transport system.

   Efforts to make it more difficult for users to set envelope return
   path and header ""From"" fields to point to valid addresses other than
   their own are largely misguided: they frustrate legitimate
   applications in which mail is sent by one user on behalf of another,
   in which error (or normal) replies should be directed to a special
   address, or in which a single message is sent to multiple recipients
   on different hosts.  (Systems that provide convenient ways for users
   to alter these header fields on a per-message basis should attempt to
   establish a primary and permanent mailbox address for the user so
   that Sender header fields within the message data can be generated
   sensibly.)





Klensin                     Standards Track                    [Page 75]

RFC 5321                          SMTP                      October 2008


   This specification does not further address the authentication issues
   associated with SMTP other than to advocate that useful functionality
   not be disabled in the hope of providing some small margin of
   protection against a user who is trying to fake mail.

7.2.  ""Blind"" Copies

   Addresses that do not appear in the message header section may appear
   in the RCPT commands to an SMTP server for a number of reasons.  The
   two most common involve the use of a mailing address as a ""list
   exploder"" (a single address that resolves into multiple addresses)
   and the appearance of ""blind copies"".  Especially when more than one
   RCPT command is present, and in order to avoid defeating some of the
   purpose of these mechanisms, SMTP clients and servers SHOULD NOT copy
   the full set of RCPT command arguments into the header section,
   either as part of trace header fields or as informational or private-
   extension header fields.  Since this rule is often violated in
   practice, and cannot be enforced, sending SMTP systems that are aware
   of ""bcc"" use MAY find it helpful to send each blind copy as a
   separate message transaction containing only a single RCPT command.

   There is no inherent relationship between either ""reverse"" (from
   MAIL, SAML, etc., commands) or ""forward"" (RCPT) addresses in the SMTP
   transaction (""envelope"") and the addresses in the header section.
   Receiving systems SHOULD NOT attempt to deduce such relationships and
   use them to alter the header section of the message for delivery.
   The popular ""Apparently-to"" header field is a violation of this
   principle as well as a common source of unintended information
   disclosure and SHOULD NOT be used.

7.3.  VRFY, EXPN, and Security

   As discussed in Section 3.5, individual sites may want to disable
   either or both of VRFY or EXPN for security reasons (see below).  As
   a corollary to the above, implementations that permit this MUST NOT
   appear to have verified addresses that are not, in fact, verified.
   If a site disables these commands for security reasons, the SMTP
   server MUST return a 252 response, rather than a code that could be
   confused with successful or unsuccessful verification.

   Returning a 250 reply code with the address listed in the VRFY
   command after having checked it only for syntax violates this rule.
   Of course, an implementation that ""supports"" VRFY by always returning
   550 whether or not the address is valid is equally not in
   conformance.

   On the public Internet, the contents of mailing lists have become
   popular as an address information source for so-called ""spammers.""



Klensin                     Standards Track                    [Page 76]

RFC 5321                          SMTP                      October 2008


   The use of EXPN to ""harvest"" addresses has increased as list
   administrators have installed protections against inappropriate uses
   of the lists themselves.  However, VRFY and EXPN are still useful for
   authenticated users and within an administrative domain.  For
   example, VRFY and EXPN are useful for performing internal audits of
   how email gets routed to check and to make sure no one is
   automatically forwarding sensitive mail outside the organization.
   Sites implementing SMTP authentication may choose to make VRFY and
   EXPN available only to authenticated requestors.  Implementations
   SHOULD still provide support for EXPN, but sites SHOULD carefully
   evaluate the tradeoffs.

   Whether disabling VRFY provides any real marginal security depends on
   a series of other conditions.  In many cases, RCPT commands can be
   used to obtain the same information about address validity.  On the
   other hand, especially in situations where determination of address
   validity for RCPT commands is deferred until after the DATA command
   is received, RCPT may return no information at all, while VRFY is
   expected to make a serious attempt to determine validity before
   generating a response code (see discussion above).

7.4.  Mail Rerouting Based on the 251 and 551 Response Codes

   Before a client uses the 251 or 551 reply codes from a RCPT command
   to automatically update its future behavior (e.g., updating the
   user's address book), it should be certain of the server's
   authenticity.  If it does not, it may be subject to a man in the
   middle attack.

7.5.  Information Disclosure in Announcements

   There has been an ongoing debate about the tradeoffs between the
   debugging advantages of announcing server type and version (and,
   sometimes, even server domain name) in the greeting response or in
   response to the HELP command and the disadvantages of exposing
   information that might be useful in a potential hostile attack.  The
   utility of the debugging information is beyond doubt.  Those who
   argue for making it available point out that it is far better to
   actually secure an SMTP server rather than hope that trying to
   conceal known vulnerabilities by hiding the server's precise identity
   will provide more protection.  Sites are encouraged to evaluate the
   tradeoff with that issue in mind; implementations SHOULD minimally
   provide for making type and version information available in some way
   to other network hosts.







Klensin                     Standards Track                    [Page 77]

RFC 5321                          SMTP                      October 2008


7.6.  Information Disclosure in Trace Fields

   In some circumstances, such as when mail originates from within a LAN
   whose hosts are not directly on the public Internet, trace
   (""Received"") header fields produced in conformance with this
   specification may disclose host names and similar information that
   would not normally be available.  This ordinarily does not pose a
   problem, but sites with special concerns about name disclosure should
   be aware of it.  Also, the optional FOR clause should be supplied
   with caution or not at all when multiple recipients are involved lest
   it inadvertently disclose the identities of ""blind copy"" recipients
   to others.

7.7.  Information Disclosure in Message Forwarding

   As discussed in Section 3.4, use of the 251 or 551 reply codes to
   identify the replacement address associated with a mailbox may
   inadvertently disclose sensitive information.  Sites that are
   concerned about those issues should ensure that they select and
   configure servers appropriately.

7.8.  Resistance to Attacks

   In recent years, there has been an increase of attacks on SMTP
   servers, either in conjunction with attempts to discover addresses
   for sending unsolicited messages or simply to make the servers
   inaccessible to others (i.e., as an application-level denial of
   service attack).  While the means of doing so are beyond the scope of
   this Standard, rational operational behavior requires that servers be
   permitted to detect such attacks and take action to defend
   themselves.  For example, if a server determines that a large number
   of RCPT TO commands are being sent, most or all with invalid
   addresses, as part of such an attack, it would be reasonable for the
   server to close the connection after generating an appropriate number
   of 5yz (normally 550) replies.

7.9.  Scope of Operation of SMTP Servers

   It is a well-established principle that an SMTP server may refuse to
   accept mail for any operational or technical reason that makes sense
   to the site providing the server.  However, cooperation among sites
   and installations makes the Internet possible.  If sites take
   excessive advantage of the right to reject traffic, the ubiquity of
   email availability (one of the strengths of the Internet) will be
   threatened; considerable care should be taken and balance maintained
   if a site decides to be selective about the traffic it will accept
   and process.




Klensin                     Standards Track                    [Page 78]

RFC 5321                          SMTP                      October 2008


   In recent years, use of the relay function through arbitrary sites
   has been used as part of hostile efforts to hide the actual origins
   of mail.  Some sites have decided to limit the use of the relay
   function to known or identifiable sources, and implementations SHOULD
   provide the capability to perform this type of filtering.  When mail
   is rejected for these or other policy reasons, a 550 code SHOULD be
   used in response to EHLO (or HELO), MAIL, or RCPT as appropriate.

8.  IANA Considerations

   IANA maintains three registries in support of this specification, all
   of which were created for RFC 2821 or earlier.  This document expands
   the third one as specified below.  The registry references listed are
   as of the time of publication; IANA does not guarantee the locations
   associated with the URLs.  The registries are as follows:

   o  The first, ""Simple Mail Transfer Protocol (SMTP) Service
      Extensions"" [46], consists of SMTP service extensions with the
      associated keywords, and, as needed, parameters and verbs.  As
      specified in Section 2.2.2, no entry may be made in this registry
      that starts in an ""X"".  Entries may be made only for service
      extensions (and associated keywords, parameters, or verbs) that
      are defined in Standards-Track or Experimental RFCs specifically
      approved by the IESG for this purpose.

   o  The second registry, ""Address Literal Tags"" [47], consists of
      ""tags"" that identify forms of domain literals other than those for
      IPv4 addresses (specified in RFC 821 and in this document).  The
      initial entry in that registry is for IPv6 addresses (specified in
      this document).  Additional literal types require standardization
      before being used; none are anticipated at this time.

   o  The third, ""Mail Transmission Types"" [46], established by RFC 821
      and renewed by this specification, is a registry of link and
      protocol identifiers to be used with the ""via"" and ""with""
      subclauses of the time stamp (""Received:"" header field) described
      in Section 4.4.  Link and protocol identifiers in addition to
      those specified in this document may be registered only by
      standardization or by way of an RFC-documented, IESG-approved,
      Experimental protocol extension.  This name space is for
      identification and not limited in size: the IESG is encouraged to
      approve on the basis of clear documentation and a distinct method
      rather than preferences about the properties of the method itself.

      An additional subsection has been added to the ""VIA link types""
      and ""WITH protocol types"" subsections of this registry to contain
      registrations of ""Additional-registered-clauses"" as described
      above.  The registry will contain clause names, a description, a



Klensin                     Standards Track                    [Page 79]

RFC 5321                          SMTP                      October 2008


      summary of the syntax of the associated String, and a reference.
      As new clauses are defined, they may, in principle, specify
      creation of their own registries if the Strings consist of
      reserved terms or keywords rather than less restricted strings.
      As with link and protocol identifiers, additional clauses may be
      registered only by standardization or by way of an RFC-documented,
      IESG-approved, Experimental protocol extension.  The additional
      clause name space is for identification and is not limited in
      size: the IESG is encouraged to approve on the basis of clear
      documentation, actual use or strong signs that the clause will be
      used, and a distinct requirement rather than preferences about the
      properties of the clause itself.

   In addition, if additional trace header fields (i.e., in addition to
   Return-path and Received) are ever created, those trace fields MUST
   be added to the IANA registry established by BCP 90 (RFC 3864) [11]
   for use with RFC 5322 [4].

9.  Acknowledgments

   Many people contributed to the development of RFC 2821.  That
   document should be consulted for those acknowledgments.  For the
   present document, the editor and the community owe thanks to Dawn
   Mann and Tony Hansen who assisted in the very painful process of
   editing and converting the internal format of the document from one
   system to another.

   Neither this document nor RFC 2821 would have been possible without
   the many contribution and insights of the late Jon Postel.  Those
   contributions of course include the original specification of SMTP in
   RFC 821.  A considerable quantity of text from RFC 821 still appears
   in this document as do several of Jon's original examples that have
   been updated only as needed to reflect other changes in the
   specification.

   Many people made comments or suggestions on the mailing list or in
   notes to the author.  Important corrections or clarifications were
   suggested by several people, including Matti Aarnio, Glenn Anderson,
   Derek J. Balling, Alex van den Bogaerdt, Stephane Bortzmeyer, Vint
   Cerf, Jutta Degener, Steve Dorner, Lisa Dusseault, Frank Ellerman,
   Ned Freed, Randy Gellens, Sabahattin Gucukoglu, Philip Guenther, Arnt
   Gulbrandsen, Eric Hall, Richard O. Hammer, Tony Hansen, Peter J.
   Holzer, Kari Hurtta, Bryon Roche Kain, Valdis Kletnieks, Mathias
   Koerber, John Leslie, Bruce Lilly, Jeff Macdonald, Mark E. Mallett,
   Mark Martinec, S. Moonesamy, Lyndon Nerenberg, Chris Newman, Douglas
   Otis, Pete Resnick, Robert A. Rosenberg, Vince Sabio, Hector Santos,
   David F. Skoll, Paul Smith, and Brett Watson.




Klensin                     Standards Track                    [Page 80]

RFC 5321                          SMTP                      October 2008


   The efforts of the Area Directors -- Lisa Dusseault, Ted Hardie, and
   Chris Newman -- to get this effort restarted and keep it moving, and
   of an ad hoc committee with the same purpose, are gratefully
   acknowledged.  The members of that committee were (in alphabetical
   order) Dave Crocker, Cyrus Daboo, Tony Finch, Ned Freed, Randall
   Gellens, Tony Hansen, the author, and Alexey Melnikov.  Tony Hansen
   also acted as ad hoc chair on the mailing list reviewing this
   document; without his efforts, sense of balance and fairness, and
   patience, it clearly would not have been possible.

10.  References

10.1.  Normative References

   [1]   Postel, J., ""Simple Mail Transfer Protocol"", STD 10, RFC 821,
         August 1982.

   [2]   Mockapetris, P., ""Domain names - implementation and
         specification"", STD 13, RFC 1035, November 1987.

   [3]   Braden, R., ""Requirements for Internet Hosts - Application and
         Support"", STD 3, RFC 1123, October 1989.

   [4]   Resnick, P., ""Internet Message Format"", RFC 5322, October 2008.

   [5]   Bradner, S., ""Key words for use in RFCs to Indicate Requirement
         Levels"", BCP 14, RFC 2119, March 1997.

   [6]   American National Standards Institute (formerly United States
         of America Standards Institute), ""USA Code for Information
         Interchange"", ANSI X3.4-1968, 1968.

         ANSI X3.4-1968 has been replaced by newer versions with slight
         modifications, but the 1968 version remains definitive for the
         Internet.

   [7]   Crocker, D. and P. Overell, ""Augmented BNF for Syntax
         Specifications: ABNF"", STD 68, RFC 5234, January 2008.

   [8]   Hinden, R. and S. Deering, ""IP Version 6 Addressing
         Architecture"", RFC 4291, February 2006.

   [9]   Newman, C., ""ESMTP and LMTP Transmission Types Registration"",
         RFC 3848, July 2004.

   [10]  Klensin, J., Freed, N., and K. Moore, ""SMTP Service Extension
         for Message Size Declaration"", STD 10, RFC 1870, November 1995.




Klensin                     Standards Track                    [Page 81]

RFC 5321                          SMTP                      October 2008


   [11]  Klyne, G., Nottingham, M., and J. Mogul, ""Registration
         Procedures for Message Header Fields"", BCP 90, RFC 3864,
         September 2004.

10.2.  Informative References

   [12]  Partridge, C., ""Mail routing and the domain system"", RFC 974,
         January 1986.

   [13]  Klensin, J., Freed, N., Rose, M., Stefferud, E., and D.
         Crocker, ""SMTP Service Extensions"", STD 10, RFC 1869,
         November 1995.

   [14]  Klensin, J., ""Simple Mail Transfer Protocol"", RFC 2821,
         April 2001.

   [15]  Butler, M., Postel, J., Chase, D., Goldberger, J., and J.
         Reynolds, ""Post Office Protocol: Version 2"", RFC 937,
         February 1985.

   [16]  Myers, J. and M. Rose, ""Post Office Protocol - Version 3"",
         STD 53, RFC 1939, May 1996.

   [17]  Crispin, M., ""INTERNET MESSAGE ACCESS PROTOCOL - VERSION
         4rev1"", RFC 3501, March 2003.

   [18]  Gellens, R. and J. Klensin, ""Message Submission for Mail"",
         RFC 4409, April 2006.

   [19]  Freed, N., ""SMTP Service Extension for Command Pipelining"",
         STD 60, RFC 2920, September 2000.

   [20]  Vaudreuil, G., ""SMTP Service Extensions for Transmission of
         Large and Binary MIME Messages"", RFC 3030, December 2000.

   [21]  Freed, N. and N. Borenstein, ""Multipurpose Internet Mail
         Extensions (MIME) Part One: Format of Internet Message Bodies"",
         RFC 2045, November 1996.

   [22]  Klensin, J., Freed, N., Rose, M., Stefferud, E., and D.
         Crocker, ""SMTP Service Extension for 8bit-MIMEtransport"",
         RFC 1652, July 1994.

   [23]  Moore, K., ""MIME (Multipurpose Internet Mail Extensions) Part
         Three: Message Header Extensions for Non-ASCII Text"", RFC 2047,
         November 1996.





Klensin                     Standards Track                    [Page 82]

RFC 5321                          SMTP                      October 2008


   [24]  Freed, N. and K. Moore, ""MIME Parameter Value and Encoded Word
         Extensions: Character Sets, Languages, and Continuations"",
         RFC 2231, November 1997.

   [25]  Vaudreuil, G., ""Enhanced Mail System Status Codes"", RFC 3463,
         January 2003.

   [26]  Hansen, T. and J. Klensin, ""A Registry for SMTP Enhanced Mail
         System Status Codes"", BCP 138, RFC 5248, June 2008.

   [27]  Freed, N., ""Behavior of and Requirements for Internet
         Firewalls"", RFC 2979, October 2000.

   [28]  Crocker, D., ""Standard for the format of ARPA Internet text
         messages"", STD 11, RFC 822, August 1982.

   [29]  Wong, M. and W. Schlitt, ""Sender Policy Framework (SPF) for
         Authorizing Use of Domains in E-Mail, Version 1"", RFC 4408,
         April 2006.

   [30]  Fenton, J., ""Analysis of Threats Motivating DomainKeys
         Identified Mail (DKIM)"", RFC 4686, September 2006.

   [31]  Allman, E., Callas, J., Delany, M., Libbey, M., Fenton, J., and
         M. Thomas, ""DomainKeys Identified Mail (DKIM) Signatures"",
         RFC 4871, May 2007.

   [32]  Moore, K., ""Simple Mail Transfer Protocol (SMTP) Service
         Extension for Delivery Status Notifications (DSNs)"", RFC 3461,
         January 2003.

   [33]  Moore, K. and G. Vaudreuil, ""An Extensible Message Format for
         Delivery Status Notifications"", RFC 3464, January 2003.

   [34]  Postel, J. and J. Reynolds, ""File Transfer Protocol"", STD 9,
         RFC 959, October 1985.

   [35]  Kille, S., ""MIXER (Mime Internet X.400 Enhanced Relay): Mapping
         between X.400 and RFC 822/MIME"", RFC 2156, January 1998.

   [36]  De Winter, J., ""SMTP Service Extension for Remote Message Queue
         Starting"", RFC 1985, August 1996.

   [37]  Hansen, T. and G. Vaudreuil, ""Message Disposition
         Notification"", RFC 3798, May 2004.

   [38]  Elz, R. and R. Bush, ""Clarifications to the DNS Specification"",
         RFC 2181, July 1997.



Klensin                     Standards Track                    [Page 83]

RFC 5321                          SMTP                      October 2008


   [39]  Nakamura, M. and J. Hagino, ""SMTP Operational Experience in
         Mixed IPv4/v6 Environments"", RFC 3974, January 2005.

   [40]  Partridge, C., ""Duplicate messages and SMTP"", RFC 1047,
         February 1988.

   [41]  Crispin, M., ""Interactive Mail Access Protocol: Version 2"",
         RFC 1176, August 1990.

   [42]  Lambert, M., ""PCMAIL: A distributed mail system for personal
         computers"", RFC 1056, June 1988.

   [43]  Galvin, J., Murphy, S., Crocker, S., and N. Freed, ""Security
         Multiparts for MIME: Multipart/Signed and Multipart/Encrypted"",
         RFC 1847, October 1995.

   [44]  Callas, J., Donnerhacke, L., Finney, H., Shaw, D., and R.
         Thayer, ""OpenPGP Message Format"", RFC 4880, November 2007.

   [45]  Ramsdell, B., ""Secure/Multipurpose Internet Mail Extensions
         (S/MIME) Version 3.1 Message Specification"", RFC 3851,
         July 2004.

   [46]  Internet Assigned Number Authority (IANA), ""IANA Mail
         Parameters"", 2007,
         <http://www.iana.org/assignments/mail-parameters>.

   [47]  Internet Assigned Number Authority (IANA), ""Address Literal
         Tags"", 2007,
         <http://www.iana.org/assignments/address-literal-tags>.





















Klensin                     Standards Track                    [Page 84]

RFC 5321                          SMTP                      October 2008


Appendix A.  TCP Transport Service

   The TCP connection supports the transmission of 8-bit bytes.  The
   SMTP data is 7-bit ASCII characters.  Each character is transmitted
   as an 8-bit byte with the high-order bit cleared to zero.  Service
   extensions may modify this rule to permit transmission of full 8-bit
   data bytes as part of the message body, or, if specifically designed
   to do so, in SMTP commands or responses.

Appendix B.  Generating SMTP Commands from RFC 822 Header Fields

   Some systems use an RFC 822 header section (only) in a mail
   submission protocol, or otherwise generate SMTP commands from RFC 822
   header fields when such a message is handed to an MTA from a UA.
   While the MTA-UA protocol is a private matter, not covered by any
   Internet Standard, there are problems with this approach.  For
   example, there have been repeated problems with proper handling of
   ""bcc"" copies and redistribution lists when information that
   conceptually belongs to the mail envelope is not separated early in
   processing from header field information (and kept separate).

   It is recommended that the UA provide its initial (""submission
   client"") MTA with an envelope separate from the message itself.
   However, if the envelope is not supplied, SMTP commands SHOULD be
   generated as follows:

   1.  Each recipient address from a TO, CC, or BCC header field SHOULD
       be copied to a RCPT command (generating multiple message copies
       if that is required for queuing or delivery).  This includes any
       addresses listed in a RFC 822 ""group"".  Any BCC header fields
       SHOULD then be removed from the header section.  Once this
       process is completed, the remaining header fields SHOULD be
       checked to verify that at least one TO, CC, or BCC header field
       remains.  If none do, then a BCC header field with no additional
       information SHOULD be inserted as specified in [4].

   2.  The return address in the MAIL command SHOULD, if possible, be
       derived from the system's identity for the submitting (local)
       user, and the ""From:"" header field otherwise.  If there is a
       system identity available, it SHOULD also be copied to the Sender
       header field if it is different from the address in the From
       header field.  (Any Sender header field that was already there
       SHOULD be removed.)  Systems may provide a way for submitters to
       override the envelope return address, but may want to restrict
       its use to privileged users.  This will not prevent mail forgery,
       but may lessen its incidence; see Section 7.1.





Klensin                     Standards Track                    [Page 85]

RFC 5321                          SMTP                      October 2008


   When an MTA is being used in this way, it bears responsibility for
   ensuring that the message being transmitted is valid.  The mechanisms
   for checking that validity, and for handling (or returning) messages
   that are not valid at the time of arrival, are part of the MUA-MTA
   interface and not covered by this specification.

   A submission protocol based on Standard RFC 822 information alone
   MUST NOT be used to gateway a message from a foreign (non-SMTP) mail
   system into an SMTP environment.  Additional information to construct
   an envelope must come from some source in the other environment,
   whether supplemental header fields or the foreign system's envelope.

   Attempts to gateway messages using only their header ""To"" and ""Cc""
   fields have repeatedly caused mail loops and other behavior adverse
   to the proper functioning of the Internet mail environment.  These
   problems have been especially common when the message originates from
   an Internet mailing list and is distributed into the foreign
   environment using envelope information.  When these messages are then
   processed by a header-section-only remailer, loops back to the
   Internet environment (and the mailing list) are almost inevitable.

Appendix C.  Source Routes

   Historically, the <reverse-path> was a reverse source routing list of
   hosts and a source mailbox.  The first host in the <reverse-path> was
   historically the host sending the MAIL command; today, source routes
   SHOULD NOT appear in the reverse-path.  Similarly, the <forward-path>
   may be a source routing lists of hosts and a destination mailbox.
   However, in general, the <forward-path> SHOULD contain only a mailbox
   and domain name, relying on the domain name system to supply routing
   information if required.  The use of source routes is deprecated (see
   Appendix F.2); while servers MUST be prepared to receive and handle
   them as discussed in Section 3.3 and Appendix F.2, clients SHOULD NOT
   transmit them and this section is included in the current
   specification only to provide context.  It has been modified somewhat
   from the material in RFC 821 to prevent server actions that might
   confuse clients or subsequent servers that do not expect a full
   source route implementation.

   For relay purposes, the forward-path may be a source route of the
   form ""@ONE,@TWO:JOE@THREE"", where ONE, TWO, and THREE MUST be fully-
   qualified domain names.  This form is used to emphasize the
   distinction between an address and a route.  The mailbox (here, JOE@
   THREE) is an absolute address, and the route is information about how
   to get there.  The two concepts should not be confused.

   If source routes are used, RFC 821 and the text below should be
   consulted for the mechanisms for constructing and updating the



Klensin                     Standards Track                    [Page 86]

RFC 5321                          SMTP                      October 2008


   forward-path.  A server that is reached by means of a source route
   (e.g., its domain name appears first in the list in the forward-path)
   MUST remove its domain name from any forward-paths in which that
   domain name appears before forwarding the message and MAY remove all
   other source routing information.  The reverse-path SHOULD NOT be
   updated by servers conforming to this specification.

   Notice that the forward-path and reverse-path appear in the SMTP
   commands and replies, but not necessarily in the message.  That is,
   there is no need for these paths and especially this syntax to appear
   in the ""To:"" , ""From:"", ""CC:"", etc. fields of the message header
   section.  Conversely, SMTP servers MUST NOT derive final message
   routing information from message header fields.

   When the list of hosts is present despite the recommendations above,
   it is a ""reverse"" source route and indicates that the mail was
   relayed through each host on the list (the first host in the list was
   the most recent relay).  This list is used as a source route to
   return non-delivery notices to the sender.  If, contrary to the
   recommendations here, a relay host adds itself to the beginning of
   the list, it MUST use its name as known in the transport environment
   to which it is relaying the mail rather than that of the transport
   environment from which the mail came (if they are different).  Note
   that a situation could easily arise in which some relay hosts add
   their names to the reverse source route and others do not, generating
   discontinuities in the routing list.  This is another reason why
   servers needing to return a message SHOULD ignore the source route
   entirely and simply use the domain as specified in the Mailbox.

Appendix D.  Scenarios

   This section presents complete scenarios of several types of SMTP
   sessions.  In the examples, ""C:"" indicates what is said by the SMTP
   client, and ""S:"" indicates what is said by the SMTP server.

















Klensin                     Standards Track                    [Page 87]

RFC 5321                          SMTP                      October 2008


D.1.  A Typical SMTP Transaction Scenario

   This SMTP example shows mail sent by Smith at host bar.com, and to
   Jones, Green, and Brown at host foo.com.  Here we assume that host
   bar.com contacts host foo.com directly.  The mail is accepted for
   Jones and Brown.  Green does not have a mailbox at host foo.com.

      S: 220 foo.com Simple Mail Transfer Service Ready
      C: EHLO bar.com
      S: 250-foo.com greets bar.com
      S: 250-8BITMIME
      S: 250-SIZE
      S: 250-DSN
      S: 250 HELP
      C: MAIL FROM:<Smith@bar.com>
      S: 250 OK
      C: RCPT TO:<Jones@foo.com>
      S: 250 OK
      C: RCPT TO:<Green@foo.com>
      S: 550 No such user here
      C: RCPT TO:<Brown@foo.com>
      S: 250 OK
      C: DATA
      S: 354 Start mail input; end with <CRLF>.<CRLF>
      C: Blah blah blah...
      C: ...etc. etc. etc.
      C: .
      S: 250 OK
      C: QUIT
      S: 221 foo.com Service closing transmission channel





















Klensin                     Standards Track                    [Page 88]

RFC 5321                          SMTP                      October 2008


D.2.  Aborted SMTP Transaction Scenario

      S: 220 foo.com Simple Mail Transfer Service Ready
      C: EHLO bar.com
      S: 250-foo.com greets bar.com
      S: 250-8BITMIME
      S: 250-SIZE
      S: 250-DSN
      S: 250 HELP
      C: MAIL FROM:<Smith@bar.com>
      S: 250 OK
      C: RCPT TO:<Jones@foo.com>
      S: 250 OK
      C: RCPT TO:<Green@foo.com>
      S: 550 No such user here
      C: RSET
      S: 250 OK
      C: QUIT
      S: 221 foo.com Service closing transmission channel
































Klensin                     Standards Track                    [Page 89]

RFC 5321                          SMTP                      October 2008


D.3.  Relayed Mail Scenario

   Step 1 -- Source Host to Relay Host

   The source host performs a DNS lookup on XYZ.COM (the destination
   address) and finds DNS MX records specifying xyz.com as the best
   preference and foo.com as a lower preference.  It attempts to open a
   connection to xyz.com and fails.  It then opens a connection to
   foo.com, with the following dialogue:

      S: 220 foo.com Simple Mail Transfer Service Ready
      C: EHLO bar.com
      S: 250-foo.com greets bar.com
      S: 250-8BITMIME
      S: 250-SIZE
      S: 250-DSN
      S: 250 HELP
      C: MAIL FROM:<JQP@bar.com>
      S: 250 OK
      C: RCPT TO:<Jones@XYZ.COM>
      S: 250 OK
      C: DATA
      S: 354 Start mail input; end with <CRLF>.<CRLF>
      C: Date: Thu, 21 May 1998 05:33:29 -0700
      C: From: John Q. Public <JQP@bar.com>
      C: Subject: The Next Meeting of the Board
      C: To: Jones@xyz.com
      C:
      C: Bill:
      C: The next meeting of the board of directors will be
      C: on Tuesday.
      C: John.
      C: .
      S: 250 OK
      C: QUIT
      S: 221 foo.com Service closing transmission channel















Klensin                     Standards Track                    [Page 90]

RFC 5321                          SMTP                      October 2008


   Step 2 -- Relay Host to Destination Host

   foo.com, having received the message, now does a DNS lookup on
   xyz.com.  It finds the same set of MX records, but cannot use the one
   that points to itself (or to any other host as a worse preference).
   It tries to open a connection to xyz.com itself and succeeds.  Then
   we have:

           S: 220 xyz.com Simple Mail Transfer Service Ready
           C: EHLO foo.com
           S: 250 xyz.com is on the air
           C: MAIL FROM:<JQP@bar.com>
           S: 250 OK
           C: RCPT TO:<Jones@XYZ.COM>
           S: 250 OK
           C: DATA
           S: 354 Start mail input; end with <CRLF>.<CRLF>
           C: Received: from bar.com by foo.com ; Thu, 21 May 1998
           C:     05:33:29 -0700
           C: Date: Thu, 21 May 1998 05:33:22 -0700
           C: From: John Q. Public <JQP@bar.com>
           C: Subject:  The Next Meeting of the Board
           C: To: Jones@xyz.com
           C:
           C: Bill:
           C: The next meeting of the board of directors will be
           C: on Tuesday.
           C:                         John.
           C: .
           S: 250 OK
           C: QUIT
           S: 221 foo.com Service closing transmission channel



















Klensin                     Standards Track                    [Page 91]

RFC 5321                          SMTP                      October 2008


D.4.  Verifying and Sending Scenario

      S: 220 foo.com Simple Mail Transfer Service Ready
      C: EHLO bar.com
      S: 250-foo.com greets bar.com
      S: 250-8BITMIME
      S: 250-SIZE
      S: 250-DSN
      S: 250-VRFY
      S: 250 HELP
      C: VRFY Crispin
      S: 250 Mark Crispin <Admin.MRC@foo.com>
      C: MAIL FROM:<EAK@bar.com>
      S: 250 OK
      C: RCPT TO:<Admin.MRC@foo.com>
      S: 250 OK
      C: DATA
      S: 354 Start mail input; end with <CRLF>.<CRLF>
      C: Blah blah blah...
      C: ...etc. etc. etc.
      C: .
      S: 250 OK
      C: QUIT
      S: 221 foo.com Service closing transmission channel

Appendix E.  Other Gateway Issues

   In general, gateways between the Internet and other mail systems
   SHOULD attempt to preserve any layering semantics across the
   boundaries between the two mail systems involved.  Gateway-
   translation approaches that attempt to take shortcuts by mapping
   (such as mapping envelope information from one system to the message
   header section or body of another) have generally proven to be
   inadequate in important ways.  Systems translating between
   environments that do not support both envelopes and a header section
   and Internet mail must be written with the understanding that some
   information loss is almost inevitable.














Klensin                     Standards Track                    [Page 92]

RFC 5321                          SMTP                      October 2008


Appendix F.  Deprecated Features of RFC 821

   A few features of RFC 821 have proven to be problematic and SHOULD
   NOT be used in Internet mail.

F.1.  TURN

   This command, described in RFC 821, raises important security issues
   since, in the absence of strong authentication of the host requesting
   that the client and server switch roles, it can easily be used to
   divert mail from its correct destination.  Its use is deprecated;
   SMTP systems SHOULD NOT use it unless the server can authenticate the
   client.

F.2.  Source Routing

   RFC 821 utilized the concept of explicit source routing to get mail
   from one host to another via a series of relays.  The requirement to
   utilize source routes in regular mail traffic was eliminated by the
   introduction of the domain name system ""MX"" record and the last
   significant justification for them was eliminated by the
   introduction, in RFC 1123, of a clear requirement that addresses
   following an ""@"" must all be fully-qualified domain names.
   Consequently, the only remaining justifications for the use of source
   routes are support for very old SMTP clients or MUAs and in mail
   system debugging.  They can, however, still be useful in the latter
   circumstance and for routing mail around serious, but temporary,
   problems such as problems with the relevant DNS records.

   SMTP servers MUST continue to accept source route syntax as specified
   in the main body of this document and in RFC 1123.  They MAY, if
   necessary, ignore the routes and utilize only the target domain in
   the address.  If they do utilize the source route, the message MUST
   be sent to the first domain shown in the address.  In particular, a
   server MUST NOT guess at shortcuts within the source route.

   Clients SHOULD NOT utilize explicit source routing except under
   unusual circumstances, such as debugging or potentially relaying
   around firewall or mail system configuration errors.

F.3.  HELO

   As discussed in Sections 3.1 and 4.1.1, EHLO SHOULD be used rather
   than HELO when the server will accept the former.  Servers MUST
   continue to accept and process HELO in order to support older
   clients.





Klensin                     Standards Track                    [Page 93]

RFC 5321                          SMTP                      October 2008


F.4.  #-literals

   RFC 821 provided for specifying an Internet address as a decimal
   integer host number prefixed by a pound sign, ""#"".  In practice, that
   form has been obsolete since the introduction of TCP/IP.  It is
   deprecated and MUST NOT be used.

F.5.  Dates and Years

   When dates are inserted into messages by SMTP clients or servers
   (e.g., in trace header fields), four-digit years MUST BE used.  Two-
   digit years are deprecated; three-digit years were never permitted in
   the Internet mail system.

F.6.  Sending versus Mailing

   In addition to specifying a mechanism for delivering messages to
   user's mailboxes, RFC 821 provided additional, optional, commands to
   deliver messages directly to the user's terminal screen.  These
   commands (SEND, SAML, SOML) were rarely implemented, and changes in
   workstation technology and the introduction of other protocols may
   have rendered them obsolete even where they are implemented.

   Clients SHOULD NOT provide SEND, SAML, or SOML as services.  Servers
   MAY implement them.  If they are implemented by servers, the
   implementation model specified in RFC 821 MUST be used and the
   command names MUST be published in the response to the EHLO command.

Author's Address

   John C. Klensin
   1770 Massachusetts Ave, Suite 322
   Cambridge, MA  02140
   USA

   EMail: john+smtp@jck.com















Klensin                     Standards Track                    [Page 94]

RFC 5321                          SMTP                      October 2008


Full Copyright Statement

   Copyright (C) The IETF Trust (2008).

   This document is subject to the rights, licenses and restrictions
   contained in BCP 78, and except as set forth therein, the authors
   retain all their rights.

   This document and the information contained herein are provided on an
   ""AS IS"" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND
   THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS
   OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF
   THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

Intellectual Property

   The IETF takes no position regarding the validity or scope of any
   Intellectual Property Rights or other rights that might be claimed to
   pertain to the implementation or use of the technology described in
   this document or the extent to which any license under such rights
   might or might not be available; nor does it represent that it has
   made any independent effort to identify any such rights.  Information
   on the procedures with respect to rights in RFC documents can be
   found in BCP 78 and BCP 79.

   Copies of IPR disclosures made to the IETF Secretariat and any
   assurances of licenses to be made available, or the result of an
   attempt made to obtain a general license or permission for the use of
   such proprietary rights by implementers or users of this
   specification can be obtained from the IETF on-line IPR repository at
   http://www.ietf.org/ipr.

   The IETF invites any interested party to bring to its attention any
   copyrights, patents or patent applications, or other proprietary
   rights that may cover technology that may be required to implement
   this standard.  Please address the information to the IETF at
   ietf-ipr@ietf.org.












Klensin                     Standards Track                    [Page 95]

"
RFC951,"
[RFC Home] [TEXT|PDF|HTML] [Tracker] [IPR] [Errata] [Info page]                                                                    DRAFT STANDARDUpdated by: 1395, 1497, 1532, 1542, 5494 Errata ExistNetwork Working Group                   Bill Croft (Stanford University)
Request for Comments: 951                John Gilmore (Sun Microsystems)
                                                          September 1985

                       BOOTSTRAP PROTOCOL (BOOTP)


1. Status of this Memo

   This RFC suggests a proposed protocol for the ARPA-Internet
   community, and requests discussion and suggestions for improvements.
   Distribution of this memo is unlimited.

2. Overview

   This RFC describes an IP/UDP bootstrap protocol (BOOTP) which allows
   a diskless client machine to discover its own IP address, the address
   of a server host, and the name of a file to be loaded into memory and
   executed.  The bootstrap operation can be thought of as consisting of
   TWO PHASES.  This RFC describes the first phase, which could be
   labeled 'address determination and bootfile selection'.  After this
   address and filename information is obtained, control passes to the
   second phase of the bootstrap where a file transfer occurs.  The file
   transfer will typically use the TFTP protocol [9], since it is
   intended that both phases reside in PROM on the client.  However
   BOOTP could also work with other protocols such as SFTP [3] or
   FTP [6].

   We suggest that the client's PROM software provide a way to do a
   complete bootstrap without 'user' interaction.  This is the type of
   boot that would occur during an unattended power-up.  A mechanism
   should be provided for the user to manually supply the necessary
   address and filename information to bypass the BOOTP protocol and
   enter the file transfer phase directly.  If non-volatile storage is
   available, we suggest keeping default settings there and bypassing
   the BOOTP protocol unless these settings cause the file transfer
   phase to fail.  If the cached information fails, the bootstrap should
   fall back to phase 1 and use BOOTP.

   Here is a brief outline of the protocol:

      1. A single packet exchange is performed.  Timeouts are used to
      retransmit until a reply is received.  The same packet field
      layout is used in both directions.  Fixed length fields of maximum
      reasonable length are used to simplify structure definition and
      parsing.

      2. An 'opcode' field exists with two values.  The client
      broadcasts a 'bootrequest' packet.  The server then answers with a
      'bootreply' packet.  The bootrequest contains the client's
      hardware address and its IP address, if known.


Croft & Gilmore                                                 [Page 1]

RFC 951                                                   September 1985
Bootstrap Protocol


      3. The request can optionally contain the name of the server the
      client wishes to respond.  This is so the client can force the
      boot to occur from a specific host (e.g. if multiple versions of
      the same bootfile exist or if the server is in a far distant
      net/domain).  The client does not have to deal with name / domain
      services; instead this function is pushed off to the BOOTP server.

      4. The request can optionally contain the 'generic' filename to be
      booted.  For example 'unix' or 'ethertip'.  When the server sends
      the bootreply, it replaces this field with the fully qualified
      path name of the appropriate boot file.  In determining this name,
      the server may consult his own database correlating the client's
      address and filename request, with a particular boot file
      customized for that client.  If the bootrequest filename is a null
      string, then the server returns a filename field indicating the
      'default' file to be loaded for that client.

      5. In the case of clients who do not know their IP addresses, the
      server must also have a database relating hardware address to IP
      address.  This client IP address is then placed into a field in
      the bootreply.

      6. Certain network topologies (such as Stanford's) may be such
      that a given physical cable does not have a TFTP server directly
      attached to it (e.g. all the gateways and hosts on a certain cable
      may be diskless).  With the cooperation of neighboring gateways,
      BOOTP can allow clients to boot off of servers several hops away,
      through these gateways.  See the section 'Booting Through
      Gateways' below.  This part of the protocol requires no special
      action on the part of the client.  Implementation is optional and
      requires a small amount of additional code in gateways and
      servers.

3. Packet Format

   All numbers shown are decimal, unless indicated otherwise.  The BOOTP
   packet is enclosed in a standard IP [8] UDP [7] datagram.  For
   simplicity it is assumed that the BOOTP packet is never fragmented.
   Any numeric fields shown are packed in 'standard network byte order',
   i.e. high order bits are sent first.

   In the IP header of a bootrequest, the client fills in its own IP
   source address if known, otherwise zero.  When the server address is
   unknown, the IP destination address will be the 'broadcast address'
   255.255.255.255.  This address means 'broadcast on the local cable,
   (I don't know my net number)' [4].



Croft & Gilmore                                                 [Page 2]

RFC 951                                                   September 1985
Bootstrap Protocol


   The UDP header contains source and destination port numbers.  The
   BOOTP protocol uses two reserved port numbers, 'BOOTP client' (68)
   and 'BOOTP server' (67).  The client sends requests using 'BOOTP
   server' as the destination port; this is usually a broadcast.  The
   server sends replies using 'BOOTP client' as the destination port;
   depending on the kernel or driver facilities in the server, this may
   or may not be a broadcast (this is explained further in the section
   titled 'Chicken/Egg issues' below).  The reason TWO reserved ports
   are used, is to avoid 'waking up' and scheduling the BOOTP server
   daemons, when a bootreply must be broadcast to a client.  Since the
   server and other hosts won't be listening on the 'BOOTP client' port,
   any such incoming broadcasts will be filtered out at the kernel
   level.  We could not simply allow the client to pick a 'random' port
   number for the UDP source port field; since the server reply may be
   broadcast, a randomly chosen port number could confuse other hosts
   that happened to be listening on that port.

   The UDP length field is set to the length of the UDP plus BOOTP
   portions of the packet.  The UDP checksum field can be set to zero by
   the client (or server) if desired, to avoid this extra overhead in a
   PROM implementation.  In the 'Packet Processing' section below the
   phrase '[UDP checksum.]' is used whenever the checksum might be
   verified/computed.

      FIELD   BYTES   DESCRIPTION
      -----   -----   -----------

         op      1       packet op code / message type.
                         1 = BOOTREQUEST, 2 = BOOTREPLY

         htype   1       hardware address type,
                         see ARP section in ""Assigned Numbers"" RFC.
                         '1' = 10mb ethernet

         hlen    1       hardware address length
                         (eg '6' for 10mb ethernet).

         hops    1       client sets to zero,
                         optionally used by gateways
                         in cross-gateway booting.

         xid     4       transaction ID, a random number,
                         used to match this boot request with the
                         responses it generates.

         secs    2       filled in by client, seconds elapsed since
                         client started trying to boot.


Croft & Gilmore                                                 [Page 3]

RFC 951                                                   September 1985
Bootstrap Protocol


         --      2       unused

         ciaddr  4       client IP address;
                         filled in by client in bootrequest if known.

         yiaddr  4       'your' (client) IP address;
                         filled by server if client doesn't
                         know its own address (ciaddr was 0).

         siaddr  4       server IP address;
                         returned in bootreply by server.

         giaddr  4       gateway IP address,
                         used in optional cross-gateway booting.

         chaddr  16      client hardware address,
                         filled in by client.

         sname   64      optional server host name,
                         null terminated string.

         file    128     boot file name, null terminated string;
                         'generic' name or null in bootrequest,
                         fully qualified directory-path
                         name in bootreply.

         vend    64      optional vendor-specific area,
                         e.g. could be hardware type/serial on request,
                         or 'capability' / remote file system handle
                         on reply.  This info may be set aside for use
                         by a third phase bootstrap or kernel.

4. Chicken / Egg Issues

   How can the server send an IP datagram to the client, if the client
   doesnt know its own IP address (yet)?  Whenever a bootreply is being
   sent, the transmitting machine performs the following operations:

      1. If the client knows its own IP address ('ciaddr' field is
      nonzero), then the IP can be sent 'as normal', since the client
      will respond to ARPs [5].

      2. If the client does not yet know its IP address (ciaddr zero),
      then the client cannot respond to ARPs sent by the transmitter of
      the bootreply.  There are two options:

         a. If the transmitter has the necessary kernel or driver hooks


Croft & Gilmore                                                 [Page 4]

RFC 951                                                   September 1985
Bootstrap Protocol


         to 'manually' construct an ARP address cache entry, then it can
         fill in an entry using the 'chaddr' and 'yiaddr' fields.  Of
         course, this entry should have a timeout on it, just like any
         other entry made by the normal ARP code itself.  The
         transmitter of the bootreply can then simply send the bootreply
         to the client's IP address.  UNIX (4.2 BSD) has this
         capability.

         b. If the transmitter lacks these kernel hooks, it can simply
         send the bootreply to the IP broadcast address on the
         appropriate interface.  This is only one additional broadcast
         over the previous case.

5. Client Use of ARP

   The client PROM must contain a simple implementation of ARP, e.g. the
   address cache could be just one entry in size.  This will allow a
   second-phase-only boot (TFTP) to be performed when the client knows
   the IP addresses and bootfile name.

   Any time the client is expecting to receive a TFTP or BOOTP reply, it
   should be prepared to answer an ARP request for its own IP to
   hardware address mapping (if known).

   Since the bootreply will contain (in the hardware encapsulation) the
   hardware source address of the server/gateway, the client MAY be able
   to avoid sending an ARP request for the server/gateway IP address to
   be used in the following TFTP phase.  However this should be treated
   only as a special case, since it is desirable to still allow a
   second-phase-only boot as described above.

6. Comparison to RARP

   An earlier protocol, Reverse Address Resolution Protocol (RARP) [1]
   was proposed to allow a client to determine its IP address, given
   that it knew its hardware address.  However RARP had the disadvantage
   that it was a hardware link level protocol (not IP/UDP based).  This
   means that RARP could only be implemented on hosts containing special
   kernel or driver modifications to access these 'raw' packets.  Since
   there are many network kernels existent now, with each source
   maintained by different organizations, a boot protocol that does not
   require kernel modifications is a decided advantage.

   BOOTP provides this hardware to IP address lookup function, in
   addition to the other useful features described in the sections
   above.



Croft & Gilmore                                                 [Page 5]

RFC 951                                                   September 1985
Bootstrap Protocol


7. Packet Processing

   7.1. Client Transmission

      Before setting up the packet for the first time, it is a good idea
      to clear the entire packet buffer to all zeros; this will place
      all fields in their default state.  The client then creates a
      packet with the following fields.

      The IP destination address is set to 255.255.255.255.  (the
      broadcast address) or to the server's IP address (if known).  The
      IP source address and 'ciaddr' are set to the client's IP address
      if known, else 0.  The UDP header is set with the proper length;
      source port = 'BOOTP client' port destination port = 'BOOTP
      server' port.

      'op' is set to '1', BOOTREQUEST.  'htype' is set to the hardware
      address type as assigned in the ARP section of the ""Assigned
      Numbers"" RFC. 'hlen' is set to the length of the hardware address,
      e.g. '6' for 10mb ethernet.

      'xid' is set to a 'random' transaction id.  'secs' is set to the
      number of seconds that have elapsed since the client has started
      booting.  This will let the servers know how long a client has
      been trying.  As the number gets larger, certain servers may feel
      more 'sympathetic' towards a client they don't normally service.
      If a client lacks a suitable clock, it could construct a rough
      estimate using a loop timer.  Or it could choose to simply send
      this field as always a fixed value, say 100 seconds.

      If the client knows its IP address, 'ciaddr' (and the IP source
      address) are set to this value.  'chaddr' is filled in with the
      client's hardware address.

      If the client wishes to restrict booting to a particular server
      name, it may place a null-terminated string in 'sname'.  The name
      used should be any of the allowable names or nicknames of the
      desired host.

      The client has several options for filling the 'file' name field.
      If left null, the meaning is 'I want to boot the default file for
      my machine'.  A null file name can also mean 'I am only interested
      in finding out client/server/gateway IP addresses, I dont care
      about file names'.

      The field can also be a 'generic' name such as 'unix' or



Croft & Gilmore                                                 [Page 6]

RFC 951                                                   September 1985
Bootstrap Protocol


      'gateway'; this means 'boot the named program configured for my
      machine'.  Finally the field can be a fully directory qualified
      path name.

      The 'vend' field can be filled in by the client with
      vendor-specific strings or structures.  For example the machine
      hardware type or serial number may be placed here.  However the
      operation of the BOOTP server should not DEPEND on this
      information existing.

      If the 'vend' field is used, it is recommended that a 4 byte
      'magic number' be the first item within 'vend'.  This lets a
      server determine what kind of information it is seeing in this
      field.  Numbers can be assigned by the usual 'magic number'
      process --you pick one and it's magic.  A different magic number
      could be used for bootreply's than bootrequest's to allow the
      client to take special action with the reply information.

      [UDP checksum.]

   7.2. Client Retransmission Strategy

      If no reply is received for a certain length of time, the client
      should retransmit the request.  The time interval must be chosen
      carefully so as not to flood the network.  Consider the case of a
      cable containing 100 machines that are just coming up after a
      power failure.  Simply retransmitting the request every four
      seconds will inundate the net.

      As a possible strategy, you might consider backing off
      exponentially, similar to the way ethernet backs off on a
      collision.  So for example if the first packet is at time 0:00,
      the second would be at :04, then :08, then :16, then :32, then
      :64.  You should also randomize each time; this would be done
      similar to the ethernet specification by starting with a mask and
      'and'ing that with with a random number to get the first backoff.
      On each succeeding backoff, the mask is increased in length by one
      bit.  This doubles the average delay on each backoff.

      After the 'average' backoff reaches about 60 seconds, it should be
      increased no further, but still randomized.

      Before each retransmission, the client should update the 'secs'
      field. [UDP checksum.]





Croft & Gilmore                                                 [Page 7]

RFC 951                                                   September 1985
Bootstrap Protocol


   7.3. Server Receives BOOTREQUEST

      [UDP checksum.]  If the UDP destination port does not match the
      'BOOTP server' port, discard the packet.

      If the server name field (sname) is null (no particular server
      specified), or sname is specified and matches our name or
      nickname, then continue with packet processing.

      If the sname field is specified, but does not match 'us', then
      there are several options:

         1. You may choose to simply discard this packet.

         2. If a name lookup on sname shows it to be on this same cable,
         discard the packet.

         3. If sname is on a different net, you may choose to forward
         the packet to that address.  If so, check the 'giaddr' (gateway
         address) field.  If 'giaddr' is zero, fill it in with my
         address or the address of a gateway that can be used to get to
         that net.  Then forward the packet.

      If the client IP address (ciaddr) is zero, then the client does
      not know its own IP address.  Attempt to lookup the client
      hardware address (chaddr, hlen, htype) in our database.  If no
      match is found, discard the packet.  Otherwise we now have an IP
      address for this client; fill it into the 'yiaddr' (your IP
      address) field.

      We now check the boot file name field (file).  The field will be
      null if the client is not interested in filenames, or wants the
      default bootfile.  If the field is non-null, it is used as a
      lookup key in a database, along with the client's IP address.  If
      there is a default file or generic file (possibly indexed by the
      client address) or a fully-specified path name that matches, then
      replace the 'file' field with the fully-specified path name of the
      selected boot file.  If the field is non-null and no match was
      found, then the client is asking for a file we dont have; discard
      the packet, perhaps some other BOOTP server will have it.

      The 'vend' vendor-specific data field should now be checked and if
      a recognized type of data is provided, client-specific actions
      should be taken, and a response placed in the 'vend' data field of
      the reply packet.  For example, a workstation client could provide




Croft & Gilmore                                                 [Page 8]

RFC 951                                                   September 1985
Bootstrap Protocol


      an authentication key and receive from the server a capability for
      remote file access, or a set of configuration options, which can
      be passed to the operating system that will shortly be booted in.

      Place my (server) IP address in the 'siaddr' field.  Set the 'op'
      field to BOOTREPLY.  The UDP destination port is set to 'BOOTP
      client'.  If the client address 'ciaddr' is nonzero, send the
      packet there; else if the gateway address 'giaddr' is nonzero, set
      the UDP destination port to 'BOOTP server' and send the packet to
      'giaddr'; else the client is on one of our cables but it doesnt
      know its own IP address yet --use a method described in the 'Egg'
      section above to send it to the client. If 'Egg' is used and we
      have multiple interfaces on this host, use the 'yiaddr' (your IP
      address) field to figure out which net (cable/interface) to send
      the packet to.  [UDP checksum.]

   7.4. Server/Gateway Receives BOOTREPLY

      [UDP checksum.]  If 'yiaddr' (your [the client's] IP address)
      refers to one of our cables, use one of the 'Egg' methods above to
      forward it to the client.  Be sure to send it to the 'BOOTP
      client' UDP destination port.

   7.5. Client Reception

      Don't forget to process ARP requests for my own IP address (if I
      know it).  [UDP checksum.]  The client should discard incoming
      packets that: are not IP/UDPs addressed to the boot port; are not
      BOOTREPLYs; do not match my IP address (if I know it) or my
      hardware address; do not match my transaction id.  Otherwise we
      have received a successful reply. 'yiaddr' will contain my IP
      address, if I didnt know it before.  'file' is the name of the
      file name to TFTP 'read request'.  The server address is in
      'siaddr'.  If 'giaddr' (gateway address) is nonzero, then the
      packets should be forwarded there first, in order to get to the
      server.

8. Booting Through Gateways

   This part of the protocol is optional and requires some additional
   code in cooperating gateways and servers, but it allows cross-gateway
   booting.  This is mainly useful when gateways are diskless machines.
   Gateways containing disks (e.g. a UNIX machine acting as a gateway),
   might as well run their own BOOTP/TFTP servers.

   Gateways listening to broadcast BOOTREQUESTs may decide to forward or
   rebroadcast these requests 'when appropriate'.  For example, the


Croft & Gilmore                                                 [Page 9]

RFC 951                                                   September 1985
Bootstrap Protocol


   gateway could have, as part of his configuration tables, a list of
   other networks or hosts to receive a copy of any broadcast
   BOOTREQUESTs.  Even though a 'hops' field exists, it is a poor idea
   to simply globally rebroadcast the requests, since broadcast loops
   will almost certainly occur.

   The forwarding could begin immediately, or wait until the 'secs'
   (seconds client has been trying) field passes a certain threshold.

   If a gateway does decide to forward the request, it should look at
   the 'giaddr' (gateway IP address) field.  If zero, it should plug its
   own IP address (on the receiving cable) into this field.  It may also
   use the 'hops' field to optionally control how far the packet is
   reforwarded. Hops should be incremented on each forwarding.  For
   example, if hops passes '3', the packet should probably be discarded.
   [UDP checksum.]

   Here we have recommended placing this special forwarding function in
   the gateways.  But that does not have to be the case.  As long as
   some 'BOOTP forwarding agent' exists on the net with the booting
   client, the agent can do the forwarding when appropriate.  Thus this
   service may or may not be co-located with the gateway.

   In the case of a forwarding agent not located in the gateway, the
   agent could save himself some work by plugging the broadcast address
   of the interface receiving the bootrequest into the 'giaddr' field.
   Thus the reply would get forwarded using normal gateways, not
   involving the forwarding agent.  Of course the disadvantage here is
   that you lose the ability to use the 'Egg' non-broadcast method of
   sending the reply, causing extra overhead for every host on the
   client cable.

9. Sample BOOTP Server Database

   As a suggestion, we show a sample text file database that the BOOTP
   server program might use.  The database has two sections, delimited
   by a line containing an percent in column 1.  The first section
   contains a 'default directory' and mappings from generic names to
   directory/pathnames.  The first generic name in this section is the
   'default file' you get when the bootrequest contains a null 'file'
   string.

   The second section maps hardware addresstype/address into an
   ipaddress. Optionally you can also overide the default generic name
   by supplying a ipaddress specific genericname.  A 'suffix' item is
   also an option; if supplied, any generic names specified by the
   client will be accessed by first appending 'suffix' to the 'pathname'


Croft & Gilmore                                                [Page 10]

RFC 951                                                   September 1985
Bootstrap Protocol


   appropriate to that generic name.  If that file is not found, then
   the plain 'pathname' will be tried.  This 'suffix' option allows a
   whole set of custom generics to be setup without a lot of effort.
   Below is shown the general format; fields are delimited by one or
   more spaces or tabs; trailing empty fields may be omitted; blank
   lines and lines beginning with '#' are ignored.

      # comment line

      homedirectory
      genericname1    pathname1
      genericname2    pathname2
      ...

      % end of generic names, start of address mappings

      hostname1 hardwaretype hardwareaddr1 ipaddr1 genericname suffix
      hostname2 hardwaretype hardwareaddr2 ipaddr2 genericname suffix
      ...

   Here is a specific example.  Note the 'hardwaretype' number is the
   same as that shown in the ARP section of the 'Assigned Numbers' RFC.
   The 'hardwaretype' and 'ipaddr' numbers are in decimal;
   'hardwareaddr' is in hex.

      # last updated by smith

      /usr/boot
      vmunix          vmunix
      tip             ethertip
      watch           /usr/diag/etherwatch
      gate            gate.

      % end of generic names, start of address mappings

      hamilton        1 02.60.8c.06.34.98     36.19.0.5
      burr            1 02.60.8c.34.11.78     36.44.0.12
      101-gateway     1 02.60.8c.23.ab.35     36.44.0.32      gate 101
      mjh-gateway     1 02.60.8c.12.32.bc     36.42.0.64      gate mjh
      welch-tipa      1 02.60.8c.22.65.32     36.47.0.14      tip
      welch-tipb      1 02.60.8c.12.15.c8     36.46.0.12      tip

   In the example above, if 'mjh-gateway' does a default boot, it will
   get the file '/usr/boot/gate.mjh'.





Croft & Gilmore                                                [Page 11]

RFC 951                                                   September 1985
Bootstrap Protocol


10. Acknowledgements

   Ross Finlayson (et. al.) produced two earlier RFC's discussing TFTP
   bootstraping [2] using RARP [1].

   We would also like to acknowledge the previous work and comments of
   Noel Chiappa, Bob Lyon, Jeff Mogul, Mark Lewis, and David Plummer.

REFERENCES

   1.  Ross Finlayson, Timothy Mann, Jeffrey Mogul, Marvin Theimer.  A
       Reverse Address Resolution Protocol.  RFC 903, NIC, June, 1984.

   2.  Ross Finlayson.  Bootstrap Loading using TFTP.  RFC 906, NIC,
       June, 1984.

   3.  Mark Lottor.  Simple File Transfer Protocol.  RFC 913, NIC,
       September, 1984.

   4.  Jeffrey Mogul.  Broadcasting Internet Packets.  RFC 919, NIC,
       October, 1984.

   5.  David Plummer.  An Ethernet Address Resolution Protocol.  RFC
       826, NIC, September, 1982.

   6.  Jon Postel.  File Transfer Protocol.  RFC 765, NIC, June, 1980.

   7.  Jon Postel.  User Datagram Protocol.  RFC 768, NIC, August, 1980.

   8.  Jon Postel.  Internet Protocol.  RFC 791, NIC, September, 1981.

   9.  K. R. Sollins, Noel Chiappa.  The TFTP Protocol.  RFC 783, NIC,
       June, 1981.
















Croft & Gilmore                                                [Page 12]

"
RFC9110,"



RFC 9110
HTTP Semantics
June 2022


Fielding, et al.
Standards Track
[Page]





Stream:
Internet Engineering Task Force (IETF)
RFC:
9110
STD:
97
Obsoletes:

2818, 7230, 7231, 7232, 7233, 7235, 7538, 7615, 7694 
Updates:

3864 
Category:
Standards Track
Published:

June 2022

ISSN:
2070-1721
Authors:


R. Fielding, Ed.

Adobe


M. Nottingham, Ed.

Fastly


J. Reschke, Ed.

greenbytes




RFC 9110
HTTP Semantics

Abstract

   The Hypertext Transfer Protocol (HTTP) is a stateless application-level
   protocol for distributed, collaborative, hypertext information systems.
   This document describes the overall architecture of HTTP, establishes common
   terminology, and defines aspects of the protocol that are shared by all
   versions. In this definition are core protocol elements, extensibility
   mechanisms, and the ""http"" and ""https"" Uniform Resource Identifier (URI)
   schemes.¶

   This document updates RFC 3864 and
   obsoletes RFCs 2818, 7231, 7232, 7233,
   7235, 7538, 7615, 7694, and portions of 7230.¶




Status of This Memo


            This is an Internet Standards Track document.¶

            This document is a product of the Internet Engineering Task Force
            (IETF).  It represents the consensus of the IETF community.  It has
            received public review and has been approved for publication by
            the Internet Engineering Steering Group (IESG).  Further
            information on Internet Standards is available in Section 2 of 
            RFC 7841.¶

            Information about the current status of this document, any
            errata, and how to provide feedback on it may be obtained at
            https://www.rfc-editor.org/info/rfc9110.¶





Copyright Notice


            Copyright (c) 2022 IETF Trust and the persons identified as the
            document authors. All rights reserved.¶

            This document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (https://trustee.ietf.org/license-info) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document. Code Components extracted from this
            document must include Revised BSD License text as described in
            Section 4.e of the Trust Legal Provisions and are provided without
            warranty as described in the Revised BSD License.¶

            This document may contain material from IETF Documents or IETF
            Contributions published or made publicly available before November
            10, 2008. The person(s) controlling the copyright in some of this
            material may not have granted the IETF Trust the right to allow
            modifications of such material outside the IETF Standards Process.
            Without obtaining an adequate license from the person(s)
            controlling the copyright in such materials, this document may not
            be modified outside the IETF Standards Process, and derivative
            works of it may not be created outside the IETF Standards Process,
            except to format it for publication as an RFC or to translate it
            into languages other than English.¶




▲
Table of Contents



1.  Introduction


1.1.  Purpose


1.2.  History and Evolution


1.3.  Core Semantics


1.4.  Specifications Obsoleted by This Document




2.  Conformance


2.1.  Syntax Notation


2.2.  Requirements Notation


2.3.  Length Requirements


2.4.  Error Handling


2.5.  Protocol Version




3.  Terminology and Core Concepts


3.1.  Resources


3.2.  Representations


3.3.  Connections, Clients, and Servers


3.4.  Messages


3.5.  User Agents


3.6.  Origin Server


3.7.  Intermediaries


3.8.  Caches


3.9.  Example Message Exchange




4.  Identifiers in HTTP


4.1.  URI References


4.2.  HTTP-Related URI Schemes


4.2.1.  http URI Scheme


4.2.2.  https URI Scheme


4.2.3.  http(s) Normalization and Comparison


4.2.4.  Deprecation of userinfo in http(s) URIs


4.2.5.  http(s) References with Fragment Identifiers




4.3.  Authoritative Access


4.3.1.  URI Origin


4.3.2.  http Origins


4.3.3.  https Origins


4.3.4.  https Certificate Verification


4.3.5.  IP-ID Reference Identity






5.  Fields


5.1.  Field Names


5.2.  Field Lines and Combined Field Value


5.3.  Field Order


5.4.  Field Limits


5.5.  Field Values


5.6.  Common Rules for Defining Field Values


5.6.1.  Lists (#rule ABNF Extension)


5.6.1.1.  Sender Requirements


5.6.1.2.  Recipient Requirements




5.6.2.  Tokens


5.6.3.  Whitespace


5.6.4.  Quoted Strings


5.6.5.  Comments


5.6.6.  Parameters


5.6.7.  Date/Time Formats






6.  Message Abstraction


6.1.  Framing and Completeness


6.2.  Control Data


6.3.  Header Fields


6.4.  Content


6.4.1.  Content Semantics


6.4.2.  Identifying Content




6.5.  Trailer Fields


6.5.1.  Limitations on Use of Trailers


6.5.2.  Processing Trailer Fields




6.6.  Message Metadata


6.6.1.  Date


6.6.2.  Trailer






7.  Routing HTTP Messages


7.1.  Determining the Target Resource


7.2.  Host and :authority


7.3.  Routing Inbound Requests


7.3.1.  To a Cache


7.3.2.  To a Proxy


7.3.3.  To the Origin




7.4.  Rejecting Misdirected Requests


7.5.  Response Correlation


7.6.  Message Forwarding


7.6.1.  Connection


7.6.2.  Max-Forwards


7.6.3.  Via




7.7.  Message Transformations


7.8.  Upgrade




8.  Representation Data and Metadata


8.1.  Representation Data


8.2.  Representation Metadata


8.3.  Content-Type


8.3.1.  Media Type


8.3.2.  Charset


8.3.3.  Multipart Types




8.4.  Content-Encoding


8.4.1.  Content Codings


8.4.1.1.  Compress Coding


8.4.1.2.  Deflate Coding


8.4.1.3.  Gzip Coding






8.5.  Content-Language


8.5.1.  Language Tags




8.6.  Content-Length


8.7.  Content-Location


8.8.  Validator Fields


8.8.1.  Weak versus Strong


8.8.2.  Last-Modified


8.8.2.1.  Generation


8.8.2.2.  Comparison




8.8.3.  ETag


8.8.3.1.  Generation


8.8.3.2.  Comparison


8.8.3.3.  Example: Entity Tags Varying on Content-Negotiated Resources








9.  Methods


9.1.  Overview


9.2.  Common Method Properties


9.2.1.  Safe Methods


9.2.2.  Idempotent Methods


9.2.3.  Methods and Caching




9.3.  Method Definitions


9.3.1.  GET


9.3.2.  HEAD


9.3.3.  POST


9.3.4.  PUT


9.3.5.  DELETE


9.3.6.  CONNECT


9.3.7.  OPTIONS


9.3.8.  TRACE






10. Message Context


10.1.  Request Context Fields


10.1.1.  Expect


10.1.2.  From


10.1.3.  Referer


10.1.4.  TE


10.1.5.  User-Agent




10.2.  Response Context Fields


10.2.1.  Allow


10.2.2.  Location


10.2.3.  Retry-After


10.2.4.  Server






11. HTTP Authentication


11.1.  Authentication Scheme


11.2.  Authentication Parameters


11.3.  Challenge and Response


11.4.  Credentials


11.5.  Establishing a Protection Space (Realm)


11.6.  Authenticating Users to Origin Servers


11.6.1.  WWW-Authenticate


11.6.2.  Authorization


11.6.3.  Authentication-Info




11.7.  Authenticating Clients to Proxies


11.7.1.  Proxy-Authenticate


11.7.2.  Proxy-Authorization


11.7.3.  Proxy-Authentication-Info






12. Content Negotiation


12.1.  Proactive Negotiation


12.2.  Reactive Negotiation


12.3.  Request Content Negotiation


12.4.  Content Negotiation Field Features


12.4.1.  Absence


12.4.2.  Quality Values


12.4.3.  Wildcard Values




12.5.  Content Negotiation Fields


12.5.1.  Accept


12.5.2.  Accept-Charset


12.5.3.  Accept-Encoding


12.5.4.  Accept-Language


12.5.5.  Vary






13. Conditional Requests


13.1.  Preconditions


13.1.1.  If-Match


13.1.2.  If-None-Match


13.1.3.  If-Modified-Since


13.1.4.  If-Unmodified-Since


13.1.5.  If-Range




13.2.  Evaluation of Preconditions


13.2.1.  When to Evaluate


13.2.2.  Precedence of Preconditions






14. Range Requests


14.1.  Range Units


14.1.1.  Range Specifiers


14.1.2.  Byte Ranges




14.2.  Range


14.3.  Accept-Ranges


14.4.  Content-Range


14.5.  Partial PUT


14.6.  Media Type multipart/byteranges




15. Status Codes


15.1.  Overview of Status Codes


15.2.  Informational 1xx


15.2.1.  100 Continue


15.2.2.  101 Switching Protocols




15.3.  Successful 2xx


15.3.1.  200 OK


15.3.2.  201 Created


15.3.3.  202 Accepted


15.3.4.  203 Non-Authoritative Information


15.3.5.  204 No Content


15.3.6.  205 Reset Content


15.3.7.  206 Partial Content


15.3.7.1.  Single Part


15.3.7.2.  Multiple Parts


15.3.7.3.  Combining Parts






15.4.  Redirection 3xx


15.4.1.  300 Multiple Choices


15.4.2.  301 Moved Permanently


15.4.3.  302 Found


15.4.4.  303 See Other


15.4.5.  304 Not Modified


15.4.6.  305 Use Proxy


15.4.7.  306 (Unused)


15.4.8.  307 Temporary Redirect


15.4.9.  308 Permanent Redirect




15.5.  Client Error 4xx


15.5.1.  400 Bad Request


15.5.2.  401 Unauthorized


15.5.3.  402 Payment Required


15.5.4.  403 Forbidden


15.5.5.  404 Not Found


15.5.6.  405 Method Not Allowed


15.5.7.  406 Not Acceptable


15.5.8.  407 Proxy Authentication Required


15.5.9.  408 Request Timeout


15.5.10. 409 Conflict


15.5.11. 410 Gone


15.5.12. 411 Length Required


15.5.13. 412 Precondition Failed


15.5.14. 413 Content Too Large


15.5.15. 414 URI Too Long


15.5.16. 415 Unsupported Media Type


15.5.17. 416 Range Not Satisfiable


15.5.18. 417 Expectation Failed


15.5.19. 418 (Unused)


15.5.20. 421 Misdirected Request


15.5.21. 422 Unprocessable Content


15.5.22. 426 Upgrade Required




15.6.  Server Error 5xx


15.6.1.  500 Internal Server Error


15.6.2.  501 Not Implemented


15.6.3.  502 Bad Gateway


15.6.4.  503 Service Unavailable


15.6.5.  504 Gateway Timeout


15.6.6.  505 HTTP Version Not Supported






16. Extending HTTP


16.1.  Method Extensibility


16.1.1.  Method Registry


16.1.2.  Considerations for New Methods




16.2.  Status Code Extensibility


16.2.1.  Status Code Registry


16.2.2.  Considerations for New Status Codes




16.3.  Field Extensibility


16.3.1.  Field Name Registry


16.3.2.  Considerations for New Fields


16.3.2.1.  Considerations for New Field Names


16.3.2.2.  Considerations for New Field Values






16.4.  Authentication Scheme Extensibility


16.4.1.  Authentication Scheme Registry


16.4.2.  Considerations for New Authentication Schemes




16.5.  Range Unit Extensibility


16.5.1.  Range Unit Registry


16.5.2.  Considerations for New Range Units




16.6.  Content Coding Extensibility


16.6.1.  Content Coding Registry


16.6.2.  Considerations for New Content Codings




16.7.  Upgrade Token Registry




17. Security Considerations


17.1.  Establishing Authority


17.2.  Risks of Intermediaries


17.3.  Attacks Based on File and Path Names


17.4.  Attacks Based on Command, Code, or Query Injection


17.5.  Attacks via Protocol Element Length


17.6.  Attacks Using Shared-Dictionary Compression


17.7.  Disclosure of Personal Information


17.8.  Privacy of Server Log Information


17.9.  Disclosure of Sensitive Information in URIs


17.10. Application Handling of Field Names


17.11. Disclosure of Fragment after Redirects


17.12. Disclosure of Product Information


17.13. Browser Fingerprinting


17.14. Validator Retention


17.15. Denial-of-Service Attacks Using Range


17.16. Authentication Considerations


17.16.1.  Confidentiality of Credentials


17.16.2.  Credentials and Idle Clients


17.16.3.  Protection Spaces


17.16.4.  Additional Response Fields






18. IANA Considerations


18.1.  URI Scheme Registration


18.2.  Method Registration


18.3.  Status Code Registration


18.4.  Field Name Registration


18.5.  Authentication Scheme Registration


18.6.  Content Coding Registration


18.7.  Range Unit Registration


18.8.  Media Type Registration


18.9.  Port Registration


18.10. Upgrade Token Registration




19. References


19.1.  Normative References


19.2.  Informative References




Appendix A.  Collected ABNF


Appendix B.  Changes from Previous RFCs


B.1.  Changes from RFC 2818


B.2.  Changes from RFC 7230


B.3.  Changes from RFC 7231


B.4.  Changes from RFC 7232


B.5.  Changes from RFC 7233


B.6.  Changes from RFC 7235


B.7.  Changes from RFC 7538


B.8.  Changes from RFC 7615


B.9.  Changes from RFC 7694




Acknowledgements


Index


Authors' Addresses








1. Introduction




1.1. Purpose


   The Hypertext Transfer Protocol (HTTP) is a family of stateless,
   application-level, request/response protocols that share a generic interface,
   extensible semantics, and self-descriptive messages to enable flexible
   interaction with network-based hypertext information systems.¶

   HTTP hides the details of how a service is implemented by presenting a
   uniform interface to clients that is independent of the types of resources
   provided. Likewise, servers do not need to be aware of each client's
   purpose: a request can be considered in isolation rather than being
   associated with a specific type of client or a predetermined sequence of
   application steps. This allows general-purpose implementations to be used
   effectively in many different contexts, reduces interaction complexity, and
   enables independent evolution over time.¶

   HTTP is also designed for use as an intermediation protocol, wherein
   proxies and gateways can translate non-HTTP information systems into a
   more generic interface.¶

   One consequence of this flexibility is that the protocol cannot be
   defined in terms of what occurs behind the interface. Instead, we
   are limited to defining the syntax of communication, the intent
   of received communication, and the expected behavior of recipients.
   If the communication is considered in isolation, then successful
   actions ought to be reflected in corresponding changes to the
   observable interface provided by servers. However, since multiple
   clients might act in parallel and perhaps at cross-purposes, we
   cannot require that such changes be observable beyond the scope
   of a single response.¶





1.2. History and Evolution


   HTTP has been the primary information transfer protocol for the World   
   Wide Web since its introduction in 1990.  It began as a trivial
   mechanism for low-latency requests, with a single method (GET) to 
   request transfer of a presumed hypertext document identified by a given pathname.
   As the Web grew, HTTP was extended to enclose requests and responses within
   messages, transfer arbitrary data formats using MIME-like media types, and
   route requests through intermediaries. These protocols were eventually
   defined as HTTP/0.9 and HTTP/1.0 (see [HTTP/1.0]).¶

   HTTP/1.1 was designed to refine the protocol's features while retaining
   compatibility with the existing text-based messaging syntax, improving
   its interoperability, scalability, and robustness across the Internet.
   This included length-based data delimiters for both fixed and dynamic
   (chunked) content, a consistent framework for content negotiation,
   opaque validators for conditional requests, cache controls for better
   cache consistency, range requests for partial updates, and default
   persistent connections. HTTP/1.1 was introduced in 1995 and published on
   the Standards Track in 1997 [RFC2068], revised in
   1999 [RFC2616], and revised again in 2014
   ([RFC7230] through [RFC7235]).¶

   HTTP/2 ([HTTP/2]) introduced a multiplexed session layer
   on top of the existing TLS and TCP protocols for exchanging concurrent
   HTTP messages with efficient field compression and server push.
   HTTP/3 ([HTTP/3]) provides greater independence for concurrent
   messages by using QUIC as a secure multiplexed transport over UDP instead of
   TCP.¶

   All three major versions of HTTP rely on the semantics defined by
   this document. They have not obsoleted each other because each one has
   specific benefits and limitations depending on the context of use.
   Implementations are expected to choose the most appropriate transport and
   messaging syntax for their particular context.¶

   This revision of HTTP separates the definition of semantics (this document)
   and caching ([CACHING]) from the current HTTP/1.1 messaging
   syntax ([HTTP/1.1]) to allow each major protocol version
   to progress independently while referring to the same core semantics.¶





1.3. Core Semantics


   HTTP provides a uniform interface for interacting with a resource
   (Section 3.1) -- regardless of its type, nature, or
   implementation -- by sending messages that manipulate or transfer
   representations (Section 3.2).¶

   Each message is either a request or a response. A client constructs request
   messages that communicate its intentions and routes those messages toward
   an identified origin server. A server listens for requests, parses each
   message received, interprets the message semantics in relation to the
   identified target resource, and responds to that request with one or more
   response messages. The client examines received responses to see if its
   intentions were carried out, determining what to do next based on the
   status codes and content received.¶

   HTTP semantics include the intentions defined by each request method
   (Section 9), extensions to those semantics that might be
   described in request header fields,
   status codes that describe the response (Section 15), and
   other control data and resource metadata that might be given in response
   fields.¶


   Semantics also include representation metadata that describe how
   content is intended to be interpreted by a recipient, request header
   fields that might influence content selection, and the various selection
   algorithms that are collectively referred to as
   ""content negotiation"" (Section 12).¶





1.4. Specifications Obsoleted by This Document


Table 1


Title
Reference
See




HTTP Over TLS

[RFC2818]


B.1



HTTP/1.1 Message Syntax and Routing [*]

[RFC7230]


B.2



HTTP/1.1 Semantics and Content

[RFC7231]


B.3



HTTP/1.1 Conditional Requests

[RFC7232]


B.4



HTTP/1.1 Range Requests

[RFC7233]


B.5



HTTP/1.1 Authentication

[RFC7235]


B.6



HTTP Status Code 308 (Permanent Redirect)

[RFC7538]


B.7



HTTP Authentication-Info and Proxy-Authentication-Info
          Response Header Fields

[RFC7615]


B.8



HTTP Client-Initiated Content-Encoding

[RFC7694]


B.9





   [*] This document only obsoletes the portions of
   RFC 7230 that are independent of
   the HTTP/1.1 messaging syntax and connection management; the remaining
   bits of RFC 7230 are
   obsoleted by ""HTTP/1.1"" [HTTP/1.1].¶







2. Conformance




2.1. Syntax Notation














   This specification uses the Augmented Backus-Naur Form (ABNF) notation of
   [RFC5234], extended with the notation for case-sensitivity
   in strings defined in [RFC7405].¶

   It also uses a list extension, defined in Section 5.6.1,
   that allows for compact definition of comma-separated lists using a ""#""
   operator (similar to how the ""*"" operator indicates repetition). Appendix A shows the collected grammar with all list
   operators expanded to standard ABNF notation.¶

   As a convention, ABNF rule names prefixed with ""obs-"" denote
   obsolete grammar rules that appear for historical reasons.¶


  
  
  
  
  
  
  
  
  
  
  
  
  The following core rules are included by
  reference, as defined in Appendix B.1 of [RFC5234]:
  ALPHA (letters), CR (carriage return), CRLF (CR LF), CTL (controls),
  DIGIT (decimal 0-9), DQUOTE (double quote),
  HEXDIG (hexadecimal 0-9/A-F/a-f), HTAB (horizontal tab), LF (line feed),
  OCTET (any 8-bit sequence of data), SP (space), and
  VCHAR (any visible US-ASCII character).¶


Section 5.6 defines some generic syntactic
   components for field values.¶

   This specification uses the terms
   ""character"",
   ""character encoding scheme"",
   ""charset"", and
   ""protocol element""
   as they are defined in [RFC6365].¶





2.2. Requirements Notation


    The key words ""MUST"", ""MUST NOT"",
    ""REQUIRED"", ""SHALL"", ""SHALL NOT"",
    ""SHOULD"", ""SHOULD NOT"",
    ""RECOMMENDED"", ""NOT RECOMMENDED"",
    ""MAY"", and ""OPTIONAL"" in this document are to be
    interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as
    shown here.¶

   This specification targets conformance criteria according to the role of
   a participant in HTTP communication.  Hence, requirements are placed
   on senders, recipients, clients, servers, user agents, intermediaries,
   origin servers, proxies, gateways, or caches, depending on what behavior
   is being constrained by the requirement. Additional requirements
   are placed on implementations, resource owners, and protocol element
   registrations when they apply beyond the scope of a single communication.¶

   The verb ""generate"" is used instead of ""send"" where a requirement applies
   only to implementations that create the protocol element, rather than an
   implementation that forwards a received element downstream.¶

   An implementation is considered conformant if it complies with all of the
   requirements associated with the roles it partakes in HTTP.¶

   A sender MUST NOT generate protocol elements that do not match the grammar
   defined by the corresponding ABNF rules.
   Within a given message, a sender MUST NOT generate protocol elements or
   syntax alternatives that are only allowed to be generated by participants in
   other roles (i.e., a role that the sender does not have for that message).¶

   Conformance to HTTP includes both conformance to the particular messaging
   syntax of the protocol version in use and conformance to the semantics of
   protocol elements sent. For example, a client that claims conformance to
   HTTP/1.1 but fails to recognize the features required of HTTP/1.1
   recipients will fail to interoperate with servers that adjust their
   responses in accordance with those claims.
   Features that reflect user choices, such as content negotiation and
   user-selected extensions, can impact application behavior beyond the
   protocol stream; sending protocol elements that inaccurately reflect a
   user's choices will confuse the user and inhibit choice.¶

   When an implementation fails semantic conformance, recipients of that
   implementation's messages will eventually develop workarounds to adjust
   their behavior accordingly. A recipient MAY employ such workarounds while
   remaining conformant to this protocol if the workarounds are limited to the
   implementations at fault. For example, servers often scan portions of the
   User-Agent field value, and user agents often scan the Server field value,
   to adjust their own behavior with respect to known bugs or poorly chosen
   defaults.¶





2.3. Length Requirements


   A recipient SHOULD parse a received protocol element defensively, with
   only marginal expectations that the element will conform to its ABNF
   grammar and fit within a reasonable buffer size.¶

   HTTP does not have specific length limitations for many of its protocol
   elements because the lengths that might be appropriate will vary widely,
   depending on the deployment context and purpose of the implementation.
   Hence, interoperability between senders and recipients depends on shared
   expectations regarding what is a reasonable length for each protocol
   element. Furthermore, what is commonly understood to be a reasonable length
   for some protocol elements has changed over the course of the past three
   decades of HTTP use and is expected to continue changing in the future.¶

   At a minimum, a recipient MUST be able to parse and process protocol
   element lengths that are at least as long as the values that it generates
   for those same protocol elements in other messages. For example, an origin
   server that publishes very long URI references to its own resources needs
   to be able to parse and process those same references when received as a
   target URI.¶

   Many received protocol elements are only parsed to the extent necessary to
   identify and forward that element downstream. For example, an intermediary
   might parse a received field into its field name and field value components,
   but then forward the field without further parsing inside the field value.¶





2.4. Error Handling


   A recipient MUST interpret a received protocol element according to the
   semantics defined for it by this specification, including extensions to
   this specification, unless the recipient has determined (through experience
   or configuration) that the sender incorrectly implements what is implied by
   those semantics.
   For example, an origin server might disregard the contents of a received
   Accept-Encoding header field if inspection of the
   User-Agent header field indicates a specific implementation
   version that is known to fail on receipt of certain content codings.¶

   Unless noted otherwise, a recipient MAY attempt to recover a usable
   protocol element from an invalid construct.  HTTP does not define
   specific error handling mechanisms except when they have a direct impact
   on security, since different applications of the protocol require
   different error handling strategies.  For example, a Web browser might
   wish to transparently recover from a response where the
   Location header field doesn't parse according to the ABNF,
   whereas a systems control client might consider any form of error recovery
   to be dangerous.¶

   Some requests can be automatically retried by a client in the event of
   an underlying connection failure, as described in
   Section 9.2.2.¶





2.5. Protocol Version


   HTTP's version number consists of two decimal digits separated by a "".""
   (period or decimal point). The first digit (major version) indicates the
   messaging syntax, whereas the second digit (minor version)
   indicates the highest minor version within that major version to which the
   sender is conformant (able to understand for future communication).¶

   While HTTP's core semantics don't change between protocol versions, their
   expression ""on the wire"" can change, and so the
   HTTP version number changes when incompatible changes are made to the wire
   format. Additionally, HTTP allows incremental, backwards-compatible
   changes to be made to the protocol without changing its version through
   the use of defined extension points (Section 16).¶

   The protocol version as a whole indicates the sender's conformance with
   the set of requirements laid out in that version's corresponding
   specification(s).
   For example, the version ""HTTP/1.1"" is defined by the combined
   specifications of this document, ""HTTP Caching"" [CACHING],
   and ""HTTP/1.1"" [HTTP/1.1].¶

   HTTP's major version number is incremented when an incompatible message
   syntax is introduced. The minor number is incremented when changes made to
   the protocol have the effect of adding to the message semantics or
   implying additional capabilities of the sender.¶

   The minor version advertises the sender's communication capabilities even
   when the sender is only using a backwards-compatible subset of the
   protocol, thereby letting the recipient know that more advanced features
   can be used in response (by servers) or in future requests (by clients).¶

   When a major version of HTTP does not define any minor versions, the minor
   version ""0"" is implied. The ""0"" is used when referring to that protocol
   within elements that require a minor version identifier.¶







3. Terminology and Core Concepts


   HTTP was created for the World Wide Web (WWW) architecture
   and has evolved over time to support the scalability needs of a worldwide
   hypertext system. Much of that architecture is reflected in the terminology
   used to define HTTP.¶



3.1. Resources



   The target of an HTTP request is called a ""resource"".
   HTTP does not limit the nature of a resource; it merely
   defines an interface that might be used to interact with resources.
   Most resources are identified by a Uniform Resource Identifier (URI), as
   described in Section 4.¶

   One design goal of HTTP is to separate resource identification from
   request semantics, which is made possible by vesting the request
   semantics in the request method (Section 9) and a few
   request-modifying header fields.
   A resource cannot treat a request in a manner inconsistent with the
   semantics of the method of the request. For example, though the URI of a
   resource might imply semantics that are not safe, a client can expect the
   resource to avoid actions that are unsafe when processing a request with a
   safe method (see Section 9.2.1).¶

   HTTP relies upon the Uniform Resource Identifier (URI)
   standard [URI] to indicate the target resource
   (Section 7.1) and relationships between resources.¶





3.2. Representations



   A ""representation"" is information
   that is intended to reflect a past, current, or desired state of a given
   resource, in a format that can be readily communicated via the protocol.
   A representation consists of a set of representation metadata and a
   potentially unbounded stream of representation data
   (Section 8).¶

   HTTP allows ""information hiding"" behind its uniform interface by defining
   communication with respect to a transferable representation of the resource
   state, rather than transferring the resource itself. This allows the
   resource identified by a URI to be anything, including temporal functions
   like ""the current weather in Laguna Beach"", while potentially providing
   information that represents that resource at the time a message is
   generated [REST].¶

   The uniform interface is similar to a window through which one can observe
   and act upon a thing only through the communication of messages to an
   independent actor on the other side. A shared abstraction is needed to
   represent (""take the place of"") the current or desired state of that thing
   in our communications. When a representation is hypertext, it can provide
   both a representation of the resource state and processing instructions
   that help guide the recipient's future interactions.¶



   A target resource might be provided with, or be capable of
   generating, multiple representations that are each intended to reflect the
   resource's current state. An algorithm, usually based on
   content negotiation (Section 12),
   would be used to select one of those representations as being most
   applicable to a given request.
   This ""selected representation"" provides the data and metadata
   for evaluating conditional requests (Section 13)
   and constructing the content for 200 (OK),
   206 (Partial Content), and
   304 (Not Modified) responses to GET (Section 9.3.1).¶






3.3. Connections, Clients, and Servers





   HTTP is a client/server protocol that operates over a reliable
   transport- or session-layer ""connection"".¶

   An HTTP ""client"" is a program that establishes a connection
   to a server for the purpose of sending one or more HTTP requests.
   An HTTP ""server"" is a program that accepts connections
   in order to service HTTP requests by sending HTTP responses.¶

   The terms client and server refer only to the roles that
   these programs perform for a particular connection.  The same program
   might act as a client on some connections and a server on others.¶

   HTTP is defined as a stateless protocol, meaning that each request message's semantics
   can be understood in isolation, and that the relationship between connections
   and messages on them has no impact on the interpretation of those messages.
   For example, a CONNECT request (Section 9.3.6) or a request with
   the Upgrade header field (Section 7.8) can occur at any time,
   not just in the first message on a connection. Many implementations depend on
   HTTP's stateless design in order to reuse proxied connections or dynamically
   load balance requests across multiple servers.¶

   As a result, a server MUST NOT
   assume that two requests on the same connection are from the same user
   agent unless the connection is secured and specific to that agent.
   Some non-standard HTTP extensions (e.g., [RFC4559]) have
   been known to violate this requirement, resulting in security and
   interoperability problems.¶





3.4. Messages








   HTTP is a stateless request/response protocol for exchanging
   ""messages"" across a connection.
   The terms ""sender"" and ""recipient"" refer to
   any implementation that sends or receives a given message, respectively.¶

   A client sends requests to a server in the form of a ""request""
   message with a method (Section 9) and request target
   (Section 7.1). The request might also contain
   header fields (Section 6.3) for request modifiers,
   client information, and representation metadata,
   content (Section 6.4) intended for processing
   in accordance with the method, and
   trailer fields (Section 6.5) to communicate information
   collected while sending the content.¶

   A server responds to a client's request by sending one or more
   ""response"" messages, each including a status
   code (Section 15). The response might also contain
   header fields for server information, resource metadata, and representation
   metadata, content to be interpreted in accordance with the status
   code, and trailer fields to communicate information
   collected while sending the content.¶





3.5. User Agents





   The term ""user agent"" refers to any of the various
   client programs that initiate a request.¶

   The most familiar form of user agent is the general-purpose Web browser, but
   that's only a small percentage of implementations. Other common user agents
   include spiders (web-traversing robots), command-line tools, billboard
   screens, household appliances, scales, light bulbs, firmware update scripts,
   mobile apps, and communication devices in a multitude of shapes and sizes.¶

   Being a user agent does not imply that there is a human user directly
   interacting with the software agent at the time of a request. In many
   cases, a user agent is installed or configured to run in the background
   and save its results for later inspection (or save only a subset of those
   results that might be interesting or erroneous). Spiders, for example, are
   typically given a start URI and configured to follow certain behavior while
   crawling the Web as a hypertext graph.¶

   Many user agents cannot, or choose not to,
   make interactive suggestions to their user or provide adequate warning for
   security or privacy concerns. In the few cases where this
   specification requires reporting of errors to the user, it is acceptable
   for such reporting to only be observable in an error console or log file.
   Likewise, requirements that an automated action be confirmed by the user
   before proceeding might be met via advance configuration choices,
   run-time options, or simple avoidance of the unsafe action; confirmation
   does not imply any specific user interface or interruption of normal
   processing if the user has already made that choice.¶





3.6. Origin Server



   The term ""origin server"" refers to a program that can
   originate authoritative responses for a given target resource.¶

   The most familiar form of origin server are large public websites.
   However, like user agents being equated with browsers, it is easy to be
   misled into thinking that all origin servers are alike.
   Common origin servers also include home automation units, configurable
   networking components, office machines, autonomous robots, news feeds,
   traffic cameras, real-time ad selectors, and video-on-demand platforms.¶

   Most HTTP communication consists of a retrieval request (GET) for
   a representation of some resource identified by a URI.  In the
   simplest case, this might be accomplished via a single bidirectional
   connection (===) between the user agent (UA) and the origin server (O).¶


         request   >
    UA ======================================= O
                                <   response


Figure 1





3.7. Intermediaries



   HTTP enables the use of intermediaries to satisfy requests through
   a chain of connections.  There are three common forms of HTTP
   ""intermediary"": proxy, gateway, and tunnel.  In some cases,
   a single intermediary might act as an origin server, proxy, gateway,
   or tunnel, switching behavior based on the nature of each request.¶


         >             >             >             >
    UA =========== A =========== B =========== C =========== O
               <             <             <             <


Figure 2

   The figure above shows three intermediaries (A, B, and C) between the
   user agent and origin server. A request or response message that
   travels the whole chain will pass through four separate connections.
   Some HTTP communication options
   might apply only to the connection with the nearest, non-tunnel
   neighbor, only to the endpoints of the chain, or to all connections
   along the chain. Although the diagram is linear, each participant might
   be engaged in multiple, simultaneous communications. For example, B
   might be receiving requests from many clients other than A, and/or
   forwarding requests to servers other than C, at the same time that it
   is handling A's request. Likewise, later requests might be sent through a
   different path of connections, often based on dynamic configuration for
   load balancing.¶





   The terms ""upstream"" and ""downstream"" are
   used to describe directional requirements in relation to the message flow:
   all messages flow from upstream to downstream.
   The terms ""inbound"" and ""outbound"" are used to describe directional
   requirements in relation to the request route:
   inbound means ""toward the origin server"", whereas
   outbound means ""toward the user agent"".¶


   A ""proxy"" is a message-forwarding agent that is chosen by the
   client, usually via local configuration rules, to receive requests
   for some type(s) of absolute URI and attempt to satisfy those
   requests via translation through the HTTP interface.  Some translations
   are minimal, such as for proxy requests for ""http"" URIs, whereas
   other requests might require translation to and from entirely different
   application-level protocols. Proxies are often used to group an
   organization's HTTP requests through a common intermediary for the
   sake of security services, annotation services, or shared caching. Some
   proxies are designed to apply transformations to selected messages or
   content while they are being forwarded, as described in
   Section 7.7.¶




   A ""gateway"" (a.k.a. ""reverse proxy"") is an
   intermediary that acts as an origin server for the outbound connection but
   translates received requests and forwards them inbound to another server or
   servers. Gateways are often used to encapsulate legacy or untrusted
   information services, to improve server performance through
   ""accelerator"" caching, and to enable partitioning or load
   balancing of HTTP services across multiple machines.¶

   All HTTP requirements applicable to an origin server
   also apply to the outbound communication of a gateway.
   A gateway communicates with inbound servers using any protocol that
   it desires, including private extensions to HTTP that are outside
   the scope of this specification.  However, an HTTP-to-HTTP gateway
   that wishes to interoperate with third-party HTTP servers needs to conform
   to user agent requirements on the gateway's inbound connection.¶


   A ""tunnel"" acts as a blind relay between two connections
   without changing the messages. Once active, a tunnel is not
   considered a party to the HTTP communication, though the tunnel might
   have been initiated by an HTTP request. A tunnel ceases to exist when
   both ends of the relayed connection are closed. Tunnels are used to
   extend a virtual connection through an intermediary, such as when
   Transport Layer Security (TLS, [TLS13]) is used to
   establish confidential communication through a shared firewall proxy.¶

   The above categories for intermediary only consider those acting as
   participants in the HTTP communication.  There are also intermediaries
   that can act on lower layers of the network protocol stack, filtering or
   redirecting HTTP traffic without the knowledge or permission of message
   senders. Network intermediaries are indistinguishable (at a protocol level)
   from an on-path attacker, often introducing security flaws or
   interoperability problems due to mistakenly violating HTTP semantics.¶



   For example, an ""interception proxy"" [RFC3040] (also commonly
   known as a ""transparent proxy"" [RFC1919])
   differs from an HTTP proxy because it is not chosen by the client.
   Instead, an interception proxy filters or redirects outgoing TCP port 80
   packets (and occasionally other common port traffic).
   Interception proxies are commonly found on public network access points,
   as a means of enforcing account subscription prior to allowing use of
   non-local Internet services, and within corporate firewalls to enforce
   network usage policies.¶





3.8. Caches



   A ""cache"" is a local store of previous response messages and the
   subsystem that controls its message storage, retrieval, and deletion.
   A cache stores cacheable responses in order to reduce the response
   time and network bandwidth consumption on future, equivalent
   requests. Any client or server MAY employ a cache, though a cache
   cannot be used while acting as a tunnel.¶

   The effect of a cache is that the request/response chain is shortened
   if one of the participants along the chain has a cached response
   applicable to that request. The following illustrates the resulting
   chain if B has a cached copy of an earlier response from O (via C)
   for a request that has not been cached by UA or A.¶


            >             >
       UA =========== A =========== B - - - - - - C - - - - - - O
                  <             <


Figure 3


   A response is ""cacheable"" if a cache is allowed to store a copy of
   the response message for use in answering subsequent requests.
   Even when a response is cacheable, there might be additional
   constraints placed by the client or by the origin server on when
   that cached response can be used for a particular request. HTTP
   requirements for cache behavior and cacheable responses are
   defined in [CACHING].¶

   There is a wide variety of architectures and configurations
   of caches deployed across the World Wide Web and
   inside large organizations. These include national hierarchies
   of proxy caches to save bandwidth and reduce latency, content delivery
   networks that use gateway caching to optimize regional and global distribution of popular sites,
   collaborative systems that
   broadcast or multicast cache entries, archives of pre-fetched cache
   entries for use in off-line or high-latency environments, and so on.¶





3.9. Example Message Exchange


   The following example illustrates a typical HTTP/1.1 message exchange for a
   GET request (Section 9.3.1) on the URI ""http://www.example.com/hello.txt"":¶

Client request:¶

GET /hello.txt HTTP/1.1
User-Agent: curl/7.64.1
Host: www.example.com
Accept-Language: en, mi

¶


Server response:¶

HTTP/1.1 200 OK
Date: Mon, 27 Jul 2009 12:28:53 GMT
Server: Apache
Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT
ETag: ""34aa387-d-1568eb00""
Accept-Ranges: bytes
Content-Length: 51
Vary: Accept-Encoding
Content-Type: text/plain

Hello World! My content includes a trailing CRLF.
¶








4. Identifiers in HTTP




   Uniform Resource Identifiers (URIs) [URI] are used
   throughout HTTP as the means for identifying resources (Section 3.1).¶



4.1. URI References



   URI references are used to target requests, indicate redirects, and define
   relationships.¶

   The definitions of ""URI-reference"",
   ""absolute-URI"", ""relative-part"", ""authority"", ""port"", ""host"",
   ""path-abempty"", ""segment"", and ""query"" are adopted from the
   URI generic syntax.
   An ""absolute-path"" rule is defined for protocol elements that can contain a
   non-empty path component. (This rule differs slightly from the path-abempty
   rule of RFC 3986, which allows for an empty path,
   and path-absolute rule, which does not allow paths that begin with ""//"".)
   A ""partial-URI"" rule is defined for protocol elements
   that can contain a relative URI but not a fragment component.¶










  URI-reference = <URI-reference, see [URI], Section 4.1>
  absolute-URI  = <absolute-URI, see [URI], Section 4.3>
  relative-part = <relative-part, see [URI], Section 4.2>
  authority     = <authority, see [URI], Section 3.2>
  uri-host      = <host, see [URI], Section 3.2.2>
  port          = <port, see [URI], Section 3.2.3>
  path-abempty  = <path-abempty, see [URI], Section 3.3>
  segment       = <segment, see [URI], Section 3.3>
  query         = <query, see [URI], Section 3.4>

  absolute-path = 1*( ""/"" segment )
  partial-URI   = relative-part [ ""?"" query ]
¶


   Each protocol element in HTTP that allows a URI reference will indicate
   in its ABNF production whether the element allows any form of reference
   (URI-reference), only a URI in absolute form (absolute-URI), only the
   path and optional query components (partial-URI),
   or some combination of the above.
   Unless otherwise indicated, URI references are parsed
   relative to the target URI (Section 7.1).¶

   It is RECOMMENDED that all senders and recipients support, at a minimum,
   URIs with lengths of 8000 octets in protocol elements. Note that this
   implies some structures and on-wire representations (for example, the
   request line in HTTP/1.1) will necessarily be larger in some cases.¶





4.2. HTTP-Related URI Schemes


   IANA maintains the registry of URI Schemes [BCP35] at
   <https://www.iana.org/assignments/uri-schemes/>.
   Although requests might target any URI scheme, the following schemes are
   inherent to HTTP servers:¶


Table 2


URI Scheme
Description
Section




http
Hypertext Transfer Protocol

4.2.1



https
Hypertext Transfer Protocol Secure

4.2.2






   Note that the presence of an ""http"" or ""https"" URI does not imply that
   there is always an HTTP server at the identified origin listening for
   connections. Anyone can mint a URI, whether or not a server exists and
   whether or not that server currently maps that identifier to a resource.
   The delegated nature of registered names and IP addresses creates a
   federated namespace whether or not an HTTP server is present.¶



4.2.1. http URI Scheme




   The ""http"" URI scheme is hereby defined for minting identifiers within the
   hierarchical namespace governed by a potential HTTP origin server
   listening for TCP ([TCP]) connections on a given port.¶


  http-URI = ""http"" ""://"" authority path-abempty [ ""?"" query ]
¶


   The origin server for an ""http"" URI is identified by the
   authority component, which includes a host identifier
   ([URI], Section 3.2.2)
   and optional port number ([URI], Section 3.2.3).
   If the port subcomponent is empty or not given, TCP port 80 (the
   reserved port for WWW services) is the default.
   The origin determines who has the right to respond authoritatively to
   requests that target the identified resource, as defined in
   Section 4.3.2.¶

   A sender MUST NOT generate an ""http"" URI with an empty host identifier.
   A recipient that processes such a URI reference MUST reject it as invalid.¶

   The hierarchical path component and optional query component identify the
   target resource within that origin server's namespace.¶





4.2.2. https URI Scheme





   The ""https"" URI scheme is hereby defined for minting identifiers within the
   hierarchical namespace governed by a potential origin server listening for
   TCP connections on a given port and capable of establishing a TLS
   ([TLS13]) connection that has been secured for HTTP
   communication. In this context, ""secured"" specifically
   means that the server has been authenticated as acting on behalf of the
   identified authority and all HTTP communication with that server has
   confidentiality and integrity protection that is acceptable to both client
   and server.¶


  https-URI = ""https"" ""://"" authority path-abempty [ ""?"" query ]
¶


   The origin server for an ""https"" URI is identified by the
   authority component, which includes a host identifier
   ([URI], Section 3.2.2)
   and optional port number ([URI], Section 3.2.3).
   If the port subcomponent is empty or not given, TCP port 443
   (the reserved port for HTTP over TLS) is the default.
   The origin determines who has the right to respond authoritatively to
   requests that target the identified resource, as defined in
   Section 4.3.3.¶

   A sender MUST NOT generate an ""https"" URI with an empty host identifier.
   A recipient that processes such a URI reference MUST reject it as invalid.¶

   The hierarchical path component and optional query component identify the
   target resource within that origin server's namespace.¶

   A client MUST ensure that its HTTP requests for an ""https"" resource are
   secured, prior to being communicated, and that it only accepts secured
   responses to those requests. Note that the definition of what cryptographic
   mechanisms are acceptable to client and server are usually negotiated and
   can change over time.¶

   Resources made available via the ""https"" scheme have no shared identity
   with the ""http"" scheme. They are distinct origins with separate namespaces.
   However, extensions to HTTP that are defined as applying to all origins with
   the same host, such as the Cookie protocol [COOKIE],
   allow information set by one service to impact communication with other
   services within a matching group of host domains. Such extensions ought to
   be designed with great care to prevent information obtained from a secured
   connection being inadvertently exchanged within an unsecured context.¶





4.2.3. http(s) Normalization and Comparison


   URIs with an ""http"" or ""https"" scheme are normalized and compared according to the
   methods defined in Section 6 of [URI], using
   the defaults described above for each scheme.¶

   HTTP does not require the use of a specific method for determining
   equivalence. For example, a cache key might be compared as a simple
   string, after syntax-based normalization, or after scheme-based
   normalization.¶

   Scheme-based normalization (Section 6.2.3 of [URI]) of ""http"" and ""https"" URIs involves the following
   additional rules:¶

If the port is equal to the default port for a scheme, the normal form
   is to omit the port subcomponent.¶

When not being used as the target of an OPTIONS request, an empty path
   component is equivalent to an absolute path of ""/"", so the normal form is
   to provide a path of ""/"" instead.¶

The scheme and host are case-insensitive and normally provided in
   lowercase; all other components are compared in a case-sensitive
   manner.¶

Characters other than those in the ""reserved"" set are equivalent to
   their percent-encoded octets: the normal form is to not encode them (see
   Sections 2.1 and 2.2 of [URI]).¶



   For example, the following three URIs are equivalent:¶

   http://example.com:80/~smith/home.html
   http://EXAMPLE.com/%7Esmith/home.html
   http://EXAMPLE.com:/%7esmith/home.html
¶


   Two HTTP URIs that are equivalent after normalization (using any method)
   can be assumed to identify the same resource, and any HTTP component MAY
   perform normalization. As a result, distinct resources SHOULD NOT be
   identified by HTTP URIs that are equivalent after normalization (using any
   method defined in Section 6.2 of [URI]).¶





4.2.4. Deprecation of userinfo in http(s) URIs


   The URI generic syntax for authority also includes a userinfo subcomponent
   ([URI], Section 3.2.1) for including user
   authentication information in the URI. In that subcomponent, the
   use of the format ""user:password"" is deprecated.¶

   Some implementations make use of the userinfo component for internal
   configuration of authentication information, such as within command
   invocation options, configuration files, or bookmark lists, even
   though such usage might expose a user identifier or password.¶

   A sender MUST NOT generate the userinfo subcomponent (and its ""@""
   delimiter) when an ""http"" or ""https"" URI reference is generated within a
   message as a target URI or field value.¶

   Before making use of an ""http"" or ""https"" URI reference received from an untrusted
   source, a recipient SHOULD parse for userinfo and treat its presence as
   an error; it is likely being used to obscure the authority for the sake of
   phishing attacks.¶





4.2.5. http(s) References with Fragment Identifiers



   Fragment identifiers allow for indirect identification
   of a secondary resource, independent of the URI scheme, as defined in
   Section 3.5 of [URI].
   Some protocol elements that refer to a URI allow inclusion of a fragment,
   while others do not. They are distinguished by use of the ABNF rule for
   elements where fragment is allowed; otherwise, a specific rule that excludes
   fragments is used.¶


Note: The fragment identifier component is not part of the scheme
    definition for a URI scheme (see Section 4.3 of [URI]),
    thus does not appear in the ABNF definitions for the ""http"" and ""https""
    URI schemes above.¶








4.3. Authoritative Access


   Authoritative access refers to dereferencing a given identifier,
   for the sake of access to the identified resource, in a way that the client
   believes is authoritative (controlled by the resource owner). The process
   for determining whether access is granted is defined by the URI scheme and often uses
   data within the URI components, such as the authority component when
   the generic syntax is used. However, authoritative access is not limited to
   the identified mechanism.¶

Section 4.3.1 defines the concept of an origin as an aid to
   such uses, and the subsequent subsections explain how to establish that a
   peer has the authority to represent an origin.¶

   See Section 17.1 for security considerations
   related to establishing authority.¶



4.3.1. URI Origin




   The ""origin"" for a given URI is the triple of scheme, host,
   and port after normalizing the scheme and host to lowercase and
   normalizing the port to remove any leading zeros. If port is elided from
   the URI, the default port for that scheme is used. For example, the URI¶

   https://Example.Com/happy.js
¶


   would have the origin¶

   { ""https"", ""example.com"", ""443"" }
¶


   which can also be described as the normalized URI prefix with port always
   present:¶

   https://example.com:443
¶


   Each origin defines its own namespace and controls how identifiers
   within that namespace are mapped to resources. In turn, how the origin
   responds to valid requests, consistently over time, determines the
   semantics that users will associate with a URI, and the usefulness of
   those semantics is what ultimately transforms these mechanisms into a
   resource for users to reference and access in the future.¶

   Two origins are distinct if they differ in scheme, host, or port. Even
   when it can be verified that the same entity controls two distinct origins,
   the two namespaces under those origins are distinct unless explicitly
   aliased by a server authoritative for that origin.¶

   Origin is also used within HTML and related Web protocols, beyond the
   scope of this document, as described in [RFC6454].¶





4.3.2. http Origins


   Although HTTP is independent of the transport protocol, the ""http"" scheme
   (Section 4.2.1) is specific to associating authority with
   whomever controls the origin
   server listening for TCP connections on the indicated port of whatever
   host is identified within the authority component. This is a very weak
   sense of authority because it depends on both client-specific name
   resolution mechanisms and communication that might not be secured from
   an on-path attacker. Nevertheless, it is a sufficient minimum for
   binding ""http"" identifiers to an origin server for consistent resolution
   within a trusted environment.¶

   If the host identifier is provided as an IP address, the origin server is
   the listener (if any) on the indicated TCP port at that IP address.
   If host is a registered name, the registered name is an indirect identifier
   for use with a name resolution service, such as DNS, to find an address for
   an appropriate origin server.¶

   When an ""http"" URI is used within a context that calls for access to the
   indicated resource, a client MAY attempt access by resolving the host
   identifier to an IP address, establishing a TCP connection to that
   address on the indicated port, and sending over that connection an HTTP
   request message containing a request target that matches the client's
   target URI (Section 7.1).¶

   If the server responds to such a request with a non-interim HTTP response
   message, as described in Section 15, then that response
   is considered an authoritative answer to the client's request.¶

   Note, however, that the above is not the only means for obtaining an
   authoritative response, nor does it imply that an authoritative response
   is always necessary (see [CACHING]).
   For example, the Alt-Svc header field [ALTSVC] allows an
   origin server to identify other services that are also authoritative for
   that origin. Access to ""http"" identified resources might also be provided
   by protocols outside the scope of this document.¶





4.3.3. https Origins


   The ""https"" scheme (Section 4.2.2) associates authority based
   on the ability of a server to use the private key corresponding to a
   certificate that the client considers to be trustworthy for the identified
   origin server. The client usually relies upon a chain of trust, conveyed
   from some prearranged or configured trust anchor, to deem a certificate
   trustworthy (Section 4.3.4).¶

   In HTTP/1.1 and earlier, a client will only attribute authority to a server
   when they are communicating over a successfully established and secured
   connection specifically to that URI origin's host. The connection
   establishment and certificate verification are used as proof of authority.¶

   In HTTP/2 and HTTP/3, a client will attribute authority to a server when
   they are communicating over a successfully established and secured
   connection if the URI origin's host matches any of the hosts present in the
   server's certificate and the client believes that it could open a connection
   to that host for that URI. In practice, a client will make a DNS query to
   check that the origin's host contains the same server IP address as the
   established connection. This restriction can be removed by the origin server
   sending an equivalent ORIGIN frame [RFC8336].¶

   The request target's host and port value are passed within each HTTP
   request, identifying the origin and distinguishing it from other namespaces
   that might be controlled by the same server (Section 7.2).
   It is the origin's responsibility to ensure that any services provided with
   control over its certificate's private key are equally responsible for
   managing the corresponding ""https"" namespaces or at least prepared to
   reject requests that appear to have been misdirected
   (Section 7.4).¶

   An origin server might be unwilling to process requests for certain target
   URIs even when they have the authority to do so. For example, when a host
   operates distinct services on different ports (e.g., 443 and 8000), checking
   the target URI at the origin server is necessary (even after the connection
   has been secured) because a network attacker might cause connections for one
   port to be received at some other port. Failing to check the target URI
   might allow such an attacker to replace a response to one target URI
   (e.g., ""https://example.com/foo"") with a seemingly authoritative response
   from the other port (e.g., ""https://example.com:8000/foo"").¶

   Note that the ""https"" scheme does not rely on TCP and the connected port
   number for associating authority, since both are outside the secured
   communication and thus cannot be trusted as definitive. Hence, the HTTP
   communication might take place over any channel that has been secured,
   as defined in Section 4.2.2, including protocols that don't
   use TCP.¶

   When an ""https"" URI is used within a context that calls for access to
   the indicated resource, a client MAY attempt access by resolving the
   host identifier to an IP address, establishing a TCP connection to that
   address on the indicated port, securing the connection end-to-end by
   successfully initiating TLS over TCP with confidentiality and integrity
   protection, and sending over that connection an HTTP request message
   containing a request target that matches the client's target URI
   (Section 7.1).¶

   If the server responds to such a request with a non-interim HTTP response
   message, as described in Section 15, then that response
   is considered an authoritative answer to the client's request.¶

   Note, however, that the above is not the only means for obtaining an
   authoritative response, nor does it imply that an authoritative response
   is always necessary (see [CACHING]).¶





4.3.4. https Certificate Verification


   To establish a secured connection to dereference a URI,
   a client MUST verify that the service's identity is an acceptable
   match for the URI's origin server. Certificate verification is used to
   prevent server impersonation by an on-path attacker or by an attacker
   that controls name resolution. This process requires that a client be
   configured with a set of trust anchors.¶

   In general, a client MUST verify the service identity using the
   verification process defined in
   Section 6 of [RFC6125]. The client MUST construct
   a reference identity from the service's host: if the host is a literal IP address
   (Section 4.3.5), the reference identity is an IP-ID, otherwise
   the host is a name and the reference identity is a DNS-ID.¶

   A reference identity of type CN-ID MUST NOT be used by clients.  As noted
   in Section 6.2.1 of [RFC6125], a reference
   identity of type CN-ID might be used by older clients.¶

   A client might be specially configured to accept an alternative form of
   server identity verification. For example, a client might be connecting
   to a server whose address and hostname are dynamic, with an expectation that
   the service will present a specific certificate (or a certificate matching
   some externally defined reference identity) rather than one matching the
   target URI's origin.¶

   In special cases, it might be appropriate for
   a client to simply ignore the server's identity, but it must be
   understood that this leaves a connection open to active attack.¶

   If the certificate is not valid for the target URI's origin,
   a user agent MUST either obtain confirmation from the user
   before proceeding (see Section 3.5) or
   terminate the connection with a bad certificate error. Automated
   clients MUST log the error to an appropriate audit log (if available)
   and SHOULD terminate the connection (with a bad certificate error).
   Automated clients MAY provide a configuration setting that disables
   this check, but MUST provide a setting which enables it.¶





4.3.5. IP-ID Reference Identity


   A server that is identified using an IP address literal in the ""host"" field
   of an ""https"" URI has a reference identity of type IP-ID.  An IP version 4
   address uses the ""IPv4address"" ABNF rule, and an IP version 6 address uses
   the ""IP-literal"" production with the ""IPv6address"" option; see
   Section 3.2.2 of [URI].  A reference identity of
   IP-ID contains the decoded bytes of the IP address.¶

   An IP version 4 address is 4 octets, and an IP version 6 address is 16 octets.
   Use of IP-ID is not defined for any other IP version. The iPAddress
   choice in the certificate subjectAltName extension does not explicitly
   include the IP version and so relies on the length of the address to
   distinguish versions; see
   Section 4.2.1.6 of [RFC5280].¶

   A reference identity of type IP-ID matches if the address is identical to
   an iPAddress value of the subjectAltName extension of the certificate.¶









5. Fields



   HTTP uses ""fields"" to provide data in the form of extensible
   name/value pairs with a registered key namespace. Fields are sent and
   received within the header and trailer sections of messages
   (Section 6).¶



5.1. Field Names


   A field name labels the corresponding field value as having the
   semantics defined by that name.  For example, the Date
   header field is defined in Section 6.6.1 as containing the
   origination timestamp for the message in which it appears.¶


  field-name     = token
¶


   Field names are case-insensitive and ought to be registered within the
   ""Hypertext Transfer Protocol (HTTP) Field Name Registry""; see Section 16.3.1.¶

   The interpretation of a field does not change between minor
   versions of the same major HTTP version, though the default behavior of a
   recipient in the absence of such a field can change. Unless specified
   otherwise, fields are defined for all versions of HTTP.
   In particular, the Host and Connection
   fields ought to be recognized by all HTTP implementations
   whether or not they advertise conformance with HTTP/1.1.¶

   New fields can be introduced without changing the protocol version if
   their defined semantics allow them to be safely ignored by recipients
   that do not recognize them; see Section 16.3.¶

   A proxy MUST forward unrecognized header fields unless the
   field name is listed in the Connection header field
   (Section 7.6.1) or the proxy is specifically
   configured to block, or otherwise transform, such fields.
   Other recipients SHOULD ignore unrecognized header and trailer fields.
   Adhering to these requirements allows HTTP's functionality to be extended
   without updating or removing deployed intermediaries.¶





5.2. Field Lines and Combined Field Value





   Field sections are composed of any number of ""field lines"",
   each with a ""field name"" (see Section 5.1)
   identifying the field, and a ""field line value"" that conveys
   data for that instance of the field.¶


   When a field name is only present once in a section, the combined
   ""field value"" for that field consists of the corresponding
   field line value.
   When a field name is repeated within a section, its combined field value
   consists of the list of corresponding field line values within that section,
   concatenated in order, with each field line value separated by a comma.¶

   For example, this section:¶

Example-Field: Foo, Bar
Example-Field: Baz
¶


   contains two field lines, both with the field name ""Example-Field"". The
   first field line has a field line value of ""Foo, Bar"", while the second
   field line value is ""Baz"". The field value for ""Example-Field"" is the list
   ""Foo, Bar, Baz"".¶





5.3. Field Order


   A recipient MAY combine multiple field lines within a field section that
   have the same field name
   into one field line, without changing the semantics of the message, by
   appending each subsequent field line value to the initial field line value
   in order, separated by a comma ("","") and optional whitespace
   (OWS, defined in Section 5.6.3).
   For consistency, use comma SP.¶

   The order in which field lines with the
   same name are received is therefore significant to the interpretation of
   the field value; a proxy MUST NOT change the order of these field line
   values when forwarding a message.¶

   This means that, aside from the well-known exception noted below, a sender
   MUST NOT generate multiple field lines with the same name in a message
   (whether in the headers or trailers) or append a field line when a field
   line of the same name already exists in the message, unless that field's
   definition allows multiple field line values to be recombined as a
   comma-separated list (i.e., at least one alternative of the field's
   definition allows a comma-separated list, such as an ABNF rule of
   #(values) defined in Section 5.6.1).¶


Note: In practice, the ""Set-Cookie"" header field ([COOKIE])
   often appears in a response message across multiple field lines and does not
   use the list syntax, violating the above requirements on multiple field lines
   with the same field name. Since it cannot be combined into a single field
   value, recipients ought to handle ""Set-Cookie"" as a special case while
   processing fields. (See Appendix A.2.3 of [Kri2001] for
   details.)¶


   The order in which field lines with differing field names are received in a
   section is not significant. However, it is good practice to send header
   fields that contain additional control data first, such as
   Host on requests and Date on responses, so
   that implementations can decide when not to handle a message as early as
   possible.¶

   A server MUST NOT apply a request to the target resource until it
   receives the entire request header section, since later header field lines
   might include conditionals, authentication credentials, or deliberately
   misleading duplicate header fields that could impact request processing.¶





5.4. Field Limits


   HTTP does not place a predefined limit on the length of each field line, field value,
   or on the length of a header or trailer section as a whole, as described in
   Section 2. Various ad hoc limitations on individual
   lengths are found in practice, often depending on the specific
   field's semantics.¶

   A server that receives a request header field line, field value, or set of
   fields larger than it wishes to process MUST respond with an appropriate
   4xx (Client Error) status code. Ignoring such header fields
   would increase the server's vulnerability to request smuggling attacks
   (Section 11.2 of [HTTP/1.1]).¶

   A client MAY discard or truncate received field lines that are larger
   than the client wishes to process if the field semantics are such that the
   dropped value(s) can be safely ignored without changing the
   message framing or response semantics.¶





5.5. Field Values


   HTTP field values consist of a sequence of characters in a format defined
   by the field's grammar. Each field's grammar is usually defined using
   ABNF ([RFC5234]).¶





  field-value    = *field-content
  field-content  = field-vchar
                   [ 1*( SP / HTAB / field-vchar ) field-vchar ]
  field-vchar    = VCHAR / obs-text
  obs-text       = %x80-FF
¶


   A field value does not include leading or trailing whitespace. When a
   specific version of HTTP allows such whitespace to appear in a message,
   a field parsing implementation MUST exclude such whitespace prior to
   evaluating the field value.¶

   Field values are usually constrained to the range of US-ASCII characters
   [USASCII].
   Fields needing a greater range of characters can use an encoding,
   such as the one defined in [RFC8187].
   Historically, HTTP allowed field content with text in the ISO-8859-1
   charset [ISO-8859-1], supporting other charsets only
   through use of [RFC2047] encoding.
   Specifications for newly defined fields SHOULD limit their values to
   visible US-ASCII octets (VCHAR), SP, and HTAB.
   A recipient SHOULD treat other allowed octets in field content
   (i.e., obs-text) as opaque data.¶

   Field values containing CR, LF, or NUL characters are invalid and dangerous,
   due to the varying ways that implementations might parse and interpret
   those characters; a recipient of CR, LF, or NUL within a field value MUST
   either reject the message or replace each of those characters with SP
   before further processing or forwarding of that message. Field values
   containing other CTL characters are also invalid; however,
   recipients MAY retain such characters for the sake of robustness when
   they appear within a safe context (e.g., an application-specific quoted
   string that will not be processed by any downstream HTTP parser).¶


   Fields that only anticipate a single member as the field value are
   referred to as ""singleton fields"".¶


   Fields that allow multiple members as the field value are referred to as
   ""list-based fields"". The list operator extension of
   Section 5.6.1 is used as a common notation for defining
   field values that can contain multiple members.¶

   Because commas ("","") are used as the delimiter between members, they need
   to be treated with care if they are allowed as data within a member. This
   is true for both list-based and singleton fields, since a singleton field
   might be erroneously sent with multiple members and detecting such errors
   improves interoperability. Fields that expect to contain a
   comma within a member, such as within an HTTP-date or
   URI-reference
   element, ought to be defined with delimiters around that element to
   distinguish any comma within that data from potential list separators.¶

   For example, a textual date and a URI (either of which might contain a comma)
   could be safely carried in list-based field values like these:¶

Example-URIs: ""http://example.com/a.html,foo"",
              ""http://without-a-comma.example.com/""
Example-Dates: ""Sat, 04 May 1996"", ""Wed, 14 Sep 2005""
¶


   Note that double-quote delimiters are almost always used with the
   quoted-string production (Section 5.6.4); using a different syntax inside double-quotes
   will likely cause unnecessary confusion.¶

   Many fields (such as Content-Type, defined in
   Section 8.3) use a common syntax for parameters
   that allows both unquoted (token) and quoted (quoted-string) syntax for
   a parameter value (Section 5.6.6). Use of common syntax
   allows recipients to reuse existing parser components. When allowing both
   forms, the meaning of a parameter value ought to be the same whether it
   was received as a token or a quoted string.¶


Note: For defining field value syntax, this specification uses an ABNF
      rule named after the field name to define the allowed grammar for that
      field's value (after said value has been extracted from the underlying
      messaging syntax and multiple instances combined into a list).¶






5.6. Common Rules for Defining Field Values




5.6.1. Lists (#rule ABNF Extension)


   A #rule extension to the ABNF rules of [RFC5234] is used to
   improve readability in the definitions of some list-based field values.¶

   A construct ""#"" is defined, similar to ""*"", for defining comma-delimited
   lists of elements. The full form is ""<n>#<m>element"" indicating
   at least <n> and at most <m> elements, each separated by a single
   comma ("","") and optional whitespace (OWS,
   defined in Section 5.6.3).¶



5.6.1.1. Sender Requirements


   In any production that uses the list construct, a sender MUST NOT
   generate empty list elements. In other words, a sender has to generate
   lists that satisfy the following syntax:¶

  1#element => element *( OWS "","" OWS element )
¶


   and:¶

  #element => [ 1#element ]
¶


   and for n >= 1 and m > 1:¶

  <n>#<m>element => element <n-1>*<m-1>( OWS "","" OWS element )
¶


Appendix A shows the collected ABNF for senders
   after the list constructs have been expanded.¶





5.6.1.2. Recipient Requirements


   Empty elements do not contribute to the count of elements present.
   A recipient MUST parse and ignore
   a reasonable number of empty list elements: enough to handle common mistakes
   by senders that merge values, but not so much that they could be used as a
   denial-of-service mechanism. In other words, a recipient MUST accept lists
   that satisfy the following syntax:¶

  #element => [ element ] *( OWS "","" OWS [ element ] )
¶


   Note that because of the potential presence of empty list elements, the
   RFC 5234 ABNF cannot enforce the cardinality of list elements, and
   consequently all cases are mapped as if there was no cardinality specified.¶

   For example, given these ABNF productions:¶

  example-list      = 1#example-list-elmt
  example-list-elmt = token ; see Section 5.6.2
¶


   Then the following are valid values for example-list (not including the
   double quotes, which are present for delimitation only):¶

  ""foo,bar""
  ""foo ,bar,""
  ""foo , ,bar,charlie""
¶


   In contrast, the following values would be invalid, since at least one
   non-empty element is required by the example-list production:¶

  """"
  "",""
  "",   ,""
¶








5.6.2. Tokens



  
  
  Tokens are short textual identifiers that do not include whitespace or
  delimiters.¶




  token          = 1*tchar

  tchar          = ""!"" / ""#"" / ""$"" / ""%"" / ""&"" / ""'"" / ""*""
                 / ""+"" / ""-"" / ""."" / ""^"" / ""_"" / ""`"" / ""|"" / ""~""
                 / DIGIT / ALPHA
                 ; any VCHAR, except delimiters
¶




   Many HTTP field values are defined using common syntax
   components, separated by whitespace or specific delimiting characters.
   Delimiters are chosen from the set of US-ASCII visual characters not
   allowed in a token (DQUOTE and ""(),/:;<=>?@[\]{}"").¶






5.6.3. Whitespace


   This specification uses three rules to denote the use of linear
   whitespace: OWS (optional whitespace), RWS (required whitespace), and
   BWS (""bad"" whitespace).¶

   The OWS rule is used where zero or more linear whitespace octets might
   appear. For protocol elements where optional whitespace is preferred to
   improve readability, a sender SHOULD generate the optional whitespace
   as a single SP; otherwise, a sender SHOULD NOT generate optional
   whitespace except as needed to overwrite invalid or unwanted protocol
   elements during in-place message filtering.¶

   The RWS rule is used when at least one linear whitespace octet is required
   to separate field tokens. A sender SHOULD generate RWS as a single SP.¶

   OWS and RWS have the same semantics as a single SP. Any content known to
   be defined as OWS or RWS MAY be replaced with a single SP before
   interpreting it or forwarding the message downstream.¶

   The BWS rule is used where the grammar allows optional whitespace only for
   historical reasons. A sender MUST NOT generate BWS in messages.
   A recipient MUST parse for such bad whitespace and remove it before
   interpreting the protocol element.¶

   BWS has no semantics. Any content known to be
   defined as BWS MAY be removed before interpreting it or forwarding the
   message downstream.¶




  OWS            = *( SP / HTAB )
                 ; optional whitespace
  RWS            = 1*( SP / HTAB )
                 ; required whitespace
  BWS            = OWS
                 ; ""bad"" whitespace
¶






5.6.4. Quoted Strings



  
  
   A string of text is parsed as a single value if it is quoted using
   double-quote marks.¶




  quoted-string  = DQUOTE *( qdtext / quoted-pair ) DQUOTE
  qdtext         = HTAB / SP / %x21 / %x23-5B / %x5D-7E / obs-text
¶



  
   The backslash octet (""\"") can be used as a single-octet
   quoting mechanism within quoted-string and comment constructs.
   Recipients that process the value of a quoted-string MUST handle a
   quoted-pair as if it were replaced by the octet following the backslash.¶



  quoted-pair    = ""\"" ( HTAB / SP / VCHAR / obs-text )
¶


   A sender SHOULD NOT generate a quoted-pair in a quoted-string except
   where necessary to quote DQUOTE and backslash octets occurring within that
   string.
   A sender SHOULD NOT generate a quoted-pair in a comment except
   where necessary to quote parentheses [""("" and "")""] and backslash octets
   occurring within that comment.¶





5.6.5. Comments



  
  
   Comments can be included in some HTTP fields by surrounding
   the comment text with parentheses. Comments are only allowed in
   fields containing ""comment"" as part of their field value definition.¶




  comment        = ""("" *( ctext / quoted-pair / comment ) "")""
  ctext          = HTAB / SP / %x21-27 / %x2A-5B / %x5D-7E / obs-text
¶






5.6.6. Parameters



   
   
   
   Parameters are instances of name/value pairs; they are often used in field
   values as a common syntax for appending auxiliary information to an item.
   Each parameter is usually delimited by an immediately preceding semicolon.¶






  parameters      = *( OWS "";"" OWS [ parameter ] )
  parameter       = parameter-name ""="" parameter-value
  parameter-name  = token
  parameter-value = ( token / quoted-string )
¶


   Parameter names are case-insensitive. Parameter values might or might
   not be case-sensitive, depending on the semantics of the parameter
   name. Examples of parameters and some equivalent forms can be seen in
   media types (Section 8.3.1) and the Accept header field
   (Section 12.5.1).¶

   A parameter value that matches the token production can be
   transmitted either as a token or within a quoted-string. The quoted and
   unquoted values are equivalent.¶


Note: Parameters do not allow whitespace (not even ""bad"" whitespace)
    around the ""="" character.¶






5.6.7. Date/Time Formats



   Prior to 1995, there were three different formats commonly used by servers
   to communicate timestamps.  For compatibility with old implementations, all
   three are defined here. The preferred format is a fixed-length and
   single-zone subset of the date and time specification used by the
   Internet Message Format [RFC5322].¶


  HTTP-date    = IMF-fixdate / obs-date
¶


   An example of the preferred format is¶

  Sun, 06 Nov 1994 08:49:37 GMT    ; IMF-fixdate
¶


   Examples of the two obsolete formats are¶

  Sunday, 06-Nov-94 08:49:37 GMT   ; obsolete RFC 850 format
  Sun Nov  6 08:49:37 1994         ; ANSI C's asctime() format
¶


   A recipient that parses a timestamp value in an HTTP field MUST
   accept all three HTTP-date formats. When a sender generates a field
   that contains one or more timestamps defined as HTTP-date,
   the sender MUST generate those timestamps in the IMF-fixdate format.¶

   An HTTP-date value represents time as an instance of Coordinated
   Universal Time (UTC). The first two formats indicate UTC by the
   three-letter abbreviation for Greenwich Mean Time, ""GMT"", a predecessor
   of the UTC name; values in the asctime format are assumed to be in UTC.¶

   A ""clock"" is an implementation capable of providing a
   reasonable approximation of the current instant in UTC.
   A clock implementation ought to use NTP ([RFC5905]),
   or some similar protocol, to synchronize with UTC.¶


  
  
  
  
  
  
  
  
  
  
  Preferred format:¶














  IMF-fixdate  = day-name "","" SP date1 SP time-of-day SP GMT
  ; fixed length/zone/capitalization subset of the format
  ; see Section 3.3 of [RFC5322]

  day-name     = %s""Mon"" / %s""Tue"" / %s""Wed""
               / %s""Thu"" / %s""Fri"" / %s""Sat"" / %s""Sun""

  date1        = day SP month SP year
               ; e.g., 02 Jun 1982

  day          = 2DIGIT
  month        = %s""Jan"" / %s""Feb"" / %s""Mar"" / %s""Apr""
               / %s""May"" / %s""Jun"" / %s""Jul"" / %s""Aug""
               / %s""Sep"" / %s""Oct"" / %s""Nov"" / %s""Dec""
  year         = 4DIGIT

  GMT          = %s""GMT""

  time-of-day  = hour "":"" minute "":"" second
               ; 00:00:00 - 23:59:60 (leap second)

  hour         = 2DIGIT
  minute       = 2DIGIT
  second       = 2DIGIT
¶



  
  
  
  
  
  
  
  Obsolete formats:¶



  obs-date     = rfc850-date / asctime-date
¶



  rfc850-date  = day-name-l "","" SP date2 SP time-of-day SP GMT
  date2        = day ""-"" month ""-"" 2DIGIT
               ; e.g., 02-Jun-82

  day-name-l   = %s""Monday"" / %s""Tuesday"" / %s""Wednesday""
               / %s""Thursday"" / %s""Friday"" / %s""Saturday""
               / %s""Sunday""
¶



  asctime-date = day-name SP date3 SP time-of-day SP year
  date3        = month SP ( 2DIGIT / ( SP 1DIGIT ))
               ; e.g., Jun  2
¶


   HTTP-date is case sensitive. Note that Section 4.2 of [CACHING] relaxes this for cache recipients.¶

   A sender MUST NOT generate additional whitespace in an HTTP-date beyond
   that specifically included as SP in the grammar.
   The semantics of day-name, day,
   month, year, and time-of-day
   are the same as those defined for the Internet Message Format constructs
   with the corresponding name ([RFC5322], Section 3.3).¶

   Recipients of a timestamp value in rfc850-date format, which uses a
   two-digit year, MUST interpret a timestamp that appears to be more
   than 50 years in the future as representing the most recent year in the
   past that had the same last two digits.¶

   Recipients of timestamp values are encouraged to be robust in parsing
   timestamps unless otherwise restricted by the field definition.
   For example, messages are occasionally forwarded over HTTP from a non-HTTP
   source that might generate any of the date and time specifications defined
   by the Internet Message Format.¶


Note: HTTP requirements for timestamp formats apply only
    to their usage within the protocol stream. Implementations are
    not required to use these formats for user presentation, request
    logging, etc.¶










6. Message Abstraction





   Each major version of HTTP defines its own syntax for communicating
   messages. This section defines an abstract data type for HTTP messages
   based on a generalization of those message characteristics, common structure,
   and capacity for conveying semantics. This abstraction is used to define
   requirements on senders and recipients that are independent of the HTTP
   version, such that a message in one version can be relayed through other
   versions without changing its meaning.¶

   A ""message"" consists of the following:¶

control data to describe and route the message,¶

a headers lookup table of name/value pairs for extending that control
      data and conveying additional information about the sender, message,
      content, or context,¶

a potentially unbounded stream of content, and¶

a trailers lookup table of name/value pairs for communicating information
      obtained while sending the content.¶



   Framing and control data is sent first, followed by a header section
   containing fields for the headers table. When a message includes content,
   the content is sent after the header section, potentially followed by a
   trailer section that might contain fields for the trailers table.¶

   Messages are expected to be processed as a stream, wherein the purpose of
   that stream and its continued processing is revealed while being read.
   Hence, control data describes what the recipient needs to know immediately,
   header fields describe what needs to be known before receiving content,
   the content (when present) presumably contains what the recipient wants or
   needs to fulfill the message semantics, and trailer fields provide
   optional metadata that was unknown prior to sending the content.¶

   Messages are intended to be ""self-descriptive"":
   everything a recipient needs to know about the message can be determined by
   looking at the message itself, after decoding or reconstituting parts that
   have been compressed or elided in transit, without requiring an
   understanding of the sender's current application state (established via
   prior messages). However, a client MUST retain knowledge of the request when
   parsing, interpreting, or caching a corresponding response. For example,
   responses to the HEAD method look just like the beginning of a
   response to GET but cannot be parsed in the same manner.¶

   Note that this message abstraction is a generalization across many versions
   of HTTP, including features that might not be found in some versions. For
   example, trailers were introduced within the HTTP/1.1 chunked transfer
   coding as a trailer section after the content. An equivalent feature is
   present in HTTP/2 and HTTP/3 within the header block that terminates each
   stream.¶



6.1. Framing and Completeness




   Message framing indicates how each message begins and ends, such that each
   message can be distinguished from other messages or noise on the same
   connection. Each major version of HTTP defines its own framing mechanism.¶

   HTTP/0.9 and early deployments of HTTP/1.0 used closure of the underlying
   connection to end a response. For backwards compatibility, this implicit
   framing is also allowed in HTTP/1.1. However, implicit framing can fail to
   distinguish an incomplete response if the connection closes early. For
   that reason, almost all modern implementations use explicit framing in
   the form of length-delimited sequences of message data.¶

   A message is considered ""complete"" when all of the octets
   indicated by its framing are available. Note that,
   when no explicit framing is used, a response message that is ended
   by the underlying connection's close is considered complete even though it
   might be indistinguishable from an incomplete response, unless a
   transport-level error indicates that it is not complete.¶





6.2. Control Data



   Messages start with control data that describe its primary purpose. Request
   message control data includes a request method (Section 9),
   request target (Section 7.1), and protocol version
   (Section 2.5). Response message control data includes
   a status code (Section 15), optional reason phrase, and
   protocol version.¶

   In HTTP/1.1 ([HTTP/1.1]) and earlier, control data is sent
   as the first line of a message. In HTTP/2 ([HTTP/2]) and
   HTTP/3 ([HTTP/3]), control data is sent as pseudo-header
   fields with a reserved name prefix (e.g., "":authority"").¶

   Every HTTP message has a protocol version. Depending on the version in use,
   it might be identified within the message explicitly or inferred by the
   connection over which the message is received. Recipients use that version
   information to determine limitations or potential for later communication
   with that sender.¶

   When a message is forwarded by an intermediary, the protocol version is
   updated to reflect the version used by that intermediary.
   The Via header field (Section 7.6.3) is used to
   communicate upstream protocol information within a forwarded message.¶

   A client SHOULD send a request version equal to the highest
   version to which the client is conformant and
   whose major version is no higher than the highest version supported
   by the server, if this is known.  A client MUST NOT send a
   version to which it is not conformant.¶

   A client MAY send a lower request version if it is known that
   the server incorrectly implements the HTTP specification, but only
   after the client has attempted at least one normal request and determined
   from the response status code or header fields (e.g., Server) that
   the server improperly handles higher request versions.¶

   A server SHOULD send a response version equal to the highest version to
   which the server is conformant that has a major version less than or equal
   to the one received in the request.
   A server MUST NOT send a version to which it is not conformant.
   A server can send a 505 (HTTP Version Not Supported)
   response if it wishes, for any reason, to refuse service of the client's
   major protocol version.¶

   A recipient that receives a message with a major version number that it
   implements and a minor version number higher than what it implements
   SHOULD process the message as if it
   were in the highest minor version within that major version to which the
   recipient is conformant. A recipient can assume that a message with a
   higher minor version, when sent to a recipient that has not yet indicated
   support for that higher version, is sufficiently backwards-compatible to be
   safely processed by any implementation of the same major version.¶





6.3. Header Fields




   Fields (Section 5) that are sent or received before the content
   are referred to as ""header fields"" (or just ""headers"", colloquially).¶

   The ""header section"" of a message consists of a sequence of
   header field lines. Each header field might modify or extend message
   semantics, describe the sender, define the content, or provide additional
   context.¶


Note: We refer to named fields specifically as a ""header field"" when they
    are only allowed to be sent in the header section.¶






6.4. Content



   HTTP messages often transfer a complete or partial representation as the
   message ""content"": a stream of octets sent after the header
   section, as delineated by the message framing.¶

   This abstract definition of content reflects the data after it has been
   extracted from the message framing. For example, an HTTP/1.1 message body
   (Section 6 of [HTTP/1.1]) might consist of a stream of data encoded
   with the chunked transfer coding -- a sequence of data chunks, one
   zero-length chunk, and a trailer section -- whereas
   the content of that same message
   includes only the data stream after the transfer coding has been decoded;
   it does not include the chunk lengths, chunked framing syntax, nor the
   trailer fields (Section 6.5).¶


Note: Some field names have a ""Content-"" prefix. This is an informal
      convention; while some of these fields refer to the content of the
      message, as defined above, others are scoped to the selected representation
      (Section 3.2). See the individual field's
      definition to disambiguate.¶




6.4.1. Content Semantics


   The purpose of content in a request is defined by the method semantics
   (Section 9).¶

   For example, a representation in the content of a PUT request
   (Section 9.3.4) represents the desired state of the
   target resource after the request is successfully applied,
   whereas a representation in the content of a POST request
   (Section 9.3.3) represents information to be processed by the
   target resource.¶

   In a response, the content's purpose is defined by the request method,
   response status code (Section 15), and response
   fields describing that content.
   For example, the content of a 200 (OK) response to GET
   (Section 9.3.1) represents the current state of the
   target resource, as observed at the time of the message
   origination date (Section 6.6.1), whereas the content of
   the same status code in a response to POST might represent either the
   processing result or the new state of the target resource after applying
   the processing.¶

   The content of a 206 (Partial Content) response to GET
   contains either a single part of the selected representation or a
   multipart message body containing multiple parts of that representation,
   as described in Section 15.3.7.¶

   Response messages with an error status code usually contain content that
   represents the error condition, such that the content describes the
   error state and what steps are suggested for resolving it.¶

   Responses to the HEAD request method (Section 9.3.2) never include
   content; the associated response header fields indicate only
   what their values would have been if the request method had been GET
   (Section 9.3.1).¶

2xx (Successful) responses to a CONNECT request method
   (Section 9.3.6) switch the connection to tunnel mode instead of
   having content.¶

   All 1xx (Informational), 204 (No Content), and
   304 (Not Modified) responses do not include content.¶

   All other responses do include content, although that content
   might be of zero length.¶





6.4.2. Identifying Content


   When a complete or partial representation is transferred as message
   content, it is often desirable for the sender to supply, or the recipient
   to determine, an identifier for a resource corresponding to that specific
   representation. For example, a client making a GET request on a resource
   for ""the current weather report"" might want an identifier specific to the
   content returned (e.g., ""weather report for Laguna Beach at 20210720T1711"").
   This can be useful for sharing or bookmarking content from resources that
   are expected to have changing representations over time.¶

   For a request message:¶

If the request has a Content-Location header field,
       then the sender asserts that the content is a representation of the
       resource identified by the Content-Location field value. However,
       such an assertion cannot be trusted unless it can be verified by
       other means (not defined by this specification). The information
       might still be useful for revision history links.¶

Otherwise, the content is unidentified by HTTP, but a more specific
       identifier might be supplied within the content itself.¶



   For a response message, the following rules are applied in order until a
   match is found:¶

If the request method is HEAD or the response status code is
       204 (No Content) or 304 (Not Modified),
       there is no content in the response.¶

If the request method is GET and the response status code is
       200 (OK),
       the content is a representation of the target resource (Section 7.1).¶

If the request method is GET and the response status code is
       203 (Non-Authoritative Information), the content is
       a potentially modified or enhanced representation of the
       target resource as provided by an intermediary.¶

If the request method is GET and the response status code is
       206 (Partial Content),
       the content is one or more parts of a representation of the
       target resource.¶

If the response has a Content-Location header field
       and its field value is a reference to the same URI as the target URI,
       the content is a representation of the target resource.¶

If the response has a Content-Location header field
       and its field value is a reference to a URI different from the
       target URI, then the sender asserts that the content is a
       representation of the resource identified by the Content-Location
       field value. However, such an assertion cannot be trusted unless
       it can be verified by other means (not defined by this specification).¶

Otherwise, the content is unidentified by HTTP, but a more specific
       identifier might be supplied within the content itself.¶









6.5. Trailer Fields





   Fields (Section 5) that are located within a
   ""trailer section"" are referred to as ""trailer fields""
   (or just ""trailers"", colloquially).
   Trailer fields can be useful for supplying message integrity checks, digital
   signatures, delivery metrics, or post-processing status information.¶

   Trailer fields ought to be processed and stored separately from the fields
   in the header section to avoid contradicting message semantics known at
   the time the header section was complete. The presence or absence of
   certain header fields might impact choices made for the routing or
   processing of the message as a whole before the trailers are received;
   those choices cannot be unmade by the later discovery of trailer fields.¶



6.5.1. Limitations on Use of Trailers


   A trailer section is only possible when supported by the version
   of HTTP in use and enabled by an explicit framing mechanism.
   For example, the chunked transfer coding in HTTP/1.1 allows a trailer section to be
   sent after the content (Section 7.1.2 of [HTTP/1.1]).¶

   Many fields cannot be processed outside the header section because
   their evaluation is necessary prior to receiving the content, such as
   those that describe message framing, routing, authentication,
   request modifiers, response controls, or content format.
   A sender MUST NOT generate a trailer field unless the sender knows the
   corresponding header field name's definition permits the field to be sent
   in trailers.¶

   Trailer fields can be difficult to process by intermediaries that forward
   messages from one protocol version to another. If the entire message can be
   buffered in transit, some intermediaries could merge trailer fields into
   the header section (as appropriate) before it is forwarded. However, in
   most cases, the trailers are simply discarded.
   A recipient MUST NOT merge a trailer field into a header section unless
   the recipient understands the corresponding header field definition and
   that definition explicitly permits and defines how trailer field values
   can be safely merged.¶

   The presence of the keyword ""trailers"" in the TE header field (Section 10.1.4) of a request indicates that the client is willing to
   accept trailer fields, on behalf of itself and any downstream clients. For
   requests from an intermediary, this implies that all
   downstream clients are willing to accept trailer fields in the forwarded
   response. Note that the presence of ""trailers"" does not mean that the
   client(s) will process any particular trailer field in the response; only
   that the trailer section(s) will not be dropped by any of the clients.¶

   Because of the potential for trailer fields to be discarded in transit, a
   server SHOULD NOT generate trailer fields that it believes are necessary
   for the user agent to receive.¶





6.5.2. Processing Trailer Fields


   The ""Trailer"" header field (Section 6.6.2) can be sent
   to indicate fields likely to be sent in the trailer section, which allows
   recipients to prepare for their receipt before processing the content.
   For example, this could be useful if a field name indicates that a dynamic
   checksum should be calculated as the content is received and then
   immediately checked upon receipt of the trailer field value.¶

   Like header fields, trailer fields with the same name are processed in the
   order received; multiple trailer field lines with the same name have the
   equivalent semantics as appending the multiple values as a list of members.
   Trailer fields that might be generated more than once during a message
   MUST be defined as a list-based field even if each member value is only
   processed once per field line received.¶

   At the end of a message, a recipient MAY treat the set of received
   trailer fields as a data structure of name/value pairs, similar to (but
   separate from) the header fields. Additional processing expectations, if
   any, can be defined within the field specification for a field intended
   for use in trailers.¶







6.6. Message Metadata


   Fields that describe the message itself, such as when and how the
   message has been generated, can appear in both requests and responses.¶



6.6.1. Date





   The ""Date"" header field represents the date and time at which
   the message was originated, having the same semantics as the Origination
   Date Field (orig-date) defined in Section 3.6.1 of [RFC5322].
   The field value is an HTTP-date, as defined in Section 5.6.7.¶


  Date = HTTP-date
¶


   An example is¶

Date: Tue, 15 Nov 1994 08:12:31 GMT
¶


   A sender that generates a Date header field SHOULD generate its
   field value as the best available approximation of the date and time of
   message generation. In theory, the date ought to represent the moment just
   before generating the message content. In practice, a sender can generate
   the date value at any time during message origination.¶

   An origin server with a clock (as defined in
   Section 5.6.7) MUST generate a Date header field in
   all 2xx (Successful), 3xx (Redirection),
   and 4xx (Client Error) responses,
   and MAY generate a Date header field in
   1xx (Informational) and
   5xx (Server Error) responses.¶

   An origin server without a clock MUST NOT generate a Date header field.¶

   A recipient with a clock that receives a response message without a Date
   header field MUST record the time it was received and append a
   corresponding Date header field to the message's header section if it is
   cached or forwarded downstream.¶

   A recipient with a clock that receives a response with an invalid Date
   header field value MAY replace that value with the time that
   response was received.¶

   A user agent MAY send a Date header field in a request, though generally
   will not do so unless it is believed to convey useful information to the
   server. For example, custom applications of HTTP might convey a Date if
   the server is expected to adjust its interpretation of the user's request
   based on differences between the user agent and server clocks.¶





6.6.2. Trailer





   The ""Trailer"" header field provides a list of field names that the sender
   anticipates sending as trailer fields within that message. This allows a
   recipient to prepare for receipt of the indicated metadata before it starts
   processing the content.¶



  Trailer = #field-name
¶


   For example, a sender might indicate that a signature will
   be computed as the content is being streamed and provide the final
   signature as a trailer field. This allows a recipient to perform the same
   check on the fly as it receives the content.¶

   A sender that intends to generate one or more trailer fields in a message
   SHOULD generate a Trailer header field in the header
   section of that message to indicate which fields might be present in the
   trailers.¶

   If an intermediary discards the trailer section in transit, the
   Trailer field could provide a hint of what metadata
   was lost, though there is no guarantee that a sender of Trailer
   will always follow through by sending the named fields.¶









7. Routing HTTP Messages


   HTTP request message routing is determined by each client based on the
   target resource, the client's proxy configuration, and
   establishment or reuse of an inbound connection.  The corresponding
   response routing follows the same connection chain back to the client.¶



7.1. Determining the Target Resource





   Although HTTP is used in a wide variety of applications, most clients rely
   on the same resource identification mechanism and configuration techniques
   as general-purpose Web browsers. Even when communication options are
   hard-coded in a client's configuration, we can think of their combined
   effect as a URI reference (Section 4.1).¶

   A URI reference is resolved to its absolute form in order to obtain the
   ""target URI"". The target URI excludes the reference's
   fragment component, if any, since fragment identifiers are reserved for
   client-side processing ([URI], Section 3.5).¶

   To perform an action on a ""target resource"", the client sends
   a request message containing enough components of its parsed target URI to
   enable recipients to identify that same resource. For historical reasons,
   the parsed target URI components, collectively referred to as the
   ""request target"", are sent within the message control data
   and the Host header field (Section 7.2).¶

   There are two unusual cases for which the request target components are in
   a method-specific form:¶


      For CONNECT (Section 9.3.6), the request target is the host
      name and port number of the tunnel destination, separated by a colon.¶


      For OPTIONS (Section 9.3.7), the request target can be a
      single asterisk (""*"").¶



   See the respective method definitions for details. These forms MUST NOT
   be used with other methods.¶

   Upon receipt of a client's request, a server reconstructs the target URI
   from the received components in accordance with their local configuration
   and incoming connection context. This reconstruction is specific to each
   major protocol version. For example,
   Section 3.3 of [HTTP/1.1] defines how a server
   determines the target URI of an HTTP/1.1 request.¶




Note: Previous specifications defined the recomposed target URI as a
    distinct concept, the ""effective request URI"".¶







7.2. Host and :authority





   The ""Host"" header field in a request provides the host and port
   information from the target URI, enabling the origin
   server to distinguish among resources while servicing requests
   for multiple host names.¶

   In HTTP/2 [HTTP/2] and HTTP/3 [HTTP/3], the
   Host header field is, in some cases, supplanted by the "":authority""
   pseudo-header field of a request's control data.¶


  Host = uri-host [ "":"" port ] ; Section 4
¶


   The target URI's authority information is critical for handling a
   request. A user agent MUST generate a Host header field in a request
   unless it sends that information as an "":authority"" pseudo-header field.
   A user agent that sends Host SHOULD send it as the first field in the
   header section of a request.¶

   For example, a GET request to the origin server for
   <http://www.example.org/pub/WWW/> would begin with:¶

GET /pub/WWW/ HTTP/1.1
Host: www.example.org
¶


   Since the host and port information acts as an application-level routing
   mechanism, it is a frequent target for malware seeking to poison
   a shared cache or redirect a request to an unintended server.
   An interception proxy is particularly vulnerable if it relies on
   the host and port information for redirecting requests to internal
   servers, or for use as a cache key in a shared cache, without
   first verifying that the intercepted connection is targeting a
   valid IP address for that host.¶





7.3. Routing Inbound Requests


   Once the target URI and its origin are determined, a client decides whether
   a network request is necessary to accomplish the desired semantics and,
   if so, where that request is to be directed.¶



7.3.1. To a Cache


   If the client has a cache [CACHING] and the request can be
   satisfied by it, then the request is
   usually directed there first.¶





7.3.2. To a Proxy


   If the request is not satisfied by a cache, then a typical client will
   check its configuration to determine whether a proxy is to be used to
   satisfy the request.  Proxy configuration is implementation-dependent,
   but is often based on URI prefix matching, selective authority matching,
   or both, and the proxy itself is usually identified by an ""http"" or
   ""https"" URI.¶

   If an ""http"" or ""https"" proxy is applicable, the client connects
   inbound by establishing (or reusing) a connection to that proxy and
   then sending it an HTTP request message containing a request target
   that matches the client's target URI.¶





7.3.3. To the Origin


   If no proxy is applicable, a typical client will invoke a handler
   routine (specific to the target URI's scheme) to obtain access to the
   identified resource. How that is accomplished is dependent on the
   target URI scheme and defined by its associated specification.¶

Section 4.3.2 defines how to obtain access to an
   ""http"" resource by establishing (or reusing) an inbound connection to
   the identified origin server and then sending it an HTTP request message
   containing a request target that matches the client's target URI.¶

Section 4.3.3 defines how to obtain access to an
   ""https"" resource by establishing (or reusing) an inbound secured
   connection to an origin server that is authoritative for the identified
   origin and then sending it an HTTP request message containing a request
   target that matches the client's target URI.¶







7.4. Rejecting Misdirected Requests


   Once a request is received by a server and parsed sufficiently to determine
   its target URI, the server decides whether to process the request itself,
   forward the request to another server, redirect the client to a different
   resource, respond with an error, or drop the connection. This decision can
   be influenced by anything about the request or connection context, but is
   specifically directed at whether the server has been configured to process
   requests for that target URI and whether the connection context is
   appropriate for that request.¶

   For example, a request might have been misdirected,
   deliberately or accidentally, such that the information within a received
   Host header field differs from the connection's host or port.
   If the connection is from a trusted gateway, such inconsistency might
   be expected; otherwise, it might indicate an attempt to bypass security
   filters, trick the server into delivering non-public content, or poison a
   cache. See Section 17 for security
   considerations regarding message routing.¶

   Unless the connection is from a trusted gateway,
   an origin server MUST reject a request if any scheme-specific requirements
   for the target URI are not met. In particular,
   a request for an ""https"" resource MUST be rejected unless it has been
   received over a connection that has been secured via a certificate
   valid for that target URI's origin, as defined by Section 4.2.2.¶

   The 421 (Misdirected Request) status code in a response
   indicates that the origin server has rejected the request because it
   appears to have been misdirected (Section 15.5.20).¶





7.5. Response Correlation


   A connection might be used for multiple request/response exchanges. The
   mechanism used to correlate between request and response messages is
   version dependent; some versions of HTTP use implicit ordering of
   messages, while others use an explicit identifier.¶

   All responses, regardless of the status code (including interim
   responses) can be sent at any time after a request is received, even if the
   request is not yet complete. A response can complete before its
   corresponding request is complete (Section 6.1). Likewise, clients are not expected
   to wait any specific amount of time for a response. Clients
   (including intermediaries) might abandon a request if the response is not
   received within a reasonable period of time.¶

   A client that receives a response while it is still sending the associated
   request SHOULD continue sending that request unless it receives
   an explicit indication to the contrary (see, e.g., Section 9.5 of [HTTP/1.1] and Section 6.4 of [HTTP/2]).¶





7.6. Message Forwarding


   As described in Section 3.7, intermediaries can serve
   a variety of roles in the processing of HTTP requests and responses.
   Some intermediaries are used to improve performance or availability.
   Others are used for access control or to filter content.
   Since an HTTP stream has characteristics similar to a pipe-and-filter
   architecture, there are no inherent limits to the extent an intermediary
   can enhance (or interfere) with either direction of the stream.¶

   Intermediaries are expected to forward messages even when protocol elements
   are not recognized (e.g., new methods, status codes, or field names) since that
   preserves extensibility for downstream recipients.¶

   An intermediary not acting as a tunnel MUST implement the
   Connection header field, as specified in
   Section 7.6.1, and exclude fields from being forwarded
   that are only intended for the incoming connection.¶

   An intermediary MUST NOT forward a message to itself unless it is
   protected from an infinite request loop. In general, an intermediary ought
   to recognize its own server names, including any aliases, local variations,
   or literal IP addresses, and respond to such requests directly.¶

   An HTTP message can be parsed as a stream for incremental processing or
   forwarding downstream.
   However, senders and recipients cannot rely on incremental
   delivery of partial messages, since some implementations will buffer or
   delay message forwarding for the sake of network efficiency, security
   checks, or content transformations.¶



7.6.1. Connection







   The ""Connection"" header field allows the sender to list desired
   control options for the current connection.¶

  Connection        = #connection-option
  connection-option = token
¶


   Connection options are case-insensitive.¶

   When a field aside from Connection is used to supply control
   information for or about the current connection, the sender MUST list
   the corresponding field name within the Connection header field.
   Note that some versions of HTTP prohibit the use of fields for such
   information, and therefore do not allow the Connection field.¶

   Intermediaries MUST parse a received Connection
   header field before a message is forwarded and, for each
   connection-option in this field, remove any header or trailer field(s) from
   the message with the same name as the connection-option, and then
   remove the Connection header field itself (or replace it with the
   intermediary's own control options for the forwarded message).¶

   Hence, the Connection header field provides a declarative way of
   distinguishing fields that are only intended for the
   immediate recipient (""hop-by-hop"") from those fields that are
   intended for all recipients on the chain (""end-to-end""), enabling the
   message to be self-descriptive and allowing future connection-specific
   extensions to be deployed without fear that they will be blindly
   forwarded by older intermediaries.¶

   Furthermore, intermediaries SHOULD remove or replace fields
   that are known to require removal before forwarding, whether or not they appear as a
   connection-option, after applying those fields' semantics. This includes but is not limited to:¶

Proxy-Connection (Appendix C.2.2 of [HTTP/1.1])¶

Keep-Alive (Section 19.7.1 of [RFC2068])¶

TE (Section 10.1.4)¶

Transfer-Encoding (Section 6.1 of [HTTP/1.1])¶

Upgrade (Section 7.8)¶



   A sender MUST NOT send a connection option corresponding to a
   field that is intended for all recipients of the content.
   For example, Cache-Control is never appropriate as a
   connection option (Section 5.2 of [CACHING]).¶

   Connection options do not always correspond to a field
   present in the message, since a connection-specific field
   might not be needed if there are no parameters associated with a
   connection option. In contrast, a connection-specific field
   received without a corresponding connection option usually indicates
   that the field has been improperly forwarded by an intermediary and
   ought to be ignored by the recipient.¶

   When defining a new connection option that does not correspond to a field,
   specification authors ought to reserve the corresponding field name
   anyway in order to avoid later collisions. Such reserved field names are
   registered in the ""Hypertext Transfer Protocol (HTTP) Field Name Registry""
   (Section 16.3.1).¶





7.6.2. Max-Forwards





   The ""Max-Forwards"" header field provides a mechanism with the
   TRACE (Section 9.3.8) and OPTIONS (Section 9.3.7)
   request methods to limit the number of times that the request is forwarded by
   proxies. This can be useful when the client is attempting to
   trace a request that appears to be failing or looping mid-chain.¶


  Max-Forwards = 1*DIGIT
¶


   The Max-Forwards value is a decimal integer indicating the remaining
   number of times this request message can be forwarded.¶

   Each intermediary that receives a TRACE or OPTIONS request containing a
   Max-Forwards header field MUST check and update its value prior to
   forwarding the request. If the received value is zero (0), the intermediary
   MUST NOT forward the request; instead, the intermediary MUST respond as
   the final recipient. If the received Max-Forwards value is greater than
   zero, the intermediary MUST generate an updated Max-Forwards field in the
   forwarded message with a field value that is the lesser of a) the received
   value decremented by one (1) or b) the recipient's maximum supported value
   for Max-Forwards.¶

   A recipient MAY ignore a Max-Forwards header field received with any
   other request methods.¶





7.6.3. Via





   The ""Via"" header field indicates the presence of intermediate protocols and
   recipients between the user agent and the server (on requests) or between
   the origin server and the client (on responses), similar to the
   ""Received"" header field in email
   (Section 3.6.7 of [RFC5322]).
   Via can be used for tracking message forwards,
   avoiding request loops, and identifying the protocol capabilities of
   senders along the request/response chain.¶







  Via = #( received-protocol RWS received-by [ RWS comment ] )

  received-protocol = [ protocol-name ""/"" ] protocol-version
                    ; see Section 7.8
  received-by       = pseudonym [ "":"" port ]
  pseudonym         = token
¶


   Each member of the Via field value represents a proxy or gateway that has
   forwarded the message. Each intermediary appends its own information
   about how the message was received, such that the end result is ordered
   according to the sequence of forwarding recipients.¶

   A proxy MUST send an appropriate Via header field, as described below, in
   each message that it forwards.
   An HTTP-to-HTTP gateway MUST send an appropriate Via header field in
   each inbound request message and MAY send a Via header field in
   forwarded response messages.¶

   For each intermediary, the received-protocol indicates the protocol and
   protocol version used by the upstream sender of the message. Hence, the
   Via field value records the advertised protocol capabilities of the
   request/response chain such that they remain visible to downstream
   recipients; this can be useful for determining what backwards-incompatible
   features might be safe to use in response, or within a later request, as
   described in Section 2.5. For brevity, the protocol-name
   is omitted when the received protocol is HTTP.¶

   The received-by portion is normally the host and optional
   port number of a recipient server or client that subsequently forwarded the
   message.
   However, if the real host is considered to be sensitive information, a
   sender MAY replace it with a pseudonym. If a port is not provided,
   a recipient MAY interpret that as meaning it was received on the default
   port, if any, for the received-protocol.¶

   A sender MAY generate comments to identify the
   software of each recipient, analogous to the User-Agent and
   Server header fields. However, comments in Via
   are optional, and a recipient MAY remove them prior to forwarding the
   message.¶

   For example, a request message could be sent from an HTTP/1.0 user
   agent to an internal proxy code-named ""fred"", which uses HTTP/1.1 to
   forward the request to a public proxy at p.example.net, which completes
   the request by forwarding it to the origin server at www.example.com.
   The request received by www.example.com would then have the following
   Via header field:¶

Via: 1.0 fred, 1.1 p.example.net
¶


   An intermediary used as a portal through a network firewall
   SHOULD NOT forward the names and ports of hosts within the firewall
   region unless it is explicitly enabled to do so. If not enabled, such an
   intermediary SHOULD replace each received-by host of any host behind the
   firewall by an appropriate pseudonym for that host.¶

   An intermediary MAY combine an ordered subsequence of Via header
   field list members into a single member if the entries have identical
   received-protocol values. For example,¶

Via: 1.0 ricky, 1.1 ethel, 1.1 fred, 1.0 lucy
¶


  could be collapsed to¶

Via: 1.0 ricky, 1.1 mertz, 1.0 lucy
¶


   A sender SHOULD NOT combine multiple list members unless they are all
   under the same organizational control and the hosts have already been
   replaced by pseudonyms. A sender MUST NOT combine members that
   have different received-protocol values.¶







7.7. Message Transformations




   Some intermediaries include features for transforming messages and their
   content. A proxy might, for example, convert between image formats in
   order to save cache space or to reduce the amount of traffic on a slow
   link. However, operational problems might occur when these transformations
   are applied to content intended for critical applications, such as medical
   imaging or scientific data analysis, particularly when integrity checks or
   digital signatures are used to ensure that the content received is
   identical to the original.¶

   An HTTP-to-HTTP proxy is called a ""transforming proxy""
   if it is designed or configured to modify messages in a semantically
   meaningful way (i.e., modifications, beyond those required by normal
   HTTP processing, that change the message in a way that would be
   significant to the original sender or potentially significant to
   downstream recipients).  For example, a transforming proxy might be
   acting as a shared annotation server (modifying responses to include
   references to a local annotation database), a malware filter, a
   format transcoder, or a privacy filter. Such transformations are presumed
   to be desired by whichever client (or client organization) chose the
   proxy.¶

   If a proxy receives a target URI with a host name that is not a
   fully qualified domain name, it MAY add its own domain to the host name
   it received when forwarding the request.  A proxy MUST NOT change the
   host name if the target URI contains a fully qualified domain name.¶

   A proxy MUST NOT modify the ""absolute-path"" and ""query"" parts of the
   received target URI when forwarding it to the next inbound server except
   as required by that forwarding protocol. For example, a proxy forwarding
   a request to an origin server via HTTP/1.1 will replace an empty path with
   ""/"" (Section 3.2.1 of [HTTP/1.1]) or ""*"" (Section 3.2.4 of [HTTP/1.1]),
   depending on the request method.¶

   A proxy MUST NOT transform the content (Section 6.4) of a
   response message that contains a no-transform cache directive
   (Section 5.2.2.6 of [CACHING]). Note that this
   does not apply to message transformations that do not change the content,
   such as the addition or removal of transfer codings
   (Section 7 of [HTTP/1.1]).¶

   A proxy MAY transform the content of a message
   that does not contain a no-transform cache directive.
   A proxy that transforms the content of a 200 (OK) response
   can inform downstream recipients that a transformation has been
   applied by changing the response status code to
   203 (Non-Authoritative Information) (Section 15.3.4).¶

   A proxy SHOULD NOT modify header fields that provide information about
   the endpoints of the communication chain, the resource state, or the
   selected representation (other than the content) unless the field's
   definition specifically allows such modification or the modification is
   deemed necessary for privacy or security.¶





7.8. Upgrade





   The ""Upgrade"" header field is intended to provide a simple mechanism
   for transitioning from HTTP/1.1 to some other protocol on the same
   connection.¶

   A client MAY send a list of protocol names in the Upgrade header field
   of a request to invite the server to switch to one or more of the named
   protocols, in order of descending preference, before sending
   the final response. A server MAY ignore a received Upgrade header field
   if it wishes to continue using the current protocol on that connection.
   Upgrade cannot be used to insist on a protocol change.¶


  Upgrade          = #protocol

  protocol         = protocol-name [""/"" protocol-version]
  protocol-name    = token
  protocol-version = token
¶


   Although protocol names are registered with a preferred case,
   recipients SHOULD use case-insensitive comparison when matching each
   protocol-name to supported protocols.¶

   A server that sends a 101 (Switching Protocols) response
   MUST send an Upgrade header field to indicate the new protocol(s) to
   which the connection is being switched; if multiple protocol layers are
   being switched, the sender MUST list the protocols in layer-ascending
   order. A server MUST NOT switch to a protocol that was not indicated by
   the client in the corresponding request's Upgrade header field.
   A server MAY choose to ignore the order of preference indicated by the
   client and select the new protocol(s) based on other factors, such as the
   nature of the request or the current load on the server.¶

   A server that sends a 426 (Upgrade Required) response
   MUST send an Upgrade header field to indicate the acceptable protocols,
   in order of descending preference.¶

   A server MAY send an Upgrade header field in any other response to
   advertise that it implements support for upgrading to the listed protocols,
   in order of descending preference, when appropriate for a future request.¶

   The following is a hypothetical example sent by a client:¶

GET /hello HTTP/1.1
Host: www.example.com
Connection: upgrade
Upgrade: websocket, IRC/6.9, RTA/x11

¶


   The capabilities and nature of the
   application-level communication after the protocol change is entirely
   dependent upon the new protocol(s) chosen. However, immediately after
   sending the 101 (Switching Protocols) response, the server is expected to continue responding to
   the original request as if it had received its equivalent within the new
   protocol (i.e., the server still has an outstanding request to satisfy
   after the protocol has been changed, and is expected to do so without
   requiring the request to be repeated).¶

   For example, if the Upgrade header field is received in a GET request
   and the server decides to switch protocols, it first responds
   with a 101 (Switching Protocols) message in HTTP/1.1 and
   then immediately follows that with the new protocol's equivalent of a
   response to a GET on the target resource.  This allows a connection to be
   upgraded to protocols with the same semantics as HTTP without the
   latency cost of an additional round trip.  A server MUST NOT switch
   protocols unless the received message semantics can be honored by the new
   protocol; an OPTIONS request can be honored by any protocol.¶

   The following is an example response to the above hypothetical request:¶

HTTP/1.1 101 Switching Protocols
Connection: upgrade
Upgrade: websocket

[... data stream switches to websocket with an appropriate response
(as defined by new protocol) to the ""GET /hello"" request ...]
¶


   A sender of Upgrade MUST also send an ""Upgrade"" connection option in the
   Connection header field (Section 7.6.1)
   to inform intermediaries not to forward this field.
   A server that receives an Upgrade header field in an HTTP/1.0 request
   MUST ignore that Upgrade field.¶

   A client cannot begin using an upgraded protocol on the connection until
   it has completely sent the request message (i.e., the client can't change
   the protocol it is sending in the middle of a message).
   If a server receives both an Upgrade and an Expect header field
   with the ""100-continue"" expectation (Section 10.1.1), the
   server MUST send a 100 (Continue) response before sending
   a 101 (Switching Protocols) response.¶

   The Upgrade header field only applies to switching protocols on top of the
   existing connection; it cannot be used to switch the underlying connection
   (transport) protocol, nor to switch the existing communication to a
   different connection. For those purposes, it is more appropriate to use a
   3xx (Redirection) response (Section 15.4).¶

   This specification only defines the protocol name ""HTTP"" for use by
   the family of Hypertext Transfer Protocols, as defined by the HTTP
   version rules of Section 2.5 and future updates to this
   specification. Additional protocol names ought to be registered using the
   registration procedure defined in Section 16.7.¶







8. Representation Data and Metadata




8.1. Representation Data


   The representation data associated with an HTTP message is
   either provided as the content of the message or
   referred to by the message semantics and the target
   URI.  The representation data is in a format and encoding defined by
   the representation metadata header fields.¶

   The data type of the representation data is determined via the header fields
   Content-Type and Content-Encoding.
   These define a two-layer, ordered encoding model:¶

  representation-data := Content-Encoding( Content-Type( data ) )
¶






8.2. Representation Metadata


   Representation header fields provide metadata about the representation.
   When a message includes content, the representation header fields
   describe how to interpret that data. In a response to a HEAD request, the
   representation header fields describe the representation data that would
   have been enclosed in the content if the same request had been a GET.¶





8.3. Content-Type





   The ""Content-Type"" header field indicates the media type of the
   associated representation: either the representation enclosed in
   the message content or the selected representation, as determined by the
   message semantics.  The indicated media type defines both the data format
   and how that data is intended to be processed by a recipient, within the
   scope of the received message semantics, after any content codings
   indicated by Content-Encoding are decoded.¶


  Content-Type = media-type
¶


   Media types are defined in Section 8.3.1. An example of the
   field is¶

Content-Type: text/html; charset=ISO-8859-4
¶


   A sender that generates a message containing content SHOULD
   generate a Content-Type header field in that message unless the intended
   media type of the enclosed representation is unknown to the sender.
   If a Content-Type header field is not present, the recipient MAY either
   assume a media type of
   ""application/octet-stream"" ([RFC2046], Section 4.5.1)
   or examine the data to determine its type.¶

   In practice, resource owners do not always properly configure their origin
   server to provide the correct Content-Type for a given representation.
   Some user agents examine the content and, in certain cases,
   override the received type (for example, see [Sniffing]).
   This ""MIME sniffing"" risks drawing incorrect conclusions about the data,
   which might expose the user to additional security risks
   (e.g., ""privilege escalation"").
   Furthermore, distinct media types often share a common data format,
   differing only in how the data is intended to be processed, which is
   impossible to distinguish by inspecting the data alone.
   When sniffing is implemented, implementers are encouraged to provide a
   means for the user to disable it.¶

   Although Content-Type is defined as a singleton field, it is
   sometimes incorrectly generated multiple times, resulting in a combined
   field value that appears to be a list.
   Recipients often attempt to handle this error by using the last
   syntactically valid member of the list, leading to potential
   interoperability and security issues if different implementations
   have different error handling behaviors.¶



8.3.1. Media Type


   HTTP uses media types [RFC2046] in the
   Content-Type (Section 8.3)
   and Accept (Section 12.5.1) header fields in
   order to provide open and extensible data typing and type negotiation.
   Media types define both a data format and various processing models:
   how to process that data in accordance with the message context.¶




  media-type = type ""/"" subtype parameters
  type       = token
  subtype    = token
¶


   The type and subtype tokens are case-insensitive.¶

   The type/subtype MAY be followed by semicolon-delimited parameters
   (Section 5.6.6) in the form of name/value pairs.
   The presence or absence of a parameter might be significant to the
   processing of a media type, depending on its definition within the media
   type registry.
   Parameter values might or might not be case-sensitive, depending on the
   semantics of the parameter name.¶

   For example, the following media types are equivalent in describing HTML
   text data encoded in the UTF-8 character encoding scheme, but the first is
   preferred for consistency (the ""charset"" parameter value is defined as
   being case-insensitive in [RFC2046], Section 4.1.2):¶

  text/html;charset=utf-8
  Text/HTML;Charset=""utf-8""
  text/html; charset=""utf-8""
  text/html;charset=UTF-8
¶


   Media types ought to be registered with IANA according to the
   procedures defined in [BCP13].¶





8.3.2. Charset


   HTTP uses ""charset"" names to indicate or negotiate the
   character encoding scheme ([RFC6365], Section 2)
   of a textual representation. In the fields defined by this document,
   charset names appear either in parameters (Content-Type),
   or, for Accept-Encoding, in the form of a plain token.
   In both cases, charset names are matched case-insensitively.¶

   Charset names ought to be registered in the IANA ""Character Sets"" registry
   (<https://www.iana.org/assignments/character-sets>)
   according to the procedures defined in Section 2 of [RFC2978].¶


Note: In theory, charset names are defined by the ""mime-charset"" ABNF
    rule defined in Section 2.3 of [RFC2978] (as
    corrected in [Err1912]). That rule allows two characters
    that are not included in ""token"" (""{"" and ""}""), but no charset name
    registered at the time of this writing includes braces
    (see [Err5433]).¶






8.3.3. Multipart Types


   MIME provides for a number of ""multipart"" types -- encapsulations of
   one or more representations within a single message body. All multipart
   types share a common syntax, as defined in Section 5.1.1 of [RFC2046],
   and include a boundary parameter as part of the media type
   value. The message body is itself a protocol element; a sender MUST
   generate only CRLF to represent line breaks between body parts.¶

   HTTP message framing does not use the multipart boundary as an indicator
   of message body length, though it might be used by implementations that
   generate or process the content. For example, the ""multipart/form-data""
   type is often used for carrying form data in a request, as described in
   [RFC7578], and the ""multipart/byteranges"" type is defined
   by this specification for use in some 206 (Partial Content)
   responses (see Section 15.3.7).¶







8.4. Content-Encoding





   The ""Content-Encoding"" header field indicates what content codings
   have been applied to the representation, beyond those inherent in the media
   type, and thus what decoding mechanisms have to be applied in order to
   obtain data in the media type referenced by the Content-Type
   header field.
   Content-Encoding is primarily used to allow a representation's data to be
   compressed without losing the identity of its underlying media type.¶


  Content-Encoding = #content-coding
¶


   An example of its use is¶

Content-Encoding: gzip
¶


   If one or more encodings have been applied to a representation, the sender
   that applied the encodings MUST generate a Content-Encoding header field
   that lists the content codings in the order in which they were applied.
   Note that the coding named ""identity"" is reserved for its special role
   in Accept-Encoding and thus SHOULD NOT be included.¶

   Additional information about the encoding parameters can be provided
   by other header fields not defined by this specification.¶

   Unlike Transfer-Encoding (Section 6.1 of [HTTP/1.1]), the codings listed
   in Content-Encoding are a characteristic of the representation; the
   representation is defined in terms of the coded form, and all other
   metadata about the representation is about the coded form unless otherwise
   noted in the metadata definition. Typically, the representation is only
   decoded just prior to rendering or analogous usage.¶

   If the media type includes an inherent encoding, such as a data format
   that is always compressed, then that encoding would not be restated in
   Content-Encoding even if it happens to be the same algorithm as one
   of the content codings.  Such a content coding would only be listed if,
   for some bizarre reason, it is applied a second time to form the
   representation.  Likewise, an origin server might choose to publish the
   same data as multiple representations that differ only in whether
   the coding is defined as part of Content-Type or
   Content-Encoding, since some user agents will behave differently in their
   handling of each response (e.g., open a ""Save as ..."" dialog instead of
   automatic decompression and rendering of content).¶

   An origin server MAY respond with a status code of
   415 (Unsupported Media Type) if a representation in the
   request message has a content coding that is not acceptable.¶



8.4.1. Content Codings








   Content coding values indicate an encoding transformation that has
   been or can be applied to a representation. Content codings are primarily
   used to allow a representation to be compressed or otherwise usefully
   transformed without losing the identity of its underlying media type
   and without loss of information. Frequently, the representation is stored
   in coded form, transmitted directly, and only decoded by the final recipient.¶


  content-coding   = token
¶


   All content codings are case-insensitive and ought to be registered
   within the ""HTTP Content Coding Registry"", as described in
   Section 16.6¶

   Content-coding values are used in the
   Accept-Encoding (Section 12.5.3)
   and Content-Encoding (Section 8.4)
   header fields.¶



8.4.1.1. Compress Coding



   The ""compress"" coding is an adaptive Lempel-Ziv-Welch (LZW) coding
   [Welch] that is commonly produced by the UNIX file
   compression program ""compress"".
   A recipient SHOULD consider ""x-compress"" to be equivalent to ""compress"".¶





8.4.1.2. Deflate Coding



   The ""deflate"" coding is a ""zlib"" data format [RFC1950]
   containing a ""deflate"" compressed data stream [RFC1951]
   that uses a combination of the Lempel-Ziv (LZ77) compression algorithm and
   Huffman coding.¶


Note: Some non-conformant implementations send the ""deflate""
    compressed data without the zlib wrapper.¶






8.4.1.3. Gzip Coding



   The ""gzip"" coding is an LZ77 coding with a 32-bit Cyclic Redundancy Check
   (CRC) that is commonly
   produced by the gzip file compression program [RFC1952].
   A recipient SHOULD consider ""x-gzip"" to be equivalent to ""gzip"".¶









8.5. Content-Language





   The ""Content-Language"" header field describes the natural
   language(s) of the intended audience for the representation. Note that this might
   not be equivalent to all the languages used within the representation.¶


  Content-Language = #language-tag
¶


   Language tags are defined in Section 8.5.1. The primary purpose of
   Content-Language is to allow a user to identify and differentiate
   representations according to the users' own preferred language. Thus, if the
   content is intended only for a Danish-literate audience, the
   appropriate field is¶

Content-Language: da
¶


   If no Content-Language is specified, the default is that the content
   is intended for all language audiences. This might mean that the
   sender does not consider it to be specific to any natural language,
   or that the sender does not know for which language it is intended.¶

   Multiple languages MAY be listed for content that is intended for
   multiple audiences. For example, a rendition of the ""Treaty of
   Waitangi"", presented simultaneously in the original Maori and English
   versions, would call for¶

Content-Language: mi, en
¶


   However, just because multiple languages are present within a representation
   does not mean that it is intended for multiple linguistic audiences.
   An example would be a beginner's language primer, such as ""A First
   Lesson in Latin"", which is clearly intended to be used by an
   English-literate audience. In this case, the Content-Language would
   properly only include ""en"".¶

   Content-Language MAY be applied to any media type -- it is not
   limited to textual documents.¶



8.5.1. Language Tags


   A language tag, as defined in [RFC5646], identifies a
   natural language spoken, written, or otherwise conveyed by human beings for
   communication of information to other human beings. Computer languages are
   explicitly excluded.¶

   HTTP uses language tags within the Accept-Language and
   Content-Language header fields.
   Accept-Language uses the broader language-range production
   defined in Section 12.5.4, whereas
   Content-Language uses the language-tag production defined
   below.¶


  language-tag = <Language-Tag, see [RFC5646], Section 2.1>
¶


   A language tag is a sequence of one or more case-insensitive subtags, each
   separated by a hyphen character (""-"", %x2D).  In most cases, a language tag
   consists of a primary language subtag that identifies a broad family of
   related languages (e.g., ""en"" = English), which is optionally followed by a
   series of subtags that refine or narrow that language's range (e.g.,
   ""en-CA"" = the variety of English as communicated in Canada).
   Whitespace is not allowed within a language tag.
   Example tags include:¶

  fr, en-US, es-419, az-Arab, x-pig-latin, man-Nkoo-GN
¶


   See [RFC5646] for further information.¶







8.6. Content-Length





   The ""Content-Length"" header field indicates the associated representation's
   data length as a decimal non-negative integer number of octets.
   When transferring a representation as content, Content-Length refers
   specifically to the amount of data enclosed so that it can be used to
   delimit framing (e.g., Section 6.2 of [HTTP/1.1]).
   In other cases, Content-Length indicates the selected representation's
   current length, which can be used by recipients to estimate transfer time
   or to compare with previously stored representations.¶


  Content-Length = 1*DIGIT
¶


   An example is¶

Content-Length: 3495
¶


   A user agent SHOULD send Content-Length in a request when the method
   defines a meaning for enclosed content and it is not sending
   Transfer-Encoding.
   For example, a user agent normally sends Content-Length in a POST request
   even when the value is 0 (indicating empty content).
   A user agent SHOULD NOT send a
   Content-Length header field when the request message does not contain
   content and the method semantics do not anticipate such data.¶

   A server MAY send a Content-Length header field in a response to a HEAD
   request (Section 9.3.2); a server MUST NOT send Content-Length in such a
   response unless its field value equals the decimal number of octets that
   would have been sent in the content of a response if the same
   request had used the GET method.¶

   A server MAY send a Content-Length header field in a
   304 (Not Modified) response to a conditional GET request
   (Section 15.4.5); a server MUST NOT send Content-Length in such a
   response unless its field value equals the decimal number of octets that
   would have been sent in the content of a 200 (OK)
   response to the same request.¶

   A server MUST NOT send a Content-Length header field in any response
   with a status code of
   1xx (Informational) or 204 (No Content).
   A server MUST NOT send a Content-Length header field in any
   2xx (Successful) response to a CONNECT request (Section 9.3.6).¶

   Aside from the cases defined above, in the absence of Transfer-Encoding,
   an origin server SHOULD send a Content-Length header field when the
   content size is known prior to sending the complete header section.
   This will allow downstream recipients to measure transfer progress,
   know when a received message is complete, and potentially reuse the
   connection for additional requests.¶

   Any Content-Length field value greater than or equal to zero is valid.
   Since there is no predefined limit to the length of content, a
   recipient MUST anticipate potentially large decimal numerals and
   prevent parsing errors due to integer conversion overflows
   or precision loss due to integer conversion
   (Section 17.5).¶

   Because Content-Length is used for message delimitation in HTTP/1.1,
   its field value can impact how the message is parsed by downstream
   recipients even when the immediate connection is not using HTTP/1.1.
   If the message is forwarded by a downstream intermediary, a Content-Length
   field value that is inconsistent with the received message framing might
   cause a security failure due to request smuggling or response splitting.¶

   As a result, a sender MUST NOT forward a message with a
   Content-Length header field value that is known to be incorrect.¶

   Likewise, a sender MUST NOT forward a message with a Content-Length
   header field value that does not match the ABNF above, with one exception:
   a recipient of a Content-Length header field value consisting of the same
   decimal value repeated as a comma-separated list (e.g,
   ""Content-Length: 42, 42"") MAY either reject the message as invalid or
   replace that invalid field value with a single instance of the decimal
   value, since this likely indicates that a duplicate was generated or
   combined by an upstream message processor.¶





8.7. Content-Location





   The ""Content-Location"" header field references a URI that can be used
   as an identifier for a specific resource corresponding to the
   representation in this message's content.
   In other words, if one were to perform a GET request on this URI at the time
   of this message's generation, then a 200 (OK) response would
   contain the same representation that is enclosed as content in this message.¶


  Content-Location = absolute-URI / partial-URI
¶


   The field value is either an absolute-URI or a
   partial-URI. In the latter case (Section 4),
   the referenced URI is relative to the target URI
   ([URI], Section 5).¶

   The Content-Location value is not a replacement for the target URI
   (Section 7.1).  It is representation metadata.
   It has the same syntax and semantics as the header field of the same name
   defined for MIME body parts in Section 4 of [RFC2557].
   However, its appearance in an HTTP message has some special implications
   for HTTP recipients.¶

   If Content-Location is included in a 2xx (Successful)
   response message and its value refers (after conversion to absolute form)
   to a URI that is the same as the target URI, then
   the recipient MAY consider the content to be a current representation of
   that resource at the time indicated by the message origination date.
   For a GET (Section 9.3.1) or HEAD (Section 9.3.2) request,
   this is the same as the default semantics when no Content-Location is
   provided by the server.
   For a state-changing request like PUT (Section 9.3.4) or
   POST (Section 9.3.3), it implies that the server's response
   contains the new representation of that resource, thereby distinguishing it
   from representations that might only report about the action
   (e.g., ""It worked!"").
   This allows authoring applications to update their local copies without
   the need for a subsequent GET request.¶

   If Content-Location is included in a 2xx (Successful)
   response message and its field value refers to a URI that differs from the
   target URI, then the origin server claims that the URI
   is an identifier for a different resource corresponding to the enclosed
   representation. Such a claim can only be trusted if both identifiers share
   the same resource owner, which cannot be programmatically determined via
   HTTP.¶

For a response to a GET or HEAD request, this is an indication that the
     target URI refers to a resource that is subject to content
     negotiation and the Content-Location field value is a more specific
     identifier for the selected representation.¶

For a 201 (Created) response to a state-changing method,
     a Content-Location field value that is identical to the
     Location field value indicates that this content is a
     current representation of the newly created resource.¶

Otherwise, such a Content-Location indicates that this content is a
     representation reporting on the requested action's status and that the
     same report is available (for future access with GET) at the given URI.
     For example, a purchase transaction made via a POST request might
     include a receipt document as the content of the 200 (OK)
     response; the Content-Location field value provides an identifier for
     retrieving a copy of that same receipt in the future.¶



   A user agent that sends Content-Location in a request message is stating
   that its value refers to where the user agent originally obtained the
   content of the enclosed representation (prior to any modifications made by
   that user agent).  In other words, the user agent is providing a back link
   to the source of the original representation.¶

   An origin server that receives a Content-Location field in a request
   message MUST treat the information as transitory request context rather
   than as metadata to be saved verbatim as part of the representation.
   An origin server MAY use that context to guide in processing the
   request or to save it for other uses, such as within source links or
   versioning metadata. However, an origin server MUST NOT use such context
   information to alter the request semantics.¶

   For example, if a client makes a PUT request on a negotiated resource and
   the origin server accepts that PUT (without redirection), then the new
   state of that resource is expected to be consistent with the one
   representation supplied in that PUT; the Content-Location cannot be used as
   a form of reverse content selection identifier to update only one of the
   negotiated representations. If the user agent had wanted the latter
   semantics, it would have applied the PUT directly to the Content-Location
   URI.¶





8.8. Validator Fields





   Resource metadata is referred to as a ""validator"" if it
   can be used within a precondition (Section 13.1) to
   make a conditional request (Section 13).
   Validator fields convey a current validator for the
   selected representation
   (Section 3.2).¶

   In responses to safe requests, validator fields describe the selected
   representation chosen by the origin server while handling the response.
   Note that, depending on the method and status code semantics, the
   selected representation for a given response is not
   necessarily the same as the representation enclosed as response content.¶

   In a successful response to a state-changing request, validator fields
   describe the new representation that has replaced the prior
   selected representation as a result of processing the
   request.¶

   For example, an ETag field in a 201 (Created) response
   communicates the entity tag of the newly created resource's
   representation, so that the entity tag can be used as a validator in
   later conditional requests to prevent the ""lost update"" problem.¶

   This specification defines two forms of metadata that are commonly used
   to observe resource state and test for preconditions: modification dates
   (Section 8.8.2) and opaque entity tags
   (Section 8.8.3).
   Additional metadata that reflects resource state
   has been defined by various extensions of HTTP, such as Web Distributed
   Authoring and Versioning [WEBDAV], that are beyond the
   scope of this specification.¶



8.8.1. Weak versus Strong




   Validators come in two flavors: strong or weak.  Weak validators are easy
   to generate but are far less useful for comparisons.  Strong validators
   are ideal for comparisons but can be very difficult (and occasionally
   impossible) to generate efficiently.  Rather than impose that all forms
   of resource adhere to the same strength of validator, HTTP exposes the
   type of validator in use and imposes restrictions on when weak validators
   can be used as preconditions.¶

   A ""strong validator"" is representation metadata that changes value whenever
   a change occurs to the representation data that would be observable in the
   content of a 200 (OK) response to GET.¶

   A strong validator might change for reasons other than a change to the
   representation data, such as when a
   semantically significant part of the representation metadata is changed
   (e.g., Content-Type), but it is in the best interests of the
   origin server to only change the value when it is necessary to invalidate
   the stored responses held by remote caches and authoring tools.¶

   Cache entries might persist for arbitrarily long periods, regardless
   of expiration times.  Thus, a cache might attempt to validate an
   entry using a validator that it obtained in the distant past.
   A strong validator is unique across all versions of all
   representations associated with a particular resource over time.
   However, there is no implication of uniqueness across representations
   of different resources (i.e., the same strong validator might be
   in use for representations of multiple resources at the same time
   and does not imply that those representations are equivalent).¶

   There are a variety of strong validators used in practice.  The best are
   based on strict revision control, wherein each change to a representation
   always results in a unique node name and revision identifier being assigned
   before the representation is made accessible to GET.
   A collision-resistant hash
   function applied to the representation data is also sufficient if the data
   is available prior to the response header fields being sent and the digest
   does not need to be recalculated every time a validation request is
   received.  However, if a resource has distinct representations that differ
   only in their metadata, such as might occur with content negotiation over
   media types that happen to share the same data format, then the origin
   server needs to incorporate additional information in the validator to
   distinguish those representations.¶

   In contrast, a ""weak validator"" is representation metadata
   that might not change for every change to the representation data. This
   weakness might be due to limitations in how the value is calculated
   (e.g., clock resolution), an inability to ensure uniqueness for all
   possible representations of the resource, or a desire of the resource
   owner to group representations by some self-determined set of
   equivalency rather than unique sequences of data.¶

   An origin server SHOULD change a weak entity tag whenever it
   considers prior representations to be unacceptable as a substitute for
   the current representation. In other words, a weak entity tag ought to
   change whenever the origin server wants caches to invalidate old
   responses.¶

   For example, the representation of a weather report that changes in
   content every second, based on dynamic measurements, might be grouped
   into sets of equivalent representations (from the origin server's
   perspective) with the same weak validator in order to allow cached
   representations to be valid for a reasonable period of time (perhaps
   adjusted dynamically based on server load or weather quality).
   Likewise, a representation's modification time, if defined with only
   one-second resolution, might be a weak validator if it is possible
   for the representation to be modified twice during a single second and
   retrieved between those modifications.¶

   Likewise, a validator is weak if it is shared by two or more
   representations of a given resource at the same time, unless those
   representations have identical representation data. For example, if the
   origin server sends the same validator for a representation with a gzip
   content coding applied as it does for a representation with no content
   coding, then that validator is weak. However, two simultaneous
   representations might share the same strong validator if they differ only
   in the representation metadata, such as when two different media types are
   available for the same representation data.¶

   Strong validators are usable for all conditional requests, including cache
   validation, partial content ranges, and ""lost update"" avoidance.
   Weak validators are only usable when the client does not require exact
   equality with previously obtained representation data, such as when
   validating a cache entry or limiting a web traversal to recent changes.¶





8.8.2. Last-Modified





   The ""Last-Modified"" header field in a response provides a timestamp
   indicating the date and time at which the origin server believes the
   selected representation was last modified, as determined at the conclusion
   of handling the request.¶


  Last-Modified = HTTP-date
¶


   An example of its use is¶

Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT
¶




8.8.2.1. Generation


   An origin server SHOULD send Last-Modified for any selected
   representation for which a last modification date can be reasonably
   and consistently determined, since its use in conditional requests
   and evaluating cache freshness ([CACHING]) can
   substantially reduce unnecessary transfers and significantly
   improve service availability and scalability.¶

   A representation is typically the sum of many parts behind the
   resource interface.  The last-modified time would usually be
   the most recent time that any of those parts were changed.
   How that value is determined for any given resource is an
   implementation detail beyond the scope of this specification.¶

   An origin server SHOULD obtain the Last-Modified value of the
   representation as close as possible to the time that it generates the
   Date field value for its response. This allows a recipient to
   make an accurate assessment of the representation's modification time,
   especially if the representation changes near the time that the
   response is generated.¶

   An origin server with a clock (as defined in Section 5.6.7)
   MUST NOT generate a Last-Modified date that is later than the
   server's time of message origination
   (Date, Section 6.6.1).
   If the last modification time is derived from implementation-specific
   metadata that evaluates to some time in the future, according to the
   origin server's clock, then the origin server MUST replace that
   value with the message origination date. This prevents a future
   modification date from having an adverse impact on cache validation.¶

   An origin server without a clock MUST NOT generate a Last-Modified
   date for a response unless that date value was assigned to the resource
   by some other system (presumably one with a clock).¶





8.8.2.2. Comparison


   A Last-Modified time, when used as a validator in a request, is
   implicitly weak unless it is possible to deduce that it is strong,
   using the following rules:¶

The validator is being compared by an origin server to the
       actual current validator for the representation and,¶

That origin server reliably knows that the associated representation did
       not change twice during the second covered by the presented
       validator;¶



   or¶

The validator is about to be used by a client in an
       If-Modified-Since,
       If-Unmodified-Since, or If-Range header
       field, because the client has a cache entry for the associated
       representation, and¶

That cache entry includes a Date value which is
       at least one second after the Last-Modified value and
       the client has reason to believe that they were generated by the
       same clock or that there is enough difference between the Last-Modified
       and Date values to make clock synchronization issues unlikely;¶



   or¶

The validator is being compared by an intermediate cache to the
       validator stored in its cache entry for the representation, and¶

That cache entry includes a Date value which is
       at least one second after the Last-Modified value and
       the cache has reason to believe that they were generated by the
       same clock or that there is enough difference between the Last-Modified
       and Date values to make clock synchronization issues unlikely.¶



   This method relies on the fact that if two different responses were
   sent by the origin server during the same second, but both had the
   same Last-Modified time, then at least one of those responses would
   have a Date value equal to its Last-Modified time.¶







8.8.3. ETag






   The ""ETag"" field in a response provides the current entity tag for
   the selected representation, as determined at the conclusion of handling
   the request.
   An entity tag is an opaque validator for differentiating between
   multiple representations of the same resource, regardless of whether
   those multiple representations are due to resource state changes over
   time, content negotiation resulting in multiple representations being
   valid at the same time, or both. An entity tag consists of an opaque
   quoted string, possibly prefixed by a weakness indicator.¶






  ETag       = entity-tag

  entity-tag = [ weak ] opaque-tag
  weak       = %s""W/""
  opaque-tag = DQUOTE *etagc DQUOTE
  etagc      = %x21 / %x23-7E / obs-text
             ; VCHAR except double quotes, plus obs-text
¶



Note: Previously, opaque-tag was defined to be a quoted-string
    ([RFC2616], Section 3.11); thus, some recipients
    might perform backslash unescaping. Servers therefore ought to avoid
    backslash characters in entity tags.¶


   An entity tag can be more reliable for validation than a modification
   date in situations where it is inconvenient to store modification
   dates, where the one-second resolution of HTTP-date values is not
   sufficient, or where modification dates are not consistently maintained.¶

  Examples:¶

ETag: ""xyzzy""
ETag: W/""xyzzy""
ETag: """"
¶


   An entity tag can be either a weak or strong validator, with
   strong being the default.  If an origin server provides an entity tag
   for a representation and the generation of that entity tag does not satisfy
   all of the characteristics of a strong validator
   (Section 8.8.1), then the origin server
   MUST mark the entity tag as weak by prefixing its opaque value
   with ""W/"" (case-sensitive).¶

   A sender MAY send the ETag field in a trailer section (see
   Section 6.5). However, since trailers are often
   ignored, it is preferable to send ETag as a header field unless the
   entity tag is generated while sending the content.¶



8.8.3.1. Generation


   The principle behind entity tags is that only the service author
   knows the implementation of a resource well enough to select the
   most accurate and efficient validation mechanism for that resource,
   and that any such mechanism can be mapped to a simple sequence of
   octets for easy comparison.  Since the value is opaque, there is no
   need for the client to be aware of how each entity tag is constructed.¶

   For example, a resource that has implementation-specific versioning
   applied to all changes might use an internal revision number, perhaps
   combined with a variance identifier for content negotiation, to
   accurately differentiate between representations.
   Other implementations might use a collision-resistant hash of
   representation content, a combination of various file attributes, or
   a modification timestamp that has sub-second resolution.¶

   An origin server SHOULD send an ETag for any selected representation
   for which detection of changes can be reasonably and consistently
   determined, since the entity tag's use in conditional requests and
   evaluating cache freshness ([CACHING]) can
   substantially reduce unnecessary transfers and significantly
   improve service availability, scalability, and reliability.¶





8.8.3.2. Comparison


   There are two entity tag comparison functions, depending on whether or not
   the comparison context allows the use of weak validators:¶


                        ""Strong comparison"":
              

    two entity tags are equivalent if both are not weak and their opaque-tags
    match character-by-character.¶



                        ""Weak comparison"":
              

    two entity tags are equivalent if their opaque-tags match
    character-by-character, regardless of either or both being tagged as ""weak"".¶




   The example below shows the results for a set of entity tag pairs and both
   the weak and strong comparison function results:¶

Table 3


ETag 1
ETag 2
Strong Comparison
Weak Comparison




W/""1""
W/""1""
no match
match


W/""1""
W/""2""
no match
no match


W/""1""
""1""
no match
match


""1""
""1""
match
match








8.8.3.3. Example: Entity Tags Varying on Content-Negotiated Resources


   Consider a resource that is subject to content negotiation
   (Section 12), and where the representations sent in response to
   a GET request vary based on the Accept-Encoding request
   header field (Section 12.5.3):¶

   >> Request:¶

GET /index HTTP/1.1
Host: www.example.com
Accept-Encoding: gzip

¶


   In this case, the response might or might not use the gzip content coding.
   If it does not, the response might look like:¶

   >> Response:¶

HTTP/1.1 200 OK
Date: Fri, 26 Mar 2010 00:05:00 GMT
ETag: ""123-a""
Content-Length: 70
Vary: Accept-Encoding
Content-Type: text/plain

Hello World!
Hello World!
Hello World!
Hello World!
Hello World!
¶


   An alternative representation that does use gzip content coding would be:¶

   >> Response:¶

HTTP/1.1 200 OK
Date: Fri, 26 Mar 2010 00:05:00 GMT
ETag: ""123-b""
Content-Length: 43
Vary: Accept-Encoding
Content-Type: text/plain
Content-Encoding: gzip

...binary data...¶



Note: Content codings are a property of the representation data,
    so a strong entity tag for a content-encoded representation has to be
    distinct from the entity tag of an unencoded representation to prevent
    potential conflicts during cache updates and range requests. In contrast,
    transfer codings (Section 7 of [HTTP/1.1]) apply only during message transfer
    and do not result in distinct entity tags.¶












9. Methods




9.1. Overview


   The request method token is the primary source of request semantics;
   it indicates the purpose for which the client has made this request
   and what is expected by the client as a successful result.¶

   The request method's semantics might be further specialized by the
   semantics of some header fields when present in a request
   if those additional semantics do not conflict with the method.
   For example, a client can send conditional request header fields
   (Section 13.1) to make the requested
   action conditional on the current state of the target resource.¶

   HTTP is designed to be usable as an interface to distributed
   object systems. The request method invokes an action to be applied to
   a target resource in much the same way that a remote
   method invocation can be sent to an identified object.¶


  method = token
¶


   The method token is case-sensitive because it might be used as a gateway
   to object-based systems with case-sensitive method names. By convention,
   standardized methods are defined in all-uppercase US-ASCII letters.¶

   Unlike distributed objects, the standardized request methods in HTTP are
   not resource-specific, since uniform interfaces provide for better
   visibility and reuse in network-based systems [REST].
   Once defined, a standardized method ought to have the same semantics when
   applied to any resource, though each resource determines for itself
   whether those semantics are implemented or allowed.¶

   This specification defines a number of standardized methods that are
   commonly used in HTTP, as outlined by the following table.¶


Table 4


Method Name
Description
Section




GET
Transfer a current representation of the target resource.

9.3.1



HEAD
Same as GET, but do not transfer the response content.

9.3.2



POST
Perform resource-specific processing on the request content.

9.3.3



PUT
Replace all current representations of the target resource with
        the request content.

9.3.4



DELETE
Remove all current representations of the target resource.

9.3.5



CONNECT
Establish a tunnel to the server identified by the target resource.

9.3.6



OPTIONS
Describe the communication options for the target resource.

9.3.7



TRACE
Perform a message loop-back test along the path to the target resource.

9.3.8






   All general-purpose servers MUST support the methods GET and HEAD.
   All other methods are OPTIONAL.¶

   The set of methods allowed by a target resource can be listed in an
   Allow header field (Section 10.2.1).
   However, the set of allowed methods can change dynamically.
   An origin server that receives a request method that is unrecognized or
   not implemented SHOULD respond with the
   501 (Not Implemented) status code.
   An origin server that receives a request method that is recognized and
   implemented, but not allowed for the target resource, SHOULD respond
   with the 405 (Method Not Allowed) status code.¶

   Additional methods, outside the scope of this specification, have been
   specified for use in HTTP. All such methods ought to be registered
   within the ""Hypertext Transfer Protocol (HTTP) Method Registry"",
   as described in Section 16.1.¶





9.2. Common Method Properties




9.2.1. Safe Methods



   Request methods are considered ""safe"" if
   their defined semantics are essentially read-only; i.e., the client does
   not request, and does not expect, any state change on the origin server
   as a result of applying a safe method to a target resource.  Likewise,
   reasonable use of a safe method is not expected to cause any harm,
   loss of property, or unusual burden on the origin server.¶

   This definition of safe methods does not prevent an implementation from
   including behavior that is potentially harmful, that is not entirely read-only,
   or that causes side effects while invoking a safe method.  What is
   important, however, is that the client did not request that additional
   behavior and cannot be held accountable for it.  For example,
   most servers append request information to access log files at the
   completion of every response, regardless of the method, and that is
   considered safe even though the log storage might become full and cause
   the server to fail.  Likewise, a safe request initiated by selecting an
   advertisement on the Web will often have the side effect of charging an
   advertising account.¶

   Of the request methods defined by this specification, the
   GET, HEAD, OPTIONS, and
   TRACE methods are defined to be safe.¶

   The purpose of distinguishing between safe and unsafe methods is to
   allow automated retrieval processes (spiders) and cache performance
   optimization (pre-fetching) to work without fear of causing harm.
   In addition, it allows a user agent to apply appropriate constraints
   on the automated use of unsafe methods when processing potentially
   untrusted content.¶

   A user agent SHOULD distinguish between safe and unsafe methods when
   presenting potential actions to a user, such that the user can be made
   aware of an unsafe action before it is requested.¶

   When a resource is constructed such that parameters within the target URI
   have the effect of selecting an action, it is the resource
   owner's responsibility to ensure that the action is consistent with the
   request method semantics.
   For example, it is common for Web-based content editing software
   to use actions within query parameters, such as ""page?do=delete"".
   If the purpose of such a resource is to perform an unsafe action, then
   the resource owner MUST disable or disallow that action when it is
   accessed using a safe request method. Failure to do so will result in
   unfortunate side effects when automated processes perform a GET on
   every URI reference for the sake of link maintenance, pre-fetching,
   building a search index, etc.¶





9.2.2. Idempotent Methods



   A request method is considered ""idempotent""
   if the intended effect on the server of multiple identical requests with
   that method is the same as the effect for a single such request.
   Of the request methods defined by this
   specification, PUT, DELETE, and safe request
   methods are idempotent.¶

   Like the definition of safe, the idempotent property only applies to
   what has been requested by the user; a server is free to log each request
   separately, retain a revision control history, or implement other
   non-idempotent side effects for each idempotent request.¶

   Idempotent methods are distinguished because the request can be repeated
   automatically if a communication failure occurs before the client is
   able to read the server's response.  For example, if a client sends a PUT
   request and the underlying connection is closed before any response is
   received, then the client can establish a new connection and retry the
   idempotent request. It knows that repeating the request will have
   the same intended effect, even if the original request succeeded, though
   the response might differ.¶

   A client SHOULD NOT automatically retry a request with a non-idempotent
   method unless it has some means to know that the request semantics are
   actually idempotent, regardless of the method, or some means to detect that
   the original request was never applied.¶

   For example, a user agent can repeat a POST request automatically if it
   knows (through design or configuration) that the request is safe for that
   resource. Likewise, a user agent designed specifically to operate on
   a version control repository might be able to recover from partial failure
   conditions by checking the target resource revision(s) after a failed
   connection, reverting or fixing any changes that were partially applied,
   and then automatically retrying the requests that failed.¶

   Some clients take a riskier approach and attempt to guess when an
   automatic retry is possible. For example, a client might automatically
   retry a POST request if the underlying transport connection closed before
   any part of a response is received, particularly if an idle persistent
   connection was used.¶

   A proxy MUST NOT automatically retry non-idempotent requests.
   A client SHOULD NOT automatically retry a failed automatic retry.¶





9.2.3. Methods and Caching


   For a cache to store and use a response, the associated method needs to
   explicitly allow caching and to detail under what conditions a response can
   be used to satisfy subsequent requests; a method definition that does not
   do so cannot be cached. For additional requirements see [CACHING].¶

   This specification defines caching semantics for GET, HEAD, and POST,
   although the overwhelming majority of cache implementations only support
   GET and HEAD.¶







9.3. Method Definitions




9.3.1. GET




   The GET method requests transfer of a current
   selected representation for the
   target resource.
   A successful response reflects the quality of ""sameness"" identified by
   the target URI (Section 1.2.2 of [URI]). Hence,
   retrieving identifiable information via HTTP is usually performed by
   making a GET request on an identifier associated with the potential for
   providing that information in a 200 (OK) response.¶

   GET is the primary mechanism of information retrieval and the focus of
   almost all performance optimizations. Applications that produce a URI for
   each important resource can benefit from those optimizations while enabling
   their reuse by other applications, creating a network effect that promotes
   further expansion of the Web.¶

   It is tempting to think of resource identifiers as remote file system
   pathnames and of representations as being a copy of the contents of such
   files. In fact, that is how many resources are implemented (see
   Section 17.3 for related security considerations).
   However, there are no such limitations in practice.¶

   The HTTP interface for
   a resource is just as likely to be implemented as a tree of content
   objects, a programmatic view on various database records, or a gateway to
   other information systems. Even when the URI mapping mechanism is tied to a
   file system, an origin server might be configured to execute the files with
   the request as input and send the output as the representation rather than
   transfer the files directly. Regardless, only the origin server needs to
   know how each resource identifier corresponds to an implementation
   and how that implementation manages to select and send a current
   representation of the target resource.¶

   A client can alter the semantics of GET to be a ""range request"", requesting
   transfer of only some part(s) of the selected representation, by sending a
   Range header field in the request (Section 14.2).¶

   Although request message framing is independent of the method used,
   content received in a GET request has no generally defined semantics,
   cannot alter the meaning or target of the request, and might lead some
   implementations to reject the request and close the connection because of
   its potential as a request smuggling attack
   (Section 11.2 of [HTTP/1.1]).
   A client SHOULD NOT generate content in a GET request unless it is
   made directly to an origin server that has previously indicated,
   in or out of band, that such a request has a purpose and will be adequately
   supported. An origin server SHOULD NOT rely on private agreements to
   receive content, since participants in HTTP communication are often
   unaware of intermediaries along the request chain.¶

   The response to a GET request is cacheable; a cache MAY use it to satisfy
   subsequent GET and HEAD requests unless otherwise indicated by the
   Cache-Control header field (Section 5.2 of [CACHING]).¶

   When information retrieval is performed with a mechanism that constructs a
   target URI from user-provided information, such as the query fields of a
   form using GET, potentially sensitive data might be provided that would not
   be appropriate for disclosure within a URI
   (see Section 17.9). In some cases, the
   data can be filtered or transformed such that it would not reveal such
   information. In others, particularly when there is no benefit from caching
   a response, using the POST method (Section 9.3.3) instead of GET
   can transmit such information in the request content rather than within
   the target URI.¶





9.3.2. HEAD




   The HEAD method is identical to GET except that the server MUST NOT
   send content in the response. HEAD is used to obtain metadata about the
   selected representation without transferring its
   representation data, often for the sake of testing hypertext links or
   finding recent modifications.¶

   The server SHOULD send the same header fields in response to a HEAD
   request as it would have sent if the request method had been GET.
   However, a server MAY omit header fields for which a value is determined
   only while generating the content. For example, some servers buffer a
   dynamic response to GET until a minimum amount of data is generated so
   that they can more efficiently delimit small responses or make late
   decisions with regard to content selection. Such a response to GET might
   contain Content-Length and Vary fields, for
   example, that are not generated within a HEAD response. These minor
   inconsistencies are considered preferable to generating and discarding the
   content for a HEAD request, since HEAD is usually requested for the
   sake of efficiency.¶

   Although request message framing is independent of the method used,
   content received in a HEAD request has no generally defined semantics,
   cannot alter the meaning or target of the request, and might lead some
   implementations to reject the request and close the connection because of
   its potential as a request smuggling attack
   (Section 11.2 of [HTTP/1.1]).
   A client SHOULD NOT generate content in a HEAD request unless it is
   made directly to an origin server that has previously indicated,
   in or out of band, that such a request has a purpose and will be adequately
   supported. An origin server SHOULD NOT rely on private agreements to
   receive content, since participants in HTTP communication are often
   unaware of intermediaries along the request chain.¶

   The response to a HEAD request is cacheable; a cache MAY use it to
   satisfy subsequent HEAD requests unless otherwise indicated by the
   Cache-Control header field (Section 5.2 of [CACHING]).
   A HEAD response might also affect previously cached responses to GET;
   see Section 4.3.5 of [CACHING].¶





9.3.3. POST




   The POST method requests that the target resource process
   the representation enclosed in the request according to the resource's own
   specific semantics. For example, POST is used for the following functions
   (among others):¶

Providing a block of data, such as the fields entered into an HTML
      form, to a data-handling process;¶

Posting a message to a bulletin board, newsgroup, mailing list, blog,
      or similar group of articles;¶

Creating a new resource that has yet to be identified by the origin
      server; and¶

Appending data to a resource's existing representation(s).¶



   An origin server indicates response semantics by choosing an appropriate
   status code depending on the result of processing the POST request;
   almost all of the status codes defined by this specification could be
   received in a response to POST (the exceptions being 206 (Partial Content),
   304 (Not Modified), and 416 (Range Not Satisfiable)).¶

   If one or more resources has been created on the origin server as a result
   of successfully processing a POST request, the origin server SHOULD send
   a 201 (Created) response containing a Location
   header field that provides an identifier for the primary resource created
   (Section 10.2.2) and a representation that describes the
   status of the request while referring to the new resource(s).¶

   Responses to POST requests are only cacheable when they include explicit
   freshness information (see Section 4.2.1 of [CACHING]) and a
   Content-Location header field that has the same value as
   the POST's target URI (Section 8.7). A cached POST response can be reused
   to satisfy a later GET or HEAD request. In contrast, a POST request cannot
   be satisfied by a cached POST response because POST is potentially unsafe;
   see Section 4 of [CACHING].¶

   If the result of processing a POST would be equivalent to a representation
   of an existing resource, an origin server MAY redirect the user agent to
   that resource by sending a 303 (See Other) response with the
   existing resource's identifier in the Location field.
   This has the benefits of providing the user agent a resource identifier
   and transferring the representation via a method more amenable to shared
   caching, though at the cost of an extra request if the user agent does not
   already have the representation cached.¶





9.3.4. PUT




   The PUT method requests that the state of the target resource
   be created or replaced with the state defined by the representation
   enclosed in the request message content.  A successful PUT of a given
   representation would suggest that a subsequent GET on that same target
   resource will result in an equivalent representation being sent in
   a 200 (OK) response.  However, there is no guarantee that
   such a state change will be observable, since the target resource might be
   acted upon by other user agents in parallel, or might be subject to dynamic
   processing by the origin server, before any subsequent GET is received.
   A successful response only implies that the user agent's intent was
   achieved at the time of its processing by the origin server.¶

   If the target resource does not have a current representation and
   the PUT successfully creates one, then the origin server MUST inform
   the user agent by sending a 201 (Created) response.  If the
   target resource does have a current representation and that representation is
   successfully modified in accordance with the state of the enclosed
   representation, then the origin server MUST send either a
   200 (OK) or a 204 (No Content) response to
   indicate successful completion of the request.¶

   An origin server SHOULD verify that the PUT representation is consistent
   with its configured constraints for the target resource. For example, if
   an origin server determines a resource's representation metadata based on
   the URI, then the origin server needs to ensure that the content received
   in a successful PUT request is consistent with that metadata. When a PUT
   representation is inconsistent with the target resource, the origin
   server SHOULD either make them consistent, by transforming the
   representation or changing the resource configuration, or respond
   with an appropriate error message containing sufficient information
   to explain why the representation is unsuitable.  The
   409 (Conflict) or 415 (Unsupported Media Type)
   status codes are suggested, with the latter being specific to constraints on
   Content-Type values.¶

   For example, if the target resource is configured to always have a
   Content-Type of ""text/html"" and the representation being PUT
   has a Content-Type of ""image/jpeg"", the origin server ought to do one of:¶

reconfigure the target resource to reflect the new media type;¶

transform the PUT representation to a format consistent with that
       of the resource before saving it as the new resource state; or,¶

reject the request with a 415 (Unsupported Media Type)
       response indicating that the target resource is limited to ""text/html"",
       perhaps including a link to a different resource that would be a
       suitable target for the new representation.¶



   HTTP does not define exactly how a PUT method affects the state
   of an origin server beyond what can be expressed by the intent of
   the user agent request and the semantics of the origin server response.
   It does not define what a resource might be, in any sense of that
   word, beyond the interface provided via HTTP.  It does not define
   how resource state is ""stored"", nor how such storage might change
   as a result of a change in resource state, nor how the origin server
   translates resource state into representations.  Generally speaking,
   all implementation details behind the resource interface are
   intentionally hidden by the server.¶

   This extends to how header and trailer fields are stored; while common
   header fields like Content-Type will typically be stored
   and returned upon subsequent GET requests, header and trailer field
   handling is specific to the resource that received the request. As a result,
   an origin server SHOULD ignore unrecognized header and trailer fields
   received in a PUT request (i.e., not save them as part of the resource
   state).¶

   An origin server MUST NOT send a validator field
   (Section 8.8), such as an ETag or
   Last-Modified field, in a successful response to PUT unless
   the request's representation data was saved without any transformation
   applied to the content (i.e., the resource's new representation data is
   identical to the content received in the PUT request) and the
   validator field value reflects the new representation.
   This requirement allows a user agent to know when the representation it
   sent (and retains in memory) is the result of the PUT, and thus it doesn't
   need to be retrieved again from the origin server. The new validator(s)
   received in the response can be used for future conditional requests in
   order to prevent accidental overwrites (Section 13.1).¶

   The fundamental difference between the POST and PUT methods is
   highlighted by the different intent for the enclosed representation.
   The target resource in a POST request is intended to handle the
   enclosed representation according to the resource's own semantics,
   whereas the enclosed representation in a PUT request is defined as
   replacing the state of the target resource. Hence, the intent of PUT is
   idempotent and visible to intermediaries, even though the exact effect is
   only known by the origin server.¶

   Proper interpretation of a PUT request presumes that the user agent knows
   which target resource is desired. A service that selects a proper URI on
   behalf of the client, after receiving a state-changing request, SHOULD be
   implemented using the POST method rather than PUT. If the origin server
   will not make the requested PUT state change to the target resource and
   instead wishes to have it applied to a different resource, such as when the
   resource has been moved to a different URI, then the origin server MUST
   send an appropriate 3xx (Redirection) response; the
   user agent MAY then make its own decision regarding whether or not to
   redirect the request.¶

   A PUT request applied to the target resource can have side effects
   on other resources.  For example, an article might have a URI for
   identifying ""the current version"" (a resource) that is separate
   from the URIs identifying each particular version (different
   resources that at one point shared the same state as the current version
   resource).  A successful PUT request on ""the current version"" URI might
   therefore create a new version resource in addition to changing the
   state of the target resource, and might also cause links to be added
   between the related resources.¶

   Some origin servers support use of the Content-Range header
   field (Section 14.4) as a request modifier to
   perform a partial PUT, as described in Section 14.5.¶

   Responses to the PUT method are not cacheable. If a successful PUT request
   passes through a cache that has one or more stored responses for the
   target URI, those stored responses will be invalidated
   (see Section 4.4 of [CACHING]).¶





9.3.5. DELETE




   The DELETE method requests that the origin server remove the association
   between the target resource and its current functionality.
   In effect, this method is similar to the ""rm"" command in UNIX: it expresses a
   deletion operation on the URI mapping of the origin server rather than an
   expectation that the previously associated information be deleted.¶

   If the target resource has one or more current representations, they might
   or might not be destroyed by the origin server, and the associated storage
   might or might not be reclaimed, depending entirely on the nature of the
   resource and its implementation by the origin server (which are beyond the
   scope of this specification). Likewise, other implementation aspects of a
   resource might need to be deactivated or archived as a result of a DELETE,
   such as database or gateway connections. In general, it is assumed that the
   origin server will only allow DELETE on resources for which it has a
   prescribed mechanism for accomplishing the deletion.¶

   Relatively few resources allow the DELETE method -- its primary use
   is for remote authoring environments, where the user has some direction
   regarding its effect. For example, a resource that was previously created
   using a PUT request, or identified via the Location header field after a
   201 (Created) response to a POST request, might allow a
   corresponding DELETE request to undo those actions.  Similarly, custom
   user agent implementations that implement an authoring function, such as
   revision control clients using HTTP for remote operations, might use
   DELETE based on an assumption that the server's URI space has been crafted
   to correspond to a version repository.¶

   If a DELETE method is successfully applied, the origin server SHOULD send¶

a 202 (Accepted) status code if the action will likely succeed but
   has not yet been enacted,¶

a 204 (No Content) status code if the action has been
   enacted and no further information is to be supplied, or¶

a 200 (OK) status code if the action has been enacted and
   the response message includes a representation describing the status.¶



   Although request message framing is independent of the method used,
   content received in a DELETE request has no generally defined semantics,
   cannot alter the meaning or target of the request, and might lead some
   implementations to reject the request and close the connection because of
   its potential as a request smuggling attack
   (Section 11.2 of [HTTP/1.1]).
   A client SHOULD NOT generate content in a DELETE request unless it is
   made directly to an origin server that has previously indicated,
   in or out of band, that such a request has a purpose and will be adequately
   supported. An origin server SHOULD NOT rely on private agreements to
   receive content, since participants in HTTP communication are often
   unaware of intermediaries along the request chain.¶

   Responses to the DELETE method are not cacheable. If a successful DELETE
   request passes through a cache that has one or more stored responses for
   the target URI, those stored responses will be invalidated (see
   Section 4.4 of [CACHING]).¶





9.3.6. CONNECT




   The CONNECT method requests that the recipient establish a tunnel to the
   destination origin server identified by the request target and, if
   successful, thereafter restrict its behavior to blind forwarding of
   data, in both directions, until the tunnel is closed.
   Tunnels are commonly used to create an end-to-end virtual connection,
   through one or more proxies, which can then be secured using TLS
   (Transport Layer Security, [TLS13]).¶

   CONNECT uses a special form of request target, unique to this method,
   consisting of only the host and port number of the tunnel destination,
   separated by a colon. There is no default port; a client MUST send the
   port number even if the CONNECT request is based on a URI reference that
   contains an authority component with an elided port
   (Section 4.1). For example,¶

CONNECT server.example.com:80 HTTP/1.1
Host: server.example.com

¶


   A server MUST reject a CONNECT request that targets an empty or invalid
   port number, typically by responding with a 400 (Bad Request) status code.¶

   Because CONNECT changes the request/response nature of an HTTP connection,
   specific HTTP versions might have different ways of mapping its semantics
   into the protocol's wire format.¶

   CONNECT is intended for use in requests to a proxy.
   The recipient can establish a tunnel either by directly connecting to
   the server identified by the request target or, if configured to use
   another proxy, by forwarding the CONNECT request to the next inbound proxy.
   An origin server MAY accept a CONNECT request, but most origin servers
   do not implement CONNECT.¶

   Any 2xx (Successful) response indicates
   that the sender (and all inbound proxies) will switch to tunnel mode
   immediately after the response header section; data received after that
   header section is from the server identified by the request target.
   Any response other than a successful response indicates that the tunnel
   has not yet been formed.¶

   A tunnel is closed when a tunnel intermediary detects that either side
   has closed its connection: the intermediary MUST attempt to send any
   outstanding data that came from the closed side to the other side, close
   both connections, and then discard any remaining data left undelivered.¶

   Proxy authentication might be used to establish the
   authority to create a tunnel.  For example,¶

CONNECT server.example.com:443 HTTP/1.1
Host: server.example.com:443
Proxy-Authorization: basic aGVsbG86d29ybGQ=

¶


   There are significant risks in establishing a tunnel to arbitrary servers,
   particularly when the destination is a well-known or reserved TCP port that
   is not intended for Web traffic. For example, a CONNECT to
   ""example.com:25"" would suggest that the proxy connect to the reserved
   port for SMTP traffic; if allowed, that could trick the proxy into
   relaying spam email. Proxies that support CONNECT SHOULD restrict its
   use to a limited set of known ports or a configurable list of safe
   request targets.¶

   A server MUST NOT send any Transfer-Encoding or
   Content-Length header fields in a
   2xx (Successful) response to CONNECT.
   A client MUST ignore any Content-Length or Transfer-Encoding header
   fields received in a successful response to CONNECT.¶

   A CONNECT request message does not have content. The interpretation of
   data sent after the header section of the CONNECT request message is
   specific to the version of HTTP in use.¶

   Responses to the CONNECT method are not cacheable.¶





9.3.7. OPTIONS




   The OPTIONS method requests information about the communication options
   available for the target resource, at either the origin server or an
   intervening intermediary. This method allows a client to determine the
   options and/or requirements associated with a resource, or the capabilities
   of a server, without implying a resource action.¶

   An OPTIONS request with an asterisk (""*"") as the request target
   (Section 7.1) applies to the server in general rather than to a
   specific resource. Since a server's communication options typically depend
   on the resource, the ""*"" request is only useful as a ""ping"" or ""no-op""
   type of method; it does nothing beyond allowing the client to test
   the capabilities of the server. For example, this can be used to test
   a proxy for HTTP/1.1 conformance (or lack thereof).¶

   If the request target is not an asterisk, the OPTIONS request applies
   to the options that are available when communicating with the target
   resource.¶

   A server generating a successful response to OPTIONS SHOULD send any
   header that might indicate optional features implemented by the
   server and applicable to the target resource (e.g., Allow),
   including potential extensions not defined by this specification.
   The response content, if any, might also describe the communication options
   in a machine or human-readable representation. A standard format for such a
   representation is not defined by this specification, but might be defined by
   future extensions to HTTP.¶

   A client MAY send a Max-Forwards header field in an
   OPTIONS request to target a specific recipient in the request chain (see
   Section 7.6.2). A proxy MUST NOT generate a
   Max-Forwards header field while forwarding a request unless that request
   was received with a Max-Forwards field.¶

   A client that generates an OPTIONS request containing content
   MUST send a valid Content-Type header field describing
   the representation media type. Note that this specification does not define
   any use for such content.¶

   Responses to the OPTIONS method are not cacheable.¶





9.3.8. TRACE




   The TRACE method requests a remote, application-level loop-back of the
   request message. The final recipient of the request SHOULD reflect the
   message received, excluding some fields described below, back to the client
   as the content of a 200 (OK) response. The ""message/http""
   format (Section 10.1 of [HTTP/1.1]) is one way to do so.
   The final recipient is either the origin server or the first server to
   receive a Max-Forwards value of zero (0) in the request
   (Section 7.6.2).¶

   A client MUST NOT generate fields in a TRACE request containing
   sensitive data that might be disclosed by the response. For example, it
   would be foolish for a user agent to send stored user credentials
   (Section 11) or cookies [COOKIE] in a TRACE
   request. The final recipient of the request SHOULD exclude any request
   fields that are likely to contain sensitive data when that recipient
   generates the response content.¶

   TRACE allows the client to see what is being received at the other
   end of the request chain and use that data for testing or diagnostic
   information. The value of the Via header field (Section 7.6.3)
   is of particular interest, since it acts as a trace of the request chain.
   Use of the Max-Forwards header field allows the client to
   limit the length of the request chain, which is useful for testing a chain
   of proxies forwarding messages in an infinite loop.¶

   A client MUST NOT send content in a TRACE request.¶

   Responses to the TRACE method are not cacheable.¶









10. Message Context




10.1. Request Context Fields


   The request header fields below provide additional information about the
   request context, including information about the user, user agent, and
   resource behind the request.¶



10.1.1. Expect






   The ""Expect"" header field in a request indicates a certain set of
   behaviors (expectations) that need to be supported by the server in
   order to properly handle this request.¶


  Expect =      #expectation
  expectation = token [ ""="" ( token / quoted-string ) parameters ]
¶


   The Expect field value is case-insensitive.¶

   The only expectation defined by this specification is ""100-continue""
   (with no defined parameters).¶

   A server that receives an Expect field value containing a member other than
   100-continue
MAY respond with a
   417 (Expectation Failed) status code to indicate that the
   unexpected expectation cannot be met.¶

   A ""100-continue"" expectation informs recipients that the
   client is about to send (presumably large) content in this request
   and wishes to receive a 100 (Continue) interim response if
   the method, target URI, and header fields are not sufficient to cause an immediate
   success, redirect, or error response. This allows the client to wait for an
   indication that it is worthwhile to send the content before actually
   doing so, which can improve efficiency when the data is huge or
   when the client anticipates that an error is likely (e.g., when sending a
   state-changing method, for the first time, without previously verified
   authentication credentials).¶

   For example, a request that begins with¶

PUT /somewhere/fun HTTP/1.1
Host: origin.example.com
Content-Type: video/h264
Content-Length: 1234567890987
Expect: 100-continue

¶


   allows the origin server to immediately respond with an error message, such
   as 401 (Unauthorized) or 405 (Method Not Allowed),
   before the client starts filling the pipes with an unnecessary data
   transfer.¶

   Requirements for clients:¶


    A client MUST NOT generate a 100-continue expectation in a request that
    does not include content.¶


    A client that will wait for a 100 (Continue) response
    before sending the request content MUST send an
    Expect header field containing a 100-continue expectation.¶


    A client that sends a 100-continue expectation is not required to wait
    for any specific length of time; such a client MAY proceed to send the
    content even if it has not yet received a response. Furthermore,
    since 100 (Continue) responses cannot be sent through an
    HTTP/1.0 intermediary, such a client SHOULD NOT wait for an indefinite
    period before sending the content.¶


    A client that receives a 417 (Expectation Failed) status
    code in response to a request containing a 100-continue expectation
    SHOULD repeat that request without a 100-continue expectation, since
    the 417 response merely indicates that the response chain does not
    support expectations (e.g., it passes through an HTTP/1.0 server).¶



   Requirements for servers:¶


    A server that receives a 100-continue expectation in an HTTP/1.0 request
    MUST ignore that expectation.¶


    A server MAY omit sending a 100 (Continue) response if
    it has already received some or all of the content for the
    corresponding request, or if the framing indicates that there is no
    content.¶


    A server that sends a 100 (Continue) response MUST
    ultimately send a final status code, once it receives and processes the
    request content, unless the connection is closed prematurely.¶


    A server that responds with a final status code before reading the
    entire request content SHOULD indicate whether it intends to
    close the connection (e.g., see Section 9.6 of [HTTP/1.1]) or
    continue reading the request content.¶



   Upon receiving an HTTP/1.1 (or later) request that has a method, target URI,
   and complete header section that contains a 100-continue expectation and
   an indication that request content will follow, an origin server MUST
   send either:¶

an immediate response with a final status code, if that status can be
      determined by examining just the method, target URI, and header fields, or¶

an immediate 100 (Continue) response to encourage the client
      to send the request content.¶



   The origin server MUST NOT wait for the content
   before sending the 100 (Continue) response.¶

   Upon receiving an HTTP/1.1 (or later) request that has a method, target URI,
   and complete header section that contains a 100-continue expectation and
   indicates a request content will follow, a proxy MUST either:¶

send an immediate
   response with a final status code, if that status can be determined by
   examining just the method, target URI, and header fields, or¶

forward the request toward the origin server by sending a corresponding
   request-line and header section to the next inbound server.¶



   If the proxy believes (from configuration or past interaction) that the
   next inbound server only supports HTTP/1.0, the proxy MAY generate an
   immediate 100 (Continue) response to encourage the client to
   begin sending the content.¶





10.1.2. From





   The ""From"" header field contains an Internet email address for a human
   user who controls the requesting user agent. The address ought to be
   machine-usable, as defined by ""mailbox""
   in Section 3.4 of [RFC5322]:¶


  From    = mailbox

  mailbox = <mailbox, see [RFC5322], Section 3.4>
¶


   An example is:¶

From: spider-admin@example.org
¶


   The From header field is rarely sent by non-robotic user agents.
   A user agent SHOULD NOT send a From header field without explicit
   configuration by the user, since that might conflict with the user's
   privacy interests or their site's security policy.¶

   A robotic user agent SHOULD send a valid From header field so that the
   person responsible for running the robot can be contacted if problems
   occur on servers, such as if the robot is sending excessive, unwanted,
   or invalid requests.¶

   A server SHOULD NOT use the From header field for access control or
   authentication, since its value is expected to be visible to anyone
   receiving or observing the request and is often recorded within logfiles
   and error reports without any expectation of privacy.¶





10.1.3. Referer





   The ""Referer"" [sic] header field allows the user agent to specify a URI
   reference for the resource from which the target URI was
   obtained (i.e., the ""referrer"", though the field name is misspelled).
   A user agent MUST NOT include the fragment and userinfo components
   of the URI reference [URI], if any, when generating the
   Referer field value.¶


  Referer = absolute-URI / partial-URI
¶


   The field value is either an absolute-URI or a
   partial-URI. In the latter case (Section 4),
   the referenced URI is relative to the target URI
   ([URI], Section 5).¶

   The Referer header field allows servers to generate back-links to other
   resources for simple analytics, logging, optimized caching, etc. It also
   allows obsolete or mistyped links to be found for maintenance. Some servers
   use the Referer header field as a means of denying links from other sites
   (so-called ""deep linking"") or restricting cross-site request forgery (CSRF),
   but not all requests contain it.¶

   Example:¶

Referer: http://www.example.org/hypertext/Overview.html
¶


   If the target URI was obtained from a source that does not have its own
   URI (e.g., input from the user keyboard, or an entry within the user's
   bookmarks/favorites), the user agent MUST either exclude the Referer header field
   or send it with a value of ""about:blank"".¶

   The Referer header field value need not convey the full URI of the referring
   resource; a user agent MAY truncate parts other than the referring origin.¶

   The Referer header field has the potential to reveal information about the request
   context or browsing history of the user, which is a privacy concern if the
   referring resource's identifier reveals personal information (such as an
   account name) or a resource that is supposed to be confidential (such as
   behind a firewall or internal to a secured service). Most general-purpose
   user agents do not send the Referer header field when the referring
   resource is a local ""file"" or ""data"" URI. A user agent SHOULD NOT send a
   Referer header field if the referring resource was accessed with
   a secure protocol and the request target has an origin differing from that
   of the referring resource, unless the referring resource explicitly allows
   Referer to be sent. A user agent MUST NOT send a
   Referer header field in an unsecured HTTP request if the
   referring resource was accessed with a secure protocol.
   See Section 17.9 for additional
   security considerations.¶

   Some intermediaries have been known to indiscriminately remove Referer
   header fields from outgoing requests. This has the unfortunate side effect
   of interfering with protection against CSRF attacks, which can be far
   more harmful to their users. Intermediaries and user agent extensions that
   wish to limit information disclosure in Referer ought to restrict their
   changes to specific edits, such as replacing internal domain names with
   pseudonyms or truncating the query and/or path components.
   An intermediary SHOULD NOT modify or delete the Referer header field when
   the field value shares the same scheme and host as the target URI.¶





10.1.4. TE





   The ""TE"" header field describes capabilities of the client with regard to
   transfer codings and trailer sections.¶

   As described in Section 6.5,
   a TE field with a ""trailers"" member sent in a request indicates that the
   client will not discard trailer fields.¶

   TE is also used within HTTP/1.1 to advise servers about which transfer
   codings the client is able to accept in a response.
   As of publication, only HTTP/1.1 uses transfer codings
   (see Section 7 of [HTTP/1.1]).¶

   The TE field value is a list of members, with each member (aside from
   ""trailers"") consisting of a transfer coding name token with an optional
   weight indicating the client's relative preference for that
   transfer coding (Section 12.4.2) and
   optional parameters for that transfer coding.¶





  TE                 = #t-codings
  t-codings          = ""trailers"" / ( transfer-coding [ weight ] )
  transfer-coding    = token *( OWS "";"" OWS transfer-parameter )
  transfer-parameter = token BWS ""="" BWS ( token / quoted-string )
¶


   A sender of TE MUST also send a ""TE"" connection option within the
   Connection header field (Section 7.6.1)
   to inform intermediaries not to forward this field.¶





10.1.5. User-Agent





   The ""User-Agent"" header field contains information about the user agent
   originating the request, which is often used by servers to help identify
   the scope of reported interoperability problems, to work around or tailor
   responses to avoid particular user agent limitations, and for analytics
   regarding browser or operating system use. A user agent SHOULD send
   a User-Agent header field in each request unless specifically configured not
   to do so.¶


  User-Agent = product *( RWS ( product / comment ) )
¶


   The User-Agent field value consists of one or more product identifiers,
   each followed by zero or more comments (Section 5.6.5), which together
   identify the user agent software and its significant subproducts.
   By convention, the product identifiers are listed in decreasing order of
   their significance for identifying the user agent software. Each product
   identifier consists of a name and optional version.¶



  product         = token [""/"" product-version]
  product-version = token
¶


   A sender SHOULD limit generated product identifiers to what is necessary
   to identify the product; a sender MUST NOT generate advertising or other
   nonessential information within the product identifier.
   A sender SHOULD NOT generate information in product-version
   that is not a version identifier (i.e., successive versions of the same
   product name ought to differ only in the product-version portion of the
   product identifier).¶

   Example:¶

User-Agent: CERN-LineMode/2.15 libwww/2.17b3
¶


   A user agent SHOULD NOT generate a User-Agent header field containing needlessly
   fine-grained detail and SHOULD limit the addition of subproducts by third
   parties. Overly long and detailed User-Agent field values increase request
   latency and the risk of a user being identified against their wishes
   (""fingerprinting"").¶

   Likewise, implementations are encouraged not to use the product tokens of
   other implementations in order to declare compatibility with them, as this
   circumvents the purpose of the field. If a user agent masquerades as a
   different user agent, recipients can assume that the user intentionally
   desires to see responses tailored for that identified user agent, even
   if they might not work as well for the actual user agent being used.¶







10.2. Response Context Fields


   The response header fields below provide additional information about the
   response, beyond what is implied by the status code, including information
   about the server, about the target resource, or about related
   resources.¶



10.2.1. Allow





   The ""Allow"" header field lists the set of methods advertised as
   supported by the target resource. The purpose of this field
   is strictly to inform the recipient of valid request methods associated
   with the resource.¶


  Allow = #method
¶


   Example of use:¶

Allow: GET, HEAD, PUT
¶


   The actual set of allowed methods is defined by the origin server at the
   time of each request. An origin server MUST generate an Allow header field in a
   405 (Method Not Allowed) response and MAY do so in any
   other response. An empty Allow field value indicates that the resource
   allows no methods, which might occur in a 405 response if the resource has
   been temporarily disabled by configuration.¶

   A proxy MUST NOT modify the Allow header field -- it does not need
   to understand all of the indicated methods in order to handle them
   according to the generic message handling rules.¶





10.2.2. Location





   The ""Location"" header field is used in some responses to refer to a
   specific resource in relation to the response. The type of relationship is
   defined by the combination of request method and status code semantics.¶


  Location = URI-reference
¶


   The field value consists of a single URI-reference. When it has the form
   of a relative reference ([URI], Section 4.2),
   the final value is computed by resolving it against the target
   URI ([URI], Section 5).¶

   For 201 (Created) responses, the Location value refers to
   the primary resource created by the request.
   For 3xx (Redirection) responses, the Location value refers
   to the preferred target resource for automatically redirecting the request.¶

   If the Location value provided in a 3xx (Redirection)
   response does not have a fragment component, a user agent MUST process the
   redirection as if the value inherits the fragment component of the URI
   reference used to generate the target URI (i.e., the redirection
   inherits the original reference's fragment, if any).¶

   For example, a GET request generated for the URI reference
   ""http://www.example.org/~tim"" might result in a
   303 (See Other) response containing the header field:¶

Location: /People.html#tim
¶


   which suggests that the user agent redirect to
   ""http://www.example.org/People.html#tim""¶

   Likewise, a GET request generated for the URI reference
   ""http://www.example.org/index.html#larry"" might result in a
   301 (Moved Permanently) response containing the header
   field:¶

Location: http://www.example.net/index.html
¶


   which suggests that the user agent redirect to
   ""http://www.example.net/index.html#larry"", preserving the original fragment
   identifier.¶

   There are circumstances in which a fragment identifier in a Location
   value would not be appropriate. For example, the Location header field in a
   201 (Created) response is supposed to provide a URI that is
   specific to the created resource.¶


Note: Some recipients attempt to recover from Location header fields
    that are not valid URI references. This specification does not mandate or
    define such processing, but does allow it for the sake of robustness.
    A Location field value cannot allow a list of members because the comma list separator
    is a valid data character within a URI-reference. If an invalid message is sent with multiple
    Location field lines, a recipient along the path might combine those field lines into
    one value. Recovery of a valid Location field value from that situation is difficult and not
    interoperable across implementations.¶



Note: The Content-Location header field
    (Section 8.7) differs from Location in that the
    Content-Location refers to the most specific resource corresponding to the
    enclosed representation. It is therefore possible for a response to contain
    both the Location and Content-Location header fields.¶






10.2.3. Retry-After





   Servers send the ""Retry-After"" header field to indicate how long the user
   agent ought to wait before making a follow-up request. When sent with a
   503 (Service Unavailable) response, Retry-After indicates
   how long the service is expected to be unavailable to the client.
   When sent with any 3xx (Redirection) response, Retry-After
   indicates the minimum time that the user agent is asked to wait before
   issuing the redirected request.¶

   The Retry-After field value can be either an HTTP-date or a number
   of seconds to delay after receiving the response.¶


  Retry-After = HTTP-date / delay-seconds
¶



  
   A delay-seconds value is a non-negative decimal integer, representing time
   in seconds.¶



  delay-seconds  = 1*DIGIT
¶


   Two examples of its use are¶

Retry-After: Fri, 31 Dec 1999 23:59:59 GMT
Retry-After: 120
¶


   In the latter example, the delay is 2 minutes.¶





10.2.4. Server





   The ""Server"" header field contains information about the
   software used by the origin server to handle the request, which is often
   used by clients to help identify the scope of reported interoperability
   problems, to work around or tailor requests to avoid particular server
   limitations, and for analytics regarding server or operating system use.
   An origin server MAY generate a Server header field in its responses.¶


  Server = product *( RWS ( product / comment ) )
¶


   The Server header field value consists of one or more product identifiers, each
   followed by zero or more comments (Section 5.6.5), which together
   identify the origin server software and its significant subproducts.
   By convention, the product identifiers are listed in decreasing order of
   their significance for identifying the origin server software. Each product
   identifier consists of a name and optional version, as defined in
   Section 10.1.5.¶

   Example:¶

Server: CERN/3.0 libwww/2.17
¶


   An origin server SHOULD NOT generate a Server header field containing needlessly
   fine-grained detail and SHOULD limit the addition of subproducts by third
   parties. Overly long and detailed Server field values increase response
   latency and potentially reveal internal implementation details that might
   make it (slightly) easier for attackers to find and exploit known security
   holes.¶









11. HTTP Authentication




11.1. Authentication Scheme


   HTTP provides a general framework for access control and authentication,
   via an extensible set of challenge-response authentication schemes, which
   can be used by a server to challenge a client request and by a client to
   provide authentication information. It uses a case-insensitive
   token to identify the authentication scheme:¶


  auth-scheme    = token
¶


   Aside from the general framework, this document does not specify any
   authentication schemes. New and existing authentication schemes are
   specified independently and ought to be registered within the
   ""Hypertext Transfer Protocol (HTTP) Authentication Scheme Registry"".
   For example, the ""basic"" and ""digest"" authentication schemes are defined by
   [RFC7617] and
   [RFC7616], respectively.¶





11.2. Authentication Parameters


   The authentication scheme is followed by additional information necessary
   for achieving authentication via that scheme as either a
   comma-separated list of parameters or a single sequence of characters
   capable of holding base64-encoded information.¶


  token68        = 1*( ALPHA / DIGIT /
                       ""-"" / ""."" / ""_"" / ""~"" / ""+"" / ""/"" ) *""=""
¶


   The token68 syntax allows the 66 unreserved URI characters
   ([URI]), plus a few others, so that it can hold a
   base64, base64url (URL and filename safe alphabet), base32, or base16 (hex)
   encoding, with or without padding, but excluding whitespace
   ([RFC4648]).¶

   Authentication parameters are name/value pairs, where the name token is
   matched case-insensitively
   and each parameter name MUST only occur once per challenge.¶


  auth-param     = token BWS ""="" BWS ( token / quoted-string )
¶


   Parameter values can be expressed either as ""token"" or as ""quoted-string""
   (Section 5.6).
   Authentication scheme definitions need to accept both notations, both for
   senders and recipients, to allow recipients to use generic parsing
   components regardless of the authentication scheme.¶

   For backwards compatibility, authentication scheme definitions can restrict
   the format for senders to one of the two variants. This can be important
   when it is known that deployed implementations will fail when encountering
   one of the two formats.¶





11.3. Challenge and Response


   A 401 (Unauthorized) response message is used by an origin
   server to challenge the authorization of a user agent, including a
   WWW-Authenticate header field containing at least one
   challenge applicable to the requested resource.¶

   A 407 (Proxy Authentication Required) response message is
   used by a proxy to challenge the authorization of a client, including a
   Proxy-Authenticate header field containing at least one
   challenge applicable to the proxy for the requested resource.¶


  challenge   = auth-scheme [ 1*SP ( token68 / #auth-param ) ]
¶



Note: Many clients fail to parse a challenge that contains an unknown
     scheme. A workaround for this problem is to list well-supported schemes
     (such as ""basic"") first.¶


   A user agent that wishes to authenticate itself with an origin server
   -- usually, but not necessarily, after receiving a
   401 (Unauthorized) -- can do so by including an
   Authorization header field with the request.¶

   A client that wishes to authenticate itself with a proxy -- usually,
   but not necessarily, after receiving a
   407 (Proxy Authentication Required) -- can do so by
   including a Proxy-Authorization header field with the
   request.¶





11.4. Credentials


   Both the Authorization field value and the
   Proxy-Authorization field value contain the client's
   credentials for the realm of the resource being requested, based upon a
   challenge received in a response (possibly at some point in the past).
   When creating their values, the user agent ought to do so by selecting the
   challenge with what it considers to be the most secure auth-scheme that it
   understands, obtaining credentials from the user as appropriate.
   Transmission of credentials within header field values implies significant
   security considerations regarding the confidentiality of the underlying
   connection, as described in
   Section 17.16.1.¶


  credentials = auth-scheme [ 1*SP ( token68 / #auth-param ) ]
¶


   Upon receipt of a request for a protected resource that omits credentials,
   contains invalid credentials (e.g., a bad password) or partial credentials
   (e.g., when the authentication scheme requires more than one round trip),
   an origin server SHOULD send a 401 (Unauthorized) response
   that contains a WWW-Authenticate header field with at least
   one (possibly new) challenge applicable to the requested resource.¶

   Likewise, upon receipt of a request that omits proxy credentials or
   contains invalid or partial proxy credentials, a proxy that requires
   authentication SHOULD generate a
   407 (Proxy Authentication Required) response that contains
   a Proxy-Authenticate header field with at least one
   (possibly new) challenge applicable to the proxy.¶

   A server that receives valid credentials that are not adequate to gain
   access ought to respond with the 403 (Forbidden) status
   code (Section 15.5.4).¶

   HTTP does not restrict applications to this simple challenge-response
   framework for access authentication. Additional mechanisms can be used,
   such as authentication at the transport level or via message encapsulation,
   and with additional header fields specifying authentication information.
   However, such additional mechanisms are not defined by this specification.¶

   Note that various custom mechanisms for user authentication use the
   Set-Cookie and Cookie header fields, defined in [COOKIE],
   for passing tokens related to authentication.¶





11.5. Establishing a Protection Space (Realm)





   The ""realm"" authentication parameter is reserved for use by
   authentication schemes that wish to indicate a scope of protection.¶

   A ""protection space"" is defined by the origin (see
   Section 4.3.1) of the
   server being accessed, in combination with the realm value if present.
   These realms allow the protected resources on a server to be
   partitioned into a set of protection spaces, each with its own
   authentication scheme and/or authorization database. The realm value
   is a string, generally assigned by the origin server, that can have
   additional semantics specific to the authentication scheme. Note that a
   response can have multiple challenges with the same auth-scheme but
   with different realms.¶

   The protection space determines the domain over which credentials can
   be automatically applied. If a prior request has been authorized, the
   user agent MAY reuse the same credentials for all other requests within
   that protection space for a period of time determined by the authentication
   scheme, parameters, and/or user preferences (such as a configurable
   inactivity timeout).¶

   The extent of a protection space, and therefore the requests to which
   credentials might be automatically applied, is not necessarily known to
   clients without additional information. An authentication scheme might
   define parameters that describe the extent of a protection space. Unless
   specifically allowed by the authentication scheme, a single protection
   space cannot extend outside the scope of its server.¶

   For historical reasons, a sender MUST only generate the quoted-string syntax.
   Recipients might have to support both token and quoted-string syntax for
   maximum interoperability with existing clients that have been accepting both
   notations for a long time.¶





11.6. Authenticating Users to Origin Servers




11.6.1. WWW-Authenticate





   The ""WWW-Authenticate"" response header field indicates the authentication
   scheme(s) and parameters applicable to the target resource.¶


  WWW-Authenticate = #challenge
¶


   A server generating a 401 (Unauthorized) response
   MUST send a WWW-Authenticate header field containing at least one
   challenge.  A server MAY generate a WWW-Authenticate header field
   in other response messages to indicate that supplying credentials
   (or different credentials) might affect the response.¶

   A proxy forwarding a response MUST NOT modify any
   WWW-Authenticate header fields in that response.¶

   User agents are advised to take special care in parsing the field value, as
   it might contain more than one challenge, and each challenge can contain a
   comma-separated list of authentication parameters. Furthermore, the header
   field itself can occur multiple times.¶

  For instance:¶

WWW-Authenticate: Basic realm=""simple"", Newauth realm=""apps"",
                 type=1, title=""Login to \""apps\""""
¶


  This header field contains two challenges, one for the ""Basic"" scheme with
  a realm value of ""simple"" and another for the ""Newauth"" scheme with a
  realm value of ""apps"". It also contains two additional parameters, ""type"" and ""title"".¶

  Some user agents do not recognize this form, however. As a result, sending
  a WWW-Authenticate field value with more than one member on the same field
  line might not be interoperable.¶


Note: The challenge grammar production uses the list syntax as
    well. Therefore, a sequence of comma, whitespace, and comma can be
    considered either as applying to the preceding challenge, or to be an
    empty entry in the list of challenges. In practice, this ambiguity
    does not affect the semantics of the header field value and thus is
    harmless.¶






11.6.2. Authorization





   The ""Authorization"" header field allows a user agent to authenticate itself
   with an origin server -- usually, but not necessarily, after receiving
   a 401 (Unauthorized) response. Its value consists of
   credentials containing the authentication information of the user agent for
   the realm of the resource being requested.¶


  Authorization = credentials
¶


   If a request is authenticated and a realm specified, the same credentials
   are presumed to be valid for all other requests within this realm (assuming
   that the authentication scheme itself does not require otherwise, such as
   credentials that vary according to a challenge value or using synchronized
   clocks).¶

   A proxy forwarding a request MUST NOT modify any
   Authorization header fields in that request.
   See Section 3.5 of [CACHING] for details of and requirements
   pertaining to handling of the Authorization header field by HTTP caches.¶





11.6.3. Authentication-Info





   HTTP authentication schemes can use the ""Authentication-Info"" response
   field to communicate information after the client's authentication credentials have been accepted.
   This information can include a finalization message from the server (e.g., it can contain the
   server authentication).¶

   The field value is a list of parameters (name/value pairs), using the ""auth-param""
   syntax defined in Section 11.3.
   This specification only describes the generic format; authentication schemes
   using Authentication-Info will define the individual parameters. The ""Digest""
   Authentication Scheme, for instance, defines multiple parameters in
   Section 3.5 of [RFC7616].¶


  Authentication-Info = #auth-param
¶


   The Authentication-Info field can be used in any HTTP response,
   independently of request method and status code. Its semantics are defined
   by the authentication scheme indicated by the Authorization header field
   (Section 11.6.2) of the corresponding request.¶

   A proxy forwarding a response is not allowed to modify the field value in any
   way.¶

   Authentication-Info can be sent as a trailer field
   (Section 6.5)
   when the authentication scheme explicitly allows this.¶







11.7. Authenticating Clients to Proxies




11.7.1. Proxy-Authenticate





   The ""Proxy-Authenticate"" header field consists of at least one
   challenge that indicates the authentication scheme(s) and parameters
   applicable to the proxy for this request.
   A proxy MUST send at least one Proxy-Authenticate header field in
   each 407 (Proxy Authentication Required) response that it
   generates.¶


  Proxy-Authenticate = #challenge
¶


   Unlike WWW-Authenticate, the Proxy-Authenticate header field
   applies only to the next outbound client on the response chain.
   This is because only the client that chose a given proxy is likely to have
   the credentials necessary for authentication.  However, when multiple
   proxies are used within the same administrative domain, such as office and
   regional caching proxies within a large corporate network, it is common
   for credentials to be generated by the user agent and passed through the
   hierarchy until consumed.  Hence, in such a configuration, it will appear
   as if Proxy-Authenticate is being forwarded because each proxy will send
   the same challenge set.¶

   Note that the parsing considerations for WWW-Authenticate
   apply to this header field as well; see Section 11.6.1
   for details.¶





11.7.2. Proxy-Authorization





   The ""Proxy-Authorization"" header field allows the client to
   identify itself (or its user) to a proxy that requires
   authentication. Its value consists of credentials containing the
   authentication information of the client for the proxy and/or realm of the
   resource being requested.¶


  Proxy-Authorization = credentials
¶


   Unlike Authorization, the Proxy-Authorization header field
   applies only to the next inbound proxy that demanded authentication using
   the Proxy-Authenticate header field. When multiple proxies are used
   in a chain, the Proxy-Authorization header field is consumed by the first
   inbound proxy that was expecting to receive credentials. A proxy MAY
   relay the credentials from the client request to the next proxy if that is
   the mechanism by which the proxies cooperatively authenticate a given
   request.¶





11.7.3. Proxy-Authentication-Info





   The ""Proxy-Authentication-Info"" response header field is equivalent to
   Authentication-Info, except that it applies to proxy authentication (Section 11.3)
   and its semantics are defined by the
   authentication scheme indicated by the Proxy-Authorization header field
   (Section 11.7.2)
   of the corresponding request:¶


  Proxy-Authentication-Info = #auth-param
¶


   However, unlike Authentication-Info, the Proxy-Authentication-Info header
   field applies only to the next outbound client on the response chain. This is
   because only the client that chose a given proxy is likely to have the
   credentials necessary for authentication. However, when multiple proxies are
   used within the same administrative domain, such as office and regional
   caching proxies within a large corporate network, it is common for
   credentials to be generated by the user agent and passed through the
   hierarchy until consumed. Hence, in such a configuration, it will appear as
   if Proxy-Authentication-Info is being forwarded because each proxy will send
   the same field value.¶

   Proxy-Authentication-Info can be sent as a trailer field
   (Section 6.5)
   when the authentication scheme explicitly allows this.¶









12. Content Negotiation


   When responses convey content, whether indicating a success or
   an error, the origin server often has different ways of representing that
   information; for example, in different formats, languages, or encodings.
   Likewise, different users or user agents might have differing capabilities,
   characteristics, or preferences that could influence which representation,
   among those available, would be best to deliver. For this reason, HTTP
   provides mechanisms for content negotiation.¶

   This specification defines three patterns of content negotiation that can
   be made visible within the protocol:
   ""proactive"" negotiation, where the server selects the representation based
   upon the user agent's stated preferences; ""reactive"" negotiation,
   where the server provides a list of representations for the user agent to
   choose from; and ""request content"" negotiation, where the user agent
   selects the representation for a future request based upon the server's
   stated preferences in past responses.¶

   Other patterns of content negotiation include
   ""conditional content"", where the representation consists of multiple
   parts that are selectively rendered based on user agent parameters,
   ""active content"", where the representation contains a script that
   makes additional (more specific) requests based on the user agent
   characteristics, and ""Transparent Content Negotiation""
   ([RFC2295]), where content selection is performed by
   an intermediary. These patterns are not mutually exclusive, and each has
   trade-offs in applicability and practicality.¶

   Note that, in all cases, HTTP is not aware of the resource semantics.
   The consistency with which an origin server responds to requests, over time
   and over the varying dimensions of content negotiation, and thus the
   ""sameness"" of a resource's observed representations over time, is
   determined entirely by whatever entity or algorithm selects or generates
   those responses.¶



12.1. Proactive Negotiation


   When content negotiation preferences are sent by the user agent in a
   request to encourage an algorithm located at the server to
   select the preferred representation, it is called
   ""proactive negotiation""
   (a.k.a., ""server-driven negotiation""). Selection is based on
   the available representations for a response (the dimensions over which it
   might vary, such as language, content coding, etc.) compared to various
   information supplied in the request, including both the explicit
   negotiation header fields below and implicit
   characteristics, such as the client's network address or parts of the
   User-Agent field.¶

   Proactive negotiation is advantageous when the algorithm for
   selecting from among the available representations is difficult to
   describe to a user agent, or when the server desires to send its
   ""best guess"" to the user agent along with the first response (when that
   ""best guess"" is good enough for the user, this avoids the round-trip
   delay of a subsequent request). In order to improve the server's
   guess, a user agent MAY send request header fields that describe
   its preferences.¶

   Proactive negotiation has serious disadvantages:¶


    It is impossible for the server to accurately determine what
    might be ""best"" for any given user, since that would require
    complete knowledge of both the capabilities of the user agent
    and the intended use for the response (e.g., does the user want
    to view it on screen or print it on paper?);¶


    Having the user agent describe its capabilities in every
    request can be both very inefficient (given that only a small
    percentage of responses have multiple representations) and a
    potential risk to the user's privacy;¶


    It complicates the implementation of an origin server and the
    algorithms for generating responses to a request; and,¶


    It limits the reusability of responses for shared caching.¶



   A user agent cannot rely on proactive negotiation preferences being
   consistently honored, since the origin server might not implement proactive
   negotiation for the requested resource or might decide that sending a
   response that doesn't conform to the user agent's preferences is better
   than sending a 406 (Not Acceptable) response.¶

   A Vary header field (Section 12.5.5) is
   often sent in a response subject to proactive negotiation to indicate what
   parts of the request information were used in the selection algorithm.¶

   The request header fields Accept,
   Accept-Charset, Accept-Encoding, and
   Accept-Language are defined below for a user agent to engage
   in proactive negotiation of the response content.
   The preferences sent in these
   fields apply to any content in the response, including representations of
   the target resource, representations of error or processing status, and
   potentially even the miscellaneous text strings that might appear within
   the protocol.¶





12.2. Reactive Negotiation


   With ""reactive negotiation"" (a.k.a., ""agent-driven negotiation""), selection of
   content (regardless of the status code) is performed by
   the user agent after receiving an initial response. The mechanism for
   reactive negotiation might be as simple as a list of references to
   alternative representations.¶

   If the user agent is not satisfied by the initial response content,
   it can perform a GET request on one or more of the alternative resources
   to obtain a different representation. Selection of such alternatives might
   be performed automatically (by the user agent) or manually (e.g., by the
   user selecting from a hypertext menu).¶

   A server might choose not to send an initial representation, other than
   the list of alternatives, and thereby indicate that reactive
   negotiation by the user agent is preferred. For example, the alternatives
   listed in responses with the 300 (Multiple Choices) and
   406 (Not Acceptable) status codes include information about
   available representations so that the user or user agent can react by
   making a selection.¶

   Reactive negotiation is advantageous when the response would vary
   over commonly used dimensions (such as type, language, or encoding),
   when the origin server is unable to determine a user agent's
   capabilities from examining the request, and generally when public
   caches are used to distribute server load and reduce network usage.¶

   Reactive negotiation suffers from the disadvantages of transmitting
   a list of alternatives to the user agent, which degrades user-perceived
   latency if transmitted in the header section, and needing a second request
   to obtain an alternate representation. Furthermore, this specification
   does not define a mechanism for supporting automatic selection, though it
   does not prevent such a mechanism from being developed.¶





12.3. Request Content Negotiation


   When content negotiation preferences are sent in a server's response, the
   listed preferences are called ""request content negotiation""
   because they intend to influence selection of an appropriate content for
   subsequent requests to that resource. For example,
   the Accept (Section 12.5.1) and
   Accept-Encoding (Section 12.5.3)
   header fields can be sent in a response to indicate preferred media types
   and content codings for subsequent requests to that resource.¶

   Similarly, Section 3.1 of [RFC5789] defines
   the ""Accept-Patch"" response header field, which allows discovery of
   which content types are accepted in PATCH requests.¶





12.4. Content Negotiation Field Features




12.4.1. Absence


   For each of the content negotiation fields, a request that does not contain
   the field implies that the sender has no preference on that dimension of
   negotiation.¶

   If a content negotiation header field is present in a request and none of
   the available
   representations for the response can be considered acceptable according to
   it, the origin server can either honor the header field by sending a
   406 (Not Acceptable) response or disregard the header field
   by treating the response as if it is not subject to content negotiation
   for that request header field. This does not imply, however, that the
   client will be able to use the representation.¶


Note: A user agent sending these header fields makes it easier for a
   server to identify an individual by virtue of the user agent's request
   characteristics (Section 17.13).¶






12.4.2. Quality Values


   The content negotiation fields defined by this specification
   use a common parameter, named ""q"" (case-insensitive), to assign a relative
   ""weight"" to the preference for that associated kind of content.
   This weight is referred to as a ""quality value"" (or ""qvalue"") because
   the same parameter name is often used within server configurations to
   assign a weight to the relative quality of the various representations
   that can be selected for a resource.¶

   The weight is normalized to a real number in the range 0 through 1,
   where 0.001 is the least preferred and 1 is the most preferred;
   a value of 0 means ""not acceptable"". If no ""q"" parameter is present,
   the default weight is 1.¶



  weight = OWS "";"" OWS ""q="" qvalue
  qvalue = ( ""0"" [ ""."" 0*3DIGIT ] )
         / ( ""1"" [ ""."" 0*3(""0"") ] )
¶


   A sender of qvalue MUST NOT generate more than three digits after the
   decimal point. User configuration of these values ought to be limited in
   the same fashion.¶





12.4.3. Wildcard Values


   Most of these header fields, where indicated, define a wildcard value (""*"")
   to select unspecified values. If no wildcard is present, values that are
   not explicitly mentioned in the field are considered unacceptable.
   Within Vary, the wildcard value means that the variance
   is unlimited.¶


Note: In practice, using wildcards in content negotiation has limited
   practical value because it is seldom useful to say, for example, ""I
   prefer image/* more or less than (some other specific value)"". By sending Accept: */*;q=0, clients can
   explicitly request a 406 (Not Acceptable) response if a
   more preferred format is not available, but
   they still need to be able to handle a different response since the
   server is allowed to ignore their preference.¶








12.5. Content Negotiation Fields




12.5.1. Accept





   The ""Accept"" header field can be used by user agents to specify their
   preferences regarding response media types. For example, Accept header
   fields can be used to indicate that the request is specifically limited to
   a small set of desired types, as in the case of a request for an in-line
   image.¶

   When sent by a server in a response, Accept provides information
   about which content types are preferred in the content of a subsequent
   request to the same resource.¶



  Accept = #( media-range [ weight ] )

  media-range    = ( ""*/*""
                     / ( type ""/"" ""*"" )
                     / ( type ""/"" subtype )
                   ) parameters
¶


   The asterisk ""*"" character is used to group media types into ranges,
   with ""*/*"" indicating all media types and ""type/*"" indicating all
   subtypes of that type. The media-range can include media type
   parameters that are applicable to that range.¶

   Each media-range might be followed by optional applicable media type
   parameters (e.g., charset), followed by an optional ""q""
   parameter for indicating a relative weight (Section 12.4.2).¶

   Previous specifications allowed additional extension parameters to appear
   after the weight parameter. The accept extension grammar (accept-params, accept-ext) has
   been removed because it had a complicated definition, was not being used in
   practice, and is more easily deployed through new header fields. Senders
   using weights SHOULD send ""q"" last (after all media-range parameters).
   Recipients SHOULD process any parameter named ""q"" as weight, regardless of
   parameter ordering.¶


Note: Use of the ""q"" parameter name to control content negotiation
    would interfere with any media type parameter having the same name.
    Hence, the media type registry disallows parameters named ""q"".¶


   The example¶

Accept: audio/*; q=0.2, audio/basic
¶


   is interpreted as ""I prefer audio/basic, but send me any audio
   type if it is the best available after an 80% markdown in quality"".¶

   A more elaborate example is¶

Accept: text/plain; q=0.5, text/html,
       text/x-dvi; q=0.8, text/x-c
¶


   Verbally, this would be interpreted as ""text/html and text/x-c are
   the equally preferred media types, but if they do not exist, then send the
   text/x-dvi representation, and if that does not exist, send the text/plain
   representation"".¶

   Media ranges can be overridden by more specific media ranges or
   specific media types. If more than one media range applies to a given
   type, the most specific reference has precedence. For example,¶

Accept: text/*, text/plain, text/plain;format=flowed, */*
¶


   have the following precedence:¶

text/plain;format=flowed¶

text/plain¶

text/*¶

*/*¶



   The media type quality factor associated with a given type is
   determined by finding the media range with the highest precedence
   that matches the type. For example,¶

Accept: text/*;q=0.3, text/plain;q=0.7, text/plain;format=flowed,
       text/plain;format=fixed;q=0.4, */*;q=0.5
¶


   would cause the following values to be associated:¶

Table 5


Media Type
Quality Value




text/plain;format=flowed
1


text/plain
0.7


text/html
0.3


image/jpeg
0.5


text/plain;format=fixed
0.4


text/html;level=3
0.7





Note: A user agent might be provided with a default set of quality
   values for certain media ranges. However, unless the user agent is
   a closed system that cannot interact with other rendering agents,
   this default set ought to be configurable by the user.¶






12.5.2. Accept-Charset





   The ""Accept-Charset"" header field can be sent by a user agent to indicate
   its preferences for charsets in textual response content. For example,
   this field allows user agents capable of understanding more comprehensive
   or special-purpose charsets to signal that capability to an origin server
   that is capable of representing information in those charsets.¶


  Accept-Charset = #( ( token / ""*"" ) [ weight ] )
¶


   Charset names are defined in Section 8.3.2.
   A user agent MAY associate a quality value with each charset to indicate
   the user's relative preference for that charset, as defined in Section 12.4.2.
   An example is¶

Accept-Charset: iso-8859-5, unicode-1-1;q=0.8
¶


   The special value ""*"", if present in the Accept-Charset header field,
   matches every charset that is not mentioned elsewhere in the
   field.¶


Note: Accept-Charset is deprecated because UTF-8 has become nearly
   ubiquitous and sending a detailed list of user-preferred charsets wastes
   bandwidth, increases latency, and makes passive fingerprinting far too
   easy (Section 17.13). Most general-purpose user agents
   do not send Accept-Charset unless specifically configured to do so.¶






12.5.3. Accept-Encoding





   The ""Accept-Encoding"" header field can be used to indicate preferences
   regarding the use of content codings (Section 8.4.1).¶

   When sent by a user agent in a request, Accept-Encoding indicates the
   content codings acceptable in a response.¶

   When sent by a server in a response, Accept-Encoding provides information
   about which content codings are preferred in the content of a subsequent
   request to the same resource.¶

   An ""identity"" token is used as a synonym for
   ""no encoding"" in order to communicate when no encoding is preferred.¶



  Accept-Encoding  = #( codings [ weight ] )
  codings          = content-coding / ""identity"" / ""*""
¶


   Each codings value MAY be given an associated quality value (weight)
   representing the preference for that encoding, as defined in Section 12.4.2.
   The asterisk ""*"" symbol in an Accept-Encoding field matches any available
   content coding not explicitly listed in the field.¶

   Examples:¶

Accept-Encoding: compress, gzip
Accept-Encoding:
Accept-Encoding: *
Accept-Encoding: compress;q=0.5, gzip;q=1.0
Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0
¶


   A server tests whether a content coding for a given representation is
   acceptable using these rules:¶

If no Accept-Encoding header field is in the request, any content coding is
       considered acceptable by the user agent.¶

If the representation has no content coding, then it is acceptable
       by default unless specifically excluded by the Accept-Encoding header field
       stating either ""identity;q=0"" or ""*;q=0"" without a more specific
       entry for ""identity"".¶

If the representation's content coding is one of the content codings
       listed in the Accept-Encoding field value, then it is acceptable unless
       it is accompanied by a qvalue of 0. (As defined in Section 12.4.2, a
       qvalue of 0 means ""not acceptable"".)¶



   A representation could be encoded with multiple content codings. However, most
   content codings are alternative ways to accomplish the same purpose
   (e.g., data compression). When selecting between multiple content codings that
   have the same purpose, the acceptable content coding with the highest
   non-zero qvalue is preferred.¶

   An Accept-Encoding header field with a field value that is empty
   implies that the user agent does not want any content coding in response.
   If a non-empty Accept-Encoding header field is present in a request and none of the
   available representations for the response have a content coding that
   is listed as acceptable, the origin server SHOULD send a response
   without any content coding unless the identity coding is indicated as unacceptable.¶

   When the Accept-Encoding header field is present in a response, it indicates
   what content codings the resource was willing to accept in the associated
   request. The field value is evaluated the same way as in a request.¶

   Note that this information is specific to the associated request; the set of
   supported encodings might be different for other resources on the same
   server and could change over time or depend on other aspects of the request
   (such as the request method).¶

   Servers that fail a request due to an unsupported content coding ought to
   respond with a 415 (Unsupported Media Type) status and
   include an Accept-Encoding header field in that response, allowing
   clients to distinguish between issues related to content codings and media
   types. In order to avoid confusion with issues related to media types,
   servers that fail a request with a 415 status for reasons unrelated to
   content codings MUST NOT include the Accept-Encoding header
   field.¶

   The most common use of Accept-Encoding is in responses with a
   415 (Unsupported Media Type) status code, in response to
   optimistic use of a content coding by clients. However, the header field
   can also be used to indicate to clients that content codings are supported in order
   to optimize future interactions. For example, a resource might include it
   in a 2xx (Successful) response when the request content was
   big enough to justify use of a compression coding but the client failed do
   so.¶





12.5.4. Accept-Language





   The ""Accept-Language"" header field can be used by user agents to
   indicate the set of natural languages that are preferred in the response.
   Language tags are defined in Section 8.5.1.¶



  Accept-Language = #( language-range [ weight ] )
  language-range  =
            <language-range, see [RFC4647], Section 2.1>
¶


   Each language-range can be given an associated quality value
   representing an estimate of the user's preference for the languages
   specified by that range, as defined in Section 12.4.2. For example,¶

Accept-Language: da, en-gb;q=0.8, en;q=0.7
¶


   would mean: ""I prefer Danish, but will accept British English and
   other types of English"".¶

   Note that some recipients treat the order in which language tags are listed
   as an indication of descending priority, particularly for tags that are
   assigned equal quality values (no value is the same as q=1). However, this
   behavior cannot be relied upon. For consistency and to maximize
   interoperability, many user agents assign each language tag a unique
   quality value while also listing them in order of decreasing quality.
   Additional discussion of language priority lists can be found in
   Section 2.3 of [RFC4647].¶

   For matching, Section 3 of [RFC4647] defines
   several matching schemes. Implementations can offer the most appropriate
   matching scheme for their requirements. The ""Basic Filtering"" scheme
   ([RFC4647], Section 3.3.1) is identical to the
   matching scheme that was previously defined for HTTP in
   Section 14.4 of [RFC2616].¶

   It might be contrary to the privacy expectations of the user to send
   an Accept-Language header field with the complete linguistic preferences of
   the user in every request (Section 17.13).¶

   Since intelligibility is highly dependent on the individual user, user
   agents need to allow user control over the linguistic preference (either
   through configuration of the user agent itself or by defaulting to a user
   controllable system setting).
   A user agent that does not provide such control to the user MUST NOT
   send an Accept-Language header field.¶


Note: User agents ought to provide guidance to users when setting a
    preference, since users are rarely familiar with the details of language
    matching as described above. For example, users might assume that on
    selecting ""en-gb"", they will be served any kind of English document if
    British English is not available. A user agent might suggest, in such a
    case, to add ""en"" to the list for better matching behavior.¶






12.5.5. Vary





   The ""Vary"" header field in a response describes what parts of a request
   message, aside from the method and target URI, might have influenced the
   origin server's process for selecting the content of this response.¶


  Vary = #( ""*"" / field-name )
¶


   A Vary field value is either the wildcard member ""*"" or a list of
   request field names, known as the selecting header fields, that might
   have had a role in selecting the representation for this response.
   Potential selecting header fields are not limited to fields defined by
   this specification.¶

   A list containing the member ""*"" signals that other aspects of the
   request might have played a role in selecting the response representation,
   possibly including aspects outside the message syntax (e.g., the
   client's network address).
   A recipient will not be able to determine whether this response is
   appropriate for a later request without forwarding the request to the
   origin server. A proxy MUST NOT generate ""*"" in a Vary field value.¶

   For example, a response that contains¶

Vary: accept-encoding, accept-language
¶


   indicates that the origin server might have used the request's
   Accept-Encoding and Accept-Language
   header fields (or lack thereof) as determining factors while choosing
   the content for this response.¶

   A Vary field containing a list of field names has two purposes:¶



       To inform cache recipients that they MUST NOT use this response
       to satisfy a later request unless the later request has the
       same values for the listed header fields as the original request
       (Section 4.1 of [CACHING]) or reuse of the
       response has been validated by the origin server.
       In other words, Vary expands the cache key
       required to match a new request to the stored cache entry.¶



       To inform user agent recipients that this response was subject to
       content negotiation (Section 12) and a
       different representation might be sent in a subsequent request if
       other values are provided in the listed header fields
       (proactive negotiation).¶



   An origin server SHOULD generate a Vary header field on a cacheable
   response when it wishes that response to be selectively reused for
   subsequent requests. Generally, that is the case when the response
   content has been tailored to better fit the preferences expressed by
   those selecting header fields, such as when an origin server has
   selected the response's language based on the request's
   Accept-Language header field.¶

   Vary might be elided when an origin server considers variance in
   content selection to be less significant than Vary's performance impact
   on caching, particularly when reuse is already limited by cache
   response directives (Section 5.2 of [CACHING]).¶

   There is no need to send the Authorization field name in Vary because
   reuse of that response for a different user is prohibited by the field
   definition (Section 11.6.2).
   Likewise, if the response content has been selected or influenced by
   network region, but the origin server wants the cached response to be
   reused even if recipients move from one region to another, then there
   is no need for the origin server to indicate such variance in Vary.¶









13. Conditional Requests



   A conditional request is an HTTP request with one or more request header
   fields that indicate a precondition to be tested before
   applying the request method to the target resource.
   Section 13.2 defines when to evaluate preconditions and
   their order of precedence when more than one precondition is present.¶

   Conditional GET requests are the most efficient mechanism for HTTP
   cache updates [CACHING].  Conditionals can also be
   applied to state-changing methods, such as PUT and DELETE, to prevent
   the ""lost update"" problem: one client accidentally overwriting
   the work of another client that has been acting in parallel.¶



13.1. Preconditions



   Preconditions are usually defined with respect to a state of the target
   resource as a whole (its current value set) or the state as observed in a
   previously obtained representation (one value in that set). If a resource
   has multiple current representations, each with its own observable state,
   a precondition will assume that the mapping of each request to a
   selected representation (Section 3.2)
   is consistent over time.
   Regardless, if the mapping is inconsistent or the server is unable to
   select an appropriate representation, then no harm will result when the
   precondition evaluates to false.¶

   Each precondition defined below consists of a comparison between a
   set of validators obtained from prior representations of the target
   resource to the current state of validators for the selected
   representation (Section 8.8). Hence, these
   preconditions evaluate whether the state of the target resource has
   changed since a given state known by the client. The effect of such an
   evaluation depends on the method semantics and choice of conditional, as
   defined in Section 13.2.¶

   Other preconditions, defined by other specifications as extension fields,
   might place conditions on all recipients, on the state of the target
   resource in general, or on a group of resources. For instance, the ""If""
   header field in WebDAV can make a request conditional on various aspects
   of multiple resources, such as locks, if the recipient understands and
   implements that field ([WEBDAV], Section 10.4).¶

   Extensibility of preconditions is only possible when the precondition can
   be safely ignored if unknown (like If-Modified-Since), when
   deployment can be assumed for a given use case, or when implementation
   is signaled by some other property of the target resource. This encourages
   a focus on mutually agreed deployment of common standards.¶



13.1.1. If-Match





   The ""If-Match"" header field makes the request method conditional on the
   recipient origin server either having at least one current
   representation of the target resource, when the field value is ""*"", or
   having a current representation of the target resource that has an
   entity tag matching a member of the list of entity tags provided in the
   field value.¶

   An origin server MUST use the strong comparison function when comparing
   entity tags for If-Match (Section 8.8.3.2), since
   the client intends this precondition to prevent the method from being
   applied if there have been any changes to the representation data.¶


  If-Match = ""*"" / #entity-tag
¶


   Examples:¶

If-Match: ""xyzzy""
If-Match: ""xyzzy"", ""r2d2xxxx"", ""c3piozzzz""
If-Match: *
¶


   If-Match is most often used with state-changing methods (e.g., POST, PUT,
   DELETE) to prevent accidental overwrites when multiple user agents might be
   acting in parallel on the same resource (i.e., to prevent the ""lost update""
   problem). In general, it can be used with any method that involves the
   selection or modification of a representation to abort the request if the
   selected representation's current entity tag is not a
   member within the If-Match field value.¶

   When an origin server receives a request that selects a representation
   and that request includes an If-Match header field,
   the origin server MUST evaluate the If-Match condition per
   Section 13.2 prior to performing the method.¶

   To evaluate a received If-Match header field:¶


      If the field value is ""*"", the condition is true if the origin server
      has a current representation for the target resource.¶


      If the field value is a list of entity tags, the condition is true if
      any of the listed tags match the entity tag of the selected representation.¶


      Otherwise, the condition is false.¶



   An origin server that evaluates an If-Match condition MUST NOT perform
   the requested method if the condition evaluates to false. Instead,
   the origin server MAY
   indicate that the conditional request failed by responding with a
   412 (Precondition Failed) status code. Alternatively,
   if the request is a state-changing operation that appears to have already
   been applied to the selected representation, the origin server MAY respond
   with a 2xx (Successful) status code
   (i.e., the change requested by the user agent has already succeeded, but
   the user agent might not be aware of it, perhaps because the prior response
   was lost or an equivalent change was made by some other user agent).¶

   Allowing an origin server to send a success response when a change request
   appears to have already been applied is more efficient for many authoring
   use cases, but comes with some risk if multiple user agents are making
   change requests that are very similar but not cooperative.
   For example, multiple user agents writing to a common resource as a
   semaphore (e.g., a nonatomic increment) are likely to collide and
   potentially lose important state transitions. For those kinds of resources,
   an origin server is better off being stringent in sending 412 for every
   failed precondition on an unsafe method.
   In other cases, excluding the ETag field from a success response might
   encourage the user agent to perform a GET as its next request to eliminate
   confusion about the resource's current state.¶

   A client MAY send an If-Match header field in a
   GET request to indicate that it would prefer a
   412 (Precondition Failed) response if the selected
   representation does not match. However, this is only useful in range
   requests (Section 14) for completing a previously
   received partial representation when there is no desire for a new
   representation. If-Range (Section 13.1.5)
   is better suited for range requests when the client prefers to receive a
   new representation.¶

   A cache or intermediary MAY ignore If-Match because its
   interoperability features are only necessary for an origin server.¶

   Note that an If-Match header field with a list value containing ""*"" and
   other values (including other instances of ""*"") is syntactically
   invalid (therefore not allowed to be generated) and furthermore is
   unlikely to be interoperable.¶





13.1.2. If-None-Match





   The ""If-None-Match"" header field makes the request method conditional on
   a recipient cache or origin server either not having any current
   representation of the target resource, when the field value is ""*"", or
   having a selected representation with an entity tag that does not match any
   of those listed in the field value.¶

   A recipient MUST use the weak comparison function when comparing
   entity tags for If-None-Match (Section 8.8.3.2),
   since weak entity tags can be used for cache validation even if there have
   been changes to the representation data.¶


  If-None-Match = ""*"" / #entity-tag
¶


   Examples:¶

If-None-Match: ""xyzzy""
If-None-Match: W/""xyzzy""
If-None-Match: ""xyzzy"", ""r2d2xxxx"", ""c3piozzzz""
If-None-Match: W/""xyzzy"", W/""r2d2xxxx"", W/""c3piozzzz""
If-None-Match: *
¶


   If-None-Match is primarily used in conditional GET requests to enable
   efficient updates of cached information with a minimum amount of
   transaction overhead. When a client desires to update one or more stored
   responses that have entity tags, the client SHOULD generate an
   If-None-Match header field containing a list of those entity tags when
   making a GET request; this allows recipient servers to send a
   304 (Not Modified) response to indicate when one of those
   stored responses matches the selected representation.¶

   If-None-Match can also be used with a value of ""*"" to prevent an unsafe
   request method (e.g., PUT) from inadvertently modifying an existing
   representation of the target resource when the client believes that
   the resource does not have a current representation (Section 9.2.1).
   This is a variation on the ""lost update"" problem that might arise if more
   than one client attempts to create an initial representation for the target
   resource.¶

   When an origin server receives a request that selects a representation
   and that request includes an If-None-Match header field,
   the origin server MUST evaluate the If-None-Match condition per
   Section 13.2 prior to performing the method.¶

   To evaluate a received If-None-Match header field:¶


      If the field value is ""*"", the condition is false if the origin server
      has a current representation for the target resource.¶


      If the field value is a list of entity tags, the condition is false if
      one of the listed tags matches the entity tag of the selected representation.¶


      Otherwise, the condition is true.¶



   An origin server that evaluates an If-None-Match condition MUST NOT
   perform the requested method if the condition evaluates to false; instead,
   the origin server MUST respond with either
   a) the 304 (Not Modified) status code if the request method
   is GET or HEAD or b) the 412 (Precondition Failed) status
   code for all other request methods.¶

   Requirements on cache handling of a received If-None-Match header field
   are defined in Section 4.3.2 of [CACHING].¶

   Note that an If-None-Match header field with a list value containing ""*"" and
   other values (including other instances of ""*"") is syntactically
   invalid (therefore not allowed to be generated) and furthermore is
   unlikely to be interoperable.¶





13.1.3. If-Modified-Since





   The ""If-Modified-Since"" header field makes a GET or HEAD request method
   conditional on the selected representation's modification
   date being more
   recent than the date provided in the field value. Transfer of the selected
   representation's data is avoided if that data has not changed.¶


  If-Modified-Since = HTTP-date
¶


   An example of the field is:¶

If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT
¶


   A recipient MUST ignore If-Modified-Since if the request contains an
   If-None-Match header field; the condition in
   If-None-Match is considered to be a more accurate
   replacement for the condition in If-Modified-Since, and the two are only
   combined for the sake of interoperating with older intermediaries that
   might not implement If-None-Match.¶

   A recipient MUST ignore the If-Modified-Since header field if the
   received field value is not a valid HTTP-date, the field value has more than
   one member, or if the request method is neither GET nor HEAD.¶

   A recipient MUST ignore the If-Modified-Since header field if the
   resource does not have a modification date available.¶

   A recipient MUST interpret an If-Modified-Since field value's timestamp
   in terms of the origin server's clock.¶

   If-Modified-Since is typically used for two distinct purposes:
   1) to allow efficient updates of a cached representation that does not
   have an entity tag and 2) to limit the scope of a web traversal to resources
   that have recently changed.¶

   When used for cache updates, a cache will typically use the value of the
   cached message's Last-Modified header field to generate the field
   value of If-Modified-Since. This behavior is most interoperable for cases
   where clocks are poorly synchronized or when the server has chosen to only
   honor exact timestamp matches (due to a problem with Last-Modified dates
   that appear to go ""back in time"" when the origin server's clock is
   corrected or a representation is restored from an archived backup).
   However, caches occasionally generate the field value based on other data,
   such as the Date header field of the cached message or the
   clock time at which the message was received, particularly when the
   cached message does not contain a Last-Modified header field.¶

   When used for limiting the scope of retrieval to a recent time window, a
   user agent will generate an If-Modified-Since field value based on either
   its own clock or a Date header field received from the
   server in a prior response. Origin servers that choose an exact
   timestamp match based on the selected representation's
   Last-Modified
   header field will not be able to help the user agent limit its data
   transfers to only those changed during the specified window.¶

   When an origin server receives a request that selects a representation
   and that request includes an If-Modified-Since header field without an
   If-None-Match header field, the origin server SHOULD
   evaluate the If-Modified-Since condition per
   Section 13.2 prior to performing the method.¶

   To evaluate a received If-Modified-Since header field:¶


      If the selected representation's last modification date is earlier or
      equal to the date provided in the field value, the condition is false.¶


      Otherwise, the condition is true.¶



   An origin server that evaluates an If-Modified-Since condition
   SHOULD NOT perform the requested method if the condition evaluates to
   false; instead,
   the origin server SHOULD generate a 304 (Not Modified)
   response, including only those metadata that are useful for identifying or
   updating a previously cached response.¶

   Requirements on cache handling of a received If-Modified-Since header field
   are defined in Section 4.3.2 of [CACHING].¶





13.1.4. If-Unmodified-Since





   The ""If-Unmodified-Since"" header field makes the request method conditional
   on the selected representation's last modification date being
   earlier than or equal to the date provided in the field value.
   This field accomplishes the
   same purpose as If-Match for cases where the user agent does
   not have an entity tag for the representation.¶


  If-Unmodified-Since = HTTP-date
¶


   An example of the field is:¶

If-Unmodified-Since: Sat, 29 Oct 1994 19:43:31 GMT
¶


   A recipient MUST ignore If-Unmodified-Since if the request contains an
   If-Match header field; the condition in
   If-Match is considered to be a more accurate replacement for
   the condition in If-Unmodified-Since, and the two are only combined for the
   sake of interoperating with older intermediaries that might not implement
   If-Match.¶

   A recipient MUST ignore the If-Unmodified-Since header field if the
   received field value is not a valid HTTP-date (including when the field
   value appears to be a list of dates).¶

   A recipient MUST ignore the If-Unmodified-Since header field if the
   resource does not have a modification date available.¶

   A recipient MUST interpret an If-Unmodified-Since field value's timestamp
   in terms of the origin server's clock.¶

   If-Unmodified-Since is most often used with state-changing methods
   (e.g., POST, PUT, DELETE) to prevent accidental overwrites when multiple
   user agents might be acting in parallel on a resource that does
   not supply entity tags with its representations (i.e., to prevent the
   ""lost update"" problem).
   In general, it can be used with any method that involves the selection
   or modification of a representation to abort the request if the
   selected representation's last modification date has
   changed since the date provided in the If-Unmodified-Since field value.¶

   When an origin server receives a request that selects a representation
   and that request includes an If-Unmodified-Since header field without
   an If-Match header field,
   the origin server MUST evaluate the If-Unmodified-Since condition per
   Section 13.2 prior to performing the method.¶

   To evaluate a received If-Unmodified-Since header field:¶


      If the selected representation's last modification date is earlier than or
      equal to the date provided in the field value, the condition is true.¶


      Otherwise, the condition is false.¶



   An origin server that evaluates an If-Unmodified-Since condition MUST NOT
   perform the requested method if the condition evaluates to false.
   Instead, the origin server MAY indicate that the conditional request
   failed by responding with a 412 (Precondition Failed)
   status code. Alternatively, if the request is a state-changing operation
   that appears to have already been applied to the selected representation,
   the origin server MAY respond with a 2xx (Successful)
   status code
   (i.e., the change requested by the user agent has already succeeded, but
   the user agent might not be aware of it, perhaps because the prior response
   was lost or an equivalent change was made by some other user agent).¶

   Allowing an origin server to send a success response when a change request
   appears to have already been applied is more efficient for many authoring
   use cases, but comes with some risk if multiple user agents are making
   change requests that are very similar but not cooperative.
   In those cases, an origin server is better off being stringent in sending
   412 for every failed precondition on an unsafe method.¶

   A client MAY send an If-Unmodified-Since header field in a
   GET request to indicate that it would prefer a
   412 (Precondition Failed) response if the selected
   representation has been modified. However, this is only useful in range
   requests (Section 14) for completing a previously
   received partial representation when there is no desire for a new
   representation. If-Range (Section 13.1.5)
   is better suited for range requests when the client prefers to receive a
   new representation.¶

   A cache or intermediary MAY ignore If-Unmodified-Since because its
   interoperability features are only necessary for an origin server.¶





13.1.5. If-Range





   The ""If-Range"" header field provides a special conditional request
   mechanism that is similar to the If-Match and
   If-Unmodified-Since header fields but that instructs the
   recipient to ignore the Range header field if the validator
   doesn't match, resulting in transfer of the new selected representation
   instead of a 412 (Precondition Failed) response.¶

   If a client has a partial copy of a representation and wishes
   to have an up-to-date copy of the entire representation, it could use the
   Range header field with a conditional GET (using
   either or both of If-Unmodified-Since and
   If-Match.) However, if the precondition fails because the
   representation has been modified, the client would then have to make a
   second request to obtain the entire current representation.¶

   The ""If-Range"" header field allows a client to ""short-circuit"" the second
   request. Informally, its meaning is as follows: if the representation is unchanged,
   send me the part(s) that I am requesting in Range; otherwise, send me the
   entire representation.¶


  If-Range = entity-tag / HTTP-date
¶


   A valid entity-tag can be distinguished from a valid
   HTTP-date by examining the first three characters for a
   DQUOTE.¶

   A client MUST NOT generate an If-Range header field in a request that
   does not contain a Range header field.
   A server MUST ignore an If-Range header field received in a request that
   does not contain a Range header field.
   An origin server MUST ignore an If-Range header field received in a
   request for a target resource that does not support Range requests.¶

   A client MUST NOT generate an If-Range header field containing an
   entity tag that is marked as weak.
   A client MUST NOT generate an If-Range header field containing an
   HTTP-date unless the client has no entity tag for
   the corresponding representation and the date is a strong validator
   in the sense defined by Section 8.8.2.2.¶

   A server that receives an If-Range header field on a Range request MUST
   evaluate the condition per Section 13.2 prior to
   performing the method.¶

   To evaluate a received If-Range header field containing an
   HTTP-date:¶

If the HTTP-date validator provided is not a
       strong validator in the sense defined by
       Section 8.8.2.2, the condition is false.¶

If the HTTP-date validator provided exactly matches
       the Last-Modified field value for the selected
       representation, the condition is true.¶

Otherwise, the condition is false.¶



   To evaluate a received If-Range header field containing an
   entity-tag:¶

If the entity-tag validator provided exactly matches
       the ETag field value for the selected representation
       using the strong comparison function
       (Section 8.8.3.2), the condition is true.¶

Otherwise, the condition is false.¶



   A recipient of an If-Range header field MUST ignore the
   Range header field if the If-Range condition
   evaluates to false. Otherwise, the recipient SHOULD process the
   Range header field as requested.¶

   Note that the If-Range comparison is by exact match, including when the
   validator is an HTTP-date, and so it
   differs from the ""earlier than or equal to"" comparison used when evaluating
   an If-Unmodified-Since conditional.¶







13.2. Evaluation of Preconditions




13.2.1. When to Evaluate


   Except when excluded below, a recipient cache or origin server MUST
   evaluate received request preconditions after it has successfully performed
   its normal request checks and just before it would process the request content
   (if any) or perform the action associated with the request method.
   A server MUST ignore all received preconditions if its response to the
   same request without those conditions, prior to processing the request content,
   would have been a status code other than a 2xx (Successful)
   or 412 (Precondition Failed).
   In other words, redirects and failures that can be detected before
   significant processing occurs take precedence over the evaluation
   of preconditions.¶

   A server that is not the origin server for the target resource and cannot
   act as a cache for requests on the target resource MUST NOT evaluate the
   conditional request header fields defined by this specification, and it
   MUST forward them if the request is forwarded, since the generating
   client intends that they be evaluated by a server that can provide a
   current representation.
   Likewise, a server MUST ignore the conditional request header fields
   defined by this specification when received with a request method that does
   not involve the selection or modification of a
   selected representation, such as CONNECT, OPTIONS, or TRACE.¶

   Note that protocol extensions can modify the conditions under which
   preconditions are evaluated or the consequences of their evaluation.
   For example, the immutable cache directive
   (defined by [RFC8246]) instructs caches to forgo
   forwarding conditional requests when they hold a fresh response.¶

   Although conditional request header fields are defined as being usable with
   the HEAD method (to keep HEAD's semantics consistent with those of GET),
   there is no point in sending a conditional HEAD because a successful
   response is around the same size as a 304 (Not Modified)
   response and more useful than a 412 (Precondition Failed)
   response.¶





13.2.2. Precedence of Preconditions


   When more than one conditional request header field is present in a request,
   the order in which the fields are evaluated becomes important. In practice,
   the fields defined in this document are consistently implemented in a
   single, logical order, since ""lost update"" preconditions have more strict
   requirements than cache validation, a validated cache is more efficient
   than a partial response, and entity tags are presumed to be more accurate
   than date validators.¶

   A recipient cache or origin server MUST evaluate the request
   preconditions defined by this specification in the following order:¶



When recipient is the origin server and
     If-Match is present,
     evaluate the If-Match precondition:¶

if true, continue to step 3¶

if false, respond 412 (Precondition Failed) unless
           it can be determined that the state-changing request has already
           succeeded (see Section 13.1.1)¶






When recipient is the origin server,
     If-Match is not present, and
     If-Unmodified-Since is present,
     evaluate the If-Unmodified-Since precondition:¶

if true, continue to step 3¶

if false, respond 412 (Precondition Failed) unless
           it can be determined that the state-changing request has already
           succeeded (see Section 13.1.4)¶






When If-None-Match is present,
     evaluate the If-None-Match precondition:¶

if true, continue to step 5¶

if false for GET/HEAD, respond 304 (Not Modified)¶

if false for other methods, respond 412 (Precondition Failed)¶






When the method is GET or HEAD,
     If-None-Match is not present, and
     If-Modified-Since is present,
     evaluate the If-Modified-Since precondition:¶

if true, continue to step 5¶

if false, respond 304 (Not Modified)¶






When the method is GET and both
     Range and If-Range are present,
     evaluate the If-Range precondition:¶

if true and the Range is
           applicable to the selected representation,
           respond 206 (Partial Content)¶

otherwise, ignore the Range header field
           and respond 200 (OK)¶






Otherwise,¶

perform the requested method and
           respond according to its success or failure.¶






   Any extension to HTTP that defines additional conditional request
   header fields ought to define the order
   for evaluating such fields in relation to those defined in this document
   and other conditionals that might be found in practice.¶









14. Range Requests


   Clients often encounter interrupted data
   transfers as a result of canceled requests or dropped connections. When a
   client has stored a partial representation, it is desirable to request the
   remainder of that representation in a subsequent request rather than
   transfer the entire representation. Likewise, devices with limited local
   storage might benefit from being able to request only a subset of a larger
   representation, such as a single page of a very large document, or the
   dimensions of an embedded image.¶

   Range requests are an OPTIONAL feature
   of HTTP, designed so that recipients not implementing this feature (or not
   supporting it for the target resource) can respond as if it is a normal
   GET request without impacting interoperability. Partial responses are
   indicated by a distinct status code to not be mistaken for full responses
   by caches that might not implement the feature.¶



14.1. Range Units


   Representation data can be partitioned into subranges when there are
   addressable structural units inherent to that data's content coding or
   media type. For example, octet (a.k.a. byte) boundaries are a structural
   unit common to all representation data, allowing partitions of the data to
   be identified as a range of bytes at some offset from the start or end of
   that data.¶

   This general notion of a ""range unit"" is used
   in the Accept-Ranges (Section 14.3)
   response header field to advertise support for range requests, the
   Range (Section 14.2) request header field
   to delineate the parts of a representation that are requested, and the
   Content-Range (Section 14.4)
   header field to describe which part of a representation is being
   transferred.¶


  range-unit       = token
¶


   All range unit names are case-insensitive and ought to be registered
   within the ""HTTP Range Unit Registry"", as defined in
   Section 16.5.1.¶

   Range units are intended to be extensible, as described in
   Section 16.5.¶



14.1.1. Range Specifiers




   Ranges are expressed in terms of a range unit paired with a set of range
   specifiers. The range unit name determines what kinds of range-spec
   are applicable to its own specifiers. Hence, the following grammar is
   generic: each range unit is expected to specify requirements on when
   int-range, suffix-range, and
   other-range are allowed.¶


  
  
  
   A range request can specify a single range or a set
   of ranges within a single representation.¶





  ranges-specifier = range-unit ""="" range-set
  range-set        = 1#range-spec
  range-spec       = int-range
                   / suffix-range
                   / other-range
¶



  
  
  
   An int-range is a range expressed as two non-negative
   integers or as one non-negative integer through to the end of the
   representation data.
   The range unit specifies what the integers mean (e.g., they might indicate
   unit offsets from the beginning, inclusive numbered parts, etc.).¶





  int-range     = first-pos ""-"" [ last-pos ]
  first-pos     = 1*DIGIT
  last-pos      = 1*DIGIT
¶


   An int-range is invalid if the
   last-pos value is present and less than the
   first-pos.¶


  
  
   A suffix-range is a range expressed as a suffix of the
   representation data with the provided non-negative integer maximum length
   (in range units). In other words, the last N units of the representation
   data.¶




  suffix-range  = ""-"" suffix-length
  suffix-length = 1*DIGIT
¶



  
   To provide for extensibility, the other-range rule is a
   mostly unconstrained grammar that allows application-specific or future
   range units to define additional range specifiers.¶



  other-range   = 1*( %x21-2B / %x2D-7E )
                ; 1*(VCHAR excluding comma)
¶


   A ranges-specifier is invalid if it contains any
   range-spec that is invalid or undefined for the indicated
   range-unit.¶


   A valid ranges-specifier is ""satisfiable""
   if it contains at least one range-spec that is
   satisfiable, as defined by the indicated range-unit.
   Otherwise, the ranges-specifier is
   ""unsatisfiable"".¶






14.1.2. Byte Ranges


   The ""bytes"" range unit is used to express subranges of a representation
   data's octet sequence.
   Each byte range is expressed as an integer range at some offset, relative
   to either the beginning (int-range) or end
   (suffix-range) of the representation data.
   Byte ranges do not use the other-range specifier.¶

   The first-pos value in a bytes int-range
   gives the offset of the first byte in a range.
   The last-pos value gives the offset of the last
   byte in the range; that is, the byte positions specified are inclusive.
   Byte offsets start at zero.¶

   If the representation data has a content coding applied, each byte range is
   calculated with respect to the encoded sequence of bytes, not the sequence
   of underlying bytes that would be obtained after decoding.¶

   Examples of bytes range specifiers:¶


The first 500 bytes (byte offsets 0-499, inclusive):¶

     bytes=0-499
¶



The second 500 bytes (byte offsets 500-999, inclusive):¶

     bytes=500-999
¶




   A client can limit the number of bytes requested without knowing the size
   of the selected representation.
   If the last-pos value is absent, or if the value is
   greater than or equal to the current length of the representation data, the
   byte range is interpreted as the remainder of the representation (i.e., the
   server replaces the value of last-pos with a value that
   is one less than the current length of the selected representation).¶

   A client can refer to the last N bytes (N > 0) of the selected
   representation using a suffix-range.
   If the selected representation is shorter than the specified
   suffix-length, the entire representation is used.¶

   Additional examples, assuming a representation of length 10000:¶


The final 500 bytes (byte offsets 9500-9999, inclusive):¶

     bytes=-500
¶

Or:¶

     bytes=9500-
¶



The first and last bytes only (bytes 0 and 9999):¶

     bytes=0-0,-1
¶



The first, middle, and last 1000 bytes:¶

     bytes= 0-999, 4500-5499, -1000
¶



Other valid (but not canonical) specifications of the second 500
      bytes (byte offsets 500-999, inclusive):¶

     bytes=500-600,601-999
     bytes=500-700,601-999
¶




   For a GET request, a valid bytes range-spec
   is satisfiable if it is either:¶

an int-range with a first-pos that
       is less than the current length of the selected representation 
       or¶

a suffix-range with a non-zero
       suffix-length.¶



   When a selected representation has zero length, the only
   satisfiable form of range-spec in a
   GET request is a suffix-range with a
   non-zero suffix-length.¶

   In the byte-range syntax, first-pos,
   last-pos, and suffix-length are
   expressed as decimal number of octets. Since there is no predefined limit
   to the length of content, recipients MUST anticipate potentially
   large decimal numerals and prevent parsing errors due to integer conversion
   overflows.¶







14.2. Range





   The ""Range"" header field on a GET request modifies the method semantics to
   request transfer of only one or more subranges of the
   selected representation data (Section 8.1),
   rather than the entire selected representation.¶


  Range = ranges-specifier
¶


   A server MAY ignore the Range header field. However, origin servers and
   intermediate caches ought to support byte ranges when possible, since they
   support efficient recovery from partially failed transfers and partial
   retrieval of large representations.¶

   A server MUST ignore a Range header field received with a request method
   that is unrecognized or for which range handling is not defined. For this
   specification, GET is the only method for which range handling
   is defined.¶

   An origin server MUST ignore a Range header field that contains a range
   unit it does not understand. A proxy MAY discard a Range header
   field that contains a range unit it does not understand.¶

   A server that supports range requests MAY ignore or reject a
   Range header field that contains an invalid
   ranges-specifier (Section 14.1.1),
   a ranges-specifier with more than two overlapping ranges,
   or a set of many small ranges that are not listed in ascending order,
   since these are indications of either a broken client or a deliberate
   denial-of-service attack (Section 17.15).
   A client SHOULD NOT request multiple ranges that are inherently less
   efficient to process and transfer than a single range that encompasses the
   same data.¶

   A server that supports range requests MAY ignore a Range
   header field when the selected representation has no content
   (i.e., the selected representation's data is of zero length).¶

   A client that is requesting multiple ranges SHOULD list those ranges in
   ascending order (the order in which they would typically be received in a
   complete representation) unless there is a specific need to request a later
   part earlier. For example, a user agent processing a large representation
   with an internal catalog of parts might need to request later parts first,
   particularly if the representation consists of pages stored in reverse
   order and the user agent wishes to transfer one page at a time.¶

   The Range header field is evaluated after evaluating the precondition header
   fields defined in Section 13.1, and only if the result in absence
   of the Range header field would be a 200 (OK) response. In
   other words, Range is ignored when a conditional GET would result in a
   304 (Not Modified) response.¶

   The If-Range header field (Section 13.1.5) can be used as
   a precondition to applying the Range header field.¶

   If all of the preconditions are true, the server supports the Range header
   field for the target resource, the received Range field-value contains a
   valid ranges-specifier with a range-unit
   supported for that target resource, and that
   ranges-specifier is satisfiable with respect
   to the selected representation,
   the server SHOULD send a 206 (Partial Content) response
   with content containing one or more partial representations
   that correspond to the satisfiable range-spec(s) requested.¶

   The above does not imply that a server will send all requested ranges.
   In some cases, it may only be possible (or efficient) to send a portion of
   the requested ranges first, while expecting the client to re-request the
   remaining portions later if they are still desired
   (see Section 15.3.7).¶

   If all of the preconditions are true, the server supports the Range header
   field for the target resource, the received Range field-value contains a
   valid ranges-specifier, and either the
   range-unit is not supported for that target resource or
   the ranges-specifier is unsatisfiable with respect to
   the selected representation, the server SHOULD send a
   416 (Range Not Satisfiable) response.¶





14.3. Accept-Ranges





   The ""Accept-Ranges"" field in a response indicates whether an upstream
   server supports range requests for the target resource.¶



  Accept-Ranges     = acceptable-ranges
  acceptable-ranges = 1#range-unit
¶


   For example, a server that supports
   byte-range requests (Section 14.1.2) can send the field¶

Accept-Ranges: bytes
¶


   to indicate that it supports byte range requests for that target resource,
   thereby encouraging its use by the client for future partial requests on
   the same request path.
   Range units are defined in Section 14.1.¶

   A client MAY generate range requests regardless of having received an
   Accept-Ranges field. The information only provides advice for the sake of
   improving performance and reducing unnecessary network transfers.¶

   Conversely, a client MUST NOT assume that receiving an Accept-Ranges field
   means that future range requests will return partial responses. The content might
   change, the server might only support range requests at certain times or under
   certain conditions, or a different intermediary might process the next request.¶

   A server that does not support any kind of range request for the target
   resource MAY send¶

Accept-Ranges: none
¶


   to advise the client not to attempt a range request on the same request path.
   The range unit ""none"" is reserved for this purpose.¶

   The Accept-Ranges field MAY be sent in a trailer section, but is preferred
   to be sent as a header field because the information is particularly useful
   for restarting large information transfers that have failed in mid-content
   (before the trailer section is received).¶





14.4. Content-Range





   The ""Content-Range"" header field is sent in a single part
   206 (Partial Content) response to indicate the partial range
   of the selected representation enclosed as the message content, sent in
   each part of a multipart 206 response to indicate the range enclosed within
   each body part (Section 14.6), and sent in 416 (Range Not Satisfiable)
   responses to provide information about the selected representation.¶








  Content-Range       = range-unit SP
                        ( range-resp / unsatisfied-range )

  range-resp          = incl-range ""/"" ( complete-length / ""*"" )
  incl-range          = first-pos ""-"" last-pos
  unsatisfied-range   = ""*/"" complete-length

  complete-length     = 1*DIGIT
¶


   If a 206 (Partial Content) response contains a
   Content-Range header field with a range unit
   (Section 14.1) that the recipient does not understand, the
   recipient MUST NOT attempt to recombine it with a stored representation.
   A proxy that receives such a message SHOULD forward it downstream.¶

   Content-Range might also be sent as a request modifier to request a
   partial PUT, as described in Section 14.5, based on private
   agreements between client and origin server.
   A server MUST ignore a Content-Range header field received in a request
   with a method for which Content-Range support is not defined.¶

   For byte ranges, a sender SHOULD indicate the complete length of the
   representation from which the range has been extracted, unless the complete
   length is unknown or difficult to determine. An asterisk character (""*"") in
   place of the complete-length indicates that the representation length was
   unknown when the header field was generated.¶

   The following example illustrates when the complete length of the selected
   representation is known by the sender to be 1234 bytes:¶

Content-Range: bytes 42-1233/1234
¶


   and this second example illustrates when the complete length is unknown:¶

Content-Range: bytes 42-1233/*
¶


   A Content-Range field value is invalid if it contains a
   range-resp that has a last-pos
   value less than its first-pos value, or a
   complete-length value less than or equal to its
   last-pos value. The recipient of an invalid
   Content-Range
MUST NOT attempt to recombine the received
   content with a stored representation.¶

   A server generating a 416 (Range Not Satisfiable) response
   to a byte-range request SHOULD send a Content-Range header field with an
   unsatisfied-range value, as in the following example:¶

Content-Range: bytes */1234
¶


   The complete-length in a 416 response indicates the current length of the
   selected representation.¶

   The Content-Range header field has no meaning for status codes that do
   not explicitly describe its semantic. For this specification, only the
   206 (Partial Content) and
   416 (Range Not Satisfiable) status codes describe a meaning
   for Content-Range.¶

   The following are examples of Content-Range values in which the
   selected representation contains a total of 1234 bytes:¶


The first 500 bytes:¶

Content-Range: bytes 0-499/1234
¶



The second 500 bytes:¶

Content-Range: bytes 500-999/1234
¶



All except for the first 500 bytes:¶

Content-Range: bytes 500-1233/1234
¶



The last 500 bytes:¶

Content-Range: bytes 734-1233/1234
¶








14.5. Partial PUT





   Some origin servers support PUT of a partial representation
   when the user agent sends a Content-Range header field
   (Section 14.4) in the request, though
   such support is inconsistent and depends on private agreements with
   user agents. In general, it requests that the state of the
   target resource be partly replaced with the enclosed content
   at an offset and length indicated by the Content-Range value, where the
   offset is relative to the current selected representation.¶

   An origin server SHOULD respond with a 400 (Bad Request)
   status code if it receives Content-Range on a PUT for a
   target resource that does not support partial PUT requests.¶

   Partial PUT is not backwards compatible with the original definition of PUT.
   It may result in the content being written as a complete replacement for the
   current representation.¶

   Partial resource updates are also possible by targeting a separately
   identified resource with state that overlaps or extends a portion of the
   larger resource, or by using a different method that has been specifically
   defined for partial updates (for example, the PATCH method defined in
   [RFC5789]).¶





14.6. Media Type multipart/byteranges




   When a 206 (Partial Content) response message includes the
   content of multiple ranges, they are transmitted as body parts in a
   multipart message body ([RFC2046], Section 5.1)
   with the media type of ""multipart/byteranges"".¶

   The ""multipart/byteranges"" media type includes one or more body parts, each
   with its own Content-Type and Content-Range
   fields. The required boundary parameter specifies the boundary string used
   to separate each body part.¶

  Implementation Notes:¶

Additional CRLFs might precede the first boundary string in the body.¶

Although [RFC2046] permits the boundary string to be
      quoted, some existing implementations handle a quoted boundary
      string incorrectly.¶

A number of clients and servers were coded to an early draft
      of the byteranges specification that used a media type of
      ""multipart/x-byteranges"",
      which is almost (but not quite) compatible with this type.¶



   Despite the name, the ""multipart/byteranges"" media type is not limited to
   byte ranges. The following example uses an ""exampleunit"" range unit:¶

HTTP/1.1 206 Partial Content
Date: Tue, 14 Nov 1995 06:25:24 GMT
Last-Modified: Tue, 14 July 04:58:08 GMT
Content-Length: 2331785
Content-Type: multipart/byteranges; boundary=THIS_STRING_SEPARATES

--THIS_STRING_SEPARATES
Content-Type: video/example
Content-Range: exampleunit 1.2-4.3/25

...the first range...
--THIS_STRING_SEPARATES
Content-Type: video/example
Content-Range: exampleunit 11.2-14.3/25

...the second range
--THIS_STRING_SEPARATES--
¶


  The following information serves as the registration form for the
  ""multipart/byteranges"" media type.¶

Type name:
multipart¶


Subtype name:
byteranges¶


Required parameters:
boundary¶


Optional parameters:
N/A¶


Encoding considerations:
only ""7bit"", ""8bit"", or ""binary"" are permitted¶


Security considerations:
see Section 17¶


Interoperability considerations:
N/A¶


Published specification:
RFC 9110 (see Section 14.6)¶


Applications that use this media type:
HTTP components supporting multiple ranges in a single request¶


Fragment identifier considerations:
N/A¶


Additional information:


Deprecated alias names for this type:
N/A¶


Magic number(s):
N/A¶


File extension(s):
N/A¶


Macintosh file type code(s):
N/A¶





Person and email address to contact for further information:
See Authors' Addresses section.¶


Intended usage:
COMMON¶


Restrictions on usage:
N/A¶


Author:
See Authors' Addresses section.¶


Change controller:
IESG¶










15. Status Codes



   The status code of a response is a three-digit integer code that describes
   the result of the request and the semantics of the response, including
   whether the request was successful and what content is enclosed (if any).
   All valid status codes are within the range of 100 to 599, inclusive.¶

   The first digit of the status code defines the class of response. The
   last two digits do not have any categorization role. There are five
   values for the first digit:¶


1xx (Informational): The request was received, continuing
    process¶


2xx (Successful): The request was successfully received,
    understood, and accepted¶


3xx (Redirection): Further action needs to be taken in order to
    complete the request¶


4xx (Client Error): The request contains bad syntax or cannot
    be fulfilled¶


5xx (Server Error): The server failed to fulfill an apparently
    valid request¶



   HTTP status codes are extensible. A client is not required to understand
   the meaning of all registered status codes, though such understanding is
   obviously desirable. However, a client MUST understand the class of any
   status code, as indicated by the first digit, and treat an unrecognized
   status code as being equivalent to the x00 status code of that class.¶

   For example, if a client receives an unrecognized status code of 471,
   it can see from the first digit that there was something wrong with its
   request and treat the response as if it had received a
   400 (Bad Request) status code. The response
   message will usually contain a representation that explains the status.¶

   Values outside the range 100..599 are invalid. Implementations often use
   three-digit integer values outside of that range (i.e., 600..999) for
   internal communication of non-HTTP status (e.g., library errors). A client
   that receives a response with an invalid status code SHOULD process the
   response as if it had a 5xx (Server Error) status code.¶





  A single request can have multiple associated responses: zero or more
  ""interim"" (non-final) responses with status codes in the
  ""informational"" (1xx) range, followed by exactly one
  ""final"" response with a status code in one of the other ranges.¶




15.1. Overview of Status Codes


   The status codes listed below are defined in this specification.
   The reason phrases listed here are only recommendations -- they can be
   replaced by local equivalents or left out altogether without affecting the
   protocol.¶

   Responses with status codes that are defined as heuristically cacheable
   (e.g., 200, 203, 204, 206, 300, 301, 308, 404, 405, 410, 414, and 501 in this
   specification) can be reused by a cache with heuristic expiration unless
   otherwise indicated by the method definition or explicit cache controls
   [CACHING]; all other status codes are not heuristically cacheable.¶

   Additional status codes, outside the scope of this specification, have been
   specified for use in HTTP. All such status codes ought to be registered
   within the ""Hypertext Transfer Protocol (HTTP) Status Code Registry"",
   as described in Section 16.2.¶





15.2. Informational 1xx




   The 1xx (Informational) class of status code indicates an
   interim response for communicating connection status or request progress
   prior to completing the requested action and sending a final response.
   Since HTTP/1.0 did not define any 1xx status codes, a server MUST NOT send
   a 1xx response to an HTTP/1.0 client.¶

   A 1xx response is terminated by the end of the header section;
   it cannot contain content or trailers.¶

   A client MUST be able to parse one or more 1xx responses received
   prior to a final response, even if the client does not expect one.
   A user agent MAY ignore unexpected 1xx responses.¶

   A proxy MUST forward 1xx responses unless the proxy itself
   requested the generation of the 1xx response. For example, if a
   proxy adds an ""Expect: 100-continue"" header field when it forwards a request,
   then it need not forward the corresponding 100 (Continue)
   response(s).¶



15.2.1. 100 Continue



   The 100 (Continue) status code indicates that the initial
   part of a request has been received and has not yet been rejected by the
   server. The server intends to send a final response after the request has
   been fully received and acted upon.¶

   When the request contains an Expect header field that
   includes a 100-continue expectation, the 100 response
   indicates that the server wishes to receive the request content,
   as described in Section 10.1.1.  The client
   ought to continue sending the request and discard the 100 response.¶

   If the request did not contain an Expect header field
   containing the 100-continue expectation,
   the client can simply discard this interim response.¶





15.2.2. 101 Switching Protocols



   The 101 (Switching Protocols) status code indicates that the
   server understands and is willing to comply with the client's request,
   via the Upgrade header field (Section 7.8), for
   a change in the application protocol being used on this connection.
   The server MUST generate an Upgrade header field in the response that
   indicates which protocol(s) will be in effect after this response.¶

   It is assumed that the server will only agree to switch protocols when
   it is advantageous to do so. For example, switching to a newer version of
   HTTP might be advantageous over older versions, and switching to a
   real-time, synchronous protocol might be advantageous when delivering
   resources that use such features.¶







15.3. Successful 2xx




   The 2xx (Successful) class of status code indicates that
   the client's request was successfully received, understood, and accepted.¶



15.3.1. 200 OK



   The 200 (OK) status code indicates that the request has
   succeeded. The content sent in a 200 response depends on the request
   method. For the methods defined by this specification, the intended meaning
   of the content can be summarized as:¶

Table 6


Request Method
Response content is a representation of:




GET
the target resource



HEAD
the target resource, like GET, but without
          transferring the representation data


POST
the status of, or results obtained from, the action


PUT, DELETE
the status of the action


OPTIONS
communication options for the target resource


TRACE
the request message as received by the server returning the
          trace




   Aside from responses to CONNECT, a 200 response is expected to contain
   message content unless the message framing explicitly indicates that the
   content has zero length. If some aspect of the request indicates a
   preference for no content upon success, the origin server ought to send a
   204 (No Content) response instead.
   For CONNECT, there is no content because the successful result is a
   tunnel, which begins immediately after the 200 response header section.¶

   A 200 response is heuristically cacheable; i.e., unless otherwise indicated by
   the method definition or explicit cache controls (see Section 4.2.2 of [CACHING]).¶

   In 200 responses to GET or HEAD, an origin server SHOULD send any
   available validator fields (Section 8.8) for the
   selected representation, with both a strong entity tag and
   a Last-Modified date being preferred.¶

   In 200 responses to state-changing methods, any validator fields
   (Section 8.8) sent in the response convey the
   current validators for the new representation formed as a result of
   successfully applying the request semantics. Note that the PUT method
   (Section 9.3.4) has additional requirements that might preclude
   sending such validators.¶





15.3.2. 201 Created



   The 201 (Created) status code indicates that the request has
   been fulfilled and has resulted in one or more new resources being created.
   The primary resource created by the request is identified by either a
   Location header field in the response or, if no
   Location header field is received, by the target URI.¶

   The 201 response content typically describes and links to the resource(s)
   created. Any validator fields (Section 8.8)
   sent in the response convey the current validators for a new
   representation created by the request. Note that the PUT method
   (Section 9.3.4) has additional requirements that might preclude
   sending such validators.¶





15.3.3. 202 Accepted



   The 202 (Accepted) status code indicates that the request
   has been accepted for processing, but the processing has not been
   completed. The request might or might not eventually be acted upon, as it
   might be disallowed when processing actually takes place. There is no
   facility in HTTP for re-sending a status code from an asynchronous
   operation.¶

   The 202 response is intentionally noncommittal. Its purpose is to
   allow a server to accept a request for some other process (perhaps a
   batch-oriented process that is only run once per day) without
   requiring that the user agent's connection to the server persist
   until the process is completed. The representation sent with this
   response ought to describe the request's current status and point to
   (or embed) a status monitor that can provide the user with an estimate of
   when the request will be fulfilled.¶





15.3.4. 203 Non-Authoritative Information



   The 203 (Non-Authoritative Information) status code
   indicates that the request was successful but the enclosed content has been
   modified from that of the origin server's 200 (OK) response
   by a transforming proxy (Section 7.7). This status code allows the
   proxy to notify recipients when a transformation has been applied, since
   that knowledge might impact later decisions regarding the content. For
   example, future cache validation requests for the content might only be
   applicable along the same request path (through the same proxies).¶

   A 203 response is heuristically cacheable; i.e., unless otherwise indicated by
   the method definition or explicit cache controls (see Section 4.2.2 of [CACHING]).¶





15.3.5. 204 No Content



   The 204 (No Content) status code indicates that the server
   has successfully fulfilled the request and that there is no additional
   content to send in the response content. Metadata in the response
   header fields refer to the target resource and its
   selected representation after the requested action was applied.¶

   For example, if a 204 status code is received in response to a PUT
   request and the response contains an ETag field, then
   the PUT was successful and the ETag field value contains the entity tag for
   the new representation of that target resource.¶

   The 204 response allows a server to indicate that the action has been
   successfully applied to the target resource, while implying that the
   user agent does not need to traverse away from its current ""document view""
   (if any).  The server assumes that the user agent will provide some
   indication of the success to its user, in accord with its own interface,
   and apply any new or updated metadata in the response to its active
   representation.¶

   For example, a 204 status code is commonly used with document editing
   interfaces corresponding to a ""save"" action, such that the document
   being saved remains available to the user for editing. It is also
   frequently used with interfaces that expect automated data transfers
   to be prevalent, such as within distributed version control systems.¶

   A 204 response is terminated by the end of the header section;
   it cannot contain content or trailers.¶

   A 204 response is heuristically cacheable; i.e., unless otherwise indicated by
   the method definition or explicit cache controls (see Section 4.2.2 of [CACHING]).¶





15.3.6. 205 Reset Content



   The 205 (Reset Content) status code indicates that the
   server has fulfilled the request and desires that the user agent reset the
   ""document view"", which caused the request to be sent, to its original state
   as received from the origin server.¶

   This response is intended to support a common data entry use case where
   the user receives content that supports data entry (a form, notepad,
   canvas, etc.), enters or manipulates data in that space, causes the entered
   data to be submitted in a request, and then the data entry mechanism is
   reset for the next entry so that the user can easily initiate another
   input action.¶

   Since the 205 status code implies that no additional content will be
   provided, a server MUST NOT generate content in a 205 response.¶





15.3.7. 206 Partial Content



   The 206 (Partial Content) status code indicates that the
   server is successfully fulfilling a range request for the target resource
   by transferring one or more parts of the
   selected representation.¶

   A server that supports range requests (Section 14) will
   usually attempt to satisfy all of the requested ranges, since sending
   less data will likely result in another client request for the remainder.
   However, a server might want to send only a subset of the data requested
   for reasons of its own, such as temporary unavailability, cache efficiency,
   load balancing, etc. Since a 206 response is self-descriptive, the client
   can still understand a response that only partially satisfies its range
   request.¶

   A client MUST inspect a 206 response's Content-Type and
   Content-Range field(s) to determine what parts are enclosed
   and whether additional requests are needed.¶

   A server that generates a 206 response MUST generate the following
   header fields, in addition to those required in the subsections below,
   if the field would
   have been sent in a 200 (OK) response to the same request:
   Date, Cache-Control, ETag,
   Expires, Content-Location, and
   Vary.¶

   A Content-Length header field present in a 206 response
   indicates the number of octets in the content of this message, which is
   usually not the complete length of the selected representation.
   Each Content-Range header field includes information about the
   selected representation's complete length.¶

   A sender that generates a 206 response to a request with an If-Range
   header field SHOULD NOT generate other representation header
   fields beyond those required because the client
   already has a prior response containing those header fields.
   Otherwise, a sender MUST generate all of the representation header
   fields that would have been sent in a 200 (OK) response
   to the same request.¶

   A 206 response is heuristically cacheable; i.e., unless otherwise indicated by
   explicit cache controls (see Section 4.2.2 of [CACHING]).¶



15.3.7.1. Single Part


   If a single part is being transferred, the server generating the 206
   response MUST generate a Content-Range header field,
   describing what range of the selected representation is enclosed, and a
   content consisting of the range. For example:¶

HTTP/1.1 206 Partial Content
Date: Wed, 15 Nov 1995 06:25:24 GMT
Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT
Content-Range: bytes 21010-47021/47022
Content-Length: 26012
Content-Type: image/gif

... 26012 bytes of partial image data ...
¶






15.3.7.2. Multiple Parts


   If multiple parts are being transferred, the server generating the 206
   response MUST generate ""multipart/byteranges"" content, as defined
   in Section 14.6, and a
   Content-Type header field containing the
   ""multipart/byteranges"" media type and its required boundary parameter.
   To avoid confusion with single-part responses, a server MUST NOT generate
   a Content-Range header field in the HTTP header section of a
   multiple part response (this field will be sent in each part instead).¶

   Within the header area of each body part in the multipart content, the
   server MUST generate a Content-Range header field
   corresponding to the range being enclosed in that body part.
   If the selected representation would have had a Content-Type
   header field in a 200 (OK) response, the server SHOULD
   generate that same Content-Type header field in the header area of
   each body part. For example:¶

HTTP/1.1 206 Partial Content
Date: Wed, 15 Nov 1995 06:25:24 GMT
Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT
Content-Length: 1741
Content-Type: multipart/byteranges; boundary=THIS_STRING_SEPARATES

--THIS_STRING_SEPARATES
Content-Type: application/pdf
Content-Range: bytes 500-999/8000

...the first range...
--THIS_STRING_SEPARATES
Content-Type: application/pdf
Content-Range: bytes 7000-7999/8000

...the second range
--THIS_STRING_SEPARATES--
¶


   When multiple ranges are requested, a server MAY coalesce any of the
   ranges that overlap, or that are separated by a gap that is smaller than the
   overhead of sending multiple parts, regardless of the order in which the
   corresponding range-spec appeared in the received Range
   header field. Since the typical overhead between each part of a
   ""multipart/byteranges"" is around 80 bytes, depending on the selected
   representation's media type and the chosen boundary parameter length, it
   can be less efficient to transfer many small disjoint parts than it is to
   transfer the entire selected representation.¶

   A server MUST NOT generate a multipart response to a request for a single
   range, since a client that does not request multiple parts might not
   support multipart responses. However, a server MAY generate a
   ""multipart/byteranges"" response with only a single body part if multiple
   ranges were requested and only one range was found to be satisfiable or
   only one range remained after coalescing.
   A client that cannot process a ""multipart/byteranges"" response MUST NOT
   generate a request that asks for multiple ranges.¶

   A server that generates a multipart response SHOULD send
   the parts in the same order that the corresponding range-spec appeared
   in the received Range header field, excluding those ranges
   that were deemed unsatisfiable or that were coalesced into other ranges.
   A client that receives a multipart response MUST inspect the
   Content-Range header field present in each body part in
   order to determine which range is contained in that body part; a client
   cannot rely on receiving the same ranges that it requested, nor the same
   order that it requested.¶





15.3.7.3. Combining Parts


   A response might transfer only a subrange of a representation if the
   connection closed prematurely or if the request used one or more Range
   specifications.  After several such transfers, a client might have
   received several ranges of the same representation.  These ranges can only
   be safely combined if they all have in common the same strong validator
   (Section 8.8.1).¶

   A client that has received multiple partial responses to GET requests on a
   target resource MAY combine those responses into a larger continuous
   range if they share the same strong validator.¶

   If the most recent response is an incomplete 200 (OK)
   response, then the header fields of that response are used for any
   combined response and replace those of the matching stored responses.¶

   If the most recent response is a 206 (Partial Content)
   response and at least one of the matching stored responses is a
   200 (OK), then the combined response header fields consist
   of the most recent 200 response's header fields. If all of the matching
   stored responses are 206 responses, then the stored response with the most
   recent header fields is used as the source of header fields for the
   combined response, except that the client MUST use other header fields
   provided in the new response, aside from Content-Range, to
   replace all instances of the corresponding header fields in the stored
   response.¶

   The combined response content consists of the union of partial content
   ranges within the new response and all of the matching stored responses.
   If the union consists of the entire range of the representation, then the
   client MUST process the combined response as if it were a complete
   200 (OK) response, including a Content-Length
   header field that reflects the complete length.
   Otherwise, the client MUST process the set of continuous ranges as one of
   the following:
   an incomplete 200 (OK) response if the combined response is
   a prefix of the representation,
   a single 206 (Partial Content) response containing
   ""multipart/byteranges"" content, or
   multiple 206 (Partial Content) responses, each with one
   continuous range that is indicated by a Content-Range header
   field.¶









15.4. Redirection 3xx




   The 3xx (Redirection) class of status code indicates that
   further action needs to be taken by the user agent in order to fulfill the
   request. There are several types of redirects:¶


    Redirects that indicate this resource might be available at a
    different URI, as provided by the Location header field,
    as in the status codes 301 (Moved Permanently),
    302 (Found), 307 (Temporary Redirect), and
    308 (Permanent Redirect).¶


    Redirection that offers a choice among matching resources capable
    of representing this resource, as in the
    300 (Multiple Choices) status code.¶


    Redirection to a different resource, identified by the
    Location header field, that can represent an indirect
    response to the request, as in the 303 (See Other)
    status code.¶


    Redirection to a previously stored result, as in the
    304 (Not Modified) status code.¶




Note: In HTTP/1.0, the status codes 301 (Moved Permanently)
    and 302 (Found) were originally defined as method-preserving
    ([HTTP/1.0], Section 9.3) to match their implementation
    at CERN; 303 (See Other) was defined for a redirection that
    changed its method to GET. However, early user agents split on whether to
    redirect POST requests as POST (according to then-current specification)
    or as GET (the safer alternative when redirected to a different site).
    Prevailing practice eventually converged on changing the method to GET.
    307 (Temporary Redirect) and
    308 (Permanent Redirect)
[RFC7538] were
    later added to unambiguously indicate method-preserving redirects, and status codes
    301 and 302 have been adjusted to allow a POST
    request to be redirected as GET.¶


   If a Location header field
   (Section 10.2.2) is provided, the user agent MAY
   automatically redirect its request to the URI referenced by the Location
   field value, even if the specific status code is not understood.
   Automatic redirection needs to be done with care for methods not known to be
   safe, as defined in Section 9.2.1, since
   the user might not wish to redirect an unsafe request.¶

   When automatically following a redirected request, the user agent SHOULD
   resend the original request message with the following modifications:¶



      Replace the target URI with the URI referenced by the redirection response's
      Location header field value after resolving it relative to the original
      request's target URI.¶



      Remove header fields that were automatically generated by the implementation,
      replacing them with updated values as appropriate to the new request. This
      includes:¶

Connection-specific header fields (see Section 7.6.1),¶

Header fields specific to the client's proxy configuration,
       including (but not limited to) Proxy-Authorization,¶

Origin-specific header fields (if any), including (but not
       limited to) Host,¶

Validating header fields that were added by the implementation's
       cache (e.g., If-None-Match,
       If-Modified-Since), and¶

Resource-specific header fields, including (but not limited to)
       Referer, Origin,
       Authorization, and Cookie.¶





      Consider removing header fields that were not automatically generated by the
      implementation (i.e., those present in the request because they were added
      by the calling context) where there are security implications; this
      includes but is not limited to Authorization and Cookie.¶



      Change the request method according to the redirecting status code's
      semantics, if applicable.¶



      If the request method has been changed to GET or HEAD, remove
      content-specific header fields, including (but not limited to)
      Content-Encoding,
      Content-Language, Content-Location,
      Content-Type, Content-Length,
      Digest, Last-Modified.¶



   A client SHOULD detect and intervene in cyclical redirections (i.e.,
   ""infinite"" redirection loops).¶


Note: An earlier version of this specification recommended a
    maximum of five redirections ([RFC2068], Section 10.3).
    Content developers need to be aware that some clients might
    implement such a fixed limitation.¶




15.4.1. 300 Multiple Choices



   The 300 (Multiple Choices) status code indicates that the
   target resource has more than one representation, each with
   its own more specific identifier, and information about the alternatives is
   being provided so that the user (or user agent) can select a preferred
   representation by redirecting its request to one or more of those
   identifiers. In other words, the server desires that the user agent engage
   in reactive negotiation to select the most appropriate representation(s)
   for its needs (Section 12).¶

   If the server has a preferred choice, the server SHOULD generate a
   Location header field containing a preferred choice's URI
   reference. The user agent MAY use the Location field value for automatic
   redirection.¶

   For request methods other than HEAD, the server SHOULD generate content
   in the 300 response containing a list of representation metadata and URI
   reference(s) from which the user or user agent can choose the one most
   preferred. The user agent MAY make a selection from that list
   automatically if it understands the provided media type. A specific format
   for automatic selection is not defined by this specification because HTTP
   tries to remain orthogonal to the definition of its content.
   In practice, the representation is provided in some easily parsed format
   believed to be acceptable to the user agent, as determined by shared design
   or content negotiation, or in some commonly accepted hypertext format.¶

   A 300 response is heuristically cacheable; i.e., unless otherwise indicated by
   the method definition or explicit cache controls (see Section 4.2.2 of [CACHING]).¶


Note: The original proposal for the 300 status code defined the URI header field as
   providing a list of alternative representations, such that it would be
   usable for 200, 300, and 406 responses and be transferred in responses to
   the HEAD method. However, lack of deployment and disagreement over syntax
   led to both URI and Alternates (a subsequent proposal) being dropped from
   this specification. It is possible to communicate the list as a
   Link header field value [RFC8288] whose members have a relationship of
   ""alternate"", though deployment is a chicken-and-egg problem.¶






15.4.2. 301 Moved Permanently



   The 301 (Moved Permanently) status code indicates that the
   target resource has been assigned a new permanent URI and
   any future references to this resource ought to use one of the enclosed
   URIs. The server is suggesting that a user agent with link-editing capability
   can permanently replace references to the target URI with one of the
   new references sent by the server. However, this suggestion is usually
   ignored unless the user agent is actively editing references
   (e.g., engaged in authoring content), the connection is secured, and
   the origin server is a trusted authority for the content being edited.¶

   The server SHOULD generate a Location header field in the
   response containing a preferred URI reference for the new permanent URI.
   The user agent MAY use the Location field value for automatic redirection.
   The server's response content usually contains a short hypertext note with
   a hyperlink to the new URI(s).¶


Note: For historical reasons, a user agent MAY change the
    request method from POST to GET for the subsequent request. If this
    behavior is undesired, the 308 (Permanent Redirect)
    status code can be used instead.¶


   A 301 response is heuristically cacheable; i.e., unless otherwise indicated by
   the method definition or explicit cache controls (see Section 4.2.2 of [CACHING]).¶





15.4.3. 302 Found



   The 302 (Found) status code indicates that the target
   resource resides temporarily under a different URI. Since the redirection
   might be altered on occasion, the client ought to continue to use the
   target URI for future requests.¶

   The server SHOULD generate a Location header field in the
   response containing a URI reference for the different URI.
   The user agent MAY use the Location field value for automatic redirection.
   The server's response content usually contains a short hypertext note with
   a hyperlink to the different URI(s).¶


Note: For historical reasons, a user agent MAY change the
    request method from POST to GET for the subsequent request. If this
    behavior is undesired, the 307 (Temporary Redirect)
    status code can be used instead.¶






15.4.4. 303 See Other



   The 303 (See Other) status code indicates that the server is
   redirecting the user agent to a different resource, as indicated by a URI
   in the Location header field, which is intended to provide
   an indirect response to the original request. A user agent can perform a
   retrieval request targeting that URI (a GET or HEAD request if using HTTP),
   which might also be redirected, and present the eventual result as an
   answer to the original request. Note that the new URI in the Location
   header field is not considered equivalent to the target URI.¶

   This status code is applicable to any HTTP method.  It is
   primarily used to allow the output of a POST action to redirect
   the user agent to a different resource, since doing so provides the
   information corresponding to the POST response as a resource that
   can be separately identified, bookmarked, and cached.¶

   A 303 response to a GET request indicates that the origin server does not
   have a representation of the target resource that can be
   transferred by the server over HTTP. However, the
   Location field value refers to a resource that is
   descriptive of the target resource, such that making a retrieval request
   on that other resource might result in a representation that is useful to
   recipients without implying that it represents the original target resource.
   Note that answers to the questions of what can be represented, what
   representations are adequate, and what might be a useful description are
   outside the scope of HTTP.¶

   Except for responses to a HEAD request, the representation of a 303
   response ought to contain a short hypertext note with a hyperlink to the
   same URI reference provided in the Location header field.¶





15.4.5. 304 Not Modified



   The 304 (Not Modified) status code indicates that a
   conditional GET or HEAD request has been
   received and would have resulted in a 200 (OK) response
   if it were not for the fact that the condition evaluated to false.
   In other words, there is no need for the server to transfer a
   representation of the target resource because the request indicates that
   the client, which made the request conditional, already has a valid
   representation; the server is therefore redirecting the client to make
   use of that stored representation as if it were the content of a
   200 (OK) response.¶

   The server generating a 304 response MUST generate any of the following
   header fields that would have been sent in a 200 (OK)
   response to the same request:¶


Content-Location, Date, ETag,
    and Vary¶


    Cache-Control and Expires (see
    [CACHING])¶



   Since the goal of a 304 response is to minimize information transfer
   when the recipient already has one or more cached representations,
   a sender SHOULD NOT generate representation metadata other
   than the above listed fields unless said metadata exists for the
   purpose of guiding cache updates (e.g., Last-Modified might
   be useful if the response does not have an ETag field).¶

   Requirements on a cache that receives a 304 response are defined in
   Section 4.3.4 of [CACHING]. If the conditional request originated with an
   outbound client, such as a user agent with its own cache sending a
   conditional GET to a shared proxy, then the proxy SHOULD forward the
   304 response to that client.¶

   A 304 response is terminated by the end of the header section;
   it cannot contain content or trailers.¶





15.4.6. 305 Use Proxy



   The 305 (Use Proxy) status code was defined in a previous
   version of this specification and is now deprecated (Appendix B of [RFC7231]).¶





15.4.7. 306 (Unused)



   The 306 status code was defined in a previous version of this
   specification, is no longer used, and the code is reserved.¶





15.4.8. 307 Temporary Redirect



   The 307 (Temporary Redirect) status code indicates that the
   target resource resides temporarily under a different URI
   and the user agent MUST NOT change the request method if it performs an
   automatic redirection to that URI.
   Since the redirection can change over time, the client ought to continue
   using the original target URI for future requests.¶

   The server SHOULD generate a Location header field in the
   response containing a URI reference for the different URI.
   The user agent MAY use the Location field value for automatic redirection.
   The server's response content usually contains a short hypertext note with
   a hyperlink to the different URI(s).¶





15.4.9. 308 Permanent Redirect



   The 308 (Permanent Redirect) status code indicates that the
   target resource has been assigned a new permanent URI and
   any future references to this resource ought to use one of the enclosed
   URIs. The server is suggesting that a user agent with link-editing capability
   can permanently replace references to the target URI with one of the
   new references sent by the server. However, this suggestion is usually
   ignored unless the user agent is actively editing references
   (e.g., engaged in authoring content), the connection is secured, and
   the origin server is a trusted authority for the content being edited.¶

   The server SHOULD generate a Location header field in the
   response containing a preferred URI reference for the new permanent URI.
   The user agent MAY use the Location field value for automatic redirection.
   The server's response content usually contains a short hypertext note with
   a hyperlink to the new URI(s).¶

   A 308 response is heuristically cacheable; i.e., unless otherwise indicated by
   the method definition or explicit cache controls (see Section 4.2.2 of [CACHING]).¶


Note: This status code is much younger (June 2014) than its sibling codes and thus
    might not be recognized everywhere. See Section 4 of [RFC7538]
    for deployment considerations.¶








15.5. Client Error 4xx




   The 4xx (Client Error) class of status code indicates that
   the client seems to have erred. Except when responding to a HEAD request,
   the server SHOULD send a representation containing an explanation of
   the error situation, and whether it is a temporary or permanent condition.
   These status codes are applicable to any request method. User agents
   SHOULD display any included representation to the user.¶



15.5.1. 400 Bad Request



   The 400 (Bad Request) status code indicates that the server
   cannot or will not process the request due to something that is perceived
   to be a client error (e.g., malformed request syntax, invalid request
   message framing, or deceptive request routing).¶





15.5.2. 401 Unauthorized



   The 401 (Unauthorized) status code indicates that the
   request has not been applied because it lacks valid authentication
   credentials for the target resource.
   The server generating a 401 response MUST send a
   WWW-Authenticate header field
   (Section 11.6.1)
   containing at least one challenge applicable to the target resource.¶

   If the request included authentication credentials, then the 401 response
   indicates that authorization has been refused for those credentials.
   The user agent MAY repeat the request with a new or replaced
   Authorization header field (Section 11.6.2).
   If the 401 response contains the same challenge as the prior response, and
   the user agent has already attempted authentication at least once, then the
   user agent SHOULD present the enclosed representation to the user, since
   it usually contains relevant diagnostic information.¶





15.5.3. 402 Payment Required



   The 402 (Payment Required) status code is reserved for
   future use.¶





15.5.4. 403 Forbidden



   The 403 (Forbidden) status code indicates that the
   server understood the request but refuses to fulfill it.
   A server that wishes to make public why the request has been forbidden
   can describe that reason in the response content (if any).¶

   If authentication credentials were provided in the request, the
   server considers them insufficient to grant access.
   The client SHOULD NOT automatically repeat the request with the same
   credentials.
   The client MAY repeat the request with new or different credentials.
   However, a request might be forbidden for reasons unrelated to the
   credentials.¶

   An origin server that wishes to ""hide"" the current existence of a forbidden
   target resource
MAY instead respond with a status
   code of 404 (Not Found).¶





15.5.5. 404 Not Found



   The 404 (Not Found) status code indicates that the origin
   server did not find a current representation for the
   target resource or is not willing to disclose that one
   exists. A 404 status code does not indicate whether this lack of representation
   is temporary or permanent; the 410 (Gone) status code is
   preferred over 404 if the origin server knows, presumably through some
   configurable means, that the condition is likely to be permanent.¶

   A 404 response is heuristically cacheable; i.e., unless otherwise indicated by
   the method definition or explicit cache controls (see Section 4.2.2 of [CACHING]).¶





15.5.6. 405 Method Not Allowed



   The 405 (Method Not Allowed) status code indicates that the
   method received in the request-line is known by the origin server but
   not supported by the target resource.
   The origin server MUST generate an Allow header field in
   a 405 response containing a list of the target resource's currently
   supported methods.¶

   A 405 response is heuristically cacheable; i.e., unless otherwise indicated by
   the method definition or explicit cache controls (see Section 4.2.2 of [CACHING]).¶





15.5.7. 406 Not Acceptable



   The 406 (Not Acceptable) status code indicates that the
   target resource does not have a current representation that
   would be acceptable to the user agent, according to the
   proactive negotiation header fields received in the request
   (Section 12.1), and the server is unwilling to supply a
   default representation.¶

   The server SHOULD generate content containing a list of available
   representation characteristics and corresponding resource identifiers from
   which the user or user agent can choose the one most appropriate.
   A user agent MAY automatically select the most appropriate choice from
   that list. However, this specification does not define any standard for
   such automatic selection, as described in Section 15.4.1.¶





15.5.8. 407 Proxy Authentication Required



   The 407 (Proxy Authentication Required) status code is
   similar to 401 (Unauthorized), but it indicates that the client
   needs to authenticate itself in order to use a proxy for this request.
   The proxy MUST send a Proxy-Authenticate header field
   (Section 11.7.1) containing a challenge
   applicable to that proxy for the request. The client MAY repeat
   the request with a new or replaced Proxy-Authorization
   header field (Section 11.7.2).¶





15.5.9. 408 Request Timeout



   The 408 (Request Timeout) status code indicates
   that the server did not receive a complete request message within the time
   that it was prepared to wait.¶

   If the client has an outstanding request in transit, it MAY repeat that
   request. If the current connection is not usable (e.g., as it would be in
   HTTP/1.1 because request delimitation is lost), a new connection will be
   used.¶





15.5.10. 409 Conflict



   The 409 (Conflict) status code indicates that the request
   could not be completed due to a conflict with the current state of the target
   resource. This code is used in situations where the user might be able to
   resolve the conflict and resubmit the request. The server SHOULD generate
   content that includes enough information for a user to recognize the
   source of the conflict.¶

   Conflicts are most likely to occur in response to a PUT request. For
   example, if versioning were being used and the representation being PUT
   included changes to a resource that conflict with those made by an
   earlier (third-party) request, the origin server might use a 409 response
   to indicate that it can't complete the request. In this case, the response
   representation would likely contain information useful for merging the
   differences based on the revision history.¶





15.5.11. 410 Gone



   The 410 (Gone) status code indicates that access to the
   target resource is no longer available at the origin
   server and that this condition is likely to be permanent. If the origin
   server does not know, or has no facility to determine, whether or not the
   condition is permanent, the status code 404 (Not Found)
   ought to be used instead.¶

   The 410 response is primarily intended to assist the task of web
   maintenance by notifying the recipient that the resource is
   intentionally unavailable and that the server owners desire that
   remote links to that resource be removed. Such an event is common for
   limited-time, promotional services and for resources belonging to
   individuals no longer associated with the origin server's site. It is not
   necessary to mark all permanently unavailable resources as ""gone"" or
   to keep the mark for any length of time -- that is left to the
   discretion of the server owner.¶

   A 410 response is heuristically cacheable; i.e., unless otherwise indicated by
   the method definition or explicit cache controls (see Section 4.2.2 of [CACHING]).¶





15.5.12. 411 Length Required



   The 411 (Length Required) status code indicates that the
   server refuses to accept the request without a defined
   Content-Length (Section 8.6).
   The client MAY repeat the request if it adds a valid Content-Length
   header field containing the length of the request content.¶





15.5.13. 412 Precondition Failed



   The 412 (Precondition Failed) status code indicates that one
   or more conditions given in the request header fields evaluated to false
   when tested on the server (Section 13). This
   response status code allows the client to place preconditions on the
   current resource state (its current representations and metadata) and,
   thus, prevent the request method from being applied if the target resource
   is in an unexpected state.¶





15.5.14. 413 Content Too Large



   The 413 (Content Too Large) status code indicates
   that the server is refusing to process a request because the request
   content is larger than the server is willing or able to process.
   The server MAY terminate the request, if the protocol version in use
   allows it; otherwise, the server MAY close the connection.¶

   If the condition is temporary, the server SHOULD generate a
   Retry-After header field to indicate that it is temporary
   and after what time the client MAY try again.¶





15.5.15. 414 URI Too Long



   The 414 (URI Too Long) status code indicates that the server
   is refusing to service the request because the
   target URI is longer than the server is willing to
   interpret. This rare condition is only likely to occur when a client has
   improperly converted a POST request to a GET request with long query
   information, when the client has descended into an infinite loop of
   redirection (e.g., a redirected URI prefix that points to a suffix of
   itself) or when the server is under attack by a client attempting to
   exploit potential security holes.¶

   A 414 response is heuristically cacheable; i.e., unless otherwise indicated by
   the method definition or explicit cache controls (see Section 4.2.2 of [CACHING]).¶





15.5.16. 415 Unsupported Media Type



   The 415 (Unsupported Media Type) status code indicates that
   the origin server is refusing to service the request because the content is
   in a format not supported by this method on the target resource.¶

   The format problem might be due to the request's indicated
   Content-Type or Content-Encoding, or as a
   result of inspecting the data directly.¶

   If the problem was caused by an unsupported content coding, the
   Accept-Encoding response header field
   (Section 12.5.3) ought to be
   used to indicate which (if any) content codings would have been accepted
   in the request.¶

   On the other hand, if the cause was an unsupported media type, the
   Accept response header field (Section 12.5.1)
   can be used to indicate which media types would have been accepted
   in the request.¶





15.5.17. 416 Range Not Satisfiable



   The 416 (Range Not Satisfiable) status code indicates that
   the set of ranges in the request's Range header field
   (Section 14.2) has been rejected either because none of
   the requested ranges are satisfiable or because the client has requested
   an excessive number of small or overlapping ranges (a potential denial of
   service attack).¶

   Each range unit defines what is required for its own range sets to be
   satisfiable. For example, Section 14.1.2 defines what makes
   a bytes range set satisfiable.¶

   A server that generates a 416 response to a byte-range request SHOULD
   generate a Content-Range header field
   specifying the current length of the selected representation
   (Section 14.4).¶

   For example:¶

HTTP/1.1 416 Range Not Satisfiable
Date: Fri, 20 Jan 2012 15:41:54 GMT
Content-Range: bytes */47022
¶



Note: Because servers are free to ignore Range, many
    implementations will respond with the entire selected representation
    in a 200 (OK) response. That is partly because
    most clients are prepared to receive a 200 (OK) to
    complete the task (albeit less efficiently) and partly because clients
    might not stop making an invalid range request until they have received
    a complete representation. Thus, clients cannot depend on receiving a
    416 (Range Not Satisfiable) response even when it is most
    appropriate.¶






15.5.18. 417 Expectation Failed



   The 417 (Expectation Failed) status code indicates that the
   expectation given in the request's Expect header field
   (Section 10.1.1) could not be met by at least one of the
   inbound servers.¶





15.5.19. 418 (Unused)



[RFC2324] was an April 1 RFC that lampooned the various ways
   HTTP was abused; one such abuse was the definition of an
   application-specific 418 status code, which has been deployed as a joke
   often enough for the code to be unusable for any future use.¶

   Therefore, the 418 status code is reserved in the IANA HTTP Status Code
   Registry. This indicates that the status code cannot be assigned to other
   applications currently. If future circumstances require its use (e.g.,
   exhaustion of 4NN status codes), it can be re-assigned to another use.¶





15.5.20. 421 Misdirected Request



   The 421 (Misdirected Request) status code indicates that the request was
   directed at a server that is unable or unwilling to produce an
   authoritative response for the target URI. An origin server (or gateway
   acting on behalf of the origin server) sends 421 to reject a target URI
   that does not match an origin for which the server has been
   configured (Section 4.3.1) or does not match the connection
   context over which the request was received
   (Section 7.4).¶

   A client that receives a 421 (Misdirected Request) response MAY retry the
   request, whether or not the request method is idempotent, over a different
   connection, such as a fresh connection specific to the target resource's
   origin, or via an alternative service [ALTSVC].¶

   A proxy MUST NOT generate a 421 response.¶





15.5.21. 422 Unprocessable Content



   The 422 (Unprocessable Content) status code indicates that the server
   understands the content type of the request content (hence a
   415 (Unsupported Media Type) status code is inappropriate),
   and the syntax of the request content is correct, but it was unable to process
   the contained instructions. For example, this status code can be sent if
   an XML request content contains well-formed (i.e., syntactically correct), but
   semantically erroneous XML instructions.¶





15.5.22. 426 Upgrade Required



   The 426 (Upgrade Required) status code indicates that the
   server refuses to perform the request using the current protocol but might
   be willing to do so after the client upgrades to a different protocol.
   The server MUST send an Upgrade header field in a 426
   response to indicate the required protocol(s) (Section 7.8).¶

   Example:¶

HTTP/1.1 426 Upgrade Required
Upgrade: HTTP/3.0
Connection: Upgrade
Content-Length: 53
Content-Type: text/plain

This service requires use of the HTTP/3.0 protocol.
¶








15.6. Server Error 5xx




   The 5xx (Server Error) class of status code indicates that
   the server is aware that it has erred or is incapable of performing the
   requested method.
   Except when responding to a HEAD request, the server SHOULD send a
   representation containing an explanation of the error situation, and
   whether it is a temporary or permanent condition.
   A user agent SHOULD display any included representation to the user.
   These status codes are applicable to any request method.¶



15.6.1. 500 Internal Server Error



   The 500 (Internal Server Error) status code indicates that
   the server encountered an unexpected condition that prevented it from
   fulfilling the request.¶





15.6.2. 501 Not Implemented



   The 501 (Not Implemented) status code indicates that the
   server does not support the functionality required to fulfill the request.
   This is the appropriate response when the server does not recognize the
   request method and is not capable of supporting it for any resource.¶

   A 501 response is heuristically cacheable; i.e., unless otherwise indicated by
   the method definition or explicit cache controls (see Section 4.2.2 of [CACHING]).¶





15.6.3. 502 Bad Gateway



   The 502 (Bad Gateway) status code indicates that the server,
   while acting as a gateway or proxy, received an invalid response from an
   inbound server it accessed while attempting to fulfill the request.¶





15.6.4. 503 Service Unavailable



   The 503 (Service Unavailable) status code indicates that the
   server is currently unable to handle the request due to a temporary overload
   or scheduled maintenance, which will likely be alleviated after some delay.
   The server MAY send a Retry-After header field
   (Section 10.2.3) to suggest an appropriate
   amount of time for the client to wait before retrying the request.¶


Note: The existence of the 503 status code does not imply that a
    server has to use it when becoming overloaded. Some servers might
    simply refuse the connection.¶






15.6.5. 504 Gateway Timeout



   The 504 (Gateway Timeout) status code indicates that the
   server, while acting as a gateway or proxy, did not receive a timely
   response from an upstream server it needed to access in order to
   complete the request.¶





15.6.6. 505 HTTP Version Not Supported



   The 505 (HTTP Version Not Supported) status code indicates
   that the server does not support, or refuses to support, the major version
   of HTTP that was used in the request message. The server is indicating that
   it is unable or unwilling to complete the request using the same major
   version as the client, as described in Section 2.5, other than with this
   error message. The server SHOULD generate a representation for the 505
   response that describes why that version is not supported and what other
   protocols are supported by that server.¶









16. Extending HTTP


   HTTP defines a number of generic extension points that can be used to
   introduce capabilities to the protocol without introducing a new version,
   including methods, status codes, field names, and further extensibility
   points within defined fields, such as authentication schemes and
   cache directives (see Cache-Control extensions in Section 5.2.3 of [CACHING]). Because the semantics of HTTP are
   not versioned, these extension points are persistent; the version of the
   protocol in use does not affect their semantics.¶

   Version-independent extensions are discouraged from depending on or
   interacting with the specific version of the protocol in use. When this is
   unavoidable, careful consideration needs to be given to how the extension
   can interoperate across versions.¶

   Additionally, specific versions of HTTP might have their own extensibility
   points, such as transfer codings in HTTP/1.1 (Section 6.1 of [HTTP/1.1]) and HTTP/2 SETTINGS or frame types
   ([HTTP/2]). These extension points are specific to the
   version of the protocol they occur within.¶

   Version-specific extensions cannot override or modify the semantics of
   a version-independent mechanism or extension point (like a method or
   header field) without explicitly being allowed by that protocol element. For
   example, the CONNECT method (Section 9.3.6) allows this.¶

   These guidelines assure that the protocol operates correctly and
   predictably, even when parts of the path implement different versions of
   HTTP.¶



16.1. Method Extensibility




16.1.1. Method Registry


  The ""Hypertext Transfer Protocol (HTTP) Method Registry"", maintained by
  IANA at <https://www.iana.org/assignments/http-methods>,
  registers method names.¶

  HTTP method registrations MUST include the following fields:¶

Method Name (see Section 9)¶

Safe (""yes"" or ""no"", see Section 9.2.1)¶

Idempotent (""yes"" or ""no"", see Section 9.2.2)¶

Pointer to specification text¶



  Values to be added to this namespace require IETF Review
  (see [RFC8126], Section 4.8).¶





16.1.2. Considerations for New Methods


   Standardized methods are generic; that is, they are potentially
   applicable to any resource, not just one particular media type, kind of
   resource, or application. As such, it is preferred that new methods
   be registered in a document that isn't specific to a single application or
   data format, since orthogonal technologies deserve orthogonal specification.¶

   Since message parsing (Section 6) needs to be
   independent of method
   semantics (aside from responses to HEAD), definitions of new methods
   cannot change the parsing algorithm or prohibit the presence of content
   on either the request or the response message.
   Definitions of new methods can specify that only a zero-length content
   is allowed by requiring a Content-Length header field with a value of ""0"".¶

   Likewise, new methods cannot use the special host:port and asterisk forms of
   request target that are allowed for CONNECT and
   OPTIONS, respectively (Section 7.1).
   A full URI in absolute form is needed for the target URI, which means either
   the request target needs to be sent in absolute form or the target URI will
   be reconstructed from the request context in the same way it is for other
   methods.¶

   A new method definition needs to indicate whether it is safe (Section 9.2.1), idempotent (Section 9.2.2),
   cacheable (Section 9.2.3), what
   semantics are to be associated with the request content (if any), and what
   refinements the method makes to header field or status code semantics.
   If the new method is cacheable, its definition ought to describe how, and
   under what conditions, a cache can store a response and use it to satisfy a
   subsequent request.
   The new method ought to describe whether it can be made conditional
   (Section 13.1) and, if so, how a server responds
   when the condition is false.
   Likewise, if the new method might have some use for partial response
   semantics (Section 14.2), it ought to document this, too.¶


Note: Avoid defining a method name that starts with ""M-"", since that
    prefix might be misinterpreted as having the semantics assigned to it
    by [RFC2774].¶








16.2. Status Code Extensibility




16.2.1. Status Code Registry


   The ""Hypertext Transfer Protocol (HTTP) Status Code Registry"", maintained
   by IANA at <https://www.iana.org/assignments/http-status-codes>,
   registers status code numbers.¶

   A registration MUST include the following fields:¶

Status Code (3 digits)¶

Short Description¶

Pointer to specification text¶



   Values to be added to the HTTP status code namespace require IETF Review
   (see [RFC8126], Section 4.8).¶





16.2.2. Considerations for New Status Codes


   When it is necessary to express semantics for a response that are not
   defined by current status codes, a new status code can be registered.
   Status codes are generic; they are potentially applicable to any resource,
   not just one particular media type, kind of resource, or application of
   HTTP. As such, it is preferred that new status codes be registered in a
   document that isn't specific to a single application.¶

   New status codes are required to fall under one of the categories
   defined in Section 15. To allow existing parsers to
   process the response message, new status codes cannot disallow content,
   although they can mandate a zero-length content.¶

   Proposals for new status codes that are not yet widely deployed ought to
   avoid allocating a specific number for the code until there is clear
   consensus that it will be registered; instead, early drafts can use a
   notation such as ""4NN"", or ""3N0"" .. ""3N9"", to indicate the class
   of the proposed status code(s) without consuming a number prematurely.¶

   The definition of a new status code ought to explain the request
   conditions that would cause a response containing that status code (e.g.,
   combinations of request header fields and/or method(s)) along with any
   dependencies on response header fields (e.g., what fields are required,
   what fields can modify the semantics, and what field semantics are
   further refined when used with the new status code).¶

   By default, a status code applies only to the request corresponding to the
   response it occurs within. If a status code applies to a larger scope of
   applicability -- for example, all requests to the resource in question or
   all requests to a server -- this must be explicitly specified. When doing
   so, it should be noted that not all clients can be expected to
   consistently apply a larger scope because they might not understand the
   new status code.¶

   The definition of a new final status code ought to specify whether or not it
   is heuristically cacheable. Note that any response with a final status code
   can be cached if the response has explicit freshness information. A status
   code defined as heuristically cacheable is allowed to be cached without
   explicit freshness information.
   Likewise, the definition of a status code can place
   constraints upon cache behavior if the must-understand cache
   directive is used. See [CACHING] for more information.¶

   Finally, the definition of a new status code ought to indicate whether the
   content has any implied association with an identified resource (Section 6.4.2).¶







16.3. Field Extensibility


  HTTP's most widely used extensibility point is the definition of new header and
  trailer fields.¶

  New fields can be defined such that, when they are understood by a
  recipient, they override or enhance the interpretation of previously
  defined fields, define preconditions on request evaluation, or
  refine the meaning of responses.¶

   However, defining a field doesn't guarantee its deployment or recognition
   by recipients. Most fields are designed with the expectation that a recipient
   can safely ignore (but forward downstream) any field not recognized.
   In other cases, the sender's ability to understand a given field might be
   indicated by its prior communication, perhaps in the protocol version
   or fields that it sent in prior messages, or its use of a specific media type.
   Likewise, direct inspection of support might be possible through an
   OPTIONS request or by interacting with a defined well-known URI
   [RFC8615] if such inspection is defined along with
   the field being introduced.¶



16.3.1. Field Name Registry


   The ""Hypertext Transfer Protocol (HTTP) Field Name Registry"" defines the
   namespace for HTTP field names.¶

   Any party can request registration of an HTTP field. See Section 16.3.2 for considerations to take
   into account when creating a new HTTP field.¶

   The ""Hypertext Transfer Protocol (HTTP) Field Name Registry"" is located at
   <https://www.iana.org/assignments/http-fields/>.
   Registration requests can be made by following the instructions located
   there or by sending an email to the ""ietf-http-wg@w3.org"" mailing list.¶

   Field names are registered on the advice of a designated expert
   (appointed by the IESG or their delegate). Fields with the status
   'permanent' are Specification Required
   ([RFC8126], Section 4.6).¶

   Registration requests consist of the following information:¶

Field name:

    The requested field name. It MUST conform to the
    field-name syntax defined in Section 5.1, and it SHOULD be
    restricted to just letters, digits, and hyphen ('-')
    characters, with the first character being a letter.¶


Status:

    ""permanent"", ""provisional"", ""deprecated"", or ""obsoleted"".¶


Specification document(s):

    Reference to the document that specifies
    the field, preferably including a URI that can be used to retrieve
    a copy of the document. Optional but encouraged for provisional registrations.
    An indication of the relevant section(s) can also be included, but is not required.¶




   And optionally:¶

Comments:

    Additional information, such as about reserved entries.¶




   The expert(s) can define additional fields to be collected in the
   registry, in consultation with the community.¶

   Standards-defined names have a status of ""permanent"". Other names can also
   be registered as permanent if the expert(s) finds that they are in use, in
   consultation with the community. Other names should be registered as
   ""provisional"".¶

   Provisional entries can be removed by the expert(s) if -- in consultation
   with the community -- the expert(s) find that they are not in use. The
   expert(s) can change a provisional entry's status to permanent at any time.¶

   Note that names can be registered by third parties (including the
   expert(s)) if the expert(s) determines that an unregistered name is widely
   deployed and not likely to be registered in a timely manner otherwise.¶





16.3.2. Considerations for New Fields


   HTTP header and trailer fields are a widely used extension point for the protocol.
   While they can be used in an ad hoc fashion, fields that are intended for
   wider use need to be carefully documented to ensure interoperability.¶

   In particular, authors of specifications defining new fields are advised to consider
   and, where appropriate, document the following aspects:¶

Under what conditions the field can be used; e.g., only in
     responses or requests, in all messages, only on responses to a
     particular request method, etc.¶

Whether the field semantics are further refined by their context,
     such as their use with certain request methods or status codes.¶

The scope of applicability for the information conveyed.
     By default, fields apply only to the message they are
     associated with, but some response fields are designed to apply to all
     representations of a resource, the resource itself, or an even broader
     scope. Specifications that expand the scope of a response field will
     need to carefully consider issues such as content negotiation, the time
     period of applicability, and (in some cases) multi-tenant server
     deployments.¶

Under what conditions intermediaries are allowed to insert,
     delete, or modify the field's value.¶

If the field is allowable in trailers; by
     default, it will not be (see Section 6.5.1).¶

Whether it is appropriate or even required to list the field name in the
     Connection header field (i.e., if the field is to
     be hop-by-hop; see Section 7.6.1).¶

Whether the field introduces any additional security considerations, such
     as disclosure of privacy-related data.¶



   Request header fields have additional considerations that need to be documented
   if the default behavior is not appropriate:¶

If it is appropriate to list the field name in a
     Vary response header field (e.g., when the request header
     field is used by an origin server's content selection algorithm; see
     Section 12.5.5).¶

If the field is intended to be stored when received in a PUT
   request (see Section 9.3.4).¶

If the field ought to be removed when automatically redirecting a
   request due to security concerns (see Section 15.4).¶





16.3.2.1. Considerations for New Field Names


   Authors of specifications defining new fields are advised to choose a short
   but descriptive field name. Short names avoid needless data transmission;
   descriptive names avoid confusion and ""squatting"" on names that might have
   broader uses.¶

   To that end, limited-use fields (such as a header confined to a single
   application or use case) are encouraged to use a name that includes that use
   (or an abbreviation) as a prefix; for example, if the Foo Application needs
   a Description field, it might use ""Foo-Desc""; ""Description"" is too generic,
   and ""Foo-Description"" is needlessly long.¶

   While the field-name syntax is defined to allow any token character, in
   practice some implementations place limits on the characters they accept
   in field-names. To be interoperable, new field names SHOULD constrain
   themselves to alphanumeric characters, ""-"", and ""."", and SHOULD
   begin with a letter. For example, the underscore
   (""_"") character can be problematic when passed through non-HTTP
   gateway interfaces (see Section 17.10).¶

   Field names ought not be prefixed with ""X-""; see
   [BCP178] for further information.¶

   Other prefixes are sometimes used in HTTP field names; for example,
   ""Accept-"" is used in many content negotiation headers, and ""Content-"" is used
   as explained in Section 6.4. These prefixes are
   only an aid to recognizing the purpose of a field and do not
   trigger automatic processing.¶





16.3.2.2. Considerations for New Field Values


   A major task in the definition of a new HTTP field is the specification of
   the field value syntax: what senders should generate, and how recipients
   should infer semantics from what is received.¶

   Authors are encouraged (but not required) to use either the ABNF rules in
   this specification or those in [RFC8941] to define the syntax
   of new field values.¶

   Authors are advised to carefully consider how the combination of multiple
   field lines will impact them (see Section 5.3). Because
   senders might erroneously send multiple values, and both intermediaries
   and HTTP libraries can perform combination automatically, this applies to
   all field values -- even when only a single value is anticipated.¶

   Therefore, authors are advised to delimit or encode values that contain
   commas (e.g., with the quoted-string rule of
   Section 5.6.4, the String data type of
   [RFC8941], or a field-specific encoding).
   This ensures that commas within field data are not confused
   with the commas that delimit a list value.¶

   For example, the Content-Type field value only allows commas
   inside quoted strings, which can be reliably parsed even when multiple
   values are present. The Location field value provides a
   counter-example that should not be emulated: because URIs can include
   commas, it is not possible to reliably distinguish between a single value
   that includes a comma from two values.¶

   Authors of fields with a singleton value (see Section 5.5) are additionally advised to document how to treat
   messages where the multiple members are present (a sensible default would
   be to ignore the field, but this might not always be the right choice).¶









16.4. Authentication Scheme Extensibility




16.4.1. Authentication Scheme Registry


   The ""Hypertext Transfer Protocol (HTTP) Authentication Scheme Registry""
   defines the namespace for the authentication schemes in challenges and
   credentials. It is maintained
   at <https://www.iana.org/assignments/http-authschemes>.¶

  Registrations MUST include the following fields:¶

Authentication Scheme Name¶

Pointer to specification text¶

Notes (optional)¶



  Values to be added to this namespace require IETF Review
  (see [RFC8126], Section 4.8).¶





16.4.2. Considerations for New Authentication Schemes


  There are certain aspects of the HTTP Authentication framework that put
  constraints on how new authentication schemes can work:¶



    HTTP authentication is presumed to be stateless: all of the information
    necessary to authenticate a request MUST be provided in the request,
    rather than be dependent on the server remembering prior requests.
    Authentication based on, or bound to, the underlying connection is
    outside the scope of this specification and inherently flawed unless
    steps are taken to ensure that the connection cannot be used by any
    party other than the authenticated user
    (see Section 3.3).¶



      The authentication parameter ""realm"" is reserved for defining protection
      spaces as described in Section 11.5. New schemes
      MUST NOT use it in a way incompatible with that definition.¶



      The ""token68"" notation was introduced for compatibility with existing
      authentication schemes and can only be used once per challenge or credential.
      Thus, new schemes ought to use the auth-param syntax instead, because
      otherwise future extensions will be impossible.¶



      The parsing of challenges and credentials is defined by this specification
      and cannot be modified by new authentication schemes. When the auth-param
      syntax is used, all parameters ought to support both token and
      quoted-string syntax, and syntactical constraints ought to be defined on
      the field value after parsing (i.e., quoted-string processing). This is
      necessary so that recipients can use a generic parser that applies to
      all authentication schemes.¶

Note: The fact that the value syntax for the ""realm"" parameter
      is restricted to quoted-string was a bad design choice not to be repeated
      for new parameters.¶



      Definitions of new schemes ought to define the treatment of unknown
      extension parameters. In general, a ""must-ignore"" rule is preferable
      to a ""must-understand"" rule, because otherwise it will be hard to introduce
      new parameters in the presence of legacy recipients. Furthermore,
      it's good to describe the policy for defining new parameters (such
      as ""update the specification"" or ""use this registry"").¶



      Authentication schemes need to document whether they are usable in
      origin-server authentication (i.e., using WWW-Authenticate),
      and/or proxy authentication (i.e., using Proxy-Authenticate).¶



      The credentials carried in an Authorization header field are specific to
      the user agent and, therefore, have the same effect on HTTP caches as the
      ""private"" cache response directive (Section 5.2.2.7 of [CACHING]),
      within the scope of the request in which they appear.¶

      Therefore, new authentication schemes that choose not to carry
      credentials in the Authorization header field (e.g., using a newly defined
      header field) will need to explicitly disallow caching, by mandating the use of
      cache response directives (e.g., ""private"").¶



      Schemes using Authentication-Info, Proxy-Authentication-Info,
      or any other authentication related response header field need to
      consider and document the related security considerations (see
      Section 17.16.4).¶









16.5. Range Unit Extensibility




16.5.1. Range Unit Registry


   The ""HTTP Range Unit Registry"" defines the namespace for the range
   unit names and refers to their corresponding specifications.
   It is maintained at
   <https://www.iana.org/assignments/http-parameters>.¶

   Registration of an HTTP Range Unit MUST include the following fields:¶

Name¶

Description¶

Pointer to specification text¶



  Values to be added to this namespace require IETF Review
  (see [RFC8126], Section 4.8).¶





16.5.2. Considerations for New Range Units


   Other range units, such as format-specific boundaries like pages,
   sections, records, rows, or time, are potentially usable in HTTP for
   application-specific purposes, but are not commonly used in practice.
   Implementors of alternative range units ought to consider how they would
   work with content codings and general-purpose intermediaries.¶







16.6. Content Coding Extensibility




16.6.1. Content Coding Registry


   The ""HTTP Content Coding Registry"", maintained by
   IANA at <https://www.iana.org/assignments/http-parameters/>,
   registers content-coding names.¶

   Content coding registrations MUST include the following fields:¶

Name¶

Description¶

Pointer to specification text¶



   Names of content codings MUST NOT overlap with names of transfer codings
   (per the ""HTTP Transfer Coding Registry"" located at
   <https://www.iana.org/assignments/http-parameters/>) unless
   the encoding transformation is
   identical (as is the case for the compression codings defined in
   Section 8.4.1).¶

   Values to be added to this namespace require IETF Review
   (see Section 4.8 of [RFC8126]) and MUST
   conform to the purpose of content coding defined in
   Section 8.4.1.¶





16.6.2. Considerations for New Content Codings


   New content codings ought to be self-descriptive whenever possible, with
   optional parameters discoverable within the coding format itself, rather
   than rely on external metadata that might be lost during transit.¶







16.7. Upgrade Token Registry


   The ""Hypertext Transfer Protocol (HTTP) Upgrade Token Registry"" defines
   the namespace for protocol-name tokens used to identify protocols in the
   Upgrade header field. The registry is maintained at
   <https://www.iana.org/assignments/http-upgrade-tokens>.¶

   Each registered protocol name is associated with contact information
   and an optional set of specifications that details how the connection
   will be processed after it has been upgraded.¶

   Registrations happen on a ""First Come First Served"" basis (see
   Section 4.4 of [RFC8126]) and are subject to the
   following rules:¶

A protocol-name token, once registered, stays registered forever.¶

A protocol-name token is case-insensitive and registered with the
       preferred case to be generated by senders.¶

The registration MUST name a responsible party for the
       registration.¶

The registration MUST name a point of contact.¶

The registration MAY name a set of specifications associated with
       that token. Such specifications need not be publicly available.¶

The registration SHOULD name a set of expected ""protocol-version""
       tokens associated with that token at the time of registration.¶

The responsible party MAY change the registration at any time.
       The IANA will keep a record of all such changes, and make them
       available upon request.¶

The IESG MAY reassign responsibility for a protocol token.
       This will normally only be used in the case when a
       responsible party cannot be contacted.¶









17. Security Considerations


   This section is meant to inform developers, information providers, and
   users of known security concerns relevant to HTTP semantics and its
   use for transferring information over the Internet. Considerations related
   to caching are discussed in Section 7 of [CACHING],
   and considerations related to HTTP/1.1 message syntax and parsing are
   discussed in Section 11 of [HTTP/1.1].¶

   The list of considerations below is not exhaustive. Most security concerns
   related to HTTP semantics are about securing server-side applications (code
   behind the HTTP interface), securing user agent processing of content
   received via HTTP, or secure use of the Internet in general, rather than
   security of the protocol. The security considerations for URIs, which
   are fundamental to HTTP operation, are discussed in
   Section 7 of [URI]. Various organizations maintain
   topical information and links to current research on Web application
   security (e.g., [OWASP]).¶



17.1. Establishing Authority




   HTTP relies on the notion of an ""authoritative response"": a
   response that has been determined by (or at the direction of) the origin
   server identified within the target URI to be the most appropriate response
   for that request given the state of the target resource at the time of
   response message origination.¶

   When a registered name is used in the authority component, the ""http"" URI
   scheme (Section 4.2.1) relies on the user's local name
   resolution service to determine where it can find authoritative responses.
   This means that any attack on a user's network host table, cached names,
   or name resolution libraries becomes an avenue for attack on establishing
   authority for ""http"" URIs. Likewise, the user's choice of server for
   Domain Name Service (DNS), and the hierarchy of servers from which it
   obtains resolution results, could impact the authenticity of address
   mappings; DNS Security Extensions (DNSSEC, [RFC4033]) are
   one way to improve authenticity, as are the various mechanisms for making
   DNS requests over more secure transfer protocols.¶

   Furthermore, after an IP address is obtained, establishing authority for
   an ""http"" URI is vulnerable to attacks on Internet Protocol routing.¶

   The ""https"" scheme (Section 4.2.2) is intended to prevent
   (or at least reveal) many of these potential attacks on establishing
   authority, provided that the negotiated connection is secured and
   the client properly verifies that the communicating server's identity
   matches the target URI's authority component
   (Section 4.3.4). Correctly implementing such verification
   can be difficult (see [Georgiev]).¶

   Authority for a given origin server can be delegated through protocol
   extensions; for example, [ALTSVC]. Likewise, the set of
   servers for which a connection is considered authoritative can be changed
   with a protocol extension like [RFC8336].¶

   Providing a response from a non-authoritative source, such as a shared
   proxy cache, is often useful to improve performance and availability, but
   only to the extent that the source can be trusted or the distrusted
   response can be safely used.¶

   Unfortunately, communicating authority to users can be difficult.
   For example, ""phishing"" is an attack on the user's perception
   of authority, where that perception can be misled by presenting similar
   branding in hypertext, possibly aided by userinfo obfuscating the authority
   component (see Section 4.2.1).
   User agents can reduce the impact of phishing attacks by enabling users to
   easily inspect a target URI prior to making an action, by prominently
   distinguishing (or rejecting) userinfo when present, and by not sending
   stored credentials and cookies when the referring document is from an
   unknown or untrusted source.¶





17.2. Risks of Intermediaries


   HTTP intermediaries are inherently situated for on-path attacks.
   Compromise of
   the systems on which the intermediaries run can result in serious security
   and privacy problems. Intermediaries might have access to security-related
   information, personal information about individual users and
   organizations, and proprietary information belonging to users and
   content providers. A compromised intermediary, or an intermediary
   implemented or configured without regard to security and privacy
   considerations, might be used in the commission of a wide range of
   potential attacks.¶

   Intermediaries that contain a shared cache are especially vulnerable
   to cache poisoning attacks, as described in Section 7 of [CACHING].¶

   Implementers need to consider the privacy and security
   implications of their design and coding decisions, and of the
   configuration options they provide to operators (especially the
   default configuration).¶

   Intermediaries are no more trustworthy than the people and policies
   under which they operate; HTTP cannot solve this problem.¶





17.3. Attacks Based on File and Path Names


   Origin servers frequently make use of their local file system to manage the
   mapping from target URI to resource representations.
   Most file systems are not designed to protect against malicious file
   or path names. Therefore, an origin server needs to avoid accessing
   names that have a special significance to the system when mapping the
   target resource to files, folders, or directories.¶

   For example, UNIX, Microsoft Windows, and other operating systems use ""..""
   as a path component to indicate a directory level above the current one,
   and they use specially named paths or file names to send data to system devices.
   Similar naming conventions might exist within other types of storage
   systems. Likewise, local storage systems have an annoying tendency to
   prefer user-friendliness over security when handling invalid or unexpected
   characters, recomposition of decomposed characters, and case-normalization
   of case-insensitive names.¶

   Attacks based on such special names tend to focus on either denial-of-service
   (e.g., telling the server to read from a COM port) or disclosure
   of configuration and source files that are not meant to be served.¶





17.4. Attacks Based on Command, Code, or Query Injection


   Origin servers often use parameters within the URI as a
   means of identifying system services, selecting database entries, or
   choosing a data source. However, data received in a request cannot be
   trusted. An attacker could construct any of the request data elements
   (method, target URI, header fields, or content) to contain data that might
   be misinterpreted as a command, code, or query when passed through a
   command invocation, language interpreter, or database interface.¶

   For example, SQL injection is a common attack wherein additional query
   language is inserted within some part of the target URI or header
   fields (e.g., Host, Referer, etc.).
   If the received data is used directly within a SELECT statement, the
   query language might be interpreted as a database command instead of a
   simple string value. This type of implementation vulnerability is extremely
   common, in spite of being easy to prevent.¶

   In general, resource implementations ought to avoid use of request data
   in contexts that are processed or interpreted as instructions.  Parameters
   ought to be compared to fixed strings and acted upon as a result of that
   comparison, rather than passed through an interface that is not prepared
   for untrusted data. Received data that isn't based on fixed parameters
   ought to be carefully filtered or encoded to avoid being misinterpreted.¶

   Similar considerations apply to request data when it is stored and later
   processed, such as within log files, monitoring tools, or when included
   within a data format that allows embedded scripts.¶





17.5. Attacks via Protocol Element Length


   Because HTTP uses mostly textual, character-delimited fields, parsers are
   often vulnerable to attacks based on sending very long (or very slow)
   streams of data, particularly where an implementation is expecting a
   protocol element with no predefined length
   (Section 2.3).¶

   To promote interoperability, specific recommendations are made for minimum
   size limits on fields (Section 5.4). These are
   minimum recommendations, chosen to be supportable even by implementations
   with limited resources; it is expected that most implementations will
   choose substantially higher limits.¶

   A server can reject a message that
   has a target URI that is too long (Section 15.5.15) or request content
   that is too large (Section 15.5.14). Additional status codes related to
   capacity limits have been defined by extensions to HTTP
   [RFC6585].¶

   Recipients ought to carefully limit the extent to which they process other
   protocol elements, including (but not limited to) request methods, response
   status phrases, field names, numeric values, and chunk lengths.
   Failure to limit such processing can result in arbitrary code execution due to
   buffer or arithmetic
   overflows, and increased vulnerability to denial-of-service attacks.¶





17.6. Attacks Using Shared-Dictionary Compression


   Some attacks on encrypted protocols use the differences in size created by
   dynamic compression to reveal confidential information; for example, [BREACH]. These attacks rely on creating a redundancy between
   attacker-controlled content and the confidential information, such that a
   dynamic compression algorithm using the same dictionary for both content
   will compress more efficiently when the attacker-controlled content matches
   parts of the confidential content.¶

   HTTP messages can be compressed in a number of ways, including using TLS
   compression, content codings, transfer codings, and other extension or
   version-specific mechanisms.¶

   The most effective mitigation for this risk is to disable compression on
   sensitive data, or to strictly separate sensitive data from attacker-controlled
   data so that they cannot share the same compression dictionary. With
   careful design, a compression scheme can be designed in a way that is not
   considered exploitable in limited use cases, such as HPACK ([HPACK]).¶





17.7. Disclosure of Personal Information


   Clients are often privy to large amounts of personal information,
   including both information provided by the user to interact with resources
   (e.g., the user's name, location, mail address, passwords, encryption
   keys, etc.) and information about the user's browsing activity over
   time (e.g., history, bookmarks, etc.). Implementations need to
   prevent unintentional disclosure of personal information.¶





17.8. Privacy of Server Log Information


   A server is in the position to save personal data about a user's requests
   over time, which might identify their reading patterns or subjects of
   interest.  In particular, log information gathered at an intermediary
   often contains a history of user agent interaction, across a multitude
   of sites, that can be traced to individual users.¶

   HTTP log information is confidential in nature; its handling is often
   constrained by laws and regulations.  Log information needs to be securely
   stored and appropriate guidelines followed for its analysis.
   Anonymization of personal information within individual entries helps,
   but it is generally not sufficient to prevent real log traces from being
   re-identified based on correlation with other access characteristics.
   As such, access traces that are keyed to a specific client are unsafe to
   publish even if the key is pseudonymous.¶

   To minimize the risk of theft or accidental publication, log information
   ought to be purged of personally identifiable information, including
   user identifiers, IP addresses, and user-provided query parameters,
   as soon as that information is no longer necessary to support operational
   needs for security, auditing, or fraud control.¶





17.9. Disclosure of Sensitive Information in URIs


   URIs are intended to be shared, not secured, even when they identify secure
   resources. URIs are often shown on displays, added to templates when a page
   is printed, and stored in a variety of unprotected bookmark lists.
   Many servers, proxies, and user agents log or display the target URI
   in places where it might be visible to third parties.
   It is therefore unwise to include information within a URI that
   is sensitive, personally identifiable, or a risk to disclose.¶

   When an application uses client-side mechanisms to construct a target URI
   out of user-provided information, such as the query fields of a form using
   GET, potentially sensitive data might be provided that would not be
   appropriate for disclosure within a URI. POST is often preferred in such
   cases because it usually doesn't construct a URI; instead, POST of a form
   transmits the potentially sensitive data in the request content. However, this
   hinders caching and uses an unsafe method for what would otherwise be a safe
   request. Alternative workarounds include transforming the user-provided data
   prior to constructing the URI or filtering the data to only include common
   values that are not sensitive. Likewise, redirecting the result of a query
   to a different (server-generated) URI can remove potentially sensitive data
   from later links and provide a cacheable response for later reuse.¶

   Since the Referer header field tells a target site about the
   context that resulted in a request, it has the potential to reveal
   information about the user's immediate browsing history and any personal
   information that might be found in the referring resource's URI.
   Limitations on the Referer header field are described in Section 10.1.3 to
   address some of its security considerations.¶





17.10. Application Handling of Field Names


   Servers often use non-HTTP gateway interfaces and frameworks to process a received
   request and produce content for the response. For historical reasons, such interfaces
   often pass received field names as external variable names, using a name mapping
   suitable for environment variables.¶

   For example, the Common Gateway Interface (CGI) mapping of protocol-specific
   meta-variables, defined by Section 4.1.18 of [RFC3875],
   is applied to received header fields that do not correspond to one of CGI's
   standard variables; the mapping consists of prepending ""HTTP_"" to each name
   and changing all instances of hyphen (""-"") to underscore (""_""). This same mapping
   has been inherited by many other application frameworks in order to simplify
   moving applications from one platform to the next.¶

   In CGI, a received Content-Length field would be passed
   as the meta-variable ""CONTENT_LENGTH"" with a string value matching the
   received field's value. In contrast, a received ""Content_Length"" header field would
   be passed as the protocol-specific meta-variable ""HTTP_CONTENT_LENGTH"",
   which might lead to some confusion if an application mistakenly reads the
   protocol-specific meta-variable instead of the default one. (This historical practice
   is why Section 16.3.2.1 discourages the creation
   of new field names that contain an underscore.)¶

   Unfortunately, mapping field names to different interface names can lead to
   security vulnerabilities if the mapping is incomplete or ambiguous. For example,
   if an attacker were to send a field named ""Transfer_Encoding"", a naive interface
   might map that to the same variable name as the ""Transfer-Encoding"" field, resulting
   in a potential request smuggling vulnerability (Section 11.2 of [HTTP/1.1]).¶

   To mitigate the associated risks, implementations that perform such
   mappings are advised to make the mapping unambiguous and complete
   for the full range of potential octets received as a name (including those
   that are discouraged or forbidden by the HTTP grammar).
   For example, a field with an unusual name character might
   result in the request being blocked, the specific field being removed,
   or the name being passed with a different prefix to distinguish it from
   other fields.¶





17.11. Disclosure of Fragment after Redirects


   Although fragment identifiers used within URI references are not sent
   in requests, implementers ought to be aware that they will be visible to
   the user agent and any extensions or scripts running as a result of the
   response. In particular, when a redirect occurs and the original request's
   fragment identifier is inherited by the new reference in
   Location (Section 10.2.2), this might
   have the effect of disclosing one site's fragment to another site.
   If the first site uses personal information in fragments, it ought to
   ensure that redirects to other sites include a (possibly empty) fragment
   component in order to block that inheritance.¶





17.12. Disclosure of Product Information


   The User-Agent (Section 10.1.5),
   Via (Section 7.6.3), and
   Server (Section 10.2.4) header fields often
   reveal information about the respective sender's software systems.
   In theory, this can make it easier for an attacker to exploit known
   security holes; in practice, attackers tend to try all potential holes
   regardless of the apparent software versions being used.¶

   Proxies that serve as a portal through a network firewall ought to take
   special precautions regarding the transfer of header information that might
   identify hosts behind the firewall. The Via header field
   allows intermediaries to replace sensitive machine names with pseudonyms.¶





17.13. Browser Fingerprinting


   Browser fingerprinting is a set of techniques for identifying a specific
   user agent over time through its unique set of characteristics. These
   characteristics might include information related to how it uses the underlying
   transport protocol,
   feature capabilities, and scripting environment, though of particular
   interest here is the set of unique characteristics that might be
   communicated via HTTP. Fingerprinting is considered a privacy concern
   because it enables tracking of a user agent's behavior over time
   ([Bujlow]) without
   the corresponding controls that the user might have over other forms of
   data collection (e.g., cookies). Many general-purpose user agents
   (i.e., Web browsers) have taken steps to reduce their fingerprints.¶

   There are a number of request header fields that might reveal information
   to servers that is sufficiently unique to enable fingerprinting.
   The From header field is the most obvious, though it is
   expected that From will only be sent when self-identification is desired by
   the user. Likewise, Cookie header fields are deliberately designed to
   enable re-identification, so fingerprinting concerns only apply to
   situations where cookies are disabled or restricted by the user agent's
   configuration.¶

   The User-Agent header field might contain enough information
   to uniquely identify a specific device, usually when combined with other
   characteristics, particularly if the user agent sends excessive details
   about the user's system or extensions. However, the source of unique
   information that is least expected by users is
   proactive negotiation (Section 12.1),
   including the Accept, Accept-Charset,
   Accept-Encoding, and Accept-Language
   header fields.¶

   In addition to the fingerprinting concern, detailed use of the
   Accept-Language header field can reveal information the
   user might consider to be of a private nature. For example, understanding
   a given language set might be strongly correlated to membership in a
   particular ethnic group.
   An approach that limits such loss of privacy would be for a user agent
   to omit the sending of Accept-Language except for sites that have been
   explicitly permitted, perhaps via interaction after detecting a Vary
   header field that indicates language negotiation might be useful.¶

   In environments where proxies are used to enhance privacy, user agents
   ought to be conservative in sending proactive negotiation header fields.
   General-purpose user agents that provide a high degree of header field
   configurability ought to inform users about the loss of privacy that might
   result if too much detail is provided. As an extreme privacy measure,
   proxies could filter the proactive negotiation header fields in relayed
   requests.¶





17.14. Validator Retention


   The validators defined by this specification are not intended to ensure
   the validity of a representation, guard against malicious changes, or
   detect on-path attacks. At best, they enable more efficient cache
   updates and optimistic concurrent writes when all participants are behaving
   nicely. At worst, the conditions will fail and the client will receive a
   response that is no more harmful than an HTTP exchange without conditional
   requests.¶

   An entity tag can be abused in ways that create privacy risks. For example,
   a site might deliberately construct a semantically invalid entity tag that
   is unique to the user or user agent, send it in a cacheable response with a
   long freshness time, and then read that entity tag in later conditional
   requests as a means of re-identifying that user or user agent. Such an
   identifying tag would become a persistent identifier for as long as the
   user agent retained the original cache entry. User agents that cache
   representations ought to ensure that the cache is cleared or replaced
   whenever the user performs privacy-maintaining actions, such as clearing
   stored cookies or changing to a private browsing mode.¶





17.15. Denial-of-Service Attacks Using Range


   Unconstrained multiple range requests are susceptible to denial-of-service
   attacks because the effort required to request many overlapping ranges of
   the same data is tiny compared to the time, memory, and bandwidth consumed
   by attempting to serve the requested data in many parts.
   Servers ought to ignore, coalesce, or reject egregious range requests, such
   as requests for more than two overlapping ranges or for many small ranges
   in a single set, particularly when the ranges are requested out of order
   for no apparent reason. Multipart range requests are not designed to
   support random access.¶





17.16. Authentication Considerations


   Everything about the topic of HTTP authentication is a security
   consideration, so the list of considerations below is not exhaustive.
   Furthermore, it is limited to security considerations regarding the
   authentication framework, in general, rather than discussing all of the
   potential considerations for specific authentication schemes (which ought
   to be documented in the specifications that define those schemes).
   Various organizations maintain topical information and links to current
   research on Web application security (e.g., [OWASP]),
   including common pitfalls for implementing and using the authentication
   schemes found in practice.¶



17.16.1. Confidentiality of Credentials


   The HTTP authentication framework does not define a single mechanism for
   maintaining the confidentiality of credentials; instead, each
   authentication scheme defines how the credentials are encoded prior to
   transmission. While this provides flexibility for the development of future
   authentication schemes, it is inadequate for the protection of existing
   schemes that provide no confidentiality on their own, or that do not
   sufficiently protect against replay attacks. Furthermore, if the server
   expects credentials that are specific to each individual user, the exchange
   of those credentials will have the effect of identifying that user even if
   the content within credentials remains confidential.¶

   HTTP depends on the security properties of the underlying transport- or
   session-level connection to provide confidential transmission of
   fields. Services that depend on individual user authentication require a
   secured connection prior to exchanging credentials
   (Section 4.2.2).¶





17.16.2. Credentials and Idle Clients


   Existing HTTP clients and user agents typically retain authentication
   information indefinitely. HTTP does not provide a mechanism for the
   origin server to direct clients to discard these cached credentials, since
   the protocol has no awareness of how credentials are obtained or managed
   by the user agent. The mechanisms for expiring or revoking credentials can
   be specified as part of an authentication scheme definition.¶

   Circumstances under which credential caching can interfere with the
   application's security model include but are not limited to:¶

Clients that have been idle for an extended period, following
       which the server might wish to cause the client to re-prompt the
       user for credentials.¶

Applications that include a session termination indication
       (such as a ""logout"" or ""commit"" button on a page) after which
       the server side of the application ""knows"" that there is no
       further reason for the client to retain the credentials.¶



   User agents that cache credentials are encouraged to provide a readily
   accessible mechanism for discarding cached credentials under user control.¶





17.16.3. Protection Spaces


  Authentication schemes that solely rely on the ""realm"" mechanism for
  establishing a protection space will expose credentials to all resources on
  an origin server. Clients that have successfully made authenticated requests
  with a resource can use the same authentication credentials for other
  resources on the same origin server. This makes it possible for a different
  resource to harvest authentication credentials for other resources.¶

  This is of particular concern when an origin server hosts resources for multiple
  parties under the same origin (Section 11.5).
  Possible mitigation strategies include restricting direct access to
  authentication credentials (i.e., not making the content of the
  Authorization request header field available), and separating protection
  spaces by using a different host name (or port number) for each party.¶





17.16.4. Additional Response Fields


  Adding information to responses that are sent over an unencrypted
  channel can affect security and privacy. The presence of the
  Authentication-Info and Proxy-Authentication-Info
  header fields alone indicates that HTTP authentication is in use. Additional
  information could be exposed by the contents of the authentication-scheme
  specific parameters; this will have to be considered in the definitions of these
  schemes.¶









18. IANA Considerations


   The change controller for the following registrations is:
   ""IETF (iesg@ietf.org) - Internet Engineering Task Force"".¶



18.1. URI Scheme Registration


   IANA has updated the ""Uniform Resource Identifier (URI) Schemes"" registry [BCP35] at
   <https://www.iana.org/assignments/uri-schemes/> with the
   permanent schemes listed in Table 2 in Section 4.2.¶





18.2. Method Registration


  IANA has updated the ""Hypertext Transfer Protocol (HTTP) Method Registry"" at
  <https://www.iana.org/assignments/http-methods> with the
  registration procedure of Section 16.1.1 and the method
  names summarized in the following table.¶


Table 7


Method
Safe
Idempotent
Section




CONNECT
no
no

9.3.6



DELETE
no
yes

9.3.5



GET
yes
yes

9.3.1



HEAD
yes
yes

9.3.2



OPTIONS
yes
yes

9.3.7



POST
no
no

9.3.3



PUT
no
yes

9.3.4



TRACE
yes
yes

9.3.8



*
no
no

18.2







   The method name ""*"" is reserved because using ""*"" as a method name would
   conflict with its usage as a wildcard in some fields (e.g.,
   ""Access-Control-Request-Method"").¶





18.3. Status Code Registration


   IANA has updated the ""Hypertext Transfer Protocol (HTTP) Status Code Registry""
   at <https://www.iana.org/assignments/http-status-codes> with
   the registration procedure of Section 16.2.1 and the
   status code values summarized in the following table.¶


Table 8


Value
Description
Section




100
Continue

15.2.1



101
Switching Protocols

15.2.2



200
OK

15.3.1



201
Created

15.3.2



202
Accepted

15.3.3



203
Non-Authoritative Information

15.3.4



204
No Content

15.3.5



205
Reset Content

15.3.6



206
Partial Content

15.3.7



300
Multiple Choices

15.4.1



301
Moved Permanently

15.4.2



302
Found

15.4.3



303
See Other

15.4.4



304
Not Modified

15.4.5



305
Use Proxy

15.4.6



306
(Unused)

15.4.7



307
Temporary Redirect

15.4.8



308
Permanent Redirect

15.4.9



400
Bad Request

15.5.1



401
Unauthorized

15.5.2



402
Payment Required

15.5.3



403
Forbidden

15.5.4



404
Not Found

15.5.5



405
Method Not Allowed

15.5.6



406
Not Acceptable

15.5.7



407
Proxy Authentication Required

15.5.8



408
Request Timeout

15.5.9



409
Conflict

15.5.10



410
Gone

15.5.11



411
Length Required

15.5.12



412
Precondition Failed

15.5.13



413
Content Too Large

15.5.14



414
URI Too Long

15.5.15



415
Unsupported Media Type

15.5.16



416
Range Not Satisfiable

15.5.17



417
Expectation Failed

15.5.18



418
(Unused)

15.5.19



421
Misdirected Request

15.5.20



422
Unprocessable Content

15.5.21



426
Upgrade Required

15.5.22



500
Internal Server Error

15.6.1



501
Not Implemented

15.6.2



502
Bad Gateway

15.6.3



503
Service Unavailable

15.6.4



504
Gateway Timeout

15.6.5



505
HTTP Version Not Supported

15.6.6










18.4. Field Name Registration


   This specification updates the HTTP-related aspects of the existing
   registration procedures for message header fields defined in [RFC3864].
   It replaces the old procedures as they relate to HTTP by defining a new
   registration procedure and moving HTTP field definitions into a separate
   registry.¶

   IANA has created a new registry titled ""Hypertext Transfer Protocol (HTTP) 
   Field Name Registry"" as outlined in Section 16.3.1.¶

   IANA has moved all entries in the ""Permanent Message Header Field
   Names"" and ""Provisional Message Header Field Names"" registries (see
   <https://www.iana.org/assignments/message-headers/>) with the
   protocol 'http' to this registry and has applied the following changes:¶

The 'Applicable Protocol' field has been omitted.¶

Entries that had a status of 'standard', 'experimental', 'reserved', or
   'informational' have been made to have a status of 'permanent'.¶

Provisional entries without a status have been made to have a status of
   'provisional'.¶

Permanent entries without a status (after confirmation that the
   registration document did not define one) have been made to have a status of
   'provisional'. The expert(s) can choose to update the entries' status if there is
   evidence that another is more appropriate.¶



   IANA has annotated the ""Permanent Message Header Field 
   Names"" and ""Provisional Message Header Field Names"" registries with the 
   following note to indicate that HTTP field name registrations have moved:¶


Note¶

    HTTP field name registrations have been moved to 
    [https://www.iana.org/assignments/http-fields] per 
    [RFC9110].¶


   IANA has updated the ""Hypertext Transfer Protocol (HTTP) Field Name Registry""
   with the field names listed in the following table.¶


Table 9


Field Name
Status
Section
Comments




Accept
permanent

12.5.1




Accept-Charset
deprecated

12.5.2




Accept-Encoding
permanent

12.5.3




Accept-Language
permanent

12.5.4




Accept-Ranges
permanent

14.3




Allow
permanent

10.2.1




Authentication-Info
permanent

11.6.3




Authorization
permanent

11.6.2




Connection
permanent

7.6.1




Content-Encoding
permanent

8.4




Content-Language
permanent

8.5




Content-Length
permanent

8.6




Content-Location
permanent

8.7




Content-Range
permanent

14.4




Content-Type
permanent

8.3




Date
permanent

6.6.1




ETag
permanent

8.8.3




Expect
permanent

10.1.1




From
permanent

10.1.2




Host
permanent

7.2




If-Match
permanent

13.1.1




If-Modified-Since
permanent

13.1.3




If-None-Match
permanent

13.1.2




If-Range
permanent

13.1.5




If-Unmodified-Since
permanent

13.1.4




Last-Modified
permanent

8.8.2




Location
permanent

10.2.2




Max-Forwards
permanent

7.6.2




Proxy-Authenticate
permanent

11.7.1




Proxy-Authentication-Info
permanent

11.7.3




Proxy-Authorization
permanent

11.7.2




Range
permanent

14.2




Referer
permanent

10.1.3




Retry-After
permanent

10.2.3




Server
permanent

10.2.4




TE
permanent

10.1.4




Trailer
permanent

6.6.2




Upgrade
permanent

7.8




User-Agent
permanent

10.1.5




Vary
permanent

12.5.5




Via
permanent

7.6.3




WWW-Authenticate
permanent

11.6.1




*
permanent

12.5.5

(reserved)







   
   The field name ""*"" is reserved because using that name as
   an HTTP header field might conflict with its special semantics in the
   Vary header field (Section 12.5.5).¶





   
   IANA has updated the ""Content-MD5"" entry in the new registry to have
   a status of 'obsoleted' with references to
   Section 14.15 of [RFC2616] (for the definition
   of the header field) and
   Appendix B of [RFC7231] (which removed the field
   definition from the updated specification).¶





18.5. Authentication Scheme Registration


   IANA has updated the
   ""Hypertext Transfer Protocol (HTTP) Authentication Scheme Registry""
   at <https://www.iana.org/assignments/http-authschemes> with
   the registration procedure of Section 16.4.1.
   No authentication schemes are defined in this document.¶





18.6. Content Coding Registration


   IANA has updated the ""HTTP Content Coding Registry"" at
   <https://www.iana.org/assignments/http-parameters/>
   with the registration procedure of Section 16.6.1
   and the content coding names summarized in the table below.¶


Table 10


Name
Description
Section




compress
UNIX ""compress"" data format [Welch]


8.4.1.1



deflate
""deflate"" compressed data ([RFC1951]) inside
      the ""zlib"" data format ([RFC1950])

8.4.1.2



gzip
GZIP file format [RFC1952]


8.4.1.3



identity
Reserved

12.5.3



x-compress
Deprecated (alias for compress)

8.4.1.1



x-gzip
Deprecated (alias for gzip)

8.4.1.3










18.7. Range Unit Registration


   IANA has updated the ""HTTP Range Unit Registry"" at
   <https://www.iana.org/assignments/http-parameters/>
   with the registration procedure of Section 16.5.1
   and the range unit names summarized in the table below.¶


Table 11


Range Unit Name
Description
Section




bytes
a range of octets

14.1.2



none
reserved as keyword to indicate range requests are not supported

14.3










18.8. Media Type Registration


   IANA has updated the ""Media Types"" registry at
   <https://www.iana.org/assignments/media-types>
   with the registration information in
   Section 14.6
   for the media type ""multipart/byteranges"".¶

   IANA has updated the registry note about ""q"" parameters with
   a link to Section 12.5.1 of this document.¶





18.9. Port Registration


   IANA has updated the ""Service Name and Transport Protocol Port Number
   Registry"" at <https://www.iana.org/assignments/service-names-port-numbers/>
   for the services on ports 80 and 443 that use UDP or TCP to:¶

use this document as ""Reference"", and¶

when currently unspecified, set ""Assignee"" to ""IESG"" and ""Contact"" to
   ""IETF_Chair"".¶







18.10. Upgrade Token Registration


  IANA has updated the
   ""Hypertext Transfer Protocol (HTTP) Upgrade Token Registry"" at
   <https://www.iana.org/assignments/http-upgrade-tokens>
   with the registration procedure described in Section 16.7
   and the upgrade token names summarized in the following table.¶

Table 12


Name
Description
Expected Version Tokens
Section




HTTP
Hypertext Transfer Protocol
any DIGIT.DIGIT (e.g., ""2.0"")

2.5










19. References



19.1. Normative References


[CACHING]

Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., ""HTTP Caching"", STD 98, RFC 9111, DOI 10.17487/RFC9111, June 2022, <https://www.rfc-editor.org/info/rfc9111>. 

[RFC1950]

Deutsch, P. and J-L. Gailly, ""ZLIB Compressed Data Format Specification version 3.3"", RFC 1950, DOI 10.17487/RFC1950, May 1996, <https://www.rfc-editor.org/info/rfc1950>. 

[RFC1951]

Deutsch, P., ""DEFLATE Compressed Data Format Specification version 1.3"", RFC 1951, DOI 10.17487/RFC1951, May 1996, <https://www.rfc-editor.org/info/rfc1951>. 

[RFC1952]

Deutsch, P., ""GZIP file format specification version 4.3"", RFC 1952, DOI 10.17487/RFC1952, May 1996, <https://www.rfc-editor.org/info/rfc1952>. 

[RFC2046]

Freed, N. and N. Borenstein, ""Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types"", RFC 2046, DOI 10.17487/RFC2046, November 1996, <https://www.rfc-editor.org/info/rfc2046>. 

[RFC2119]

Bradner, S., ""Key words for use in RFCs to Indicate Requirement Levels"", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>. 

[RFC4647]

Phillips, A., Ed. and M. Davis, Ed., ""Matching of Language Tags"", BCP 47, RFC 4647, DOI 10.17487/RFC4647, September 2006, <https://www.rfc-editor.org/info/rfc4647>. 

[RFC4648]

Josefsson, S., ""The Base16, Base32, and Base64 Data Encodings"", RFC 4648, DOI 10.17487/RFC4648, October 2006, <https://www.rfc-editor.org/info/rfc4648>. 

[RFC5234]

Crocker, D., Ed. and P. Overell, ""Augmented BNF for Syntax Specifications: ABNF"", STD 68, RFC 5234, DOI 10.17487/RFC5234, January 2008, <https://www.rfc-editor.org/info/rfc5234>. 

[RFC5280]

Cooper, D., Santesson, S., Farrell, S., Boeyen, S., Housley, R., and W. Polk, ""Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile"", RFC 5280, DOI 10.17487/RFC5280, May 2008, <https://www.rfc-editor.org/info/rfc5280>. 

[RFC5322]

Resnick, P., Ed., ""Internet Message Format"", RFC 5322, DOI 10.17487/RFC5322, October 2008, <https://www.rfc-editor.org/info/rfc5322>. 

[RFC5646]

Phillips, A., Ed. and M. Davis, Ed., ""Tags for Identifying Languages"", BCP 47, RFC 5646, DOI 10.17487/RFC5646, September 2009, <https://www.rfc-editor.org/info/rfc5646>. 

[RFC6125]

Saint-Andre, P. and J. Hodges, ""Representation and Verification of Domain-Based Application Service Identity within Internet Public Key Infrastructure Using X.509 (PKIX) Certificates in the Context of Transport Layer Security (TLS)"", RFC 6125, DOI 10.17487/RFC6125, March 2011, <https://www.rfc-editor.org/info/rfc6125>. 

[RFC6365]

Hoffman, P. and J. Klensin, ""Terminology Used in Internationalization in the IETF"", BCP 166, RFC 6365, DOI 10.17487/RFC6365, September 2011, <https://www.rfc-editor.org/info/rfc6365>. 

[RFC7405]

Kyzivat, P., ""Case-Sensitive String Support in ABNF"", RFC 7405, DOI 10.17487/RFC7405, December 2014, <https://www.rfc-editor.org/info/rfc7405>. 

[RFC8174]

Leiba, B., ""Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words"", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>. 

[TCP]

Postel, J., ""Transmission Control Protocol"", STD 7, RFC 793, DOI 10.17487/RFC0793, September 1981, <https://www.rfc-editor.org/info/rfc793>. 

[TLS13]

Rescorla, E., ""The Transport Layer Security (TLS) Protocol Version 1.3"", RFC 8446, DOI 10.17487/RFC8446, August 2018, <https://www.rfc-editor.org/info/rfc8446>. 

[URI]

Berners-Lee, T., Fielding, R., and L. Masinter, ""Uniform Resource Identifier (URI): Generic Syntax"", STD 66, RFC 3986, DOI 10.17487/RFC3986, January 2005, <https://www.rfc-editor.org/info/rfc3986>. 

[USASCII]

American National Standards Institute, ""Coded Character Set -- 7-bit American Standard Code for Information Interchange"", ANSI X3.4, 1986. 

[Welch]

Welch, T., ""A Technique for High-Performance Data Compression"", IEEE Computer 17(6), DOI 10.1109/MC.1984.1659158, June 1984, <https://ieeexplore.ieee.org/document/1659158/>. 





19.2. Informative References


[ALTSVC]

Nottingham, M., McManus, P., and J. Reschke, ""HTTP Alternative Services"", RFC 7838, DOI 10.17487/RFC7838, April 2016, <https://www.rfc-editor.org/info/rfc7838>. 

[BCP13]


Freed, N. and J. Klensin, ""Multipurpose Internet Mail Extensions (MIME) Part Four: Registration Procedures"", BCP 13, RFC 4289, December 2005. 

Freed, N., Klensin, J., and T. Hansen, ""Media Type Specifications and Registration Procedures"", BCP 13, RFC 6838, January 2013. 
<https://www.rfc-editor.org/info/bcp13>


[BCP178]


Saint-Andre, P., Crocker, D., and M. Nottingham, ""Deprecating the ""X-"" Prefix and Similar Constructs in Application Protocols"", BCP 178, RFC 6648, June 2012. 
<https://www.rfc-editor.org/info/bcp178>


[BCP35]


Thaler, D., Ed., Hansen, T., and T. Hardie, ""Guidelines and Registration Procedures for URI Schemes"", BCP 35, RFC 7595, June 2015. 
<https://www.rfc-editor.org/info/bcp35>


[BREACH]

Gluck, Y., Harris, N., and A. Prado, ""BREACH: Reviving the CRIME Attack"", July 2013, <http://breachattack.com/resources/BREACH%20-%20SSL,%20gone%20in%2030%20seconds.pdf>. 

[Bujlow]

Bujlow, T., Carela-Español, V., Solé-Pareta, J., and P. Barlet-Ros, ""A Survey on Web Tracking: Mechanisms, Implications, and Defenses"", In Proceedings of the IEEE 105(8), DOI 10.1109/JPROC.2016.2637878, August 2017, <https://doi.org/10.1109/JPROC.2016.2637878>. 

[COOKIE]

Barth, A., ""HTTP State Management Mechanism"", RFC 6265, DOI 10.17487/RFC6265, April 2011, <https://www.rfc-editor.org/info/rfc6265>. 

[Err1912]

RFC Errata, Erratum ID 1912, RFC 2978, <https://www.rfc-editor.org/errata/eid1912>. 

[Err5433]

RFC Errata, Erratum ID 5433, RFC 2978, <https://www.rfc-editor.org/errata/eid5433>. 

[Georgiev]

Georgiev, M., Iyengar, S., Jana, S., Anubhai, R., Boneh, D., and V. Shmatikov, ""The Most Dangerous Code in the World: Validating SSL Certificates in Non-Browser Software"", In Proceedings of the 2012 ACM Conference on Computer and Communications Security (CCS '12), pp. 38-49, DOI 10.1145/2382196.2382204, October 2012, <https://doi.org/10.1145/2382196.2382204>. 

[HPACK]

Peon, R. and H. Ruellan, ""HPACK: Header Compression for HTTP/2"", RFC 7541, DOI 10.17487/RFC7541, May 2015, <https://www.rfc-editor.org/info/rfc7541>. 

[HTTP/1.0]

Berners-Lee, T., Fielding, R., and H. Frystyk, ""Hypertext Transfer Protocol -- HTTP/1.0"", RFC 1945, DOI 10.17487/RFC1945, May 1996, <https://www.rfc-editor.org/info/rfc1945>. 

[HTTP/1.1]

Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., ""HTTP/1.1"", STD 99, RFC 9112, DOI 10.17487/RFC9112, June 2022, <https://www.rfc-editor.org/info/rfc9112>. 

[HTTP/2]

Thomson, M., Ed. and C. Benfield, Ed., ""HTTP/2"", RFC 9113, DOI 10.17487/RFC9113, June 2022, <https://www.rfc-editor.org/info/rfc9113>. 

[HTTP/3]

Bishop, M., Ed., ""HTTP/3"", RFC 9114, DOI 10.17487/RFC9114, June 2022, <https://www.rfc-editor.org/info/rfc9114>. 

[ISO-8859-1]

International Organization for Standardization, ""Information technology -- 8-bit single-byte coded graphic character sets -- Part 1: Latin alphabet No. 1"", ISO/IEC 8859-1:1998, 1998. 

[Kri2001]

Kristol, D., ""HTTP Cookies: Standards, Privacy, and Politics"", ACM Transactions on Internet Technology 1(2), November 2001, <http://arxiv.org/abs/cs.SE/0105018>. 

[OWASP]

The Open Web Application Security Project, <https://www.owasp.org/>. 

[REST]

Fielding, R.T., ""Architectural Styles and the Design of Network-based Software Architectures"", Doctoral Dissertation, University of California, Irvine, September 2000, <https://roy.gbiv.com/pubs/dissertation/top.htm>. 

[RFC1919]

Chatel, M., ""Classical versus Transparent IP Proxies"", RFC 1919, DOI 10.17487/RFC1919, March 1996, <https://www.rfc-editor.org/info/rfc1919>. 

[RFC2047]

Moore, K., ""MIME (Multipurpose Internet Mail Extensions) Part Three: Message Header Extensions for Non-ASCII Text"", RFC 2047, DOI 10.17487/RFC2047, November 1996, <https://www.rfc-editor.org/info/rfc2047>. 

[RFC2068]

Fielding, R., Gettys, J., Mogul, J., Frystyk, H., and T. Berners-Lee, ""Hypertext Transfer Protocol -- HTTP/1.1"", RFC 2068, DOI 10.17487/RFC2068, January 1997, <https://www.rfc-editor.org/info/rfc2068>. 

[RFC2145]

Mogul, J. C., Fielding, R., Gettys, J., and H. Frystyk, ""Use and Interpretation of HTTP Version Numbers"", RFC 2145, DOI 10.17487/RFC2145, May 1997, <https://www.rfc-editor.org/info/rfc2145>. 

[RFC2295]

Holtman, K. and A. Mutz, ""Transparent Content Negotiation in HTTP"", RFC 2295, DOI 10.17487/RFC2295, March 1998, <https://www.rfc-editor.org/info/rfc2295>. 

[RFC2324]

Masinter, L., ""Hyper Text Coffee Pot Control Protocol (HTCPCP/1.0)"", RFC 2324, DOI 10.17487/RFC2324, 1 April 1998, <https://www.rfc-editor.org/info/rfc2324>. 

[RFC2557]

Palme, J., Hopmann, A., and N. Shelness, ""MIME Encapsulation of Aggregate Documents, such as HTML (MHTML)"", RFC 2557, DOI 10.17487/RFC2557, March 1999, <https://www.rfc-editor.org/info/rfc2557>. 

[RFC2616]

Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P., and T. Berners-Lee, ""Hypertext Transfer Protocol -- HTTP/1.1"", RFC 2616, DOI 10.17487/RFC2616, June 1999, <https://www.rfc-editor.org/info/rfc2616>. 

[RFC2617]

Franks, J., Hallam-Baker, P., Hostetler, J., Lawrence, S., Leach, P., Luotonen, A., and L. Stewart, ""HTTP Authentication: Basic and Digest Access Authentication"", RFC 2617, DOI 10.17487/RFC2617, June 1999, <https://www.rfc-editor.org/info/rfc2617>. 

[RFC2774]

Nielsen, H., Leach, P., and S. Lawrence, ""An HTTP Extension Framework"", RFC 2774, DOI 10.17487/RFC2774, February 2000, <https://www.rfc-editor.org/info/rfc2774>. 

[RFC2818]

Rescorla, E., ""HTTP Over TLS"", RFC 2818, DOI 10.17487/RFC2818, May 2000, <https://www.rfc-editor.org/info/rfc2818>. 

[RFC2978]

Freed, N. and J. Postel, ""IANA Charset Registration Procedures"", BCP 19, RFC 2978, DOI 10.17487/RFC2978, October 2000, <https://www.rfc-editor.org/info/rfc2978>. 

[RFC3040]

Cooper, I., Melve, I., and G. Tomlinson, ""Internet Web Replication and Caching Taxonomy"", RFC 3040, DOI 10.17487/RFC3040, January 2001, <https://www.rfc-editor.org/info/rfc3040>. 

[RFC3864]

Klyne, G., Nottingham, M., and J. Mogul, ""Registration Procedures for Message Header Fields"", BCP 90, RFC 3864, DOI 10.17487/RFC3864, September 2004, <https://www.rfc-editor.org/info/rfc3864>. 

[RFC3875]

Robinson, D. and K. Coar, ""The Common Gateway Interface (CGI) Version 1.1"", RFC 3875, DOI 10.17487/RFC3875, October 2004, <https://www.rfc-editor.org/info/rfc3875>. 

[RFC4033]

Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, ""DNS Security Introduction and Requirements"", RFC 4033, DOI 10.17487/RFC4033, March 2005, <https://www.rfc-editor.org/info/rfc4033>. 

[RFC4559]

Jaganathan, K., Zhu, L., and J. Brezak, ""SPNEGO-based Kerberos and NTLM HTTP Authentication in Microsoft Windows"", RFC 4559, DOI 10.17487/RFC4559, June 2006, <https://www.rfc-editor.org/info/rfc4559>. 

[RFC5789]

Dusseault, L. and J. Snell, ""PATCH Method for HTTP"", RFC 5789, DOI 10.17487/RFC5789, March 2010, <https://www.rfc-editor.org/info/rfc5789>. 

[RFC5905]

Mills, D., Martin, J., Ed., Burbank, J., and W. Kasch, ""Network Time Protocol Version 4: Protocol and Algorithms Specification"", RFC 5905, DOI 10.17487/RFC5905, June 2010, <https://www.rfc-editor.org/info/rfc5905>. 

[RFC6454]

Barth, A., ""The Web Origin Concept"", RFC 6454, DOI 10.17487/RFC6454, December 2011, <https://www.rfc-editor.org/info/rfc6454>. 

[RFC6585]

Nottingham, M. and R. Fielding, ""Additional HTTP Status Codes"", RFC 6585, DOI 10.17487/RFC6585, April 2012, <https://www.rfc-editor.org/info/rfc6585>. 

[RFC7230]

Fielding, R., Ed. and J. Reschke, Ed., ""Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing"", RFC 7230, DOI 10.17487/RFC7230, June 2014, <https://www.rfc-editor.org/info/rfc7230>. 

[RFC7231]

Fielding, R., Ed. and J. Reschke, Ed., ""Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content"", RFC 7231, DOI 10.17487/RFC7231, June 2014, <https://www.rfc-editor.org/info/rfc7231>. 

[RFC7232]

Fielding, R., Ed. and J. Reschke, Ed., ""Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests"", RFC 7232, DOI 10.17487/RFC7232, June 2014, <https://www.rfc-editor.org/info/rfc7232>. 

[RFC7233]

Fielding, R., Ed., Lafon, Y., Ed., and J. Reschke, Ed., ""Hypertext Transfer Protocol (HTTP/1.1): Range Requests"", RFC 7233, DOI 10.17487/RFC7233, June 2014, <https://www.rfc-editor.org/info/rfc7233>. 

[RFC7234]

Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., ""Hypertext Transfer Protocol (HTTP/1.1): Caching"", RFC 7234, DOI 10.17487/RFC7234, June 2014, <https://www.rfc-editor.org/info/rfc7234>. 

[RFC7235]

Fielding, R., Ed. and J. Reschke, Ed., ""Hypertext Transfer Protocol (HTTP/1.1): Authentication"", RFC 7235, DOI 10.17487/RFC7235, June 2014, <https://www.rfc-editor.org/info/rfc7235>. 

[RFC7538]

Reschke, J., ""The Hypertext Transfer Protocol Status Code 308 (Permanent Redirect)"", RFC 7538, DOI 10.17487/RFC7538, April 2015, <https://www.rfc-editor.org/info/rfc7538>. 

[RFC7540]

Belshe, M., Peon, R., and M. Thomson, Ed., ""Hypertext Transfer Protocol Version 2 (HTTP/2)"", RFC 7540, DOI 10.17487/RFC7540, May 2015, <https://www.rfc-editor.org/info/rfc7540>. 

[RFC7578]

Masinter, L., ""Returning Values from Forms: multipart/form-data"", RFC 7578, DOI 10.17487/RFC7578, July 2015, <https://www.rfc-editor.org/info/rfc7578>. 

[RFC7615]

Reschke, J., ""HTTP Authentication-Info and Proxy-Authentication-Info Response Header Fields"", RFC 7615, DOI 10.17487/RFC7615, September 2015, <https://www.rfc-editor.org/info/rfc7615>. 

[RFC7616]

Shekh-Yusef, R., Ed., Ahrens, D., and S. Bremer, ""HTTP Digest Access Authentication"", RFC 7616, DOI 10.17487/RFC7616, September 2015, <https://www.rfc-editor.org/info/rfc7616>. 

[RFC7617]

Reschke, J., ""The 'Basic' HTTP Authentication Scheme"", RFC 7617, DOI 10.17487/RFC7617, September 2015, <https://www.rfc-editor.org/info/rfc7617>. 

[RFC7694]

Reschke, J., ""Hypertext Transfer Protocol (HTTP) Client-Initiated Content-Encoding"", RFC 7694, DOI 10.17487/RFC7694, November 2015, <https://www.rfc-editor.org/info/rfc7694>. 

[RFC8126]

Cotton, M., Leiba, B., and T. Narten, ""Guidelines for Writing an IANA Considerations Section in RFCs"", BCP 26, RFC 8126, DOI 10.17487/RFC8126, June 2017, <https://www.rfc-editor.org/info/rfc8126>. 

[RFC8187]

Reschke, J., ""Indicating Character Encoding and Language for HTTP Header Field Parameters"", RFC 8187, DOI 10.17487/RFC8187, September 2017, <https://www.rfc-editor.org/info/rfc8187>. 

[RFC8246]

McManus, P., ""HTTP Immutable Responses"", RFC 8246, DOI 10.17487/RFC8246, September 2017, <https://www.rfc-editor.org/info/rfc8246>. 

[RFC8288]

Nottingham, M., ""Web Linking"", RFC 8288, DOI 10.17487/RFC8288, October 2017, <https://www.rfc-editor.org/info/rfc8288>. 

[RFC8336]

Nottingham, M. and E. Nygren, ""The ORIGIN HTTP/2 Frame"", RFC 8336, DOI 10.17487/RFC8336, March 2018, <https://www.rfc-editor.org/info/rfc8336>. 

[RFC8615]

Nottingham, M., ""Well-Known Uniform Resource Identifiers (URIs)"", RFC 8615, DOI 10.17487/RFC8615, May 2019, <https://www.rfc-editor.org/info/rfc8615>. 

[RFC8941]

Nottingham, M. and P-H. Kamp, ""Structured Field Values for HTTP"", RFC 8941, DOI 10.17487/RFC8941, February 2021, <https://www.rfc-editor.org/info/rfc8941>. 

[Sniffing]

WHATWG, ""MIME Sniffing"", <https://mimesniff.spec.whatwg.org>. 

[WEBDAV]

Dusseault, L., Ed., ""HTTP Extensions for Web Distributed Authoring and Versioning (WebDAV)"", RFC 4918, DOI 10.17487/RFC4918, June 2007, <https://www.rfc-editor.org/info/rfc4918>. 







Appendix A. Collected ABNF

In the collected ABNF below, list rules are expanded per Section 5.6.1.¶

Accept = [ ( media-range [ weight ] ) *( OWS "","" OWS ( media-range [
 weight ] ) ) ]
Accept-Charset = [ ( ( token / ""*"" ) [ weight ] ) *( OWS "","" OWS ( (
 token / ""*"" ) [ weight ] ) ) ]
Accept-Encoding = [ ( codings [ weight ] ) *( OWS "","" OWS ( codings [
 weight ] ) ) ]
Accept-Language = [ ( language-range [ weight ] ) *( OWS "","" OWS (
 language-range [ weight ] ) ) ]
Accept-Ranges = acceptable-ranges
Allow = [ method *( OWS "","" OWS method ) ]
Authentication-Info = [ auth-param *( OWS "","" OWS auth-param ) ]
Authorization = credentials

BWS = OWS

Connection = [ connection-option *( OWS "","" OWS connection-option )
 ]
Content-Encoding = [ content-coding *( OWS "","" OWS content-coding )
 ]
Content-Language = [ language-tag *( OWS "","" OWS language-tag ) ]
Content-Length = 1*DIGIT
Content-Location = absolute-URI / partial-URI
Content-Range = range-unit SP ( range-resp / unsatisfied-range )
Content-Type = media-type

Date = HTTP-date

ETag = entity-tag
Expect = [ expectation *( OWS "","" OWS expectation ) ]

From = mailbox

GMT = %x47.4D.54 ; GMT

HTTP-date = IMF-fixdate / obs-date
Host = uri-host [ "":"" port ]

IMF-fixdate = day-name "","" SP date1 SP time-of-day SP GMT
If-Match = ""*"" / [ entity-tag *( OWS "","" OWS entity-tag ) ]
If-Modified-Since = HTTP-date
If-None-Match = ""*"" / [ entity-tag *( OWS "","" OWS entity-tag ) ]
If-Range = entity-tag / HTTP-date
If-Unmodified-Since = HTTP-date

Last-Modified = HTTP-date
Location = URI-reference

Max-Forwards = 1*DIGIT

OWS = *( SP / HTAB )

Proxy-Authenticate = [ challenge *( OWS "","" OWS challenge ) ]
Proxy-Authentication-Info = [ auth-param *( OWS "","" OWS auth-param )
 ]
Proxy-Authorization = credentials

RWS = 1*( SP / HTAB )
Range = ranges-specifier
Referer = absolute-URI / partial-URI
Retry-After = HTTP-date / delay-seconds

Server = product *( RWS ( product / comment ) )

TE = [ t-codings *( OWS "","" OWS t-codings ) ]
Trailer = [ field-name *( OWS "","" OWS field-name ) ]

URI-reference = <URI-reference, see [URI], Section 4.1>
Upgrade = [ protocol *( OWS "","" OWS protocol ) ]
User-Agent = product *( RWS ( product / comment ) )

Vary = [ ( ""*"" / field-name ) *( OWS "","" OWS ( ""*"" / field-name ) )
 ]
Via = [ ( received-protocol RWS received-by [ RWS comment ] ) *( OWS
 "","" OWS ( received-protocol RWS received-by [ RWS comment ] ) ) ]

WWW-Authenticate = [ challenge *( OWS "","" OWS challenge ) ]

absolute-URI = <absolute-URI, see [URI], Section 4.3>
absolute-path = 1*( ""/"" segment )
acceptable-ranges = range-unit *( OWS "","" OWS range-unit )
asctime-date = day-name SP date3 SP time-of-day SP year
auth-param = token BWS ""="" BWS ( token / quoted-string )
auth-scheme = token
authority = <authority, see [URI], Section 3.2>

challenge = auth-scheme [ 1*SP ( token68 / [ auth-param *( OWS "",""
 OWS auth-param ) ] ) ]
codings = content-coding / ""identity"" / ""*""
comment = ""("" *( ctext / quoted-pair / comment ) "")""
complete-length = 1*DIGIT
connection-option = token
content-coding = token
credentials = auth-scheme [ 1*SP ( token68 / [ auth-param *( OWS "",""
 OWS auth-param ) ] ) ]
ctext = HTAB / SP / %x21-27 ; '!'-'''
 / %x2A-5B ; '*'-'['
 / %x5D-7E ; ']'-'~'
 / obs-text

date1 = day SP month SP year
date2 = day ""-"" month ""-"" 2DIGIT
date3 = month SP ( 2DIGIT / ( SP DIGIT ) )
day = 2DIGIT
day-name = %x4D.6F.6E ; Mon
 / %x54.75.65 ; Tue
 / %x57.65.64 ; Wed
 / %x54.68.75 ; Thu
 / %x46.72.69 ; Fri
 / %x53.61.74 ; Sat
 / %x53.75.6E ; Sun
day-name-l = %x4D.6F.6E.64.61.79 ; Monday
 / %x54.75.65.73.64.61.79 ; Tuesday
 / %x57.65.64.6E.65.73.64.61.79 ; Wednesday
 / %x54.68.75.72.73.64.61.79 ; Thursday
 / %x46.72.69.64.61.79 ; Friday
 / %x53.61.74.75.72.64.61.79 ; Saturday
 / %x53.75.6E.64.61.79 ; Sunday
delay-seconds = 1*DIGIT

entity-tag = [ weak ] opaque-tag
etagc = ""!"" / %x23-7E ; '#'-'~'
 / obs-text
expectation = token [ ""="" ( token / quoted-string ) parameters ]

field-content = field-vchar [ 1*( SP / HTAB / field-vchar )
 field-vchar ]
field-name = token
field-value = *field-content
field-vchar = VCHAR / obs-text
first-pos = 1*DIGIT

hour = 2DIGIT
http-URI = ""http://"" authority path-abempty [ ""?"" query ]
https-URI = ""https://"" authority path-abempty [ ""?"" query ]

incl-range = first-pos ""-"" last-pos
int-range = first-pos ""-"" [ last-pos ]

language-range = <language-range, see [RFC4647], Section 2.1>
language-tag = <Language-Tag, see [RFC5646], Section 2.1>
last-pos = 1*DIGIT

mailbox = <mailbox, see [RFC5322], Section 3.4>
media-range = ( ""*/*"" / ( type ""/*"" ) / ( type ""/"" subtype ) )
 parameters
media-type = type ""/"" subtype parameters
method = token
minute = 2DIGIT
month = %x4A.61.6E ; Jan
 / %x46.65.62 ; Feb
 / %x4D.61.72 ; Mar
 / %x41.70.72 ; Apr
 / %x4D.61.79 ; May
 / %x4A.75.6E ; Jun
 / %x4A.75.6C ; Jul
 / %x41.75.67 ; Aug
 / %x53.65.70 ; Sep
 / %x4F.63.74 ; Oct
 / %x4E.6F.76 ; Nov
 / %x44.65.63 ; Dec

obs-date = rfc850-date / asctime-date
obs-text = %x80-FF
opaque-tag = DQUOTE *etagc DQUOTE
other-range = 1*( %x21-2B ; '!'-'+'
 / %x2D-7E ; '-'-'~'
 )

parameter = parameter-name ""="" parameter-value
parameter-name = token
parameter-value = ( token / quoted-string )
parameters = *( OWS "";"" OWS [ parameter ] )
partial-URI = relative-part [ ""?"" query ]
path-abempty = <path-abempty, see [URI], Section 3.3>
port = <port, see [URI], Section 3.2.3>
product = token [ ""/"" product-version ]
product-version = token
protocol = protocol-name [ ""/"" protocol-version ]
protocol-name = token
protocol-version = token
pseudonym = token

qdtext = HTAB / SP / ""!"" / %x23-5B ; '#'-'['
 / %x5D-7E ; ']'-'~'
 / obs-text
query = <query, see [URI], Section 3.4>
quoted-pair = ""\"" ( HTAB / SP / VCHAR / obs-text )
quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE
qvalue = ( ""0"" [ ""."" *3DIGIT ] ) / ( ""1"" [ ""."" *3""0"" ] )

range-resp = incl-range ""/"" ( complete-length / ""*"" )
range-set = range-spec *( OWS "","" OWS range-spec )
range-spec = int-range / suffix-range / other-range
range-unit = token
ranges-specifier = range-unit ""="" range-set
received-by = pseudonym [ "":"" port ]
received-protocol = [ protocol-name ""/"" ] protocol-version
relative-part = <relative-part, see [URI], Section 4.2>
rfc850-date = day-name-l "","" SP date2 SP time-of-day SP GMT

second = 2DIGIT
segment = <segment, see [URI], Section 3.3>
subtype = token
suffix-length = 1*DIGIT
suffix-range = ""-"" suffix-length

t-codings = ""trailers"" / ( transfer-coding [ weight ] )
tchar = ""!"" / ""#"" / ""$"" / ""%"" / ""&"" / ""'"" / ""*"" / ""+"" / ""-"" / ""."" /
 ""^"" / ""_"" / ""`"" / ""|"" / ""~"" / DIGIT / ALPHA
time-of-day = hour "":"" minute "":"" second
token = 1*tchar
token68 = 1*( ALPHA / DIGIT / ""-"" / ""."" / ""_"" / ""~"" / ""+"" / ""/"" )
 *""=""
transfer-coding = token *( OWS "";"" OWS transfer-parameter )
transfer-parameter = token BWS ""="" BWS ( token / quoted-string )
type = token

unsatisfied-range = ""*/"" complete-length
uri-host = <host, see [URI], Section 3.2.2>

weak = %x57.2F ; W/
weight = OWS "";"" OWS ""q="" qvalue

year = 4DIGIT
¶






Appendix B. Changes from Previous RFCs




B.1. Changes from RFC 2818


   None.¶





B.2. Changes from RFC 7230


   The sections introducing HTTP's design goals, history, architecture,
   conformance criteria, protocol versioning, URIs, message routing, and
   header fields have been moved here.¶

   The requirement on semantic conformance has been replaced with permission to
   ignore or work around implementation-specific failures. 
   (Section 2.2)¶

   The description of an origin and authoritative access to origin servers has
   been extended for both ""http"" and ""https"" URIs to account for alternative
   services and secured connections that are not necessarily based on TCP. 
   (Sections 4.2.1, 4.2.2,
   4.3.1, and 7.3.3)¶

   Explicit requirements have been added to check the target URI scheme's semantics
   and reject requests that don't meet any associated requirements.
   (Section 7.4)¶

   Parameters in media type, media range, and expectation can be empty via
   one or more trailing semicolons. 
   (Section 5.6.6)¶

   ""Field value"" now refers to the value after multiple field lines are combined
   with commas -- by far the most common use. To refer to a single header
   line's value, use ""field line value"".
   (Section 6.3)¶

   Trailer field semantics now transcend the specifics of chunked transfer coding.
   The use of trailer fields has been further limited to allow generation
   as a trailer field only when the sender knows the field defines that usage and
   to allow merging into the header section only if the recipient knows the
   corresponding field definition permits and defines how to merge. In all
   other cases, implementations are encouraged either to store the trailer
   fields separately or to discard them instead of merging.
   (Section 6.5.1)¶

   The priority of the absolute form of the request URI over the Host
   header field by origin servers has been made explicit to align with proxy handling.
   (Section 7.2)¶

   The grammar definition for the Via field's ""received-by"" was
   expanded in RFC 7230 due to changes in the URI grammar for host
   [URI] that are not desirable for Via. For simplicity,
   we have removed uri-host from the received-by production because it can
   be encompassed by the existing grammar for pseudonym. In particular, this
   change removed comma from the allowed set of characters for a host name in
   received-by.
   (Section 7.6.3)¶





B.3. Changes from RFC 7231


   Minimum URI lengths to be supported by implementations are now recommended.
   (Section 4.1)¶

   The following have been clarified: CR and NUL in field values are to be rejected or
   mapped to SP, and leading and trailing whitespace needs to be
   stripped from field values before they are consumed.
   (Section 5.5)¶

   Parameters in media type, media range, and expectation can be empty via
   one or more trailing semicolons.
   (Section 5.6.6)¶

   An abstract data type for HTTP messages has been introduced to define the
   components of a message and their semantics as an abstraction across
   multiple HTTP versions, rather than in terms of the specific syntax form of
   HTTP/1.1 in [HTTP/1.1], and reflect the contents after the
   message is parsed. This makes it easier to distinguish between requirements
   on the content (what is conveyed) versus requirements on the messaging
   syntax (how it is conveyed) and avoids baking limitations of early protocol
   versions into the future of HTTP. (Section 6)¶

   The terms ""payload"" and ""payload body"" have been replaced with ""content"", to better
   align with its usage elsewhere (e.g., in field names) and to avoid confusion
   with frame payloads in HTTP/2 and HTTP/3.
   (Section 6.4)¶

   The term ""effective request URI"" has been replaced with ""target URI"".
   (Section 7.1)¶

   Restrictions on client retries have been loosened to reflect implementation
   behavior.
   (Section 9.2.2)¶

   The fact that request bodies on GET, HEAD, and DELETE are not interoperable has been clarified.
   (Sections 9.3.1, 9.3.2, and 9.3.5)¶

   The use of the Content-Range header field
   (Section 14.4) as a request modifier on PUT is allowed.
   (Section 9.3.4)¶

   A superfluous requirement about setting Content-Length
   has been removed from the description of the OPTIONS method.
   (Section 9.3.7)¶

   The normative requirement to use the ""message/http"" media type in
   TRACE responses has been removed.
   (Section 9.3.8)¶

   List-based grammar for Expect has been restored for compatibility with
   RFC 2616.
   (Section 10.1.1)¶

Accept and Accept-Encoding are allowed in response
   messages; the latter was introduced by [RFC7694].
   (Section 12.3)¶

   ""Accept Parameters"" (accept-params and accept-ext ABNF production) have
   been removed from the definition of the Accept field.
   (Section 12.5.1)¶

   The Accept-Charset field is now deprecated.
   (Section 12.5.2)¶

   The semantics of ""*"" in the Vary header field when other
   values are present was clarified.
   (Section 12.5.5)¶

   Range units are compared in a case-insensitive fashion.
   (Section 14.1)¶

   The use of the Accept-Ranges field is not restricted to origin servers.
   (Section 14.3)¶

   The process of creating a redirected request has been clarified.
   (Section 15.4)¶

   Status code 308 (previously defined in [RFC7538])
   has been added so that it's defined closer to status codes 301, 302, and 307.
   (Section 15.4.9)¶

   Status code 421 (previously defined in
   Section 9.1.2 of [RFC7540]) has been added because of its general
   applicability. 421 is no longer defined as heuristically cacheable since
   the response is specific to the connection (not the target resource).
   (Section 15.5.20)¶

   Status code 422 (previously defined in
   Section 11.2 of [WEBDAV]) has been added because of its general
   applicability.
   (Section 15.5.21)¶





B.4. Changes from RFC 7232


   Previous revisions of HTTP imposed an arbitrary 60-second limit on the
   determination of whether Last-Modified was a strong validator to guard
   against the possibility that the Date and Last-Modified values are
   generated from different clocks or at somewhat different times during the
   preparation of the response. This specification has relaxed that to allow
   reasonable discretion.
   (Section 8.8.2.2)¶

   An edge-case requirement on If-Match and If-Unmodified-Since
   has been removed that required a validator not to be sent in a 2xx
   response if validation fails because the change request has already
   been applied.
   (Sections 13.1.1 and
   13.1.4)¶

   The fact that If-Unmodified-Since does not apply to a resource without a
   concept of modification time has been clarified.
   (Section 13.1.4)¶

   Preconditions can now be evaluated before the request content is processed
   rather than waiting until the response would otherwise be successful.
   (Section 13.2)¶





B.5. Changes from RFC 7233


   Refactored the range-unit and ranges-specifier grammars to simplify
   and reduce artificial distinctions between bytes and other
   (extension) range units, removing the overlapping grammar of
   other-range-unit by defining range units generically as a token and
   placing extensions within the scope of a range-spec (other-range).
   This disambiguates the role of list syntax (commas) in all range sets,
   including extension range units, for indicating a range-set of more than
   one range. Moving the extension grammar into range specifiers also allows
   protocol specific to byte ranges to be specified separately.¶

   It is now possible to define Range handling on extension methods.
   (Section 14.2)¶

   Described use of the Content-Range header field
   (Section 14.4) as a request modifier to perform a
   partial PUT.
   (Section 14.5)¶





B.6. Changes from RFC 7235


   None.¶





B.7. Changes from RFC 7538


   None.¶





B.8. Changes from RFC 7615


   None.¶





B.9. Changes from RFC 7694


   This specification includes the extension defined in [RFC7694]
   but leaves out examples and deployment considerations.¶







Acknowledgements


   Aside from the current editors, the following individuals deserve special
   recognition for their contributions to early aspects of HTTP and its
   core specifications:
   Marc Andreessen, Tim Berners-Lee, Robert Cailliau, Daniel W. Connolly,
   Bob Denny, John Franks, Jim Gettys,
   Jean-François Groff,
   Phillip M. Hallam-Baker,
   Koen Holtman, Jeffery L. Hostetler, Shel Kaphan,
   Dave Kristol, Yves Lafon, Scott D. Lawrence,
   Paul J. Leach, Håkon W. Lie,
   Ari Luotonen, Larry Masinter, Rob McCool,
   Jeffrey C. Mogul, Lou Montulli,
   David Morris, Henrik Frystyk Nielsen, Dave Raggett, Eric Rescorla,
   Tony Sanders, Lawrence C. Stewart,
   Marc VanHeyningen, and Steve Zilles.¶

   This document builds on the many contributions
   that went into past specifications of HTTP, including
   [HTTP/1.0],
   [RFC2068],
   [RFC2145],
   [RFC2616],
   [RFC2617],
   [RFC2818],
   [RFC7230],
   [RFC7231],
   [RFC7232],
   [RFC7233],
   [RFC7234], and
   [RFC7235].
   The acknowledgements within those documents still apply.¶

   Since 2014, the following contributors have helped improve this
   specification by reporting bugs, asking smart questions, drafting or
   reviewing text, and evaluating issues:¶

Alan Egerton,
   Alex Rousskov,
   Amichai Rothman,
   Amos Jeffries,
   Anders Kaseorg,
   Andreas Gebhardt,
   Anne van Kesteren,
   Armin Abfalterer,
   Aron Duby,
   Asanka Herath,
   Asbjørn Ulsberg,
   Asta Olofsson,
   Attila Gulyas,
   Austin Wright,
   Barry Pollard,
   Ben Burkert,
   Benjamin Kaduk,
   Björn Höhrmann,
   Brad Fitzpatrick,
   Chris Pacejo,
   Colin Bendell,
   Cory Benfield,
   Cory Nelson,
   Daisuke Miyakawa,
   Dale Worley,
   Daniel Stenberg,
   Danil Suits,
   David Benjamin,
   David Matson,
   David Schinazi,
   Дилян Палаузов (Dilyan Palauzov),
   Eric Anderson,
   Eric Rescorla,
   Éric Vyncke,
   Erik Kline,
   Erwin Pe,
   Etan Kissling,
   Evert Pot,
   Evgeny Vrublevsky,
   Florian Best,
   Francesca Palombini,
   Igor Lubashev,
   James Callahan,
   James Peach,
   Jeffrey Yasskin,
   Kalin Gyokov,
   Kannan Goundan,
   奥 一穂 (Kazuho Oku),
   Ken Murchison,
   Krzysztof Maczyński,
   Lars Eggert,
   Lucas Pardue,
   Martin Duke,
   Martin Dürst,
   Martin Thomson,
   Martynas Jusevičius,
   Matt Menke,
   Matthias Pigulla,
   Mattias Grenfeldt,
   Michael Osipov,
   Mike Bishop,
   Mike Pennisi,
   Mike Taylor,
   Mike West,
   Mohit Sethi,
   Murray Kucherawy,
   Nathaniel J. Smith,
   Nicholas Hurley,
   Nikita Prokhorov,
   Patrick McManus,
   Piotr Sikora,
   Poul-Henning Kamp,
   Rick van Rein,
   Robert Wilton,
   Roberto Polli,
   Roman Danyliw,
   Samuel Williams,
   Semyon Kholodnov,
   Simon Pieters,
   Simon Schüppel,
   Stefan Eissing,
   Taylor Hunt,
   Todd Greer,
   Tommy Pauly,
   Vasiliy Faronov,
   Vladimir Lashchev,
   Wenbo Zhu,
   William A. Rowe Jr.,
   Willy Tarreau,
   Xingwei Liu,
   Yishuai Li, and
   Zaheduzzaman Sarker.¶




Index



1
2
3
4
5
A
B
C
D
E
F
G
H
I
L
M
N
O
P
R
S
T
U
V
W
X¶





1¶




100 Continue (status code)


Section 15.2.1¶


100-continue (expect value)


Section 10.1.1¶


101 Switching Protocols (status code)


Section 15.2.2¶


1xx Informational (status code class)


Section 15.2¶









2¶




200 OK (status code)


Section 15.3.1¶


201 Created (status code)


Section 15.3.2¶


202 Accepted (status code)


Section 15.3.3¶


203 Non-Authoritative Information (status code)


Section 15.3.4¶


204 No Content (status code)


Section 15.3.5¶


205 Reset Content (status code)


Section 15.3.6¶


206 Partial Content (status code)


Section 15.3.7¶


2xx Successful (status code class)


Section 15.3¶









3¶




300 Multiple Choices (status code)


Section 15.4.1¶


301 Moved Permanently (status code)


Section 15.4.2¶


302 Found (status code)


Section 15.4.3¶


303 See Other (status code)


Section 15.4.4¶


304 Not Modified (status code)


Section 15.4.5¶


305 Use Proxy (status code)


Section 15.4.6¶


306 (Unused) (status code)


Section 15.4.7¶


307 Temporary Redirect (status code)


Section 15.4.8¶


308 Permanent Redirect (status code)


Section 15.4.9¶


3xx Redirection (status code class)


Section 15.4¶









4¶




400 Bad Request (status code)


Section 15.5.1¶


401 Unauthorized (status code)


Section 15.5.2¶


402 Payment Required (status code)


Section 15.5.3¶


403 Forbidden (status code)


Section 15.5.4¶


404 Not Found (status code)


Section 15.5.5¶


405 Method Not Allowed (status code)


Section 15.5.6¶


406 Not Acceptable (status code)


Section 15.5.7¶


407 Proxy Authentication Required (status code)


Section 15.5.8¶


408 Request Timeout (status code)


Section 15.5.9¶


409 Conflict (status code)


Section 15.5.10¶


410 Gone (status code)


Section 15.5.11¶


411 Length Required (status code)


Section 15.5.12¶


412 Precondition Failed (status code)


Section 15.5.13¶


413 Content Too Large (status code)


Section 15.5.14¶


414 URI Too Long (status code)


Section 15.5.15¶


415 Unsupported Media Type (status code)


Section 15.5.16¶


416 Range Not Satisfiable (status code)


Section 15.5.17¶


417 Expectation Failed (status code)


Section 15.5.18¶


418 (Unused) (status code)


Section 15.5.19¶


421 Misdirected Request (status code)


Section 15.5.20¶


422 Unprocessable Content (status code)


Section 15.5.21¶


426 Upgrade Required (status code)


Section 15.5.22¶


4xx Client Error (status code class)


Section 15.5¶









5¶




500 Internal Server Error (status code)


Section 15.6.1¶


501 Not Implemented (status code)


Section 15.6.2¶


502 Bad Gateway (status code)


Section 15.6.3¶


503 Service Unavailable (status code)


Section 15.6.4¶


504 Gateway Timeout (status code)


Section 15.6.5¶


505 HTTP Version Not Supported (status code)


Section 15.6.6¶


5xx Server Error (status code class)


Section 15.6¶









A¶




accelerator


Section 3.7, Paragraph 6¶


Accept header field


Section 12.5.1¶


Accept-Charset header field


Section 12.5.2¶


Accept-Encoding header field


Section 12.5.3¶


Accept-Language header field


Section 12.5.4¶


Accept-Ranges header field


Section 14.3¶


Allow header field


Section 10.2.1¶


Authentication-Info header field


Section 11.6.3¶


authoritative response


Section 17.1¶


Authorization header field


Section 11.6.2¶









B¶




browser


Section 3.5¶









C¶




cache


Section 3.8¶


cacheable


Section 3.8, Paragraph 4¶


client


Section 3.3¶


clock


Section 5.6.7¶


complete


Section 6.1¶


compress (Coding Format)


Section 8.4.1.1¶


compress (content coding)


Section 8.4.1¶


conditional request


Section 13¶


CONNECT method


Section 9.3.6¶


connection


Section 3.3¶


Connection header field


Section 7.6.1¶


content


Section 6.4¶


content coding


Section 8.4.1¶


content negotiation


Section 1.3, Paragraph 4¶


Content-Encoding header field


Section 8.4¶


Content-Language header field


Section 8.5¶


Content-Length header field


Section 8.6¶


Content-Location header field


Section 8.7¶


Content-MD5 header field


Section 18.4, Paragraph 10¶


Content-Range header field


Section 14.4; 
Section 14.5¶


Content-Type header field


Section 8.3¶


control data


Section 6.2¶









D¶




Date header field


Section 6.6.1¶


deflate (Coding Format)


Section 8.4.1.2¶


deflate (content coding)


Section 8.4.1¶


DELETE method


Section 9.3.5¶


Delimiters


Section 5.6.2, Paragraph 3¶


downstream


Section 3.7, Paragraph 4¶









E¶




effective request URI


Section 7.1, Paragraph 8.1¶


ETag field


Section 8.8.3¶


Expect header field


Section 10.1.1¶









F¶




field


Section 5; 
Section 6.3¶


field line


Section 5.2, Paragraph 1¶


field line value


Section 5.2, Paragraph 1¶


field name


Section 5.2, Paragraph 1¶


field value


Section 5.2, Paragraph 2¶


Fields





*


Section 18.4, Paragraph 9¶


Accept


Section 12.5.1¶


Accept-Charset


Section 12.5.2¶


Accept-Encoding


Section 12.5.3¶


Accept-Language


Section 12.5.4¶


Accept-Ranges


Section 14.3¶


Allow


Section 10.2.1¶


Authentication-Info


Section 11.6.3¶


Authorization


Section 11.6.2¶


Connection


Section 7.6.1¶


Content-Encoding


Section 8.4¶


Content-Language


Section 8.5¶


Content-Length


Section 8.6¶


Content-Location


Section 8.7¶


Content-MD5


Section 18.4, Paragraph 10¶


Content-Range


Section 14.4; 
Section 14.5¶


Content-Type


Section 8.3¶


Date


Section 6.6.1¶


ETag


Section 8.8.3¶


Expect


Section 10.1.1¶


From


Section 10.1.2¶


Host


Section 7.2¶


If-Match


Section 13.1.1¶


If-Modified-Since


Section 13.1.3¶


If-None-Match


Section 13.1.2¶


If-Range


Section 13.1.5¶


If-Unmodified-Since


Section 13.1.4¶


Last-Modified


Section 8.8.2¶


Location


Section 10.2.2¶


Max-Forwards


Section 7.6.2¶


Proxy-Authenticate


Section 11.7.1¶


Proxy-Authentication-Info


Section 11.7.3¶


Proxy-Authorization


Section 11.7.2¶


Range


Section 14.2¶


Referer


Section 10.1.3¶


Retry-After


Section 10.2.3¶


Server


Section 10.2.4¶


TE


Section 10.1.4¶


Trailer


Section 6.6.2¶


Upgrade


Section 7.8¶


User-Agent


Section 10.1.5¶


Vary


Section 12.5.5¶


Via


Section 7.6.3¶


WWW-Authenticate


Section 11.6.1¶





Fragment Identifiers


Section 4.2.5¶


From header field


Section 10.1.2¶









G¶




gateway


Section 3.7, Paragraph 6¶


GET method


Section 9.3.1¶


Grammar





ALPHA


Section 2.1¶


Accept


Section 12.5.1¶


Accept-Charset


Section 12.5.2¶


Accept-Encoding


Section 12.5.3¶


Accept-Language


Section 12.5.4¶


Accept-Ranges


Section 14.3¶


Allow


Section 10.2.1¶


Authentication-Info


Section 11.6.3¶


Authorization


Section 11.6.2¶


BWS


Section 5.6.3¶


CR


Section 2.1¶


CRLF


Section 2.1¶


CTL


Section 2.1¶


Connection


Section 7.6.1¶


Content-Encoding


Section 8.4¶


Content-Language


Section 8.5¶


Content-Length


Section 8.6¶


Content-Location


Section 8.7¶


Content-Range


Section 14.4¶


Content-Type


Section 8.3¶


DIGIT


Section 2.1¶


DQUOTE


Section 2.1¶


Date


Section 6.6.1¶


ETag


Section 8.8.3¶


Expect


Section 10.1.1¶


From


Section 10.1.2¶


GMT


Section 5.6.7¶


HEXDIG


Section 2.1¶


HTAB


Section 2.1¶


HTTP-date


Section 5.6.7¶


Host


Section 7.2¶


IMF-fixdate


Section 5.6.7¶


If-Match


Section 13.1.1¶


If-Modified-Since


Section 13.1.3¶


If-None-Match


Section 13.1.2¶


If-Range


Section 13.1.5¶


If-Unmodified-Since


Section 13.1.4¶


LF


Section 2.1¶


Last-Modified


Section 8.8.2¶


Location


Section 10.2.2¶


Max-Forwards


Section 7.6.2¶


OCTET


Section 2.1¶


OWS


Section 5.6.3¶


Proxy-Authenticate


Section 11.7.1¶


Proxy-Authentication-Info


Section 11.7.3¶


Proxy-Authorization


Section 11.7.2¶


RWS


Section 5.6.3¶


Range


Section 14.2¶


Referer


Section 10.1.3¶


Retry-After


Section 10.2.3¶


SP


Section 2.1¶


Server


Section 10.2.4¶


TE


Section 10.1.4¶


Trailer


Section 6.6.2¶


URI-reference


Section 4.1¶


Upgrade


Section 7.8¶


User-Agent


Section 10.1.5¶


VCHAR


Section 2.1¶


Vary


Section 12.5.5¶


Via


Section 7.6.3¶


WWW-Authenticate


Section 11.6.1¶


absolute-URI


Section 4.1¶


absolute-path


Section 4.1¶


acceptable-ranges


Section 14.3¶


asctime-date


Section 5.6.7¶


auth-param


Section 11.2¶


auth-scheme


Section 11.1¶


authority


Section 4.1¶


challenge


Section 11.3¶


codings


Section 12.5.3¶


comment


Section 5.6.5¶


complete-length


Section 14.4¶


connection-option


Section 7.6.1¶


content-coding


Section 8.4.1¶


credentials


Section 11.4¶


ctext


Section 5.6.5¶


date1


Section 5.6.7¶


day


Section 5.6.7¶


day-name


Section 5.6.7¶


day-name-l


Section 5.6.7¶


delay-seconds


Section 10.2.3¶


entity-tag


Section 8.8.3¶


etagc


Section 8.8.3¶


field-content


Section 5.5¶


field-name


Section 5.1; 
Section 6.6.2¶


field-value


Section 5.5¶


field-vchar


Section 5.5¶


first-pos


Section 14.1.1; 
Section 14.4¶


hour


Section 5.6.7¶


http-URI


Section 4.2.1¶


https-URI


Section 4.2.2¶


incl-range


Section 14.4¶


int-range


Section 14.1.1¶


language-range


Section 12.5.4¶


language-tag


Section 8.5.1¶


last-pos


Section 14.1.1; 
Section 14.4¶


media-range


Section 12.5.1¶


media-type


Section 8.3.1¶


method


Section 9.1¶


minute


Section 5.6.7¶


month


Section 5.6.7¶


obs-date


Section 5.6.7¶


obs-text


Section 5.5¶


opaque-tag


Section 8.8.3¶


other-range


Section 14.1.1¶


parameter


Section 5.6.6¶


parameter-name


Section 5.6.6¶


parameter-value


Section 5.6.6¶


parameters


Section 5.6.6¶


partial-URI


Section 4.1¶


port


Section 4.1¶


product


Section 10.1.5¶


product-version


Section 10.1.5¶


protocol-name


Section 7.6.3¶


protocol-version


Section 7.6.3¶


pseudonym


Section 7.6.3¶


qdtext


Section 5.6.4¶


query


Section 4.1¶


quoted-pair


Section 5.6.4¶


quoted-string


Section 5.6.4¶


qvalue


Section 12.4.2¶


range-resp


Section 14.4¶


range-set


Section 14.1.1¶


range-spec


Section 14.1.1¶


range-unit


Section 14.1¶


ranges-specifier


Section 14.1.1¶


received-by


Section 7.6.3¶


received-protocol


Section 7.6.3¶


rfc850-date


Section 5.6.7¶


second


Section 5.6.7¶


segment


Section 4.1¶


subtype


Section 8.3.1¶


suffix-length


Section 14.1.1¶


suffix-range


Section 14.1.1¶


t-codings


Section 10.1.4¶


tchar


Section 5.6.2¶


time-of-day


Section 5.6.7¶


token


Section 5.6.2¶


token68


Section 11.2¶


transfer-coding


Section 10.1.4¶


transfer-parameter


Section 10.1.4¶


type


Section 8.3.1¶


unsatisfied-range


Section 14.4¶


uri-host


Section 4.1¶


weak


Section 8.8.3¶


weight


Section 12.4.2¶


year


Section 5.6.7¶





gzip (Coding Format)


Section 8.4.1.3¶


gzip (content coding)


Section 8.4.1¶









H¶




HEAD method


Section 9.3.2¶


Header Fields





Accept


Section 12.5.1¶


Accept-Charset


Section 12.5.2¶


Accept-Encoding


Section 12.5.3¶


Accept-Language


Section 12.5.4¶


Accept-Ranges


Section 14.3¶


Allow


Section 10.2.1¶


Authentication-Info


Section 11.6.3¶


Authorization


Section 11.6.2¶


Connection


Section 7.6.1¶


Content-Encoding


Section 8.4¶


Content-Language


Section 8.5¶


Content-Length


Section 8.6¶


Content-Location


Section 8.7¶


Content-MD5


Section 18.4, Paragraph 10¶


Content-Range


Section 14.4; 
Section 14.5¶


Content-Type


Section 8.3¶


Date


Section 6.6.1¶


ETag


Section 8.8.3¶


Expect


Section 10.1.1¶


From


Section 10.1.2¶


Host


Section 7.2¶


If-Match


Section 13.1.1¶


If-Modified-Since


Section 13.1.3¶


If-None-Match


Section 13.1.2¶


If-Range


Section 13.1.5¶


If-Unmodified-Since


Section 13.1.4¶


Last-Modified


Section 8.8.2¶


Location


Section 10.2.2¶


Max-Forwards


Section 7.6.2¶


Proxy-Authenticate


Section 11.7.1¶


Proxy-Authentication-Info


Section 11.7.3¶


Proxy-Authorization


Section 11.7.2¶


Range


Section 14.2¶


Referer


Section 10.1.3¶


Retry-After


Section 10.2.3¶


Server


Section 10.2.4¶


TE


Section 10.1.4¶


Trailer


Section 6.6.2¶


Upgrade


Section 7.8¶


User-Agent


Section 10.1.5¶


Vary


Section 12.5.5¶


Via


Section 7.6.3¶


WWW-Authenticate


Section 11.6.1¶





header section


Section 6.3¶


Host header field


Section 7.2¶


http URI scheme


Section 4.2.1¶


https URI scheme


Section 4.2.2¶









I¶




idempotent


Section 9.2.2¶


If-Match header field


Section 13.1.1¶


If-Modified-Since header field


Section 13.1.3¶


If-None-Match header field


Section 13.1.2¶


If-Range header field


Section 13.1.5¶


If-Unmodified-Since header field


Section 13.1.4¶


inbound


Section 3.7, Paragraph 4¶


incomplete


Section 6.1¶


interception proxy


Section 3.7, Paragraph 10¶


intermediary


Section 3.7¶









L¶




Last-Modified header field


Section 8.8.2¶


list-based field


Section 5.5, Paragraph 7¶


Location header field


Section 10.2.2¶









M¶




Max-Forwards header field


Section 7.6.2¶


Media Type





multipart/byteranges


Section 14.6¶


multipart/x-byteranges


Section 14.6, Paragraph 4, Item 3¶





message


Section 3.4; 
Section 6¶


message abstraction


Section 6¶


messages


Section 3.4¶


metadata


Section 8.8¶


Method





*


Section 18.2, Paragraph 3¶


CONNECT


Section 9.3.6¶


DELETE


Section 9.3.5¶


GET


Section 9.3.1¶


HEAD


Section 9.3.2¶


OPTIONS


Section 9.3.7¶


POST


Section 9.3.3¶


PUT


Section 9.3.4¶


TRACE


Section 9.3.8¶





multipart/byteranges Media Type


Section 14.6¶


multipart/x-byteranges Media Type


Section 14.6, Paragraph 4, Item 3¶









N¶




non-transforming proxy


Section 7.7¶









O¶




OPTIONS method


Section 9.3.7¶


origin


Section 4.3.1; 
Section 11.5¶


origin server


Section 3.6¶


outbound


Section 3.7, Paragraph 4¶









P¶




phishing


Section 17.1¶


POST method


Section 9.3.3¶


Protection Space


Section 11.5¶


proxy


Section 3.7, Paragraph 5¶


Proxy-Authenticate header field


Section 11.7.1¶


Proxy-Authentication-Info header field


Section 11.7.3¶


Proxy-Authorization header field


Section 11.7.2¶


PUT method


Section 9.3.4¶









R¶




Range header field


Section 14.2¶


Realm


Section 11.5¶


recipient


Section 3.4¶


Referer header field


Section 10.1.3¶


representation


Section 3.2¶


request


Section 3.4¶


request target


Section 7.1¶


resource


Section 3.1; 
Section 4¶


response


Section 3.4¶


Retry-After header field


Section 10.2.3¶


reverse proxy


Section 3.7, Paragraph 6¶









S¶




safe


Section 9.2.1¶


satisfiable range


Section 14.1.1¶


secured


Section 4.2.2¶


selected representation


Section 3.2, Paragraph 4; 
Section 8.8; 
Section 13.1¶


self-descriptive


Section 6¶


sender


Section 3.4¶


server


Section 3.3¶


Server header field


Section 10.2.4¶


singleton field


Section 5.5, Paragraph 6¶


spider


Section 3.5¶


Status Code


Section 15¶


Status Codes





Final


Section 15, Paragraph 7¶


Informational


Section 15, Paragraph 7¶


Interim


Section 15, Paragraph 7¶





Status Codes Classes





1xx Informational


Section 15.2¶


2xx Successful


Section 15.3¶


3xx Redirection


Section 15.4¶


4xx Client Error


Section 15.5¶


5xx Server Error


Section 15.6¶












T¶




target resource


Section 7.1¶


target URI


Section 7.1¶


TE header field


Section 10.1.4¶


TRACE method


Section 9.3.8¶


Trailer Fields


Section 6.5¶





ETag


Section 8.8.3¶





Trailer header field


Section 6.6.2¶


trailer section


Section 6.5¶


trailers


Section 6.5¶


transforming proxy


Section 7.7¶


transparent proxy


Section 3.7, Paragraph 10¶


tunnel


Section 3.7, Paragraph 8¶









U¶




unsatisfiable range


Section 14.1.1¶


Upgrade header field


Section 7.8¶


upstream


Section 3.7, Paragraph 4¶


URI


Section 4¶





origin


Section 4.3.1¶





URI reference


Section 4.1¶


URI scheme





http


Section 4.2.1¶


https


Section 4.2.2¶





user agent


Section 3.5¶


User-Agent header field


Section 10.1.5¶









V¶




validator


Section 8.8¶





strong


Section 8.8.1¶


weak


Section 8.8.1¶





Vary header field


Section 12.5.5¶


Via header field


Section 7.6.3¶









W¶




WWW-Authenticate header field


Section 11.6.1¶









X¶




x-compress (content coding)


Section 8.4.1¶


x-gzip (content coding)


Section 8.4.1¶











Authors' Addresses


Roy T. Fielding (editor)
Adobe
345 Park AveSan Jose, CA 95110
United States of America

Email:
fielding@gbiv.com


URI:
https://roy.gbiv.com/



Mark Nottingham (editor)
Fastly
Prahran
Australia

Email:
mnot@mnot.net


URI:
https://www.mnot.net/



Julian Reschke (editor)
greenbytes GmbH
Hafenweg 1648155 Münster
Germany

Email:
julian.reschke@greenbytes.de


URI:
https://greenbytes.de/tech/webdav/





"
RFC4120,"
[RFC Home] [TEXT|PDF|HTML] [Tracker] [IPR] [Errata] [Info page]          Updated by: 4537, 5021, 5896, 6111, 6112, 6113, 6649,  PROPOSED STANDARD 6806, 7751, 8062, 8129, 8429, 8553 Errata ExistNetwork Working Group                                          C. Neuman
Request for Comments: 4120                                       USC-ISI
Obsoletes: 1510                                                    T. Yu
Category: Standards Track                                     S. Hartman
                                                              K. Raeburn
                                                                     MIT
                                                               July 2005


            The Kerberos Network Authentication Service (V5)

Status of This Memo

   This document specifies an Internet standards track protocol for the
   Internet community, and requests discussion and suggestions for
   improvements.  Please refer to the current edition of the Internet
   Official Protocol Standards"" (STD 1) for the standardization state
   and status of this protocol.  Distribution of this memo is unlimited.

Copyright Notice

   Copyright (C) The Internet Society (2005).

Abstract

   This document provides an overview and specification of Version 5 of
   the Kerberos protocol, and it obsoletes RFC 1510 to clarify aspects
   of the protocol and its intended use that require more detailed or
   clearer explanation than was provided in RFC 1510.  This document is
   intended to provide a detailed description of the protocol, suitable
   for implementation, together with descriptions of the appropriate use
   of protocol messages and fields within those messages.



















Neuman, et al.              Standards Track                     [Page 1]

RFC 4120                      Kerberos V5                      July 2005


Table of Contents

   1. Introduction ....................................................5
      1.1. The Kerberos Protocol ......................................6
      1.2. Cross-Realm Operation ......................................8
      1.3. Choosing a Principal with Which to Communicate .............9
      1.4. Authorization .............................................10
      1.5. Extending Kerberos without Breaking Interoperability ......11
           1.5.1. Compatibility with RFC 1510 ........................11
           1.5.2. Sending Extensible Messages ........................12
      1.6. Environmental Assumptions .................................12
      1.7. Glossary of Terms .........................................13
   2. Ticket Flag Uses and Requests ..................................16
      2.1. Initial, Pre-authenticated, and
           Hardware-Authenticated Tickets ............................17
      2.2. Invalid Tickets ...........................................17
      2.3. Renewable Tickets .........................................17
      2.4. Postdated Tickets .........................................18
      2.5. Proxiable and Proxy Tickets ...............................19
      2.6. Forwardable Tickets .......................................19
      2.7. Transited Policy Checking .................................20
      2.8. OK as Delegate ............................................21
      2.9. Other KDC Options .........................................21
           2.9.1. Renewable-OK .......................................21
           2.9.2. ENC-TKT-IN-SKEY ....................................22
           2.9.3. Passwordless Hardware Authentication ...............22
   3. Message Exchanges ..............................................22
      3.1. The Authentication Service Exchange .......................22
           3.1.1. Generation of KRB_AS_REQ Message ...................24
           3.1.2. Receipt of KRB_AS_REQ Message ......................24
           3.1.3. Generation of KRB_AS_REP Message ...................24
           3.1.4. Generation of KRB_ERROR Message ....................27
           3.1.5. Receipt of KRB_AS_REP Message ......................27
           3.1.6. Receipt of KRB_ERROR Message .......................28
      3.2. The Client/Server Authentication Exchange .................29
           3.2.1. The KRB_AP_REQ Message .............................29
           3.2.2. Generation of a KRB_AP_REQ Message .................29
           3.2.3. Receipt of KRB_AP_REQ Message ......................30
           3.2.4. Generation of a KRB_AP_REP Message .................33
           3.2.5. Receipt of KRB_AP_REP Message ......................33
           3.2.6. Using the Encryption Key ...........................33
      3.3. The Ticket-Granting Service (TGS) Exchange ................34
           3.3.1. Generation of KRB_TGS_REQ Message ..................35
           3.3.2. Receipt of KRB_TGS_REQ Message .....................37
           3.3.3. Generation of KRB_TGS_REP Message ..................38
           3.3.4. Receipt of KRB_TGS_REP Message .....................42





Neuman, et al.              Standards Track                     [Page 2]

RFC 4120                      Kerberos V5                      July 2005


      3.4. The KRB_SAFE Exchange .....................................42
           3.4.1. Generation of a KRB_SAFE Message ...................42
           3.4.2. Receipt of KRB_SAFE Message ........................43
      3.5. The KRB_PRIV Exchange .....................................44
           3.5.1. Generation of a KRB_PRIV Message ...................44
           3.5.2. Receipt of KRB_PRIV Message ........................44
      3.6. The KRB_CRED Exchange .....................................45
           3.6.1. Generation of a KRB_CRED Message ...................45
           3.6.2. Receipt of KRB_CRED Message ........................46
      3.7. User-to-User Authentication Exchanges .....................47
   4. Encryption and Checksum Specifications .........................48
   5. Message Specifications .........................................50
      5.1. Specific Compatibility Notes on ASN.1 .....................51
           5.1.1. ASN.1 Distinguished Encoding Rules .................51
           5.1.2. Optional Integer Fields ............................52
           5.1.3. Empty SEQUENCE OF Types ............................52
           5.1.4. Unrecognized Tag Numbers ...........................52
           5.1.5. Tag Numbers Greater Than 30 ........................53
      5.2. Basic Kerberos Types ......................................53
           5.2.1. KerberosString .....................................53
           5.2.2. Realm and PrincipalName ............................55
           5.2.3. KerberosTime .......................................55
           5.2.4. Constrained Integer Types ..........................55
           5.2.5. HostAddress and HostAddresses ......................56
           5.2.6. AuthorizationData ..................................57
           5.2.7. PA-DATA ............................................60
           5.2.8. KerberosFlags ......................................64
           5.2.9. Cryptosystem-Related Types .........................65
      5.3. Tickets ...................................................66
      5.4. Specifications for the AS and TGS Exchanges ...............73
           5.4.1. KRB_KDC_REQ Definition .............................73
           5.4.2. KRB_KDC_REP Definition .............................81
      5.5. Client/Server (CS) Message Specifications .................84
           5.5.1. KRB_AP_REQ Definition ..............................84
           5.5.2. KRB_AP_REP Definition ..............................88
           5.5.3. Error Message Reply ................................89
      5.6. KRB_SAFE Message Specification ............................89
           5.6.1. KRB_SAFE definition ................................89
      5.7. KRB_PRIV Message Specification ............................91
           5.7.1. KRB_PRIV Definition ................................91
      5.8. KRB_CRED Message Specification ............................92
           5.8.1. KRB_CRED Definition ................................92
      5.9. Error Message Specification ...............................94
           5.9.1. KRB_ERROR Definition ...............................94
      5.10. Application Tag Numbers ..................................96






Neuman, et al.              Standards Track                     [Page 3]

RFC 4120                      Kerberos V5                      July 2005


   6. Naming Constraints .............................................97
      6.1. Realm Names ...............................................97
      6.2. Principal Names .......................................... 99
           6.2.1. Name of Server Principals .........................100
   7. Constants and Other Defined Values ............................101
      7.1. Host Address Types .......................................101
      7.2. KDC Messaging: IP Transports .............................102
           7.2.1. UDP/IP transport ..................................102
           7.2.2. TCP/IP Transport ..................................103
           7.2.3. KDC Discovery on IP Networks ......................104
      7.3. Name of the TGS ..........................................105
      7.4. OID Arc for KerberosV5 ...................................106
      7.5. Protocol Constants and Associated Values .................106
           7.5.1. Key Usage Numbers .................................106
           7.5.2. PreAuthentication Data Types ......................108
           7.5.3. Address Types .....................................109
           7.5.4. Authorization Data Types ..........................109
           7.5.5. Transited Encoding Types ..........................109
           7.5.6. Protocol Version Number ...........................109
           7.5.7. Kerberos Message Types ............................110
           7.5.8. Name Types ........................................110
           7.5.9. Error Codes .......................................110
   8. Interoperability Requirements .................................113
      8.1. Specification 2 ..........................................113
      8.2. Recommended KDC Values ...................................116
   9. IANA Considerations ...........................................116
   10. Security Considerations ......................................117
   11. Acknowledgements .............................................121
   A. ASN.1 Module ..................................................123
   B. Changes since RFC 1510 ........................................131
   Normative References .............................................134
   Informative References ...........................................135



















Neuman, et al.              Standards Track                     [Page 4]

RFC 4120                      Kerberos V5                      July 2005


1.  Introduction

   This document describes the concepts and model upon which the
   Kerberos network authentication system is based.  It also specifies
   Version 5 of the Kerberos protocol.  The motivations, goals,
   assumptions, and rationale behind most design decisions are treated
   cursorily; they are more fully described in a paper available in IEEE
   communications [NT94] and earlier in the Kerberos portion of the
   Athena Technical Plan [MNSS87].

   This document is not intended to describe Kerberos to the end user,
   system administrator, or application developer.  Higher-level papers
   describing Version 5 of the Kerberos system [NT94] and documenting
   version 4 [SNS88] are available elsewhere.

   The Kerberos model is based in part on Needham and Schroeder's
   trusted third-party authentication protocol [NS78] and on
   modifications suggested by Denning and Sacco [DS81].  The original
   design and implementation of Kerberos Versions 1 through 4 was the
   work of two former Project Athena staff members, Steve Miller of
   Digital Equipment Corporation and Clifford Neuman (now at the
   Information Sciences Institute of the University of Southern
   California), along with Jerome Saltzer, Technical Director of Project
   Athena, and Jeffrey Schiller, MIT Campus Network Manager.  Many other
   members of Project Athena have also contributed to the work on
   Kerberos.

   Version 5 of the Kerberos protocol (described in this document) has
   evolved because of new requirements and desires for features not
   available in Version 4.  The design of Version 5 was led by Clifford
   Neuman and John Kohl with much input from the community.  The
   development of the MIT reference implementation was led at MIT by
   John Kohl and Theodore Ts'o, with help and contributed code from many
   others.  Since RFC 1510 was issued, many individuals have proposed
   extensions and revisions to the protocol.  This document reflects
   some of these proposals.  Where such changes involved significant
   effort, the document cites the contribution of the proposer.

   Reference implementations of both Version 4 and Version 5 of Kerberos
   are publicly available, and commercial implementations have been
   developed and are widely used.  Details on the differences between
   Versions 4 and 5 can be found in [KNT94].

   The key words ""MUST"", ""MUST NOT"", ""REQUIRED"", ""SHALL"", ""SHALL NOT"",
   ""SHOULD"", ""SHOULD NOT"", ""RECOMMENDED"", ""MAY"", and ""OPTIONAL"" in this
   document are to be interpreted as described in [RFC2119].





Neuman, et al.              Standards Track                     [Page 5]

RFC 4120                      Kerberos V5                      July 2005


1.1.  The Kerberos Protocol

   Kerberos provides a means of verifying the identities of principals,
   (e.g., a workstation user or a network server) on an open
   (unprotected) network.  This is accomplished without relying on
   assertions by the host operating system, without basing trust on host
   addresses, without requiring physical security of all the hosts on
   the network, and under the assumption that packets traveling along
   the network can be read, modified, and inserted at will.  Kerberos
   performs authentication under these conditions as a trusted third-
   party authentication service by using conventional (shared secret
   key) cryptography.  Extensions to Kerberos (outside the scope of this
   document) can provide for the use of public key cryptography during
   certain phases of the authentication protocol.  Such extensions
   support Kerberos authentication for users registered with public key
   certification authorities and provide certain benefits of public key
   cryptography in situations where they are needed.

   The basic Kerberos authentication process proceeds as follows: A
   client sends a request to the authentication server (AS) for
   ""credentials"" for a given server.  The AS responds with these
   credentials, encrypted in the client's key.  The credentials consist
   of a ""ticket"" for the server and a temporary encryption key (often
   called a ""session key"").  The client transmits the ticket (which
   contains the client's identity and a copy of the session key, all
   encrypted in the server's key) to the server.  The session key (now
   shared by the client and server) is used to authenticate the client
   and may optionally be used to authenticate the server.  It may also
   be used to encrypt further communication between the two parties or
   to exchange a separate sub-session key to be used to encrypt further
   communication.  Note that many applications use Kerberos' functions
   only upon the initiation of a stream-based network connection.
   Unless an application performs encryption or integrity protection for
   the data stream, the identity verification applies only to the
   initiation of the connection, and it does not guarantee that
   subsequent messages on the connection originate from the same
   principal.

   Implementation of the basic protocol consists of one or more
   authentication servers running on physically secure hosts.  The
   authentication servers maintain a database of principals (i.e., users
   and servers) and their secret keys.  Code libraries provide
   encryption and implement the Kerberos protocol.  In order to add
   authentication to its transactions, a typical network application
   adds calls to the Kerberos library directly or through the Generic
   Security Services Application Programming Interface (GSS-API)
   described in a separate document [RFC4121].  These calls result in
   the transmission of the messages necessary to achieve authentication.



Neuman, et al.              Standards Track                     [Page 6]

RFC 4120                      Kerberos V5                      July 2005


   The Kerberos protocol consists of several sub-protocols (or
   exchanges).  There are two basic methods by which a client can ask a
   Kerberos server for credentials.  In the first approach, the client
   sends a cleartext request for a ticket for the desired server to the
   AS.  The reply is sent encrypted in the client's secret key.  Usually
   this request is for a ticket-granting ticket (TGT), which can later
   be used with the ticket-granting server (TGS).  In the second method,
   the client sends a request to the TGS.  The client uses the TGT to
   authenticate itself to the TGS in the same manner as if it were
   contacting any other application server that requires Kerberos
   authentication.  The reply is encrypted in the session key from the
   TGT.  Though the protocol specification describes the AS and the TGS
   as separate servers, in practice they are implemented as different
   protocol entry points within a single Kerberos server.

   Once obtained, credentials may be used to verify the identity of the
   principals in a transaction, to ensure the integrity of messages
   exchanged between them, or to preserve privacy of the messages.  The
   application is free to choose whatever protection may be necessary.

   To verify the identities of the principals in a transaction, the
   client transmits the ticket to the application server.  Because the
   ticket is sent ""in the clear"" (parts of it are encrypted, but this
   encryption doesn't thwart replay) and might be intercepted and reused
   by an attacker, additional information is sent to prove that the
   message originated with the principal to whom the ticket was issued.
   This information (called the authenticator) is encrypted in the
   session key and includes a timestamp.  The timestamp proves that the
   message was recently generated and is not a replay.  Encrypting the
   authenticator in the session key proves that it was generated by a
   party possessing the session key.  Since no one except the requesting
   principal and the server know the session key (it is never sent over
   the network in the clear), this guarantees the identity of the
   client.

   The integrity of the messages exchanged between principals can also
   be guaranteed by using the session key (passed in the ticket and
   contained in the credentials).  This approach provides detection of
   both replay attacks and message stream modification attacks.  It is
   accomplished by generating and transmitting a collision-proof
   checksum (elsewhere called a hash or digest function) of the client's
   message, keyed with the session key.  Privacy and integrity of the
   messages exchanged between principals can be secured by encrypting
   the data to be passed by using the session key contained in the
   ticket or the sub-session key found in the authenticator.






Neuman, et al.              Standards Track                     [Page 7]

RFC 4120                      Kerberos V5                      July 2005


   The authentication exchanges mentioned above require read-only access
   to the Kerberos database.  Sometimes, however, the entries in the
   database must be modified, such as when adding new principals or
   changing a principal's key.  This is done using a protocol between a
   client and a third Kerberos server, the Kerberos Administration
   Server (KADM).  There is also a protocol for maintaining multiple
   copies of the Kerberos database.  Neither of these protocols are
   described in this document.

1.2.  Cross-Realm Operation

   The Kerberos protocol is designed to operate across organizational
   boundaries.  A client in one organization can be authenticated to a
   server in another.  Each organization wishing to run a Kerberos
   server establishes its own ""realm"".  The name of the realm in which a
   client is registered is part of the client's name and can be used by
   the end-service to decide whether to honor a request.

   By establishing ""inter-realm"" keys, the administrators of two realms
   can allow a client authenticated in the local realm to prove its
   identity to servers in other realms.  The exchange of inter-realm
   keys (a separate key may be used for each direction) registers the
   ticket-granting service of each realm as a principal in the other
   realm.  A client is then able to obtain a TGT for the remote realm's
   ticket-granting service from its local realm.  When that TGT is used,
   the remote ticket-granting service uses the inter-realm key (which
   usually differs from its own normal TGS key) to decrypt the TGT; thus
   it is certain that the ticket was issued by the client's own TGS.
   Tickets issued by the remote ticket-granting service will indicate to
   the end-service that the client was authenticated from another realm.

   Without cross-realm operation, and with appropriate permission, the
   client can arrange registration of a separately-named principal in a
   remote realm and engage in normal exchanges with that realm's
   services.  However, for even small numbers of clients this becomes
   cumbersome, and more automatic methods as described here are
   necessary.

   A realm is said to communicate with another realm if the two realms
   share an inter-realm key, or if the local realm shares an inter-realm
   key with an intermediate realm that communicates with the remote
   realm.  An authentication path is the sequence of intermediate realms
   that are transited in communicating from one realm to another.

   Realms may be organized hierarchically.  Each realm shares a key with
   its parent and a different key with each child.  If an inter-realm
   key is not directly shared by two realms, the hierarchical
   organization allows an authentication path to be easily constructed.



Neuman, et al.              Standards Track                     [Page 8]

RFC 4120                      Kerberos V5                      July 2005


   If a hierarchical organization is not used, it may be necessary to
   consult a database in order to construct an authentication path
   between realms.

   Although realms are typically hierarchical, intermediate realms may
   be bypassed to achieve cross-realm authentication through alternate
   authentication paths.  (These might be established to make
   communication between two realms more efficient.)  It is important
   for the end-service to know which realms were transited when deciding
   how much faith to place in the authentication process.  To facilitate
   this decision, a field in each ticket contains the names of the
   realms that were involved in authenticating the client.

   The application server is ultimately responsible for accepting or
   rejecting authentication and SHOULD check the transited field.  The
   application server may choose to rely on the Key Distribution Center
   (KDC) for the application server's realm to check the transited
   field.  The application server's KDC will set the
   TRANSITED-POLICY-CHECKED flag in this case.  The KDCs for
   intermediate realms may also check the transited field as they issue
   TGTs for other realms, but they are encouraged not to do so.  A
   client may request that the KDCs not check the transited field by
   setting the DISABLE-TRANSITED-CHECK flag.  KDCs SHOULD honor this
   flag.

1.3.  Choosing a Principal with Which to Communicate

   The Kerberos protocol provides the means for verifying (subject to
   the assumptions in Section 1.6) that the entity with which one
   communicates is the same entity that was registered with the KDC
   using the claimed identity (principal name).  It is still necessary
   to determine whether that identity corresponds to the entity with
   which one intends to communicate.

   When appropriate data has been exchanged in advance, the application
   may perform this determination syntactically based on the application
   protocol specification, information provided by the user, and
   configuration files.  For example, the server principal name
   (including realm) for a telnet server might be derived from the
   user-specified host name (from the telnet command line), the ""host/""
   prefix specified in the application protocol specification, and a
   mapping to a Kerberos realm derived syntactically from the domain
   part of the specified hostname and information from the local
   Kerberos realms database.

   One can also rely on trusted third parties to make this
   determination, but only when the data obtained from the third party
   is suitably integrity-protected while resident on the third-party



Neuman, et al.              Standards Track                     [Page 9]

RFC 4120                      Kerberos V5                      July 2005


   server and when transmitted.  Thus, for example, one should not rely
   on an unprotected DNS record to map a host alias to the primary name
   of a server, accepting the primary name as the party that one intends
   to contact, since an attacker can modify the mapping and impersonate
   the party.

   Implementations of Kerberos and protocols based on Kerberos MUST NOT
   use insecure DNS queries to canonicalize the hostname components of
   the service principal names (i.e., they MUST NOT use insecure DNS
   queries to map one name to another to determine the host part of the
   principal name with which one is to communicate).  In an environment
   without secure name service, application authors MAY append a
   statically configured domain name to unqualified hostnames before
   passing the name to the security mechanisms, but they should do no
   more than that.  Secure name service facilities, if available, might
   be trusted for hostname canonicalization, but such canonicalization
   by the client SHOULD NOT be required by KDC implementations.

   Implementation note: Many current implementations do some degree of
   canonicalization of the provided service name, often using DNS even
   though it creates security problems.  However, there is no
   consistency among implementations as to whether the service name is
   case folded to lowercase or whether reverse resolution is used.  To
   maximize interoperability and security, applications SHOULD provide
   security mechanisms with names that result from folding the user-
   entered name to lowercase without performing any other modifications
   or canonicalization.

1.4.  Authorization

   As an authentication service, Kerberos provides a means of verifying
   the identity of principals on a network.  Authentication is usually
   useful primarily as a first step in the process of authorization,
   determining whether a client may use a service, which objects the
   client is allowed to access, and the type of access allowed for each.
   Kerberos does not, by itself, provide authorization.  Possession of a
   client ticket for a service provides only for authentication of the
   client to that service, and in the absence of a separate
   authorization procedure, an application should not consider it to
   authorize the use of that service.

   Separate authorization methods MAY be implemented as application-
   specific access control functions and may utilize files on the
   application server, on separately issued authorization credentials
   such as those based on proxies [Neu93], or on other authorization
   services.  Separately authenticated authorization credentials MAY be
   embedded in a ticket's authorization data when encapsulated by the
   KDC-issued authorization data element.



Neuman, et al.              Standards Track                    [Page 10]

RFC 4120                      Kerberos V5                      July 2005


   Applications should not accept the mere issuance of a service ticket
   by the Kerberos server (even by a modified Kerberos server) as
   granting authority to use the service, since such applications may
   become vulnerable to the bypass of this authorization check in an
   environment where other options for application authentication are
   provided, or if they interoperate with other KDCs.

1.5.  Extending Kerberos without Breaking Interoperability

   As the deployed base of Kerberos implementations grows, extending
   Kerberos becomes more important.  Unfortunately, some extensions to
   the existing Kerberos protocol create interoperability issues because
   of uncertainty regarding the treatment of certain extensibility
   options by some implementations.  This section includes guidelines
   that will enable future implementations to maintain interoperability.

   Kerberos provides a general mechanism for protocol extensibility.
   Some protocol messages contain typed holes -- sub-messages that
   contain an octet-string along with an integer that defines how to
   interpret the octet-string.  The integer types are registered
   centrally, but they can be used both for vendor extensions and for
   extensions standardized through the IETF.

   In this document, the word ""extension"" refers to extension by
   defining a new type to insert into an existing typed hole in a
   protocol message.  It does not refer to extension by addition of new
   fields to ASN.1 types, unless the text explicitly indicates
   otherwise.

1.5.1.  Compatibility with RFC 1510

   Note that existing Kerberos message formats cannot readily be
   extended by adding fields to the ASN.1 types.  Sending additional
   fields often results in the entire message being discarded without an
   error indication.  Future versions of this specification will provide
   guidelines to ensure that ASN.1 fields can be added without creating
   an interoperability problem.

   In the meantime, all new or modified implementations of Kerberos that
   receive an unknown message extension SHOULD preserve the encoding of
   the extension but otherwise ignore its presence.  Recipients MUST NOT
   decline a request simply because an extension is present.

   There is one exception to this rule.  If an unknown authorization
   data element type is received by a server other than the ticket-
   granting service either in an AP-REQ or in a ticket contained in an
   AP-REQ, then authentication MUST fail.  One of the primary uses of
   authorization data is to restrict the use of the ticket.  If the



Neuman, et al.              Standards Track                    [Page 11]

RFC 4120                      Kerberos V5                      July 2005


   service cannot determine whether the restriction applies to that
   service, then a security weakness may result if the ticket can be
   used for that service.  Authorization elements that are optional
   SHOULD be enclosed in the AD-IF-RELEVANT element.

   The ticket-granting service MUST ignore but propagate to derivative
   tickets any unknown authorization data types, unless those data types
   are embedded in a MANDATORY-FOR-KDC element, in which case the
   request will be rejected.  This behavior is appropriate because
   requiring that the ticket-granting service understand unknown
   authorization data types would require that KDC software be upgraded
   to understand new application-level restrictions before applications
   used these restrictions, decreasing the utility of authorization data
   as a mechanism for restricting the use of tickets.  No security
   problem is created because services to which the tickets are issued
   will verify the authorization data.

   Implementation note: Many RFC 1510 implementations ignore unknown
   authorization data elements.  Depending on these implementations to
   honor authorization data restrictions may create a security weakness.

1.5.2.  Sending Extensible Messages

   Care must be taken to ensure that old implementations can understand
   messages sent to them, even if they do not understand an extension
   that is used.  Unless the sender knows that an extension is
   supported, the extension cannot change the semantics of the core
   message or previously defined extensions.

   For example, an extension including key information necessary to
   decrypt the encrypted part of a KDC-REP could only be used in
   situations where the recipient was known to support the extension.
   Thus when designing such extensions it is important to provide a way
   for the recipient to notify the sender of support for the extension.
   For example in the case of an extension that changes the KDC-REP
   reply key, the client could indicate support for the extension by
   including a padata element in the AS-REQ sequence.  The KDC should
   only use the extension if this padata element is present in the
   AS-REQ.  Even if policy requires the use of the extension, it is
   better to return an error indicating that the extension is required
   than to use the extension when the recipient may not support it.
   Debugging implementations that do not interoperate is easier when
   errors are returned.

1.6.  Environmental Assumptions

   Kerberos imposes a few assumptions on the environment in which it can
   properly function, including the following:



Neuman, et al.              Standards Track                    [Page 12]

RFC 4120                      Kerberos V5                      July 2005


   *  ""Denial of service"" attacks are not solved with Kerberos.  There
      are places in the protocols where an intruder can prevent an
      application from participating in the proper authentication steps.
      Detection and solution of such attacks (some of which can appear
      to be not-uncommon ""normal"" failure modes for the system) are
      usually best left to the human administrators and users.

   *  Principals MUST keep their secret keys secret.  If an intruder
      somehow steals a principal's key, it will be able to masquerade as
      that principal or to impersonate any server to the legitimate
      principal.

   *  ""Password guessing"" attacks are not solved by Kerberos.  If a user
      chooses a poor password, it is possible for an attacker to
      successfully mount an offline dictionary attack by repeatedly
      attempting to decrypt, with successive entries from a dictionary,
      messages obtained which are encrypted under a key derived from the
      user's password.

   *  Each host on the network MUST have a clock which is ""loosely
      synchronized"" to the time of the other hosts; this synchronization
      is used to reduce the bookkeeping needs of application servers
      when they do replay detection.  The degree of ""looseness"" can be
      configured on a per-server basis, but it is typically on the order
      of 5 minutes.  If the clocks are synchronized over the network,
      the clock synchronization protocol MUST itself be secured from
      network attackers.

   *  Principal identifiers are not recycled on a short-term basis.  A
      typical mode of access control will use access control lists
      (ACLs) to grant permissions to particular principals.  If a stale
      ACL entry remains for a deleted principal and the principal
      identifier is reused, the new principal will inherit rights
      specified in the stale ACL entry.  By not re-using principal
      identifiers, the danger of inadvertent access is removed.

1.7.  Glossary of Terms

   Below is a list of terms used throughout this document.

   Authentication
      Verifying the claimed identity of a principal.

   Authentication header
      A record containing a Ticket and an Authenticator to be presented
      to a server as part of the authentication process.





Neuman, et al.              Standards Track                    [Page 13]

RFC 4120                      Kerberos V5                      July 2005


   Authentication path
      A sequence of intermediate realms transited in the authentication
      process when communicating from one realm to another.

   Authenticator
      A record containing information that can be shown to have been
      recently generated using the session key known only by the client
      and server.

   Authorization
      The process of determining whether a client may use a service,
      which objects the client is allowed to access, and the type of
      access allowed for each.

   Capability
      A token that grants the bearer permission to access an object or
      service.  In Kerberos, this might be a ticket whose use is
      restricted by the contents of the authorization data field, but
      which lists no network addresses, together with the session key
      necessary to use the ticket.

   Ciphertext
      The output of an encryption function.  Encryption transforms
      plaintext into ciphertext.

   Client
      A process that makes use of a network service on behalf of a user.
      Note that in some cases a Server may itself be a client of some
      other server (e.g., a print server may be a client of a file
      server).

   Credentials
      A ticket plus the secret session key necessary to use that ticket
      successfully in an authentication exchange.

   Encryption Type (etype)
      When associated with encrypted data, an encryption type identifies
      the algorithm used to encrypt the data and is used to select the
      appropriate algorithm for decrypting the data.  Encryption type
      tags are communicated in other messages to enumerate algorithms
      that are desired, supported, preferred, or allowed to be used for
      encryption of data between parties.  This preference is combined
      with local information and policy to select an algorithm to be
      used.

   KDC
      Key Distribution Center.  A network service that supplies tickets
      and temporary session keys; or an instance of that service or the



Neuman, et al.              Standards Track                    [Page 14]

RFC 4120                      Kerberos V5                      July 2005


      host on which it runs.  The KDC services both initial ticket and
      ticket-granting ticket requests.  The initial ticket portion is
      sometimes referred to as the Authentication Server (or service).
      The ticket-granting ticket portion is sometimes referred to as the
      ticket-granting server (or service).

   Kerberos
      The name given to the Project Athena's authentication service, the
      protocol used by that service, or the code used to implement the
      authentication service.  The name is adopted from the three-headed
      dog that guards Hades.

   Key Version Number (kvno)
      A tag associated with encrypted data identifies which key was used
      for encryption when a long-lived key associated with a principal
      changes over time.  It is used during the transition to a new key
      so that the party decrypting a message can tell whether the data
      was encrypted with the old or the new key.

   Plaintext
      The input to an encryption function or the output of a decryption
      function.  Decryption transforms ciphertext into plaintext.

   Principal
      A named client or server entity that participates in a network
      communication, with one name that is considered canonical.

   Principal identifier
      The canonical name used to identify each different principal
      uniquely.

   Seal
      To encipher a record containing several fields in such a way that
      the fields cannot be individually replaced without knowledge of
      the encryption key or leaving evidence of tampering.

   Secret key
      An encryption key shared by a principal and the KDC, distributed
      outside the bounds of the system, with a long lifetime.  In the
      case of a human user's principal, the secret key MAY be derived
      from a password.

   Server
      A particular Principal that provides a resource to network
      clients.  The server is sometimes referred to as the Application
      Server.





Neuman, et al.              Standards Track                    [Page 15]

RFC 4120                      Kerberos V5                      July 2005


   Service
      A resource provided to network clients; often provided by more
      than one server (for example, remote file service).

   Session key
      A temporary encryption key used between two principals, with a
      lifetime limited to the duration of a single login ""session"".  In
      the Kerberos system, a session key is generated by the KDC.  The
      session key is distinct from the sub-session key, described next.

   Sub-session key
      A temporary encryption key used between two principals, selected
      and exchanged by the principals using the session key, and with a
      lifetime limited to the duration of a single association.  The
      sub-session key is also referred to as the subkey.

   Ticket
      A record that helps a client authenticate itself to a server; it
      contains the client's identity, a session key, a timestamp, and
      other information, all sealed using the server's secret key.  It
      only serves to authenticate a client when presented along with a
      fresh Authenticator.

2.  Ticket Flag Uses and Requests

   Each Kerberos ticket contains a set of flags that are used to
   indicate attributes of that ticket.  Most flags may be requested by a
   client when the ticket is obtained; some are automatically turned on
   and off by a Kerberos server as required.  The following sections
   explain what the various flags mean and give examples of reasons to
   use them.  With the exception of the INVALID flag, clients MUST
   ignore ticket flags that are not recognized.  KDCs MUST ignore KDC
   options that are not recognized.  Some implementations of RFC 1510
   are known to reject unknown KDC options, so clients may need to
   resend a request without new KDC options if the request was rejected
   when sent with options added since RFC 1510.  Because new KDCs will
   ignore unknown options, clients MUST confirm that the ticket returned
   by the KDC meets their needs.

   Note that it is not, in general, possible to determine whether an
   option was not honored because it was not understood or because it
   was rejected through either configuration or policy.  When adding a
   new option to the Kerberos protocol, designers should consider
   whether the distinction is important for their option.  If it is, a
   mechanism for the KDC to return an indication that the option was
   understood but rejected needs to be provided in the specification of
   the option.  Often in such cases, the mechanism needs to be broad
   enough to permit an error or reason to be returned.



Neuman, et al.              Standards Track                    [Page 16]

RFC 4120                      Kerberos V5                      July 2005


2.1.  Initial, Pre-authenticated, and Hardware-Authenticated Tickets

   The INITIAL flag indicates that a ticket was issued using the AS
   protocol, rather than issued based on a TGT.  Application servers
   that want to require the demonstrated knowledge of a client's secret
   key (e.g., a password-changing program) can insist that this flag be
   set in any tickets they accept, and can thus be assured that the
   client's key was recently presented to the authentication server.

   The PRE-AUTHENT and HW-AUTHENT flags provide additional information
   about the initial authentication, regardless of whether the current
   ticket was issued directly (in which case INITIAL will also be set)
   or issued on the basis of a TGT (in which case the INITIAL flag is
   clear, but the PRE-AUTHENT and HW-AUTHENT flags are carried forward
   from the TGT).

2.2.  Invalid Tickets

   The INVALID flag indicates that a ticket is invalid.  Application
   servers MUST reject tickets that have this flag set.  A postdated
   ticket will be issued in this form.  Invalid tickets MUST be
   validated by the KDC before use, by being presented to the KDC in a
   TGS request with the VALIDATE option specified.  The KDC will only
   validate tickets after their starttime has passed.  The validation is
   required so that postdated tickets that have been stolen before their
   starttime can be rendered permanently invalid (through a hot-list
   mechanism) (see Section 3.3.3.1).

2.3.  Renewable Tickets

   Applications may desire to hold tickets that can be valid for long
   periods of time.  However, this can expose their credentials to
   potential theft for equally long periods, and those stolen
   credentials would be valid until the expiration time of the
   ticket(s).  Simply using short-lived tickets and obtaining new ones
   periodically would require the client to have long-term access to its
   secret key, an even greater risk.  Renewable tickets can be used to
   mitigate the consequences of theft.  Renewable tickets have two
   ""expiration times"": the first is when the current instance of the
   ticket expires, and the second is the latest permissible value for an
   individual expiration time.  An application client must periodically
   (i.e., before it expires) present a renewable ticket to the KDC, with
   the RENEW option set in the KDC request.  The KDC will issue a new
   ticket with a new session key and a later expiration time.  All other
   fields of the ticket are left unmodified by the renewal process.
   When the latest permissible expiration time arrives, the ticket
   expires permanently.  At each renewal, the KDC MAY consult a hot-list
   to determine whether the ticket had been reported stolen since its



Neuman, et al.              Standards Track                    [Page 17]

RFC 4120                      Kerberos V5                      July 2005


   last renewal; it will refuse to renew stolen tickets, and thus the
   usable lifetime of stolen tickets is reduced.

   The RENEWABLE flag in a ticket is normally only interpreted by the
   ticket-granting service (discussed below in Section 3.3).  It can
   usually be ignored by application servers.  However, some
   particularly careful application servers MAY disallow renewable
   tickets.

   If a renewable ticket is not renewed by its expiration time, the KDC
   will not renew the ticket.  The RENEWABLE flag is reset by default,
   but a client MAY request it be set by setting the RENEWABLE option in
   the KRB_AS_REQ message.  If it is set, then the renew-till field in
   the ticket contains the time after which the ticket may not be
   renewed.

2.4.  Postdated Tickets

   Applications may occasionally need to obtain tickets for use much
   later; e.g., a batch submission system would need tickets to be valid
   at the time the batch job is serviced.  However, it is dangerous to
   hold valid tickets in a batch queue, since they will be on-line
   longer and more prone to theft.  Postdated tickets provide a way to
   obtain these tickets from the KDC at job submission time, but to
   leave them ""dormant"" until they are activated and validated by a
   further request of the KDC.  If a ticket theft were reported in the
   interim, the KDC would refuse to validate the ticket, and the thief
   would be foiled.

   The MAY-POSTDATE flag in a ticket is normally only interpreted by the
   ticket-granting service.  It can be ignored by application servers.
   This flag MUST be set in a TGT in order to issue a postdated ticket
   based on the presented ticket.  It is reset by default; a client MAY
   request it by setting the ALLOW-POSTDATE option in the KRB_AS_REQ
   message.  This flag does not allow a client to obtain a postdated
   TGT; postdated TGTs can only be obtained by requesting the postdating
   in the KRB_AS_REQ message.  The life (endtime-starttime) of a
   postdated ticket will be the remaining life of the TGT at the time of
   the request, unless the RENEWABLE option is also set, in which case
   it can be the full life (endtime-starttime) of the TGT.  The KDC MAY
   limit how far in the future a ticket may be postdated.

   The POSTDATED flag indicates that a ticket has been postdated.  The
   application server can check the authtime field in the ticket to see
   when the original authentication occurred.  Some services MAY choose
   to reject postdated tickets, or they may only accept them within a
   certain period after the original authentication.  When the KDC
   issues a POSTDATED ticket, it will also be marked as INVALID, so that



Neuman, et al.              Standards Track                    [Page 18]

RFC 4120                      Kerberos V5                      July 2005


   the application client MUST present the ticket to the KDC to be
   validated before use.

2.5.  Proxiable and Proxy Tickets

   At times it may be necessary for a principal to allow a service to
   perform an operation on its behalf.  The service must be able to take
   on the identity of the client, but only for a particular purpose.  A
   principal can allow a service to do this by granting it a proxy.

   The process of granting a proxy by using the proxy and proxiable
   flags is used to provide credentials for use with specific services.
   Though conceptually also a proxy, users wishing to delegate their
   identity in a form usable for all purposes MUST use the ticket
   forwarding mechanism described in the next section to forward a TGT.

   The PROXIABLE flag in a ticket is normally only interpreted by the
   ticket-granting service.  It can be ignored by application servers.
   When set, this flag tells the ticket-granting server that it is OK to
   issue a new ticket (but not a TGT) with a different network address
   based on this ticket.  This flag is set if requested by the client on
   initial authentication.  By default, the client will request that it
   be set when requesting a TGT, and that it be reset when requesting
   any other ticket.

   This flag allows a client to pass a proxy to a server to perform a
   remote request on its behalf (e.g., a print service client can give
   the print server a proxy to access the client's files on a particular
   file server in order to satisfy a print request).

   In order to complicate the use of stolen credentials, Kerberos
   tickets are often valid only from those network addresses
   specifically included in the ticket, but it is permissible as a
   policy option to allow requests and to issue tickets with no network
   addresses specified.  When granting a proxy, the client MUST specify
   the new network address from which the proxy is to be used or
   indicate that the proxy is to be issued for use from any address.

   The PROXY flag is set in a ticket by the TGS when it issues a proxy
   ticket.  Application servers MAY check this flag; and at their option
   they MAY require additional authentication from the agent presenting
   the proxy in order to provide an audit trail.

2.6.  Forwardable Tickets

   Authentication forwarding is an instance of a proxy where the service
   that is granted is complete use of the client's identity.  An example
   of where it might be used is when a user logs in to a remote system



Neuman, et al.              Standards Track                    [Page 19]

RFC 4120                      Kerberos V5                      July 2005


   and wants authentication to work from that system as if the login
   were local.

   The FORWARDABLE flag in a ticket is normally only interpreted by the
   ticket-granting service.  It can be ignored by application servers.
   The FORWARDABLE flag has an interpretation similar to that of the
   PROXIABLE flag, except TGTs may also be issued with different network
   addresses.  This flag is reset by default, but users MAY request that
   it be set by setting the FORWARDABLE option in the AS request when
   they request their initial TGT.

   This flag allows for authentication forwarding without requiring the
   user to enter a password again.  If the flag is not set, then
   authentication forwarding is not permitted, but the same result can
   still be achieved if the user engages in the AS exchange, specifies
   the requested network addresses, and supplies a password.

   The FORWARDED flag is set by the TGS when a client presents a ticket
   with the FORWARDABLE flag set and requests a forwarded ticket by
   specifying the FORWARDED KDC option and supplying a set of addresses
   for the new ticket.  It is also set in all tickets issued based on
   tickets with the FORWARDED flag set.  Application servers may choose
   to process FORWARDED tickets differently than non-FORWARDED tickets.

   If addressless tickets are forwarded from one system to another,
   clients SHOULD still use this option to obtain a new TGT in order to
   have different session keys on the different systems.

2.7.  Transited Policy Checking

   In Kerberos, the application server is ultimately responsible for
   accepting or rejecting authentication, and it SHOULD check that only
   suitably trusted KDCs are relied upon to authenticate a principal.
   The transited field in the ticket identifies which realms (and thus
   which KDCs) were involved in the authentication process, and an
   application server would normally check this field.  If any of these
   are untrusted to authenticate the indicated client principal
   (probably determined by a realm-based policy), the authentication
   attempt MUST be rejected.  The presence of trusted KDCs in this list
   does not provide any guarantee; an untrusted KDC may have fabricated
   the list.

   Although the end server ultimately decides whether authentication is
   valid, the KDC for the end server's realm MAY apply a realm-specific
   policy for validating the transited field and accepting credentials
   for cross-realm authentication.  When the KDC applies such checks and
   accepts such cross-realm authentication, it will set the
   TRANSITED-POLICY-CHECKED flag in the service tickets it issues based



Neuman, et al.              Standards Track                    [Page 20]

RFC 4120                      Kerberos V5                      July 2005


   on the cross-realm TGT.  A client MAY request that the KDCs not check
   the transited field by setting the DISABLE-TRANSITED-CHECK flag.
   KDCs are encouraged but not required to honor this flag.

   Application servers MUST either do the transited-realm checks
   themselves or reject cross-realm tickets without
   TRANSITED-POLICY-CHECKED set.

2.8.  OK as Delegate

   For some applications, a client may need to delegate authority to a
   server to act on its behalf in contacting other services.  This
   requires that the client forward credentials to an intermediate
   server.  The ability for a client to obtain a service ticket to a
   server conveys no information to the client about whether the server
   should be trusted to accept delegated credentials.  The
   OK-AS-DELEGATE provides a way for a KDC to communicate local realm
   policy to a client regarding whether an intermediate server is
   trusted to accept such credentials.

   The copy of the ticket flags in the encrypted part of the KDC reply
   may have the OK-AS-DELEGATE flag set to indicate to the client that
   the server specified in the ticket has been determined by the policy
   of the realm to be a suitable recipient of delegation.  A client can
   use the presence of this flag to help it decide whether to delegate
   credentials (grant either a proxy or a forwarded TGT) to this server.
   It is acceptable to ignore the value of this flag.  When setting this
   flag, an administrator should consider the security and placement of
   the server on which the service will run, as well as whether the
   service requires the use of delegated credentials.

2.9.  Other KDC Options

   There are three additional options that MAY be set in a client's
   request of the KDC.

2.9.1.  Renewable-OK

   The RENEWABLE-OK option indicates that the client will accept a
   renewable ticket if a ticket with the requested life cannot otherwise
   be provided.  If a ticket with the requested life cannot be provided,
   then the KDC MAY issue a renewable ticket with a renew-till equal to
   the requested endtime.  The value of the renew-till field MAY still
   be adjusted by site-determined limits or limits imposed by the
   individual principal or server.






Neuman, et al.              Standards Track                    [Page 21]

RFC 4120                      Kerberos V5                      July 2005


2.9.2.  ENC-TKT-IN-SKEY

   In its basic form, the Kerberos protocol supports authentication in a
   client-server setting and is not well suited to authentication in a
   peer-to-peer environment because the long-term key of the user does
   not remain on the workstation after initial login.  Authentication of
   such peers may be supported by Kerberos in its user-to-user variant.
   The ENC-TKT-IN-SKEY option supports user-to-user authentication by
   allowing the KDC to issue a service ticket encrypted using the
   session key from another TGT issued to another user.  The
   ENC-TKT-IN-SKEY option is honored only by the ticket-granting
   service.  It indicates that the ticket to be issued for the end
   server is to be encrypted in the session key from the additional
   second TGT provided with the request.  See Section 3.3.3 for specific
   details.

2.9.3.  Passwordless Hardware Authentication

   The OPT-HARDWARE-AUTH option indicates that the client wishes to use
   some form of hardware authentication instead of or in addition to the
   client's password or other long-lived encryption key.
   OPT-HARDWARE-AUTH is honored only by the authentication service.  If
   supported and allowed by policy, the KDC will return an error code of
   KDC_ERR_PREAUTH_REQUIRED and include the required METHOD-DATA to
   perform such authentication.

3.  Message Exchanges

   The following sections describe the interactions between network
   clients and servers and the messages involved in those exchanges.

3.1.  The Authentication Service Exchange

                             Summary

         Message direction       Message type    Section
         1. Client to Kerberos   KRB_AS_REQ      5.4.1
         2. Kerberos to client   KRB_AS_REP or   5.4.2
                                 KRB_ERROR       5.9.1

   The Authentication Service (AS) Exchange between the client and the
   Kerberos Authentication Server is initiated by a client when it
   wishes to obtain authentication credentials for a given server but
   currently holds no credentials.  In its basic form, the client's
   secret key is used for encryption and decryption.  This exchange is
   typically used at the initiation of a login session to obtain
   credentials for a Ticket-Granting Server, which will subsequently be
   used to obtain credentials for other servers (see Section 3.3)



Neuman, et al.              Standards Track                    [Page 22]

RFC 4120                      Kerberos V5                      July 2005


   without requiring further use of the client's secret key.  This
   exchange is also used to request credentials for services that must
   not be mediated through the Ticket-Granting Service, but rather
   require knowledge of a principal's secret key, such as the password-
   changing service (the password-changing service denies requests
   unless the requester can demonstrate knowledge of the user's old
   password; requiring this knowledge prevents unauthorized password
   changes by someone walking up to an unattended session).

   This exchange does not by itself provide any assurance of the
   identity of the user.  To authenticate a user logging on to a local
   system, the credentials obtained in the AS exchange may first be used
   in a TGS exchange to obtain credentials for a local server; those
   credentials must then be verified by a local server through
   successful completion of the Client/Server exchange.

   The AS exchange consists of two messages: KRB_AS_REQ from the client
   to Kerberos, and KRB_AS_REP or KRB_ERROR in reply.  The formats for
   these messages are described in Sections 5.4.1, 5.4.2, and 5.9.1.

   In the request, the client sends (in cleartext) its own identity and
   the identity of the server for which it is requesting credentials,
   other information about the credentials it is requesting, and a
   randomly generated nonce, which can be used to detect replays and to
   associate replies with the matching requests.  This nonce MUST be
   generated randomly by the client and remembered for checking against
   the nonce in the expected reply.  The response, KRB_AS_REP, contains
   a ticket for the client to present to the server, and a session key
   that will be shared by the client and the server.  The session key
   and additional information are encrypted in the client's secret key.
   The encrypted part of the KRB_AS_REP message also contains the nonce
   that MUST be matched with the nonce from the KRB_AS_REQ message.

   Without pre-authentication, the authentication server does not know
   whether the client is actually the principal named in the request.
   It simply sends a reply without knowing or caring whether they are
   the same.  This is acceptable because nobody but the principal whose
   identity was given in the request will be able to use the reply.  Its
   critical information is encrypted in that principal's key.  However,
   an attacker can send a KRB_AS_REQ message to get known plaintext in
   order to attack the principal's key.  Especially if the key is based
   on a password, this may create a security exposure.  So the initial
   request supports an optional field that can be used to pass
   additional information that might be needed for the initial exchange.
   This field SHOULD be used for pre-authentication as described in
   sections 3.1.1 and 5.2.7.





Neuman, et al.              Standards Track                    [Page 23]

RFC 4120                      Kerberos V5                      July 2005


   Various errors can occur; these are indicated by an error response
   (KRB_ERROR) instead of the KRB_AS_REP response.  The error message is
   not encrypted.  The KRB_ERROR message contains information that can
   be used to associate it with the message to which it replies.  The
   contents of the KRB_ERROR message are not integrity-protected.  As
   such, the client cannot detect replays, fabrications, or
   modifications.  A solution to this problem will be included in a
   future version of the protocol.

3.1.1.  Generation of KRB_AS_REQ Message

   The client may specify a number of options in the initial request.
   Among these options are whether pre-authentication is to be
   performed; whether the requested ticket is to be renewable,
   proxiable, or forwardable; whether it should be postdated or allow
   postdating of derivative tickets; and whether a renewable ticket will
   be accepted in lieu of a non-renewable ticket if the requested ticket
   expiration date cannot be satisfied by a non-renewable ticket (due to
   configuration constraints).

   The client prepares the KRB_AS_REQ message and sends it to the KDC.

3.1.2.  Receipt of KRB_AS_REQ Message

   If all goes well, processing the KRB_AS_REQ message will result in
   the creation of a ticket for the client to present to the server.
   The format for the ticket is described in Section 5.3.

   Because Kerberos can run over unreliable transports such as UDP, the
   KDC MUST be prepared to retransmit responses in case they are lost.
   If a KDC receives a request identical to one it has recently
   processed successfully, the KDC MUST respond with a KRB_AS_REP
   message rather than a replay error.  In order to reduce ciphertext
   given to a potential attacker, KDCs MAY send the same response
   generated when the request was first handled.  KDCs MUST obey this
   replay behavior even if the actual transport in use is reliable.

3.1.3.  Generation of KRB_AS_REP Message

   The authentication server looks up the client and server principals
   named in the KRB_AS_REQ in its database, extracting their respective
   keys.  If the requested client principal named in the request is
   unknown because it doesn't exist in the KDC's principal database,
   then an error message with a KDC_ERR_C_PRINCIPAL_UNKNOWN is returned.

   If required to do so, the server pre-authenticates the request, and
   if the pre-authentication check fails, an error message with the code
   KDC_ERR_PREAUTH_FAILED is returned.  If pre-authentication is



Neuman, et al.              Standards Track                    [Page 24]

RFC 4120                      Kerberos V5                      July 2005


   required, but was not present in the request, an error message with
   the code KDC_ERR_PREAUTH_REQUIRED is returned, and a METHOD-DATA
   object will be stored in the e-data field of the KRB-ERROR message to
   specify which pre-authentication mechanisms are acceptable.  Usually
   this will include PA-ETYPE-INFO and/or PA-ETYPE-INFO2 elements as
   described below.  If the server cannot accommodate any encryption
   type requested by the client, an error message with code
   KDC_ERR_ETYPE_NOSUPP is returned.  Otherwise, the KDC generates a
   'random' session key, meaning that, among other things, it should be
   impossible to guess the next session key based on knowledge of past
   session keys.  Although this can be achieved in a pseudo-random
   number generator if it is based on cryptographic principles, it is
   more desirable to use a truly random number generator, such as one
   based on measurements of random physical phenomena.  See [RFC4086]
   for an in-depth discussion of randomness.

   In response to an AS request, if there are multiple encryption keys
   registered for a client in the Kerberos database, then the etype
   field from the AS request is used by the KDC to select the encryption
   method to be used to protect the encrypted part of the KRB_AS_REP
   message that is sent to the client.  If there is more than one
   supported strong encryption type in the etype list, the KDC SHOULD
   use the first valid strong etype for which an encryption key is
   available.

   When the user's key is generated from a password or pass phrase, the
   string-to-key function for the particular encryption key type is
   used, as specified in [RFC3961].  The salt value and additional
   parameters for the string-to-key function have default values
   (specified by Section 4 and by the encryption mechanism
   specification, respectively) that may be overridden by
   pre-authentication data (PA-PW-SALT, PA-AFS3-SALT, PA-ETYPE-INFO,
   PA-ETYPE-INFO2, etc).  Since the KDC is presumed to store a copy of
   the resulting key only, these values should not be changed for
   password-based keys except when changing the principal's key.

   When the AS server is to include pre-authentication data in a
   KRB-ERROR or in an AS-REP, it MUST use PA-ETYPE-INFO2, not PA-ETYPE-
   INFO, if the etype field of the client's AS-REQ lists at least one
   ""newer"" encryption type.  Otherwise (when the etype field of the
   client's AS-REQ does not list any ""newer"" encryption types), it MUST
   send both PA-ETYPE-INFO2 and PA-ETYPE-INFO (both with an entry for
   each enctype).  A ""newer"" enctype is any enctype first officially
   specified concurrently with or subsequent to the issue of this RFC.
   The enctypes DES, 3DES, or RC4 and any defined in [RFC1510] are not
   ""newer"" enctypes.





Neuman, et al.              Standards Track                    [Page 25]

RFC 4120                      Kerberos V5                      July 2005


   It is not possible to generate a user's key reliably given a pass
   phrase without contacting the KDC, since it will not be known whether
   alternate salt or parameter values are required.

   The KDC will attempt to assign the type of the random session key
   from the list of methods in the etype field.  The KDC will select the
   appropriate type using the list of methods provided and information
   from the Kerberos database indicating acceptable encryption methods
   for the application server.  The KDC will not issue tickets with a
   weak session key encryption type.

   If the requested starttime is absent, indicates a time in the past,
   or is within the window of acceptable clock skew for the KDC and the
   POSTDATE option has not been specified, then the starttime of the
   ticket is set to the authentication server's current time.  If it
   indicates a time in the future beyond the acceptable clock skew, but
   the POSTDATED option has not been specified, then the error
   KDC_ERR_CANNOT_POSTDATE is returned.  Otherwise the requested
   starttime is checked against the policy of the local realm (the
   administrator might decide to prohibit certain types or ranges of
   postdated tickets), and if the ticket's starttime is acceptable, it
   is set as requested, and the INVALID flag is set in the new ticket.
   The postdated ticket MUST be validated before use by presenting it to
   the KDC after the starttime has been reached.

   The expiration time of the ticket will be set to the earlier of the
   requested endtime and a time determined by local policy, possibly by
   using realm- or principal-specific factors.  For example, the
   expiration time MAY be set to the earliest of the following:

      *  The expiration time (endtime) requested in the KRB_AS_REQ
         message.

      *  The ticket's starttime plus the maximum allowable lifetime
         associated with the client principal from the authentication
         server's database.

      *  The ticket's starttime plus the maximum allowable lifetime
         associated with the server principal.

      *  The ticket's starttime plus the maximum lifetime set by the
         policy of the local realm.

   If the requested expiration time minus the starttime (as determined
   above) is less than a site-determined minimum lifetime, an error
   message with code KDC_ERR_NEVER_VALID is returned.  If the requested
   expiration time for the ticket exceeds what was determined as above,
   and if the 'RENEWABLE-OK' option was requested, then the 'RENEWABLE'



Neuman, et al.              Standards Track                    [Page 26]

RFC 4120                      Kerberos V5                      July 2005


   flag is set in the new ticket, and the renew-till value is set as if
   the 'RENEWABLE' option were requested (the field and option names are
   described fully in Section 5.4.1).

   If the RENEWABLE option has been requested or if the RENEWABLE-OK
   option has been set and a renewable ticket is to be issued, then the
   renew-till field MAY be set to the earliest of:

      *  Its requested value.

      *  The starttime of the ticket plus the minimum of the two maximum
         renewable lifetimes associated with the principals' database
         entries.

      *  The starttime of the ticket plus the maximum renewable lifetime
         set by the policy of the local realm.

   The flags field of the new ticket will have the following options set
   if they have been requested and if the policy of the local realm
   allows:  FORWARDABLE, MAY-POSTDATE, POSTDATED, PROXIABLE, RENEWABLE.
   If the new ticket is postdated (the starttime is in the future), its
   INVALID flag will also be set.

   If all of the above succeed, the server will encrypt the ciphertext
   part of the ticket using the encryption key extracted from the server
   principal's record in the Kerberos database using the encryption type
   associated with the server principal's key.  (This choice is NOT
   affected by the etype field in the request.)  It then formats a
   KRB_AS_REP message (see Section 5.4.2), copying the addresses in the
   request into the caddr of the response, placing any required pre-
   authentication data into the padata of the response, and encrypts the
   ciphertext part in the client's key using an acceptable encryption
   method requested in the etype field of the request, or in some key
   specified by pre-authentication mechanisms being used.

3.1.4.  Generation of KRB_ERROR Message

   Several errors can occur, and the Authentication Server responds by
   returning an error message, KRB_ERROR, to the client, with the
   error-code and e-text fields set to appropriate values.  The error
   message contents and details are described in Section 5.9.1.

3.1.5.  Receipt of KRB_AS_REP Message

   If the reply message type is KRB_AS_REP, then the client verifies
   that the cname and crealm fields in the cleartext portion of the
   reply match what it requested.  If any padata fields are present,
   they may be used to derive the proper secret key to decrypt the



Neuman, et al.              Standards Track                    [Page 27]

RFC 4120                      Kerberos V5                      July 2005


   message.  The client decrypts the encrypted part of the response
   using its secret key and verifies that the nonce in the encrypted
   part matches the nonce it supplied in its request (to detect
   replays).  It also verifies that the sname and srealm in the response
   match those in the request (or are otherwise expected values), and
   that the host address field is also correct.  It then stores the
   ticket, session key, start and expiration times, and other
   information for later use.  The last-req field (and the deprecated
   key-expiration field) from the encrypted part of the response MAY be
   checked to notify the user of impending key expiration.  This enables
   the client program to suggest remedial action, such as a password
   change.

   Upon validation of the KRB_AS_REP message (by checking the returned
   nonce against that sent in the KRB_AS_REQ message), the client knows
   that the current time on the KDC is that read from the authtime field
   of the encrypted part of the reply.  The client can optionally use
   this value for clock synchronization in subsequent messages by
   recording with the ticket the difference (offset) between the
   authtime value and the local clock.  This offset can then be used by
   the same user to adjust the time read from the system clock when
   generating messages [DGT96].

   This technique MUST be used when adjusting for clock skew instead of
   directly changing the system clock, because the KDC reply is only
   authenticated to the user whose secret key was used, but not to the
   system or workstation.  If the clock were adjusted, an attacker
   colluding with a user logging into a workstation could agree on a
   password, resulting in a KDC reply that would be correctly validated
   even though it did not originate from a KDC trusted by the
   workstation.

   Proper decryption of the KRB_AS_REP message is not sufficient for the
   host to verify the identity of the user; the user and an attacker
   could cooperate to generate a KRB_AS_REP format message that decrypts
   properly but is not from the proper KDC.  If the host wishes to
   verify the identity of the user, it MUST require the user to present
   application credentials that can be verified using a securely-stored
   secret key for the host.  If those credentials can be verified, then
   the identity of the user can be assured.

3.1.6.  Receipt of KRB_ERROR Message

   If the reply message type is KRB_ERROR, then the client interprets it
   as an error and performs whatever application-specific tasks are
   necessary for recovery.





Neuman, et al.              Standards Track                    [Page 28]

RFC 4120                      Kerberos V5                      July 2005


3.2.  The Client/Server Authentication Exchange

                                Summary

   Message direction                         Message type    Section
   Client to Application server              KRB_AP_REQ      5.5.1
   [optional] Application server to client   KRB_AP_REP or   5.5.2
                                             KRB_ERROR       5.9.1

   The client/server authentication (CS) exchange is used by network
   applications to authenticate the client to the server and vice versa.
   The client MUST have already acquired credentials for the server
   using the AS or TGS exchange.

3.2.1.  The KRB_AP_REQ Message

   The KRB_AP_REQ contains authentication information that SHOULD be
   part of the first message in an authenticated transaction.  It
   contains a ticket, an authenticator, and some additional bookkeeping
   information (see Section 5.5.1 for the exact format).  The ticket by
   itself is insufficient to authenticate a client, since tickets are
   passed across the network in cleartext (tickets contain both an
   encrypted and unencrypted portion, so cleartext here refers to the
   entire unit, which can be copied from one message and replayed in
   another without any cryptographic skill).  The authenticator is used
   to prevent invalid replay of tickets by proving to the server that
   the client knows the session key of the ticket and thus is entitled
   to use the ticket.  The KRB_AP_REQ message is referred to elsewhere
   as the 'authentication header'.

3.2.2.  Generation of a KRB_AP_REQ Message

   When a client wishes to initiate authentication to a server, it
   obtains (either through a credentials cache, the AS exchange, or the
   TGS exchange) a ticket and session key for the desired service.  The
   client MAY re-use any tickets it holds until they expire.  To use a
   ticket, the client constructs a new Authenticator from the system
   time and its name, and optionally from an application-specific
   checksum, an initial sequence number to be used in KRB_SAFE or
   KRB_PRIV messages, and/or a session subkey to be used in negotiations
   for a session key unique to this particular session.  Authenticators
   MUST NOT be re-used and SHOULD be rejected if replayed to a server.
   Note that this can make applications based on unreliable transports
   difficult to code correctly.  If the transport might deliver
   duplicated messages, either a new authenticator MUST be generated for
   each retry, or the application server MUST match requests and replies
   and replay the first reply in response to a detected duplicate.




Neuman, et al.              Standards Track                    [Page 29]

RFC 4120                      Kerberos V5                      July 2005


   If a sequence number is to be included, it SHOULD be randomly chosen
   so that even after many messages have been exchanged it is not likely
   to collide with other sequence numbers in use.

   The client MAY indicate a requirement of mutual authentication or the
   use of a session-key based ticket (for user-to-user authentication,
   see section 3.7) by setting the appropriate flag(s) in the ap-options
   field of the message.

   The Authenticator is encrypted in the session key and combined with
   the ticket to form the KRB_AP_REQ message, which is then sent to the
   end server along with any additional application-specific
   information.

3.2.3.  Receipt of KRB_AP_REQ Message

   Authentication is based on the server's current time of day (clocks
   MUST be loosely synchronized), the authenticator, and the ticket.
   Several errors are possible.  If an error occurs, the server is
   expected to reply to the client with a KRB_ERROR message.  This
   message MAY be encapsulated in the application protocol if its raw
   form is not acceptable to the protocol.  The format of error messages
   is described in Section 5.9.1.

   The algorithm for verifying authentication information is as follows.
   If the message type is not KRB_AP_REQ, the server returns the
   KRB_AP_ERR_MSG_TYPE error.  If the key version indicated by the
   Ticket in the KRB_AP_REQ is not one the server can use (e.g., it
   indicates an old key, and the server no longer possesses a copy of
   the old key), the KRB_AP_ERR_BADKEYVER error is returned.  If the
   USE-SESSION-KEY flag is set in the ap-options field, it indicates to
   the server that user-to-user authentication is in use, and that the
   ticket is encrypted in the session key from the server's TGT rather
   than in the server's secret key.  See Section 3.7 for a more complete
   description of the effect of user-to-user authentication on all
   messages in the Kerberos protocol.

   Because it is possible for the server to be registered in multiple
   realms, with different keys in each, the srealm field in the
   unencrypted portion of the ticket in the KRB_AP_REQ is used to
   specify which secret key the server should use to decrypt that
   ticket.  The KRB_AP_ERR_NOKEY error code is returned if the server
   doesn't have the proper key to decipher the ticket.

   The ticket is decrypted using the version of the server's key
   specified by the ticket.  If the decryption routines detect a
   modification of the ticket (each encryption system MUST provide
   safeguards to detect modified ciphertext), the



Neuman, et al.              Standards Track                    [Page 30]

RFC 4120                      Kerberos V5                      July 2005


   KRB_AP_ERR_BAD_INTEGRITY error is returned (chances are good that
   different keys were used to encrypt and decrypt).

   The authenticator is decrypted using the session key extracted from
   the decrypted ticket.  If decryption shows that is has been modified,
   the KRB_AP_ERR_BAD_INTEGRITY error is returned.  The name and realm
   of the client from the ticket are compared against the same fields in
   the authenticator.  If they don't match, the KRB_AP_ERR_BADMATCH
   error is returned; normally this is caused by a client error or an
   attempted attack.  The addresses in the ticket (if any) are then
   searched for an address matching the operating-system reported
   address of the client.  If no match is found or the server insists on
   ticket addresses but none are present in the ticket, the
   KRB_AP_ERR_BADADDR error is returned.  If the local (server) time and
   the client time in the authenticator differ by more than the
   allowable clock skew (e.g., 5 minutes), the KRB_AP_ERR_SKEW error is
   returned.

   Unless the application server provides its own suitable means to
   protect against replay (for example, a challenge-response sequence
   initiated by the server after authentication, or use of a server-
   generated encryption subkey), the server MUST utilize a replay cache
   to remember any authenticator presented within the allowable clock
   skew.  Careful analysis of the application protocol and
   implementation is recommended before eliminating this cache.  The
   replay cache will store at least the server name, along with the
   client name, time, and microsecond fields from the recently-seen
   authenticators, and if a matching tuple is found, the
   KRB_AP_ERR_REPEAT error is returned.  Note that the rejection here is
   restricted to authenticators from the same principal to the same
   server.  Other client principals communicating with the same server
   principal should not have their authenticators rejected if the time
   and microsecond fields happen to match some other client's
   authenticator.

   If a server loses track of authenticators presented within the
   allowable clock skew, it MUST reject all requests until the clock
   skew interval has passed, providing assurance that any lost or
   replayed authenticators will fall outside the allowable clock skew
   and can no longer be successfully replayed.  If this were not done,
   an attacker could subvert the authentication by recording the ticket
   and authenticator sent over the network to a server and replaying
   them following an event that caused the server to lose track of
   recently seen authenticators.

   Implementation note: If a client generates multiple requests to the
   KDC with the same timestamp, including the microsecond field, all but
   the first of the requests received will be rejected as replays.  This



Neuman, et al.              Standards Track                    [Page 31]

RFC 4120                      Kerberos V5                      July 2005


   might happen, for example, if the resolution of the client's clock is
   too coarse.  Client implementations SHOULD ensure that the timestamps
   are not reused, possibly by incrementing the microseconds field in
   the time stamp when the clock returns the same time for multiple
   requests.

   If multiple servers (for example, different services on one machine,
   or a single service implemented on multiple machines) share a service
   principal (a practice that we do not recommend in general, but that
   we acknowledge will be used in some cases), either they MUST share
   this replay cache, or the application protocol MUST be designed so as
   to eliminate the need for it.  Note that this applies to all of the
   services.  If any of the application protocols does not have replay
   protection built in, an authenticator used with such a service could
   later be replayed to a different service with the same service
   principal but no replay protection, if the former doesn't record the
   authenticator information in the common replay cache.

   If a sequence number is provided in the authenticator, the server
   saves it for later use in processing KRB_SAFE and/or KRB_PRIV
   messages.  If a subkey is present, the server either saves it for
   later use or uses it to help generate its own choice for a subkey to
   be returned in a KRB_AP_REP message.

   The server computes the age of the ticket: local (server) time minus
   the starttime inside the Ticket.  If the starttime is later than the
   current time by more than the allowable clock skew, or if the INVALID
   flag is set in the ticket, the KRB_AP_ERR_TKT_NYV error is returned.
   Otherwise, if the current time is later than end time by more than
   the allowable clock skew, the KRB_AP_ERR_TKT_EXPIRED error is
   returned.

   If all these checks succeed without an error, the server is assured
   that the client possesses the credentials of the principal named in
   the ticket, and thus, that the client has been authenticated to the
   server.

   Passing these checks provides only authentication of the named
   principal; it does not imply authorization to use the named service.
   Applications MUST make a separate authorization decision based upon
   the authenticated name of the user, the requested operation, local
   access control information such as that contained in a .k5login or
   .k5users file, and possibly a separate distributed authorization
   service.







Neuman, et al.              Standards Track                    [Page 32]

RFC 4120                      Kerberos V5                      July 2005


3.2.4.  Generation of a KRB_AP_REP Message

   Typically, a client's request will include both the authentication
   information and its initial request in the same message, and the
   server need not explicitly reply to the KRB_AP_REQ.  However, if
   mutual authentication (authenticating not only the client to the
   server, but also the server to the client) is being performed, the
   KRB_AP_REQ message will have MUTUAL-REQUIRED set in its ap-options
   field, and a KRB_AP_REP message is required in response.  As with the
   error message, this message MAY be encapsulated in the application
   protocol if its ""raw"" form is not acceptable to the application's
   protocol.  The timestamp and microsecond field used in the reply MUST
   be the client's timestamp and microsecond field (as provided in the
   authenticator).  If a sequence number is to be included, it SHOULD be
   randomly chosen as described above for the authenticator.  A subkey
   MAY be included if the server desires to negotiate a different
   subkey.  The KRB_AP_REP message is encrypted in the session key
   extracted from the ticket.

   Note that in the Kerberos Version 4 protocol, the timestamp in the
   reply was the client's timestamp plus one.  This is not necessary in
   Version 5 because Version 5 messages are formatted in such a way that
   it is not possible to create the reply by judicious message surgery
   (even in encrypted form) without knowledge of the appropriate
   encryption keys.

3.2.5.  Receipt of KRB_AP_REP Message

   If a KRB_AP_REP message is returned, the client uses the session key
   from the credentials obtained for the server to decrypt the message
   and verifies that the timestamp and microsecond fields match those in
   the Authenticator it sent to the server.  If they match, then the
   client is assured that the server is genuine.  The sequence number
   and subkey (if present) are retained for later use.  (Note that for
   encrypting the KRB_AP_REP message, the sub-session key is not used,
   even if it is present in the Authentication.)

3.2.6.  Using the Encryption Key

   After the KRB_AP_REQ/KRB_AP_REP exchange has occurred, the client and
   server share an encryption key that can be used by the application.
   In some cases, the use of this session key will be implicit in the
   protocol; in others the method of use must be chosen from several
   alternatives.  The application MAY choose the actual encryption key
   to be used for KRB_PRIV, KRB_SAFE, or other application-specific uses
   based on the session key from the ticket and subkeys in the
   KRB_AP_REP message and the authenticator.  Implementations of the
   protocol MAY provide routines to choose subkeys based on session keys



Neuman, et al.              Standards Track                    [Page 33]

RFC 4120                      Kerberos V5                      July 2005


   and random numbers and to generate a negotiated key to be returned in
   the KRB_AP_REP message.

   To mitigate the effect of failures in random number generation on the
   client, it is strongly encouraged that any key derived by an
   application for subsequent use include the full key entropy derived
   from the KDC-generated session key carried in the ticket.  We leave
   the protocol negotiations of how to use the key (e.g., for selecting
   an encryption or checksum type) to the application programmer.  The
   Kerberos protocol does not constrain the implementation options, but
   an example of how this might be done follows.

   One way that an application may choose to negotiate a key to be used
   for subsequent integrity and privacy protection is for the client to
   propose a key in the subkey field of the authenticator.  The server
   can then choose a key using the key proposed by the client as input,
   returning the new subkey in the subkey field of the application
   reply.  This key could then be used for subsequent communication.

   With both the one-way and mutual authentication exchanges, the peers
   should take care not to send sensitive information to each other
   without proper assurances.  In particular, applications that require
   privacy or integrity SHOULD use the KRB_AP_REP response from the
   server to the client to assure both client and server of their peer's
   identity.  If an application protocol requires privacy of its
   messages, it can use the KRB_PRIV message (section 3.5).  The
   KRB_SAFE message (Section 3.4) can be used to ensure integrity.

3.3.  The Ticket-Granting Service (TGS) Exchange

                             Summary

         Message direction       Message type     Section
         1. Client to Kerberos   KRB_TGS_REQ      5.4.1
         2. Kerberos to client   KRB_TGS_REP or   5.4.2
                                 KRB_ERROR        5.9.1

   The TGS exchange between a client and the Kerberos TGS is initiated
   by a client when it seeks to obtain authentication credentials for a
   given server (which might be registered in a remote realm), when it
   seeks to renew or validate an existing ticket, or when it seeks to
   obtain a proxy ticket.  In the first case, the client must already
   have acquired a ticket for the Ticket-Granting Service using the AS
   exchange (the TGT is usually obtained when a client initially
   authenticates to the system, such as when a user logs in).  The
   message format for the TGS exchange is almost identical to that for
   the AS exchange.  The primary difference is that encryption and
   decryption in the TGS exchange does not take place under the client's



Neuman, et al.              Standards Track                    [Page 34]

RFC 4120                      Kerberos V5                      July 2005


   key.  Instead, the session key from the TGT or renewable ticket, or
   sub-session key from an Authenticator is used.  As is the case for
   all application servers, expired tickets are not accepted by the TGS,
   so once a renewable or TGT expires, the client must use a separate
   exchange to obtain valid tickets.

   The TGS exchange consists of two messages: a request (KRB_TGS_REQ)
   from the client to the Kerberos Ticket-Granting Server, and a reply
   (KRB_TGS_REP or KRB_ERROR).  The KRB_TGS_REQ message includes
   information authenticating the client plus a request for credentials.
   The authentication information consists of the authentication header
   (KRB_AP_REQ), which includes the client's previously obtained
   ticket-granting, renewable, or invalid ticket.  In the TGT and proxy
   cases, the request MAY include one or more of the following: a list
   of network addresses, a collection of typed authorization data to be
   sealed in the ticket for authorization use by the application server,
   or additional tickets (the use of which are described later).  The
   TGS reply (KRB_TGS_REP) contains the requested credentials, encrypted
   in the session key from the TGT or renewable ticket, or, if present,
   in the sub-session key from the Authenticator (part of the
   authentication header).  The KRB_ERROR message contains an error code
   and text explaining what went wrong.  The KRB_ERROR message is not
   encrypted.  The KRB_TGS_REP message contains information that can be
   used to detect replays, and to associate it with the message to which
   it replies.  The KRB_ERROR message also contains information that can
   be used to associate it with the message to which it replies.  The
   same comments about integrity protection of KRB_ERROR messages
   mentioned in Section 3.1 apply to the TGS exchange.

3.3.1.  Generation of KRB_TGS_REQ Message

   Before sending a request to the ticket-granting service, the client
   MUST determine in which realm the application server is believed to
   be registered.  This can be accomplished in several ways.  It might
   be known beforehand (since the realm is part of the principal
   identifier), it might be stored in a nameserver, or it might be
   obtained from a configuration file.  If the realm to be used is
   obtained from a nameserver, there is a danger of being spoofed if the
   nameservice providing the realm name is not authenticated.  This
   might result in the use of a realm that has been compromised, which
   would result in an attacker's ability to compromise the
   authentication of the application server to the client.

   If the client knows the service principal name and realm and it does
   not already possess a TGT for the appropriate realm, then one must be
   obtained.  This is first attempted by requesting a TGT for the
   destination realm from a Kerberos server for which the client
   possesses a TGT (by using the KRB_TGS_REQ message recursively).  The



Neuman, et al.              Standards Track                    [Page 35]

RFC 4120                      Kerberos V5                      July 2005


   Kerberos server MAY return a TGT for the desired realm, in which case
   one can proceed.  Alternatively, the Kerberos server MAY return a TGT
   for a realm that is 'closer' to the desired realm (further along the
   standard hierarchical path between the client's realm and the
   requested realm server's realm).  Note that in this case
   misconfiguration of the Kerberos servers may cause loops in the
   resulting authentication path, which the client should be careful to
   detect and avoid.

   If the Kerberos server returns a TGT for a realm 'closer' than the
   desired realm, the client MAY use local policy configuration to
   verify that the authentication path used is an acceptable one.
   Alternatively, a client MAY choose its own authentication path,
   rather than rely on the Kerberos server to select one.  In either
   case, any policy or configuration information used to choose or
   validate authentication paths, whether by the Kerberos server or by
   the client, MUST be obtained from a trusted source.

   When a client obtains a TGT that is 'closer' to the destination
   realm, the client MAY cache this ticket and reuse it in future
   KRB-TGS exchanges with services in the 'closer' realm.  However, if
   the client were to obtain a TGT for the 'closer' realm by starting at
   the initial KDC rather than as part of obtaining another ticket, then
   a shorter path to the 'closer' realm might be used.  This shorter
   path may be desirable because fewer intermediate KDCs would know the
   session key of the ticket involved.  For this reason, clients SHOULD
   evaluate whether they trust the realms transited in obtaining the
   'closer' ticket when making a decision to use the ticket in future.

   Once the client obtains a TGT for the appropriate realm, it
   determines which Kerberos servers serve that realm and contacts one
   of them.  The list might be obtained through a configuration file or
   network service, or it MAY be generated from the name of the realm.
   As long as the secret keys exchanged by realms are kept secret, only
   denial of service results from using a false Kerberos server.

   As in the AS exchange, the client MAY specify a number of options in
   the KRB_TGS_REQ message.  One of these options is the ENC-TKT-IN-SKEY
   option used for user-to-user authentication.  An overview of user-
   to-user authentication can be found in Section 3.7.  When generating
   the KRB_TGS_REQ message, this option indicates that the client is
   including a TGT obtained from the application server in the
   additional tickets field of the request and that the KDC SHOULD
   encrypt the ticket for the application server using the session key
   from this additional ticket, instead of a server key from the
   principal database.





Neuman, et al.              Standards Track                    [Page 36]

RFC 4120                      Kerberos V5                      July 2005


   The client prepares the KRB_TGS_REQ message, providing an
   authentication header as an element of the padata field, and
   including the same fields as used in the KRB_AS_REQ message along
   with several optional fields: the enc-authorizatfion-data field for
   application server use and additional tickets required by some
   options.

   In preparing the authentication header, the client can select a sub-
   session key under which the response from the Kerberos server will be
   encrypted.  If the client selects a sub-session key, care must be
   taken to ensure the randomness of the selected sub-session key.

   If the sub-session key is not specified, the session key from the TGT
   will be used.  If the enc-authorization-data is present, it MUST be
   encrypted in the sub-session key, if present, from the authenticator
   portion of the authentication header, or, if not present, by using
   the session key from the TGT.

   Once prepared, the message is sent to a Kerberos server for the
   destination realm.

3.3.2.  Receipt of KRB_TGS_REQ Message

   The KRB_TGS_REQ message is processed in a manner similar to the
   KRB_AS_REQ message, but there are many additional checks to be
   performed.  First, the Kerberos server MUST determine which server
   the accompanying ticket is for, and it MUST select the appropriate
   key to decrypt it.  For a normal KRB_TGS_REQ message, it will be for
   the ticket-granting service, and the TGS's key will be used.  If the
   TGT was issued by another realm, then the appropriate inter-realm key
   MUST be used.  If (a) the accompanying ticket is not a TGT for the
   current realm, but is for an application server in the current realm,
   (b) the RENEW, VALIDATE, or PROXY options are specified in the
   request, and (c) the server for which a ticket is requested is the
   server named in the accompanying ticket, then the KDC will decrypt
   the ticket in the authentication header using the key of the server
   for which it was issued.  If no ticket can be found in the padata
   field, the KDC_ERR_PADATA_TYPE_NOSUPP error is returned.

   Once the accompanying ticket has been decrypted, the user-supplied
   checksum in the Authenticator MUST be verified against the contents
   of the request, and the message MUST be rejected if the checksums do
   not match (with an error code of KRB_AP_ERR_MODIFIED) or if the
   checksum is not collision-proof (with an error code of
   KRB_AP_ERR_INAPP_CKSUM).  If the checksum type is not supported, the
   KDC_ERR_SUMTYPE_NOSUPP error is returned.  If the authorization-data
   are present, they are decrypted using the sub-session key from the
   Authenticator.



Neuman, et al.              Standards Track                    [Page 37]

RFC 4120                      Kerberos V5                      July 2005


   If any of the decryptions indicate failed integrity checks, the
   KRB_AP_ERR_BAD_INTEGRITY error is returned.

   As discussed in Section 3.1.2, the KDC MUST send a valid KRB_TGS_REP
   message if it receives a KRB_TGS_REQ message identical to one it has
   recently processed.  However, if the authenticator is a replay, but
   the rest of the request is not identical, then the KDC SHOULD return
   KRB_AP_ERR_REPEAT.

3.3.3.  Generation of KRB_TGS_REP Message

   The KRB_TGS_REP message shares its format with the KRB_AS_REP
   (KRB_KDC_REP), but with its type field set to KRB_TGS_REP.  The
   detailed specification is in Section 5.4.2.

   The response will include a ticket for the requested server or for a
   ticket granting server of an intermediate KDC to be contacted to
   obtain the requested ticket.  The Kerberos database is queried to
   retrieve the record for the appropriate server (including the key
   with which the ticket will be encrypted).  If the request is for a
   TGT for a remote realm, and if no key is shared with the requested
   realm, then the Kerberos server will select the realm 'closest' to
   the requested realm with which it does share a key and use that realm
   instead.  This is the only case where the response for the KDC will
   be for a different server than that requested by the client.

   By default, the address field, the client's name and realm, the list
   of transited realms, the time of initial authentication, the
   expiration time, and the authorization data of the newly-issued
   ticket will be copied from the TGT or renewable ticket.  If the
   transited field needs to be updated, but the transited type is not
   supported, the KDC_ERR_TRTYPE_NOSUPP error is returned.

   If the request specifies an endtime, then the endtime of the new
   ticket is set to the minimum of (a) that request, (b) the endtime
   from the TGT, and (c) the starttime of the TGT plus the minimum of
   the maximum life for the application server and the maximum life for
   the local realm (the maximum life for the requesting principal was
   already applied when the TGT was issued).  If the new ticket is to be
   a renewal, then the endtime above is replaced by the minimum of (a)
   the value of the renew_till field of the ticket and (b) the starttime
   for the new ticket plus the life (endtime-starttime) of the old
   ticket.

   If the FORWARDED option has been requested, then the resulting ticket
   will contain the addresses specified by the client.  This option will
   only be honored if the FORWARDABLE flag is set in the TGT.  The PROXY
   option is similar; the resulting ticket will contain the addresses



Neuman, et al.              Standards Track                    [Page 38]

RFC 4120                      Kerberos V5                      July 2005


   specified by the client.  It will be honored only if the PROXIABLE
   flag in the TGT is set.  The PROXY option will not be honored on
   requests for additional TGTs.

   If the requested starttime is absent, indicates a time in the past,
   or is within the window of acceptable clock skew for the KDC and the
   POSTDATE option has not been specified, then the starttime of the
   ticket is set to the authentication server's current time.  If it
   indicates a time in the future beyond the acceptable clock skew, but
   the POSTDATED option has not been specified or the MAY-POSTDATE flag
   is not set in the TGT, then the error KDC_ERR_CANNOT_POSTDATE is
   returned.  Otherwise, if the TGT has the MAY-POSTDATE flag set, then
   the resulting ticket will be postdated, and the requested starttime
   is checked against the policy of the local realm.  If acceptable, the
   ticket's starttime is set as requested, and the INVALID flag is set.
   The postdated ticket MUST be validated before use by presenting it to
   the KDC after the starttime has been reached.  However, in no case
   may the starttime, endtime, or renew-till time of a newly-issued
   postdated ticket extend beyond the renew-till time of the TGT.

   If the ENC-TKT-IN-SKEY option has been specified and an additional
   ticket has been included in the request, it indicates that the client
   is using user-to-user authentication to prove its identity to a
   server that does not have access to a persistent key.  Section 3.7
   describes the effect of this option on the entire Kerberos protocol.
   When generating the KRB_TGS_REP message, this option in the
   KRB_TGS_REQ message tells the KDC to decrypt the additional ticket
   using the key for the server to which the additional ticket was
   issued and to verify that it is a TGT.  If the name of the requested
   server is missing from the request, the name of the client in the
   additional ticket will be used.  Otherwise, the name of the requested
   server will be compared to the name of the client in the additional
   ticket.  If it is different, the request will be rejected.  If the
   request succeeds, the session key from the additional ticket will be
   used to encrypt the new ticket that is issued instead of using the
   key of the server for which the new ticket will be used.

   If (a) the name of the server in the ticket that is presented to the
   KDC as part of the authentication header is not that of the TGS
   itself, (b) the server is registered in the realm of the KDC, and (c)
   the RENEW option is requested, then the KDC will verify that the
   RENEWABLE flag is set in the ticket, that the INVALID flag is not set
   in the ticket, and that the renew_till time is still in the future.
   If the VALIDATE option is requested, the KDC will check that the
   starttime has passed and that the INVALID flag is set.  If the PROXY
   option is requested, then the KDC will check that the PROXIABLE flag





Neuman, et al.              Standards Track                    [Page 39]

RFC 4120                      Kerberos V5                      July 2005


   is set in the ticket.  If the tests succeed and the ticket passes the
   hotlist check described in the next section, the KDC will issue the
   appropriate new ticket.

   The ciphertext part of the response in the KRB_TGS_REP message is
   encrypted in the sub-session key from the Authenticator, if present,
   or in the session key from the TGT.  It is not encrypted using the
   client's secret key.  Furthermore, the client's key's expiration date
   and the key version number fields are left out since these values are
   stored along with the client's database record, and that record is
   not needed to satisfy a request based on a TGT.

3.3.3.1.  Checking for Revoked Tickets

   Whenever a request is made to the ticket-granting server, the
   presented ticket(s) is (are) checked against a hot-list of tickets
   that have been canceled.  This hot-list might be implemented by
   storing a range of issue timestamps for 'suspect tickets'; if a
   presented ticket had an authtime in that range, it would be rejected.
   In this way, a stolen TGT or renewable ticket cannot be used to gain
   additional tickets (renewals or otherwise) once the theft has been
   reported to the KDC for the realm in which the server resides.  Any
   normal ticket obtained before it was reported stolen will still be
   valid (because tickets require no interaction with the KDC), but only
   until its normal expiration time.  If TGTs have been issued for
   cross-realm authentication, use of the cross-realm TGT will not be
   affected unless the hot-list is propagated to the KDCs for the realms
   for which such cross-realm tickets were issued.

3.3.3.2.  Encoding the Transited Field

   If the identity of the server in the TGT that is presented to the KDC
   as part of the authentication header is that of the ticket-granting
   service, but the TGT was issued from another realm, the KDC will look
   up the inter-realm key shared with that realm and use that key to
   decrypt the ticket.  If the ticket is valid, then the KDC will honor
   the request, subject to the constraints outlined above in the section
   describing the AS exchange.  The realm part of the client's identity
   will be taken from the TGT.  The name of the realm that issued the
   TGT, if it is not the realm of the client principal, will be added to
   the transited field of the ticket to be issued.  This is accomplished
   by reading the transited field from the TGT (which is treated as an
   unordered set of realm names), adding the new realm to the set, and
   then constructing and writing out its encoded (shorthand) form (this
   may involve a rearrangement of the existing encoding).

   Note that the ticket-granting service does not add the name of its
   own realm.  Instead, its responsibility is to add the name of the



Neuman, et al.              Standards Track                    [Page 40]

RFC 4120                      Kerberos V5                      July 2005


   previous realm.  This prevents a malicious Kerberos server from
   intentionally leaving out its own name (it could, however, omit other
   realms' names).

   The names of neither the local realm nor the principal's realm are to
   be included in the transited field.  They appear elsewhere in the
   ticket and both are known to have taken part in authenticating the
   principal.  Because the endpoints are not included, both local and
   single-hop inter-realm authentication result in a transited field
   that is empty.

   Because this field has the name of each transited realm added to it,
   it might potentially be very long.  To decrease the length of this
   field, its contents are encoded.  The initially supported encoding is
   optimized for the normal case of inter-realm communication: a
   hierarchical arrangement of realms using either domain or X.500 style
   realm names.  This encoding (called DOMAIN-X500-COMPRESS) is now
   described.

   Realm names in the transited field are separated by a "","".  The "","",
   ""\"", trailing "".""s, and leading spaces ("" "") are special characters,
   and if they are part of a realm name, they MUST be quoted in the
   transited field by preceding them with a ""\"".

   A realm name ending with a ""."" is interpreted as being prepended to
   the previous realm.  For example, we can encode traversal of EDU,
   MIT.EDU, ATHENA.MIT.EDU, WASHINGTON.EDU, and CS.WASHINGTON.EDU as:

      ""EDU,MIT.,ATHENA.,WASHINGTON.EDU,CS."".

   Note that if either ATHENA.MIT.EDU, or CS.WASHINGTON.EDU were
   endpoints, they would not be included in this field, and we would
   have:

      ""EDU,MIT.,WASHINGTON.EDU""

   A realm name beginning with a ""/"" is interpreted as being appended to
   the previous realm.  For the purpose of appending, the realm
   preceding the first listed realm is considered the null realm ("""").
   If a realm name beginning with a ""/"" is to stand by itself, then it
   SHOULD be preceded by a space ("" "").  For example, we can encode
   traversal of /COM/HP/APOLLO, /COM/HP, /COM, and /COM/DEC as:

      ""/COM,/HP,/APOLLO, /COM/DEC"".

   As in the example above, if /COM/HP/APOLLO and /COM/DEC were
   endpoints, they would not be included in this field, and we would
   have:



Neuman, et al.              Standards Track                    [Page 41]

RFC 4120                      Kerberos V5                      July 2005


      ""/COM,/HP""

   A null subfield preceding or following a "","" indicates that all
   realms between the previous realm and the next realm have been
   traversed.  For the purpose of interpreting null subfields, the
   client's realm is considered to precede those in the transited field,
   and the server's realm is considered to follow them.  Thus, "","" means
   that all realms along the path between the client and the server have
   been traversed.  "",EDU, /COM,"" means that all realms from the
   client's realm up to EDU (in a domain style hierarchy) have been
   traversed, and that everything from /COM down to the server's realm
   in an X.500 style has also been traversed.  This could occur if the
   EDU realm in one hierarchy shares an inter-realm key directly with
   the /COM realm in another hierarchy.

3.3.4.  Receipt of KRB_TGS_REP Message

   When the KRB_TGS_REP is received by the client, it is processed in
   the same manner as the KRB_AS_REP processing described above.  The
   primary difference is that the ciphertext part of the response must
   be decrypted using the sub-session key from the Authenticator, if it
   was specified in the request, or the session key from the TGT, rather
   than the client's secret key.  The server name returned in the reply
   is the true principal name of the service.

3.4.  The KRB_SAFE Exchange

   The KRB_SAFE message MAY be used by clients requiring the ability to
   detect modifications of messages they exchange.  It achieves this by
   including a keyed collision-proof checksum of the user data and some
   control information.  The checksum is keyed with an encryption key
   (usually the last key negotiated via subkeys, or the session key if
   no negotiation has occurred).

3.4.1.  Generation of a KRB_SAFE Message

   When an application wishes to send a KRB_SAFE message, it collects
   its data and the appropriate control information and computes a
   checksum over them.  The checksum algorithm should be the keyed
   checksum mandated to be implemented along with the crypto system used
   for the sub-session or session key.  The checksum is generated using
   the sub-session key, if present, or the session key.  Some
   implementations use a different checksum algorithm for the KRB_SAFE
   messages, but doing so in an interoperable manner is not always
   possible.

   The control information for the KRB_SAFE message includes both a
   timestamp and a sequence number.  The designer of an application



Neuman, et al.              Standards Track                    [Page 42]

RFC 4120                      Kerberos V5                      July 2005


   using the KRB_SAFE message MUST choose at least one of the two
   mechanisms.  This choice SHOULD be based on the needs of the
   application protocol.

   Sequence numbers are useful when all messages sent will be received
   by one's peer.  Connection state is presently required to maintain
   the session key, so maintaining the next sequence number should not
   present an additional problem.

   If the application protocol is expected to tolerate lost messages
   without their being resent, the use of the timestamp is the
   appropriate replay detection mechanism.  Using timestamps is also the
   appropriate mechanism for multi-cast protocols in which all of one's
   peers share a common sub-session key, but some messages will be sent
   to a subset of one's peers.

   After computing the checksum, the client then transmits the
   information and checksum to the recipient in the message format
   specified in Section 5.6.1.

3.4.2.  Receipt of KRB_SAFE Message

   When an application receives a KRB_SAFE message, it verifies it as
   follows.  If any error occurs, an error code is reported for use by
   the application.

   The message is first checked by verifying that the protocol version
   and type fields match the current version and KRB_SAFE, respectively.
   A mismatch generates a KRB_AP_ERR_BADVERSION or KRB_AP_ERR_MSG_TYPE
   error.  The application verifies that the checksum used is a
   collision-proof keyed checksum that uses keys compatible with the
   sub-session or session key as appropriate (or with the application
   key derived from the session or sub-session keys).  If it is not, a
   KRB_AP_ERR_INAPP_CKSUM error is generated.  The sender's address MUST
   be included in the control information; the recipient verifies that
   the operating system's report of the sender's address matches the
   sender's address in the message, and (if a recipient address is
   specified or the recipient requires an address) that one of the
   recipient's addresses appears as the recipient's address in the
   message.  To work with network address translation, senders MAY use
   the directional address type specified in Section 8.1 for the sender
   address and not include recipient addresses.  A failed match for
   either case generates a KRB_AP_ERR_BADADDR error.  Then the timestamp
   and usec and/or the sequence number fields are checked.  If timestamp
   and usec are expected and not present, or if they are present but not
   current, the KRB_AP_ERR_SKEW error is generated.  Timestamps are not
   required to be strictly ordered; they are only required to be in the
   skew window.  If the server name, along with the client name, time,



Neuman, et al.              Standards Track                    [Page 43]

RFC 4120                      Kerberos V5                      July 2005


   and microsecond fields from the Authenticator match any recently-seen
   (sent or received) such tuples, the KRB_AP_ERR_REPEAT error is
   generated.  If an incorrect sequence number is included, or if a
   sequence number is expected but not present, the KRB_AP_ERR_BADORDER
   error is generated.  If neither a time-stamp and usec nor a sequence
   number is present, a KRB_AP_ERR_MODIFIED error is generated.
   Finally, the checksum is computed over the data and control
   information, and if it doesn't match the received checksum, a
   KRB_AP_ERR_MODIFIED error is generated.

   If all the checks succeed, the application is assured that the
   message was generated by its peer and was not modified in transit.

   Implementations SHOULD accept any checksum algorithm they implement
   that has both adequate security and keys compatible with the sub-
   session or session key.  Unkeyed or non-collision-proof checksums are
   not suitable for this use.

3.5.  The KRB_PRIV Exchange

   The KRB_PRIV message MAY be used by clients requiring confidentiality
   and the ability to detect modifications of exchanged messages.  It
   achieves this by encrypting the messages and adding control
   information.

3.5.1.  Generation of a KRB_PRIV Message

   When an application wishes to send a KRB_PRIV message, it collects
   its data and the appropriate control information (specified in
   Section 5.7.1) and encrypts them under an encryption key (usually the
   last key negotiated via subkeys, or the session key if no negotiation
   has occurred).  As part of the control information, the client MUST
   choose to use either a timestamp or a sequence number (or both); see
   the discussion in Section 3.4.1 for guidelines on which to use.
   After the user data and control information are encrypted, the client
   transmits the ciphertext and some 'envelope' information to the
   recipient.

3.5.2.  Receipt of KRB_PRIV Message

   When an application receives a KRB_PRIV message, it verifies it as
   follows.  If any error occurs, an error code is reported for use by
   the application.

   The message is first checked by verifying that the protocol version
   and type fields match the current version and KRB_PRIV, respectively.
   A mismatch generates a KRB_AP_ERR_BADVERSION or KRB_AP_ERR_MSG_TYPE
   error.  The application then decrypts the ciphertext and processes



Neuman, et al.              Standards Track                    [Page 44]

RFC 4120                      Kerberos V5                      July 2005


   the resultant plaintext.  If decryption shows that the data has been
   modified, a KRB_AP_ERR_BAD_INTEGRITY error is generated.

   The sender's address MUST be included in the control information; the
   recipient verifies that the operating system's report of the sender's
   address matches the sender's address in the message.  If a recipient
   address is specified or the recipient requires an address, then one
   of the recipient's addresses MUST also appear as the recipient's
   address in the message.  Where a sender's or receiver's address might
   not otherwise match the address in a message because of network
   address translation, an application MAY be written to use addresses
   of the directional address type in place of the actual network
   address.

   A failed match for either case generates a KRB_AP_ERR_BADADDR error.
   To work with network address translation, implementations MAY use the
   directional address type defined in Section 7.1 for the sender
   address and include no recipient address.

   Next the timestamp and usec and/or the sequence number fields are
   checked.  If timestamp and usec are expected and not present, or if
   they are present but not current, the KRB_AP_ERR_SKEW error is
   generated.  If the server name, along with the client name, time, and
   microsecond fields from the Authenticator match any such recently-
   seen tuples, the KRB_AP_ERR_REPEAT error is generated.  If an
   incorrect sequence number is included, or if a sequence number is
   expected but not present, the KRB_AP_ERR_BADORDER error is generated.
   If neither a time-stamp and usec nor a sequence number is present, a
   KRB_AP_ERR_MODIFIED error is generated.

   If all the checks succeed, the application can assume the message was
   generated by its peer and was securely transmitted (without intruders
   seeing the unencrypted contents).

3.6.  The KRB_CRED Exchange

   The KRB_CRED message MAY be used by clients requiring the ability to
   send Kerberos credentials from one host to another.  It achieves this
   by sending the tickets together with encrypted data containing the
   session keys and other information associated with the tickets.

3.6.1.  Generation of a KRB_CRED Message

   When an application wishes to send a KRB_CRED message, it first
   (using the KRB_TGS exchange) obtains credentials to be sent to the
   remote host.  It then constructs a KRB_CRED message using the ticket
   or tickets so obtained, placing the session key needed to use each




Neuman, et al.              Standards Track                    [Page 45]

RFC 4120                      Kerberos V5                      July 2005


   ticket in the key field of the corresponding KrbCredInfo sequence of
   the encrypted part of the KRB_CRED message.

   Other information associated with each ticket and obtained during the
   KRB_TGS exchange is also placed in the corresponding KrbCredInfo
   sequence in the encrypted part of the KRB_CRED message.  The current
   time and, if they are specifically required by the application, the
   nonce, s-address, and r-address fields are placed in the encrypted
   part of the KRB_CRED message, which is then encrypted under an
   encryption key previously exchanged in the KRB_AP exchange (usually
   the last key negotiated via subkeys, or the session key if no
   negotiation has occurred).

   Implementation note: When constructing a KRB_CRED message for
   inclusion in a GSSAPI initial context token, the MIT implementation
   of Kerberos will not encrypt the KRB_CRED message if the session key
   is a DES or triple DES key.  For interoperability with MIT, the
   Microsoft implementation will not encrypt the KRB_CRED in a GSSAPI
   token if it is using a DES session key.  Starting at version 1.2.5,
   MIT Kerberos can receive and decode either encrypted or unencrypted
   KRB_CRED tokens in the GSSAPI exchange.  The Heimdal implementation
   of Kerberos can also accept either encrypted or unencrypted KRB_CRED
   messages.  Since the KRB_CRED message in a GSSAPI token is encrypted
   in the authenticator, the MIT behavior does not present a security
   problem, although it is a violation of the Kerberos specification.

3.6.2.  Receipt of KRB_CRED Message

   When an application receives a KRB_CRED message, it verifies it.  If
   any error occurs, an error code is reported for use by the
   application.  The message is verified by checking that the protocol
   version and type fields match the current version and KRB_CRED,
   respectively.  A mismatch generates a KRB_AP_ERR_BADVERSION or
   KRB_AP_ERR_MSG_TYPE error.  The application then decrypts the
   ciphertext and processes the resultant plaintext.  If decryption
   shows the data to have been modified, a KRB_AP_ERR_BAD_INTEGRITY
   error is generated.

   If present or required, the recipient MAY verify that the operating
   system's report of the sender's address matches the sender's address
   in the message, and that one of the recipient's addresses appears as
   the recipient's address in the message.  The address check does not
   provide any added security, since the address, if present, has
   already been checked in the KRB_AP_REQ message and there is not any
   benefit to be gained by an attacker in reflecting a KRB_CRED message
   back to its originator.  Thus, the recipient MAY ignore the address
   even if it is present in order to work better in Network Address
   Translation (NAT) environments.  A failed match for either case



Neuman, et al.              Standards Track                    [Page 46]

RFC 4120                      Kerberos V5                      July 2005


   generates a KRB_AP_ERR_BADADDR error.  Recipients MAY skip the
   address check, as the KRB_CRED message cannot generally be reflected
   back to the originator.  The timestamp and usec fields (and the nonce
   field, if required) are checked next.  If the timestamp and usec are
   not present, or if they are present but not current, the
   KRB_AP_ERR_SKEW error is generated.

   If all the checks succeed, the application stores each of the new
   tickets in its credentials cache together with the session key and
   other information in the corresponding KrbCredInfo sequence from the
   encrypted part of the KRB_CRED message.

3.7.  User-to-User Authentication Exchanges

   User-to-User authentication provides a method to perform
   authentication when the verifier does not have a access to long-term
   service key.  This might be the case when running a server (for
   example, a window server) as a user on a workstation.  In such cases,
   the server may have access to the TGT obtained when the user logged
   in to the workstation, but because the server is running as an
   unprivileged user, it might not have access to system keys.  Similar
   situations may arise when running peer-to-peer applications.

                             Summary

       Message direction                    Message type     Sections
       0. Message from application server   Not specified
       1. Client to Kerberos                KRB_TGS_REQ      3.3 & 5.4.1
       2. Kerberos to client                KRB_TGS_REP or   3.3 & 5.4.2
                                            KRB_ERROR        5.9.1
       3. Client to application server      KRB_AP_REQ       3.2 & 5.5.1

   To address this problem, the Kerberos protocol allows the client to
   request that the ticket issued by the KDC be encrypted using a
   session key from a TGT issued to the party that will verify the
   authentication.  This TGT must be obtained from the verifier by means
   of an exchange external to the Kerberos protocol, usually as part of
   the application protocol.  This message is shown in the summary above
   as message 0.  Note that because the TGT is encrypted in the KDC's
   secret key, it cannot be used for authentication without possession
   of the corresponding secret key.  Furthermore, because the verifier
   does not reveal the corresponding secret key, providing a copy of the
   verifier's TGT does not allow impersonation of the verifier.

   Message 0 in the table above represents an application-specific
   negotiation between the client and server, at the end of which both
   have determined that they will use user-to-user authentication, and
   the client has obtained the server's TGT.



Neuman, et al.              Standards Track                    [Page 47]

RFC 4120                      Kerberos V5                      July 2005


   Next, the client includes the server's TGT as an additional ticket in
   its KRB_TGS_REQ request to the KDC (message 1 in the table above) and
   specifies the ENC-TKT-IN-SKEY option in its request.

   If validated according to the instructions in Section 3.3.3, the
   application ticket returned to the client (message 2 in the table
   above) will be encrypted using the session key from the additional
   ticket and the client will note this when it uses or stores the
   application ticket.

   When contacting the server using a ticket obtained for user-to-user
   authentication (message 3 in the table above), the client MUST
   specify the USE-SESSION-KEY flag in the ap-options field.  This tells
   the application server to use the session key associated with its TGT
   to decrypt the server ticket provided in the application request.

4.  Encryption and Checksum Specifications

   The Kerberos protocols described in this document are designed to
   encrypt messages of arbitrary sizes, using stream or block encryption
   ciphers.  Encryption is used to prove the identities of the network
   entities participating in message exchanges.  The Key Distribution
   Center for each realm is trusted by all principals registered in that
   realm to store a secret key in confidence.  Proof of knowledge of
   this secret key is used to verify the authenticity of a principal.

   The KDC uses the principal's secret key (in the AS exchange) or a
   shared session key (in the TGS exchange) to encrypt responses to
   ticket requests; the ability to obtain the secret key or session key
   implies the knowledge of the appropriate keys and the identity of the
   KDC.  The ability of a principal to decrypt the KDC response and to
   present a Ticket and a properly formed Authenticator (generated with
   the session key from the KDC response) to a service verifies the
   identity of the principal; likewise the ability of the service to
   extract the session key from the Ticket and to prove its knowledge
   thereof in a response verifies the identity of the service.

   [RFC3961] defines a framework for defining encryption and checksum
   mechanisms for use with Kerberos.  It also defines several such
   mechanisms, and more may be added in future updates to that document.

   The string-to-key operation provided by [RFC3961] is used to produce
   a long-term key for a principal (generally for a user).  The default
   salt string, if none is provided via pre-authentication data, is the
   concatenation of the principal's realm and name components, in order,
   with no separators.  Unless it is indicated otherwise, the default
   string-to-key opaque parameter set as defined in [RFC3961] is used.




Neuman, et al.              Standards Track                    [Page 48]

RFC 4120                      Kerberos V5                      July 2005


   Encrypted data, keys, and checksums are transmitted using the
   EncryptedData, EncryptionKey, and Checksum data objects defined in
   Section 5.2.9.  The encryption, decryption, and checksum operations
   described in this document use the corresponding encryption,
   decryption, and get_mic operations described in [RFC3961], with
   implicit ""specific key"" generation using the ""key usage"" values
   specified in the description of each EncryptedData or Checksum object
   to vary the key for each operation.  Note that in some cases, the
   value to be used is dependent on the method of choosing the key or
   the context of the message.

   Key usages are unsigned 32-bit integers; zero is not permitted.  The
   key usage values for encrypting or checksumming Kerberos messages are
   indicated in Section 5 along with the message definitions.  The key
   usage values 512-1023 are reserved for uses internal to a Kerberos
   implementation.  (For example, seeding a pseudo-random number
   generator with a value produced by encrypting something with a
   session key and a key usage value not used for any other purpose.)
   Key usage values between 1024 and 2047 (inclusive) are reserved for
   application use; applications SHOULD use even values for encryption
   and odd values for checksums within this range.  Key usage values are
   also summarized in a table in Section 7.5.1.

   There might exist other documents that define protocols in terms of
   the RFC 1510 encryption types or checksum types.  These documents
   would not know about key usages.  In order that these specifications
   continue to be meaningful until they are updated, if no key usage
   values are specified, then key usages 1024 and 1025 must be used to
   derive keys for encryption and checksums, respectively.  (This does
   not apply to protocols that do their own encryption independent of
   this framework, by directly using the key resulting from the Kerberos
   authentication exchange.)  New protocols defined in terms of the
   Kerberos encryption and checksum types SHOULD use their own key usage
   values.

   Unless it is indicated otherwise, no cipher state chaining is done
   from one encryption operation to another.

   Implementation note: Although it is not recommended, some application
   protocols will continue to use the key data directly, even if only in
   currently existing protocol specifications.  An implementation
   intended to support general Kerberos applications may therefore need
   to make key data available, as well as the attributes and operations
   described in [RFC3961].  One of the more common reasons for directly
   performing encryption is direct control over negotiation and
   selection of a ""sufficiently strong"" encryption algorithm (in the
   context of a given application).  Although Kerberos does not directly
   provide a facility for negotiating encryption types between the



Neuman, et al.              Standards Track                    [Page 49]

RFC 4120                      Kerberos V5                      July 2005


   application client and server, there are approaches for using
   Kerberos to facilitate this negotiation.  For example, a client may
   request only ""sufficiently strong"" session key types from the KDC and
   expect that any type returned by the KDC will be understood and
   supported by the application server.

5.  Message Specifications

   The ASN.1 collected here should be identical to the contents of
   Appendix A.  In the case of a conflict, the contents of Appendix A
   shall take precedence.

   The Kerberos protocol is defined here in terms of Abstract Syntax
   Notation One (ASN.1) [X680], which provides a syntax for specifying
   both the abstract layout of protocol messages as well as their
   encodings.  Implementors not utilizing an existing ASN.1 compiler or
   support library are cautioned to understand the actual ASN.1
   specification thoroughly in order to ensure correct implementation
   behavior.  There is more complexity in the notation than is
   immediately obvious, and some tutorials and guides to ASN.1 are
   misleading or erroneous.

   Note that in several places, changes to abstract types from RFC 1510
   have been made.  This is in part to address widespread assumptions
   that various implementors have made, in some cases resulting in
   unintentional violations of the ASN.1 standard.  These are clearly
   flagged where they occur.  The differences between the abstract types
   in RFC 1510 and abstract types in this document can cause
   incompatible encodings to be emitted when certain encoding rules,
   e.g., the Packed Encoding Rules (PER), are used.  This theoretical
   incompatibility should not be relevant for Kerberos, since Kerberos
   explicitly specifies the use of the Distinguished Encoding Rules
   (DER).  It might be an issue for protocols seeking to use Kerberos
   types with other encoding rules.  (This practice is not recommended.)
   With very few exceptions (most notably the usages of BIT STRING), the
   encodings resulting from using the DER remain identical between the
   types defined in RFC 1510 and the types defined in this document.

   The type definitions in this section assume an ASN.1 module
   definition of the following form:











Neuman, et al.              Standards Track                    [Page 50]

RFC 4120                      Kerberos V5                      July 2005


   KerberosV5Spec2 {
           iso(1) identified-organization(3) dod(6) internet(1)
           security(5) kerberosV5(2) modules(4) krb5spec2(2)
   } DEFINITIONS EXPLICIT TAGS ::= BEGIN

   -- rest of definitions here

   END

   This specifies that the tagging context for the module will be
   explicit and non-automatic.

   Note that in some other publications (such as [RFC1510] and
   [RFC1964]), the ""dod"" portion of the object identifier is erroneously
   specified as having the value ""5"".  In the case of RFC 1964, use of
   the ""correct"" OID value would result in a change in the wire
   protocol; therefore, it remains unchanged for now.

   Note that elsewhere in this document, nomenclature for various
   message types is inconsistent, but it largely follows C language
   conventions, including use of underscore (_) characters and all-caps
   spelling of names intended to be numeric constants.  Also, in some
   places, identifiers (especially those referring to constants) are
   written in all-caps in order to distinguish them from surrounding
   explanatory text.

   The ASN.1 notation does not permit underscores in identifiers, so in
   actual ASN.1 definitions, underscores are replaced with hyphens (-).
   Additionally, structure member names and defined values in ASN.1 MUST
   begin with a lowercase letter, whereas type names MUST begin with an
   uppercase letter.

5.1.  Specific Compatibility Notes on ASN.1

   For compatibility purposes, implementors should heed the following
   specific notes regarding the use of ASN.1 in Kerberos.  These notes
   do not describe deviations from standard usage of ASN.1.  The purpose
   of these notes is instead to describe some historical quirks and
   non-compliance of various implementations, as well as historical
   ambiguities, which, although they are valid ASN.1, can lead to
   confusion during implementation.

5.1.1.  ASN.1 Distinguished Encoding Rules

   The encoding of Kerberos protocol messages shall obey the
   Distinguished Encoding Rules (DER) of ASN.1 as described in [X690].
   Some implementations (believed primarily to be those derived from DCE
   1.1 and earlier) are known to use the more general Basic Encoding



Neuman, et al.              Standards Track                    [Page 51]

RFC 4120                      Kerberos V5                      July 2005


   Rules (BER); in particular, these implementations send indefinite
   encodings of lengths.  Implementations MAY accept such encodings in
   the interest of backward compatibility, though implementors are
   warned that decoding fully-general BER is fraught with peril.

5.1.2.  Optional Integer Fields

   Some implementations do not internally distinguish between an omitted
   optional integer value and a transmitted value of zero.  The places
   in the protocol where this is relevant include various microseconds
   fields, nonces, and sequence numbers.  Implementations SHOULD treat
   omitted optional integer values as having been transmitted with a
   value of zero, if the application is expecting this.

5.1.3.  Empty SEQUENCE OF Types

   There are places in the protocol where a message contains a SEQUENCE
   OF type as an optional member.  This can result in an encoding that
   contains an empty SEQUENCE OF encoding.  The Kerberos protocol does
   not semantically distinguish between an absent optional SEQUENCE OF
   type and a present optional but empty SEQUENCE OF type.
   Implementations SHOULD NOT send empty SEQUENCE OF encodings that are
   marked OPTIONAL, but SHOULD accept them as being equivalent to an
   omitted OPTIONAL type.  In the ASN.1 syntax describing Kerberos
   messages, instances of these problematic optional SEQUENCE OF types
   are indicated with a comment.

5.1.4.  Unrecognized Tag Numbers

   Future revisions to this protocol may include new message types with
   different APPLICATION class tag numbers.  Such revisions should
   protect older implementations by only sending the message types to
   parties that are known to understand them; e.g., by means of a flag
   bit set by the receiver in a preceding request.  In the interest of
   robust error handling, implementations SHOULD gracefully handle
   receiving a message with an unrecognized tag anyway, and return an
   error message, if appropriate.

   In particular, KDCs SHOULD return KRB_AP_ERR_MSG_TYPE if the
   incorrect tag is sent over a TCP transport.  The KDCs SHOULD NOT
   respond to messages received with an unknown tag over UDP transport
   in order to avoid denial of service attacks.  For non-KDC
   applications, the Kerberos implementation typically indicates an
   error to the application which takes appropriate steps based on the
   application protocol.






Neuman, et al.              Standards Track                    [Page 52]

RFC 4120                      Kerberos V5                      July 2005


5.1.5.  Tag Numbers Greater Than 30

   A naive implementation of a DER ASN.1 decoder may experience problems
   with ASN.1 tag numbers greater than 30, due to such tag numbers being
   encoded using more than one byte.  Future revisions of this protocol
   may utilize tag numbers greater than 30, and implementations SHOULD
   be prepared to gracefully return an error, if appropriate, when they
   do not recognize the tag.

5.2.  Basic Kerberos Types

   This section defines a number of basic types that are potentially
   used in multiple Kerberos protocol messages.

5.2.1.  KerberosString

   The original specification of the Kerberos protocol in RFC 1510 uses
   GeneralString in numerous places for human-readable string data.
   Historical implementations of Kerberos cannot utilize the full power
   of GeneralString.  This ASN.1 type requires the use of designation
   and invocation escape sequences as specified in ISO-2022/ECMA-35
   [ISO-2022/ECMA-35] to switch character sets, and the default
   character set that is designated as G0 is the ISO-646/ECMA-6
   [ISO-646/ECMA-6] International Reference Version (IRV) (a.k.a. U.S.
   ASCII), which mostly works.

   ISO-2022/ECMA-35 defines four character-set code elements (G0..G3)
   and two Control-function code elements (C0..C1).  DER prohibits the
   designation of character sets as any but the G0 and C0 sets.
   Unfortunately, this seems to have the side effect of prohibiting the
   use of ISO-8859 (ISO Latin) [ISO-8859] character sets or any other
   character sets that utilize a 96-character set, as ISO-2022/ECMA-35
   prohibits designating them as the G0 code element.  This side effect
   is being investigated in the ASN.1 standards community.

   In practice, many implementations treat GeneralStrings as if they
   were 8-bit strings of whichever character set the implementation
   defaults to, without regard to correct usage of character-set
   designation escape sequences.  The default character set is often
   determined by the current user's operating system-dependent locale.
   At least one major implementation places unescaped UTF-8 encoded
   Unicode characters in the GeneralString.  This failure to adhere to
   the GeneralString specifications results in interoperability issues
   when conflicting character encodings are utilized by the Kerberos
   clients, services, and KDC.






Neuman, et al.              Standards Track                    [Page 53]

RFC 4120                      Kerberos V5                      July 2005


   This unfortunate situation is the result of improper documentation of
   the restrictions of the ASN.1 GeneralString type in prior Kerberos
   specifications.

   The new (post-RFC 1510) type KerberosString, defined below, is a
   GeneralString that is constrained to contain only characters in
   IA5String.

      KerberosString  ::= GeneralString (IA5String)

   In general, US-ASCII control characters should not be used in
   KerberosString.  Control characters SHOULD NOT be used in principal
   names or realm names.

   For compatibility, implementations MAY choose to accept GeneralString
   values that contain characters other than those permitted by
   IA5String, but they should be aware that character set designation
   codes will likely be absent, and that the encoding should probably be
   treated as locale-specific in almost every way.  Implementations MAY
   also choose to emit GeneralString values that are beyond those
   permitted by IA5String, but they should be aware that doing so is
   extraordinarily risky from an interoperability perspective.

   Some existing implementations use GeneralString to encode unescaped
   locale-specific characters.  This is a violation of the ASN.1
   standard.  Most of these implementations encode US-ASCII in the
   left-hand half, so as long as the implementation transmits only
   US-ASCII, the ASN.1 standard is not violated in this regard.  As soon
   as such an implementation encodes unescaped locale-specific
   characters with the high bit set, it violates the ASN.1 standard.

   Other implementations have been known to use GeneralString to contain
   a UTF-8 encoding.  This also violates the ASN.1 standard, since UTF-8
   is a different encoding, not a 94 or 96 character ""G"" set as defined
   by ISO 2022.  It is believed that these implementations do not even
   use the ISO 2022 escape sequence to change the character encoding.
   Even if implementations were to announce the encoding change by using
   that escape sequence, the ASN.1 standard prohibits the use of any
   escape sequences other than those used to designate/invoke ""G"" or ""C""
   sets allowed by GeneralString.

   Future revisions to this protocol will almost certainly allow for a
   more interoperable representation of principal names, probably
   including UTF8String.

   Note that applying a new constraint to a previously unconstrained
   type constitutes creation of a new ASN.1 type.  In this particular
   case, the change does not result in a changed encoding under DER.



Neuman, et al.              Standards Track                    [Page 54]

RFC 4120                      Kerberos V5                      July 2005


5.2.2.  Realm and PrincipalName

   Realm           ::= KerberosString

   PrincipalName   ::= SEQUENCE {
           name-type       [0] Int32,
           name-string     [1] SEQUENCE OF KerberosString
   }

   Kerberos realm names are encoded as KerberosStrings.  Realms shall
   not contain a character with the code 0 (the US-ASCII NUL).  Most
   realms will usually consist of several components separated by
   periods (.), in the style of Internet Domain Names, or separated by
   slashes (/), in the style of X.500 names.  Acceptable forms for realm
   names are specified in Section 6.1.  A PrincipalName is a typed
   sequence of components consisting of the following subfields:

   name-type
      This field specifies the type of name that follows.  Pre-defined
      values for this field are specified in Section 6.2.  The name-type
      SHOULD be treated as a hint.  Ignoring the name type, no two names
      can be the same (i.e., at least one of the components, or the
      realm, must be different).

   name-string
      This field encodes a sequence of components that form a name, each
      component encoded as a KerberosString.  Taken together, a
      PrincipalName and a Realm form a principal identifier.  Most
      PrincipalNames will have only a few components (typically one or
      two).

5.2.3.  KerberosTime

   KerberosTime    ::= GeneralizedTime -- with no fractional seconds

   The timestamps used in Kerberos are encoded as GeneralizedTimes.  A
   KerberosTime value shall not include any fractional portions of the
   seconds.  As required by the DER, it further shall not include any
   separators, and it shall specify the UTC time zone (Z).  Example: The
   only valid format for UTC time 6 minutes, 27 seconds after 9 pm on 6
   November 1985 is 19851106210627Z.

5.2.4.  Constrained Integer Types

   Some integer members of types SHOULD be constrained to values
   representable in 32 bits, for compatibility with reasonable
   implementation limits.




Neuman, et al.              Standards Track                    [Page 55]

RFC 4120                      Kerberos V5                      July 2005


   Int32           ::= INTEGER (-2147483648..2147483647)
                       -- signed values representable in 32 bits

   UInt32          ::= INTEGER (0..4294967295)
                       -- unsigned 32 bit values

   Microseconds    ::= INTEGER (0..999999)
                       -- microseconds

   Although this results in changes to the abstract types from the RFC
   1510 version, the encoding in DER should be unaltered.  Historical
   implementations were typically limited to 32-bit integer values
   anyway, and assigned numbers SHOULD fall in the space of integer
   values representable in 32 bits in order to promote interoperability
   anyway.

   Several integer fields in messages are constrained to fixed values.

   pvno
      also TKT-VNO or AUTHENTICATOR-VNO, this recurring field is always
      the constant integer 5.  There is no easy way to make this field
      into a useful protocol version number, so its value is fixed.

   msg-type
      this integer field is usually identical to the application tag
      number of the containing message type.

5.2.5.  HostAddress and HostAddresses

   HostAddress     ::= SEQUENCE  {
           addr-type       [0] Int32,
           address         [1] OCTET STRING
   }

   -- NOTE: HostAddresses is always used as an OPTIONAL field and
   -- should not be empty.
   HostAddresses   -- NOTE: subtly different from rfc1510,
                   -- but has a value mapping and encodes the same
           ::= SEQUENCE OF HostAddress

   The host address encodings consist of two fields:

   addr-type
      This field specifies the type of address that follows.  Pre-
      defined values for this field are specified in Section 7.5.3.

   address
      This field encodes a single address of type addr-type.



Neuman, et al.              Standards Track                    [Page 56]

RFC 4120                      Kerberos V5                      July 2005


5.2.6.  AuthorizationData

      -- NOTE: AuthorizationData is always used as an OPTIONAL field and
      -- should not be empty.
      AuthorizationData       ::= SEQUENCE OF SEQUENCE {
              ad-type         [0] Int32,
              ad-data         [1] OCTET STRING
      }

   ad-data
      This field contains authorization data to be interpreted according
      to the value of the corresponding ad-type field.

   ad-type
      This field specifies the format for the ad-data subfield.  All
      negative values are reserved for local use.  Non-negative values
      are reserved for registered use.

   Each sequence of type and data is referred to as an authorization
   element.  Elements MAY be application specific; however, there is a
   common set of recursive elements that should be understood by all
   implementations.  These elements contain other elements embedded
   within them, and the interpretation of the encapsulating element
   determines which of the embedded elements must be interpreted, and
   which may be ignored.

   These common authorization data elements are recursively defined,
   meaning that the ad-data for these types will itself contain a
   sequence of authorization data whose interpretation is affected by
   the encapsulating element.  Depending on the meaning of the
   encapsulating element, the encapsulated elements may be ignored,
   might be interpreted as issued directly by the KDC, or might be
   stored in a separate plaintext part of the ticket.  The types of the
   encapsulating elements are specified as part of the Kerberos
   specification because the behavior based on these values should be
   understood across implementations, whereas other elements need only
   be understood by the applications that they affect.

   Authorization data elements are considered critical if present in a
   ticket or authenticator.  If an unknown authorization data element
   type is received by a server either in an AP-REQ or in a ticket
   contained in an AP-REQ, then, unless it is encapsulated in a known
   authorization data element amending the criticality of the elements
   it contains, authentication MUST fail.  Authorization data is
   intended to restrict the use of a ticket.  If the service cannot
   determine whether the restriction applies to that service, then a





Neuman, et al.              Standards Track                    [Page 57]

RFC 4120                      Kerberos V5                      July 2005


   security weakness may result if the ticket can be used for that
   service.  Authorization elements that are optional can be enclosed in
   an AD-IF-RELEVANT element.

   In the definitions that follow, the value of the ad-type for the
   element will be specified as the least significant part of the
   subsection number, and the value of the ad-data will be as shown in
   the ASN.1 structure that follows the subsection heading.

   Contents of ad-data                ad-type

   DER encoding of AD-IF-RELEVANT        1

   DER encoding of AD-KDCIssued          4

   DER encoding of AD-AND-OR             5

   DER encoding of AD-MANDATORY-FOR-KDC  8

5.2.6.1.  IF-RELEVANT

   AD-IF-RELEVANT          ::= AuthorizationData

   AD elements encapsulated within the if-relevant element are intended
   for interpretation only by application servers that understand the
   particular ad-type of the embedded element.  Application servers that
   do not understand the type of an element embedded within the
   if-relevant element MAY ignore the uninterpretable element.  This
   element promotes interoperability across implementations that may
   have local extensions for authorization.  The ad-type for
   AD-IF-RELEVANT is (1).

5.2.6.2.  KDCIssued

   AD-KDCIssued            ::= SEQUENCE {
           ad-checksum     [0] Checksum,
           i-realm         [1] Realm OPTIONAL,
           i-sname         [2] PrincipalName OPTIONAL,
           elements        [3] AuthorizationData
   }

   ad-checksum
      A cryptographic checksum computed over the DER encoding of the
      AuthorizationData in the ""elements"" field, keyed with the session
      key.  Its checksumtype is the mandatory checksum type for the
      encryption type of the session key, and its key usage value is 19.





Neuman, et al.              Standards Track                    [Page 58]

RFC 4120                      Kerberos V5                      July 2005


   i-realm, i-sname
      The name of the issuing principal if different from that of the
      KDC itself.  This field would be used when the KDC can verify the
      authenticity of elements signed by the issuing principal, and it
      allows this KDC to notify the application server of the validity
      of those elements.

   elements
      A sequence of authorization data elements issued by the KDC.

   The KDC-issued ad-data field is intended to provide a means for
   Kerberos principal credentials to embed within themselves privilege
   attributes and other mechanisms for positive authorization,
   amplifying the privileges of the principal beyond what can be done
   using credentials without such an a-data element.

   The above means cannot be provided without this element because the
   definition of the authorization-data field allows elements to be
   added at will by the bearer of a TGT at the time when they request
   service tickets, and elements may also be added to a delegated ticket
   by inclusion in the authenticator.

   For KDC-issued elements, this is prevented because the elements are
   signed by the KDC by including a checksum encrypted using the
   server's key (the same key used to encrypt the ticket or a key
   derived from that key).  Elements encapsulated with in the KDC-issued
   element MUST be ignored by the application server if this ""signature""
   is not present.  Further, elements encapsulated within this element
   from a TGT MAY be interpreted by the KDC, and used as a basis
   according to policy for including new signed elements within
   derivative tickets, but they will not be copied to a derivative
   ticket directly.  If they are copied directly to a derivative ticket
   by a KDC that is not aware of this element, the signature will not be
   correct for the application ticket elements, and the field will be
   ignored by the application server.

   This element and the elements it encapsulates MAY safely be ignored
   by applications, application servers, and KDCs that do not implement
   this element.

   The ad-type for AD-KDC-ISSUED is (4).

5.2.6.3.  AND-OR

   AD-AND-OR               ::= SEQUENCE {
           condition-count [0] Int32,
           elements        [1] AuthorizationData
   }



Neuman, et al.              Standards Track                    [Page 59]

RFC 4120                      Kerberos V5                      July 2005


   When restrictive AD elements are encapsulated within the and-or
   element, the and-or element is considered satisfied if and only if at
   least the number of encapsulated elements specified in condition-
   count are satisfied.  Therefore, this element MAY be used to
   implement an ""or"" operation by setting the condition-count field to
   1, and it MAY specify an ""and"" operation by setting the condition
   count to the number of embedded elements.  Application servers that
   do not implement this element MUST reject tickets that contain
   authorization data elements of this type.

   The ad-type for AD-AND-OR is (5).

5.2.6.4.  MANDATORY-FOR-KDC

   AD-MANDATORY-FOR-KDC    ::= AuthorizationData

   AD elements encapsulated within the mandatory-for-kdc element are to
   be interpreted by the KDC.  KDCs that do not understand the type of
   an element embedded within the mandatory-for-kdc element MUST reject
   the request.

   The ad-type for AD-MANDATORY-FOR-KDC is (8).

5.2.7.  PA-DATA

   Historically, PA-DATA have been known as ""pre-authentication data"",
   meaning that they were used to augment the initial authentication
   with the KDC.  Since that time, they have also been used as a typed
   hole with which to extend protocol exchanges with the KDC.

   PA-DATA         ::= SEQUENCE {
           -- NOTE: first tag is [1], not [0]
           padata-type     [1] Int32,
           padata-value    [2] OCTET STRING -- might be encoded AP-REQ
   }

   padata-type
      Indicates the way that the padata-value element is to be
      interpreted.  Negative values of padata-type are reserved for
      unregistered use; non-negative values are used for a registered
      interpretation of the element type.

   padata-value
      Usually contains the DER encoding of another type; the padata-type
      field identifies which type is encoded here.






Neuman, et al.              Standards Track                    [Page 60]

RFC 4120                      Kerberos V5                      July 2005


      padata-type  Name             Contents of padata-value

      1            pa-tgs-req       DER encoding of AP-REQ

      2            pa-enc-timestamp DER encoding of PA-ENC-TIMESTAMP

      3            pa-pw-salt       salt (not ASN.1 encoded)

      11           pa-etype-info    DER encoding of ETYPE-INFO

      19           pa-etype-info2   DER encoding of ETYPE-INFO2

      This field MAY also contain information needed by certain
      extensions to the Kerberos protocol.  For example, it might be
      used to verify the identity of a client initially before any
      response is returned.

      The padata field can also contain information needed to help the
      KDC or the client select the key needed for generating or
      decrypting the response.  This form of the padata is useful for
      supporting the use of certain token cards with Kerberos.  The
      details of such extensions are specified in separate documents.
      See [Pat92] for additional uses of this field.

5.2.7.1.  PA-TGS-REQ

   In the case of requests for additional tickets (KRB_TGS_REQ),
   padata-value will contain an encoded AP-REQ.  The checksum in the
   authenticator (which MUST be collision-proof) is to be computed over
   the KDC-REQ-BODY encoding.

5.2.7.2.  Encrypted Timestamp Pre-authentication

   There are pre-authentication types that may be used to pre-
   authenticate a client by means of an encrypted timestamp.

   PA-ENC-TIMESTAMP        ::= EncryptedData -- PA-ENC-TS-ENC

   PA-ENC-TS-ENC           ::= SEQUENCE {
           patimestamp     [0] KerberosTime -- client's time --,
           pausec          [1] Microseconds OPTIONAL
   }

   Patimestamp contains the client's time, and pausec contains the
   microseconds, which MAY be omitted if a client will not generate more
   than one request per second.  The ciphertext (padata-value) consists
   of the PA-ENC-TS-ENC encoding, encrypted using the client's secret
   key and a key usage value of 1.



Neuman, et al.              Standards Track                    [Page 61]

RFC 4120                      Kerberos V5                      July 2005


   This pre-authentication type was not present in RFC 1510, but many
   implementations support it.

5.2.7.3.  PA-PW-SALT

   The padata-value for this pre-authentication type contains the salt
   for the string-to-key to be used by the client to obtain the key for
   decrypting the encrypted part of an AS-REP message.  Unfortunately,
   for historical reasons, the character set to be used is unspecified
   and probably locale-specific.

   This pre-authentication type was not present in RFC 1510, but many
   implementations support it.  It is necessary in any case where the
   salt for the string-to-key algorithm is not the default.

   In the trivial example, a zero-length salt string is very commonplace
   for realms that have converted their principal databases from
   Kerberos Version 4.

   A KDC SHOULD NOT send PA-PW-SALT when issuing a KRB-ERROR message
   that requests additional pre-authentication.  Implementation note:
   Some KDC implementations issue an erroneous PA-PW-SALT when issuing a
   KRB-ERROR message that requests additional pre-authentication.
   Therefore, clients SHOULD ignore a PA-PW-SALT accompanying a
   KRB-ERROR message that requests additional pre-authentication.  As
   noted in section 3.1.3, a KDC MUST NOT send PA-PW-SALT when the
   client's AS-REQ includes at least one ""newer"" etype.

5.2.7.4.  PA-ETYPE-INFO

   The ETYPE-INFO pre-authentication type is sent by the KDC in a
   KRB-ERROR indicating a requirement for additional pre-authentication.
   It is usually used to notify a client of which key to use for the
   encryption of an encrypted timestamp for the purposes of sending a
   PA-ENC-TIMESTAMP pre-authentication value.  It MAY also be sent in an
   AS-REP to provide information to the client about which key salt to
   use for the string-to-key to be used by the client to obtain the key
   for decrypting the encrypted part the AS-REP.

   ETYPE-INFO-ENTRY        ::= SEQUENCE {
           etype           [0] Int32,
           salt            [1] OCTET STRING OPTIONAL
   }

   ETYPE-INFO              ::= SEQUENCE OF ETYPE-INFO-ENTRY

   The salt, like that of PA-PW-SALT, is also completely unspecified
   with respect to character set and is probably locale-specific.



Neuman, et al.              Standards Track                    [Page 62]

RFC 4120                      Kerberos V5                      July 2005


   If ETYPE-INFO is sent in an AS-REP, there shall be exactly one
   ETYPE-INFO-ENTRY, and its etype shall match that of the enc-part in
   the AS-REP.

   This pre-authentication type was not present in RFC 1510, but many
   implementations that support encrypted timestamps for pre-
   authentication need to support ETYPE-INFO as well.  As noted in
   Section 3.1.3, a KDC MUST NOT send PA-ETYPE-INFO when the client's
   AS-REQ includes at least one ""newer"" etype.

5.2.7.5.  PA-ETYPE-INFO2

   The ETYPE-INFO2 pre-authentication type is sent by the KDC in a
   KRB-ERROR indicating a requirement for additional pre-authentication.
   It is usually used to notify a client of which key to use for the
   encryption of an encrypted timestamp for the purposes of sending a
   PA-ENC-TIMESTAMP pre-authentication value.  It MAY also be sent in an
   AS-REP to provide information to the client about which key salt to
   use for the string-to-key to be used by the client to obtain the key
   for decrypting the encrypted part the AS-REP.

ETYPE-INFO2-ENTRY       ::= SEQUENCE {
        etype           [0] Int32,
        salt            [1] KerberosString OPTIONAL,
        s2kparams       [2] OCTET STRING OPTIONAL
}

ETYPE-INFO2              ::= SEQUENCE SIZE (1..MAX) OF ETYPE-INFO2-ENTRY

   The type of the salt is KerberosString, but existing installations
   might have locale-specific characters stored in salt strings, and
   implementors MAY choose to handle them.

   The interpretation of s2kparams is specified in the cryptosystem
   description associated with the etype.  Each cryptosystem has a
   default interpretation of s2kparams that will hold if that element is
   omitted from the encoding of ETYPE-INFO2-ENTRY.

   If ETYPE-INFO2 is sent in an AS-REP, there shall be exactly one
   ETYPE-INFO2-ENTRY, and its etype shall match that of the enc-part in
   the AS-REP.

   The preferred ordering of the ""hint"" pre-authentication data that
   affect client key selection is: ETYPE-INFO2, followed by ETYPE-INFO,
   followed by PW-SALT.  As noted in Section 3.1.3, a KDC MUST NOT send
   ETYPE-INFO or PW-SALT when the client's AS-REQ includes at least one
   ""newer"" etype.




Neuman, et al.              Standards Track                    [Page 63]

RFC 4120                      Kerberos V5                      July 2005


   The ETYPE-INFO2 pre-authentication type was not present in RFC 1510.

5.2.8.  KerberosFlags

   For several message types, a specific constrained bit string type,
   KerberosFlags, is used.

   KerberosFlags   ::= BIT STRING (SIZE (32..MAX))
                       -- minimum number of bits shall be sent,
                       -- but no fewer than 32

   Compatibility note: The following paragraphs describe a change from
   the RFC 1510 description of bit strings that would result in
   incompatility in the case of an implementation that strictly
   conformed to ASN.1 DER and RFC 1510.

   ASN.1 bit strings have multiple uses.  The simplest use of a bit
   string is to contain a vector of bits, with no particular meaning
   attached to individual bits.  This vector of bits is not necessarily
   a multiple of eight bits long.  The use in Kerberos of a bit string
   as a compact boolean vector wherein each element has a distinct
   meaning poses some problems.  The natural notation for a compact
   boolean vector is the ASN.1 ""NamedBit"" notation, and the DER require
   that encodings of a bit string using ""NamedBit"" notation exclude any
   trailing zero bits.  This truncation is easy to neglect, especially
   given C language implementations that naturally choose to store
   boolean vectors as 32-bit integers.

   For example, if the notation for KDCOptions were to include the
   ""NamedBit"" notation, as in RFC 1510, and a KDCOptions value to be
   encoded had only the ""forwardable"" (bit number one) bit set, the DER
   encoding MUST include only two bits: the first reserved bit
   (""reserved"", bit number zero, value zero) and the one-valued bit (bit
   number one) for ""forwardable"".

   Most existing implementations of Kerberos unconditionally send 32
   bits on the wire when encoding bit strings used as boolean vectors.
   This behavior violates the ASN.1 syntax used for flag values in RFC
   1510, but it occurs on such a widely installed base that the protocol
   description is being modified to accommodate it.

   Consequently, this document removes the ""NamedBit"" notations for
   individual bits, relegating them to comments.  The size constraint on
   the KerberosFlags type requires that at least 32 bits be encoded at
   all times, though a lenient implementation MAY choose to accept fewer
   than 32 bits and to treat the missing bits as set to zero.





Neuman, et al.              Standards Track                    [Page 64]

RFC 4120                      Kerberos V5                      July 2005


   Currently, no uses of KerberosFlags specify more than 32 bits' worth
   of flags, although future revisions of this document may do so.  When
   more than 32 bits are to be transmitted in a KerberosFlags value,
   future revisions to this document will likely specify that the
   smallest number of bits needed to encode the highest-numbered one-
   valued bit should be sent.  This is somewhat similar to the DER
   encoding of a bit string that is declared with the ""NamedBit""
   notation.

5.2.9.  Cryptosystem-Related Types

   Many Kerberos protocol messages contain an EncryptedData as a
   container for arbitrary encrypted data, which is often the encrypted
   encoding of another data type.  Fields within EncryptedData assist
   the recipient in selecting a key with which to decrypt the enclosed
   data.

   EncryptedData   ::= SEQUENCE {
           etype   [0] Int32 -- EncryptionType --,
           kvno    [1] UInt32 OPTIONAL,
           cipher  [2] OCTET STRING -- ciphertext
   }

   etype
      This field identifies which encryption algorithm was used to
      encipher the cipher.

   kvno
      This field contains the version number of the key under which data
      is encrypted.  It is only present in messages encrypted under long
      lasting keys, such as principals' secret keys.

   cipher
      This field contains the enciphered text, encoded as an OCTET
      STRING.  (Note that the encryption mechanisms defined in [RFC3961]
      MUST incorporate integrity protection as well, so no additional
      checksum is required.)

   The EncryptionKey type is the means by which cryptographic keys used
   for encryption are transferred.

   EncryptionKey   ::= SEQUENCE {
           keytype         [0] Int32 -- actually encryption type --,
           keyvalue        [1] OCTET STRING
   }






Neuman, et al.              Standards Track                    [Page 65]

RFC 4120                      Kerberos V5                      July 2005


   keytype
      This field specifies the encryption type of the encryption key
      that follows in the keyvalue field.  Although its name is
      ""keytype"", it actually specifies an encryption type.  Previously,
      multiple cryptosystems that performed encryption differently but
      were capable of using keys with the same characteristics were
      permitted to share an assigned number to designate the type of
      key; this usage is now deprecated.

   keyvalue
      This field contains the key itself, encoded as an octet string.

   Messages containing cleartext data to be authenticated will usually
   do so by using a member of type Checksum.  Most instances of Checksum
   use a keyed hash, though exceptions will be noted.

   Checksum        ::= SEQUENCE {
           cksumtype       [0] Int32,
           checksum        [1] OCTET STRING
   }

   cksumtype
      This field indicates the algorithm used to generate the
      accompanying checksum.

   checksum
      This field contains the checksum itself, encoded as an octet
      string.

   See Section 4 for a brief description of the use of encryption and
   checksums in Kerberos.

5.3.  Tickets

   This section describes the format and encryption parameters for
   tickets and authenticators.  When a ticket or authenticator is
   included in a protocol message, it is treated as an opaque object.  A
   ticket is a record that helps a client authenticate to a service.  A
   Ticket contains the following information:

   Ticket          ::= [APPLICATION 1] SEQUENCE {
           tkt-vno         [0] INTEGER (5),
           realm           [1] Realm,
           sname           [2] PrincipalName,
           enc-part        [3] EncryptedData -- EncTicketPart
   }

   -- Encrypted part of ticket



Neuman, et al.              Standards Track                    [Page 66]

RFC 4120                      Kerberos V5                      July 2005


   EncTicketPart   ::= [APPLICATION 3] SEQUENCE {
           flags                   [0] TicketFlags,
           key                     [1] EncryptionKey,
           crealm                  [2] Realm,
           cname                   [3] PrincipalName,
           transited               [4] TransitedEncoding,
           authtime                [5] KerberosTime,
           starttime               [6] KerberosTime OPTIONAL,
           endtime                 [7] KerberosTime,
           renew-till              [8] KerberosTime OPTIONAL,
           caddr                   [9] HostAddresses OPTIONAL,
           authorization-data      [10] AuthorizationData OPTIONAL
   }

   -- encoded Transited field
   TransitedEncoding       ::= SEQUENCE {
           tr-type         [0] Int32 -- must be registered --,
           contents        [1] OCTET STRING
   }

   TicketFlags     ::= KerberosFlags
           -- reserved(0),
           -- forwardable(1),
           -- forwarded(2),
           -- proxiable(3),
           -- proxy(4),
           -- may-postdate(5),
           -- postdated(6),
           -- invalid(7),
           -- renewable(8),
           -- initial(9),
           -- pre-authent(10),
           -- hw-authent(11),
   -- the following are new since 1510
           -- transited-policy-checked(12),
           -- ok-as-delegate(13)

   tkt-vno
      This field specifies the version number for the ticket format.
      This document describes version number 5.

   realm
      This field specifies the realm that issued a ticket.  It also
      serves to identify the realm part of the server's principal
      identifier.  Since a Kerberos server can only issue tickets for
      servers within its realm, the two will always be identical.





Neuman, et al.              Standards Track                    [Page 67]

RFC 4120                      Kerberos V5                      July 2005


   sname
      This field specifies all components of the name part of the
      server's identity, including those parts that identify a specific
      instance of a service.

   enc-part
      This field holds the encrypted encoding of the EncTicketPart
      sequence.  It is encrypted in the key shared by Kerberos and the
      end server (the server's secret key), using a key usage value of
      2.

   flags
      This field indicates which of various options were used or
      requested when the ticket was issued.  The meanings of the flags
      are as follows:

   Bit(s)  Name             Description

   0       reserved         Reserved for future expansion of this field.

   1       forwardable      The FORWARDABLE flag is normally only
                            interpreted by the TGS, and can be ignored
                            by end servers.  When set, this flag tells
                            the ticket-granting server that it is OK to
                            issue a new TGT with a different network
                            address based on the presented ticket.

   2       forwarded        When set, this flag indicates that the
                            ticket has either been forwarded or was
                            issued based on authentication involving a
                            forwarded TGT.

   3       proxiable        The PROXIABLE flag is normally only
                            interpreted by the TGS, and can be ignored
                            by end servers.  The PROXIABLE flag has an
                            interpretation identical to that of the
                            FORWARDABLE flag, except that the PROXIABLE
                            flag tells the ticket-granting server that
                            only non-TGTs may be issued with different
                            network addresses.

   4       proxy            When set, this flag indicates that a ticket
                            is a proxy.

   5       may-postdate     The MAY-POSTDATE flag is normally only
                            interpreted by the TGS, and can be ignored
                            by end servers.  This flag tells the




Neuman, et al.              Standards Track                    [Page 68]

RFC 4120                      Kerberos V5                      July 2005


                            ticket-granting server that a post-dated
                            ticket MAY be issued based on this TGT.

   6       postdated        This flag indicates that this ticket has
                            been postdated.  The end-service can check
                            the authtime field to see when the original
                            authentication occurred.

   7       invalid          This flag indicates that a ticket is
                            invalid, and it must be validated by the KDC
                            before use.  Application servers must reject
                            tickets which have this flag set.

   8       renewable        The RENEWABLE flag is normally only
                            interpreted by the TGS, and can usually be
                            ignored by end servers (some particularly
                            careful servers MAY disallow renewable
                            tickets).  A renewable ticket can be used to
                            obtain a replacement ticket that expires at
                            a later date.

   9       initial          This flag indicates that this ticket was
                            issued using the AS protocol, and not issued
                            based on a TGT.

   10      pre-authent      This flag indicates that during initial
                            authentication, the client was authenticated
                            by the KDC before a ticket was issued.  The
                            strength of the pre-authentication method is
                            not indicated, but is acceptable to the KDC.

   11      hw-authent       This flag indicates that the protocol
                            employed for initial authentication required
                            the use of hardware expected to be possessed
                            solely by the named client.  The hardware
                            authentication method is selected by the KDC
                            and the strength of the method is not
                            indicated.

   12      transited-       This flag indicates that the KDC for
           policy-checked   the realm has checked the transited field
                            against a realm-defined policy for trusted
                            certifiers.  If this flag is reset (0), then
                            the application server must check the
                            transited field itself, and if unable to do
                            so, it must reject the authentication.  If
                            the flag is set (1), then the application
                            server MAY skip its own validation of the



Neuman, et al.              Standards Track                    [Page 69]

RFC 4120                      Kerberos V5                      July 2005


                            transited field, relying on the validation
                            performed by the KDC.  At its option the
                            application server MAY still apply its own
                            validation based on a separate policy for
                            acceptance.

                            This flag is new since RFC 1510.

   13      ok-as-delegate   This flag indicates that the server (not the
                            client) specified in the ticket has been
                            determined by policy of the realm to be a
                            suitable recipient of delegation.  A client
                            can use the presence of this flag to help it
                            decide whether to delegate credentials
                            (either grant a proxy or a forwarded TGT) to
                            this server.  The client is free to ignore
                            the value of this flag.  When setting this
                            flag, an administrator should consider the
                            security and placement of the server on
                            which the service will run, as well as
                            whether the service requires the use of
                            delegated credentials.

                            This flag is new since RFC 1510.

   14-31   reserved         Reserved for future use.

   key
      This field exists in the ticket and the KDC response and is used
      to pass the session key from Kerberos to the application server
      and the client.

   crealm
      This field contains the name of the realm in which the client is
      registered and in which initial authentication took place.

   cname
      This field contains the name part of the client's principal
      identifier.

   transited
      This field lists the names of the Kerberos realms that took part
      in authenticating the user to whom this ticket was issued.  It
      does not specify the order in which the realms were transited.
      See Section 3.3.3.2 for details on how this field encodes the
      traversed realms.  When the names of CAs are to be embedded in the
      transited field (as specified for some extensions to the




Neuman, et al.              Standards Track                    [Page 70]

RFC 4120                      Kerberos V5                      July 2005


      protocol), the X.500 names of the CAs SHOULD be mapped into items
      in the transited field using the mapping defined by RFC 2253.

   authtime
      This field indicates the time of initial authentication for the
      named principal.  It is the time of issue for the original ticket
      on which this ticket is based.  It is included in the ticket to
      provide additional information to the end service, and to provide
      the necessary information for implementation of a ""hot list""
      service at the KDC.  An end service that is particularly paranoid
      could refuse to accept tickets for which the initial
      authentication occurred ""too far"" in the past.  This field is also
      returned as part of the response from the KDC.  When it is
      returned as part of the response to initial authentication
      (KRB_AS_REP), this is the current time on the Kerberos server.  It
      is NOT recommended that this time value be used to adjust the
      workstation's clock, as the workstation cannot reliably determine
      that such a KRB_AS_REP actually came from the proper KDC in a
      timely manner.

   starttime
      This field in the ticket specifies the time after which the ticket
      is valid.  Together with endtime, this field specifies the life of
      the ticket.  If the starttime field is absent from the ticket,
      then the authtime field SHOULD be used in its place to determine
      the life of the ticket.

   endtime
      This field contains the time after which the ticket will not be
      honored (its expiration time).  Note that individual services MAY
      place their own limits on the life of a ticket and MAY reject
      tickets which have not yet expired.  As such, this is really an
      upper bound on the expiration time for the ticket.

   renew-till
      This field is only present in tickets that have the RENEWABLE flag
      set in the flags field.  It indicates the maximum endtime that may
      be included in a renewal.  It can be thought of as the absolute
      expiration time for the ticket, including all renewals.

   caddr
      This field in a ticket contains zero (if omitted) or more (if
      present) host addresses.  These are the addresses from which the
      ticket can be used.  If there are no addresses, the ticket can be
      used from any location.  The decision by the KDC to issue or by
      the end server to accept addressless tickets is a policy decision
      and is left to the Kerberos and end-service administrators; they
      MAY refuse to issue or accept such tickets.  Because of the wide



Neuman, et al.              Standards Track                    [Page 71]

RFC 4120                      Kerberos V5                      July 2005


      deployment of network address translation, it is recommended that
      policy allow the issue and acceptance of such tickets.

      Network addresses are included in the ticket to make it harder for
      an attacker to use stolen credentials.  Because the session key is
      not sent over the network in cleartext, credentials can't be
      stolen simply by listening to the network; an attacker has to gain
      access to the session key (perhaps through operating system
      security breaches or a careless user's unattended session) to make
      use of stolen tickets.

      Note that the network address from which a connection is received
      cannot be reliably determined.  Even if it could be, an attacker
      who has compromised the client's workstation could use the
      credentials from there.  Including the network addresses only
      makes it more difficult, not impossible, for an attacker to walk
      off with stolen credentials and then to use them from a ""safe""
      location.

   authorization-data
      The authorization-data field is used to pass authorization data
      from the principal on whose behalf a ticket was issued to the
      application service.  If no authorization data is included, this
      field will be left out.  Experience has shown that the name of
      this field is confusing, and that a better name would be
      ""restrictions"".  Unfortunately, it is not possible to change the
      name at this time.

      This field contains restrictions on any authority obtained on the
      basis of authentication using the ticket.  It is possible for any
      principal in possession of credentials to add entries to the
      authorization data field since these entries further restrict what
      can be done with the ticket.  Such additions can be made by
      specifying the additional entries when a new ticket is obtained
      during the TGS exchange, or they MAY be added during chained
      delegation using the authorization data field of the
      authenticator.

      Because entries may be added to this field by the holder of
      credentials, except when an entry is separately authenticated by
      encapsulation in the KDC-issued element, it is not allowable for
      the presence of an entry in the authorization data field of a
      ticket to amplify the privileges one would obtain from using a
      ticket.

      The data in this field may be specific to the end service; the
      field will contain the names of service specific objects, and the
      rights to those objects.  The format for this field is described



Neuman, et al.              Standards Track                    [Page 72]

RFC 4120                      Kerberos V5                      July 2005


      in Section 5.2.6.  Although Kerberos is not concerned with the
      format of the contents of the subfields, it does carry type
      information (ad-type).

      By using the authorization_data field, a principal is able to
      issue a proxy that is valid for a specific purpose.  For example,
      a client wishing to print a file can obtain a file server proxy to
      be passed to the print server.  By specifying the name of the file
      in the authorization_data field, the file server knows that the
      print server can only use the client's rights when accessing the
      particular file to be printed.

      A separate service providing authorization or certifying group
      membership may be built using the authorization-data field.  In
      this case, the entity granting authorization (not the authorized
      entity) may obtain a ticket in its own name (e.g., the ticket is
      issued in the name of a privilege server), and this entity adds
      restrictions on its own authority and delegates the restricted
      authority through a proxy to the client.  The client would then
      present this authorization credential to the application server
      separately from the authentication exchange.  Alternatively, such
      authorization credentials MAY be embedded in the ticket
      authenticating the authorized entity, when the authorization is
      separately authenticated using the KDC-issued authorization data
      element (see 5.2.6.2).

      Similarly, if one specifies the authorization-data field of a
      proxy and leaves the host addresses blank, the resulting ticket
      and session key can be treated as a capability.  See [Neu93] for
      some suggested uses of this field.

      The authorization-data field is optional and does not have to be
      included in a ticket.

5.4.  Specifications for the AS and TGS Exchanges

   This section specifies the format of the messages used in the
   exchange between the client and the Kerberos server.  The format of
   possible error messages appears in Section 5.9.1.

5.4.1.  KRB_KDC_REQ Definition

   The KRB_KDC_REQ message has no application tag number of its own.
   Instead, it is incorporated into either KRB_AS_REQ or KRB_TGS_REQ,
   each of which has an application tag, depending on whether the
   request is for an initial ticket or an additional ticket.  In either
   case, the message is sent from the client to the KDC to request
   credentials for a service.



Neuman, et al.              Standards Track                    [Page 73]

RFC 4120                      Kerberos V5                      July 2005


   The message fields are as follows:

AS-REQ          ::= [APPLICATION 10] KDC-REQ

TGS-REQ         ::= [APPLICATION 12] KDC-REQ

KDC-REQ         ::= SEQUENCE {
        -- NOTE: first tag is [1], not [0]
        pvno            [1] INTEGER (5) ,
        msg-type        [2] INTEGER (10 -- AS -- | 12 -- TGS --),
        padata          [3] SEQUENCE OF PA-DATA OPTIONAL
                            -- NOTE: not empty --,
        req-body        [4] KDC-REQ-BODY
}

KDC-REQ-BODY    ::= SEQUENCE {
        kdc-options             [0] KDCOptions,
        cname                   [1] PrincipalName OPTIONAL
                                    -- Used only in AS-REQ --,
        realm                   [2] Realm
                                    -- Server's realm
                                    -- Also client's in AS-REQ --,
        sname                   [3] PrincipalName OPTIONAL,
        from                    [4] KerberosTime OPTIONAL,
        till                    [5] KerberosTime,
        rtime                   [6] KerberosTime OPTIONAL,
        nonce                   [7] UInt32,
        etype                   [8] SEQUENCE OF Int32 -- EncryptionType
                                    -- in preference order --,
        addresses               [9] HostAddresses OPTIONAL,
        enc-authorization-data  [10] EncryptedData OPTIONAL
                                    -- AuthorizationData --,
        additional-tickets      [11] SEQUENCE OF Ticket OPTIONAL
                                       -- NOTE: not empty
}

KDCOptions      ::= KerberosFlags
        -- reserved(0),
        -- forwardable(1),
        -- forwarded(2),
        -- proxiable(3),
        -- proxy(4),
        -- allow-postdate(5),
        -- postdated(6),
        -- unused7(7),
        -- renewable(8),
        -- unused9(9),
        -- unused10(10),



Neuman, et al.              Standards Track                    [Page 74]

RFC 4120                      Kerberos V5                      July 2005


        -- opt-hardware-auth(11),
        -- unused12(12),
        -- unused13(13),
-- 15 is reserved for canonicalize
        -- unused15(15),
-- 26 was unused in 1510
        -- disable-transited-check(26),
--
        -- renewable-ok(27),
        -- enc-tkt-in-skey(28),
        -- renew(30),
        -- validate(31)

   The fields in this message are as follows:

   pvno
      This field is included in each message, and specifies the protocol
      version number.  This document specifies protocol version 5.

   msg-type
      This field indicates the type of a protocol message.  It will
      almost always be the same as the application identifier associated
      with a message.  It is included to make the identifier more
      readily accessible to the application.  For the KDC-REQ message,
      this type will be KRB_AS_REQ or KRB_TGS_REQ.

   padata
      Contains pre-authentication data.  Requests for additional tickets
      (KRB_TGS_REQ) MUST contain a padata of PA-TGS-REQ.

      The padata (pre-authentication data) field contains a sequence of
      authentication information that may be needed before credentials
      can be issued or decrypted.

   req-body
      This field is a placeholder delimiting the extent of the remaining
      fields.  If a checksum is to be calculated over the request, it is
      calculated over an encoding of the KDC-REQ-BODY sequence which is
      enclosed within the req-body field.

   kdc-options
      This field appears in the KRB_AS_REQ and KRB_TGS_REQ requests to
      the KDC and indicates the flags that the client wants set on the
      tickets as well as other information that is to modify the
      behavior of the KDC.  Where appropriate, the name of an option may
      be the same as the flag that is set by that option.  Although in
      most cases, the bit in the options field will be the same as that
      in the flags field, this is not guaranteed, so it is not



Neuman, et al.              Standards Track                    [Page 75]

RFC 4120                      Kerberos V5                      July 2005


      acceptable simply to copy the options field to the flags field.
      There are various checks that must be made before an option is
      honored anyway.

      The kdc_options field is a bit-field, where the selected options
      are indicated by the bit being set (1), and the unselected options
      and reserved fields being reset (0).  The encoding of the bits is
      specified in Section 5.2.  The options are described in more
      detail above in Section 2.  The meanings of the options are as
      follows:

   Bits    Name                     Description

   0       RESERVED                 Reserved for future expansion of
                                    this field.

   1       FORWARDABLE              The FORWARDABLE option indicates
                                    that the ticket to be issued is to
                                    have its forwardable flag set.  It
                                    may only be set on the initial
                                    request, or in a subsequent request
                                    if the TGT on which it is based is
                                    also forwardable.

   2       FORWARDED                The FORWARDED option is only
                                    specified in a request to the
                                    ticket-granting server and will only
                                    be honored if the TGT in the request
                                    has its FORWARDABLE bit set.  This
                                    option indicates that this is a
                                    request for forwarding.  The
                                    address(es) of the host from which
                                    the resulting ticket is to be valid
                                    are included in the addresses field
                                    of the request.

   3       PROXIABLE                The PROXIABLE option indicates that
                                    the ticket to be issued is to have
                                    its proxiable flag set.  It may only
                                    be set on the initial request, or a
                                    subsequent request if the TGT on
                                    which it is based is also proxiable.

   4       PROXY                    The PROXY option indicates that this
                                    is a request for a proxy.  This
                                    option will only be honored if the
                                    TGT in the request has its PROXIABLE
                                    bit set.  The address(es) of the



Neuman, et al.              Standards Track                    [Page 76]

RFC 4120                      Kerberos V5                      July 2005


                                    host from which the resulting ticket
                                    is to be valid are included in the
                                    addresses field of the request.

   5       ALLOW-POSTDATE           The ALLOW-POSTDATE option indicates
                                    that the ticket to be issued is to
                                    have its MAY-POSTDATE flag set.  It
                                    may only be set on the initial
                                    request, or in a subsequent request
                                    if the TGT on which it is based also
                                    has its MAY-POSTDATE flag set.

   6       POSTDATED                The POSTDATED option indicates that
                                    this is a request for a postdated
                                    ticket.  This option will only be
                                    honored if the TGT on which it is
                                    based has its MAY-POSTDATE flag set.
                                    The resulting ticket will also have
                                    its INVALID flag set, and that flag
                                    may be reset by a subsequent request
                                    to the KDC after the starttime in
                                    the ticket has been reached.

   7       RESERVED                 This option is presently unused.

   8       RENEWABLE                The RENEWABLE option indicates that
                                    the ticket to be issued is to have
                                    its RENEWABLE flag set.  It may only
                                    be set on the initial request, or
                                    when the TGT on which the request is
                                    based is also renewable.  If this
                                    option is requested, then the rtime
                                    field in the request contains the
                                    desired absolute expiration time for
                                    the ticket.

   9       RESERVED                 Reserved for PK-Cross.

   10      RESERVED                 Reserved for future use.

   11      RESERVED                 Reserved for opt-hardware-auth.

   12-25   RESERVED                 Reserved for future use.

   26      DISABLE-TRANSITED-CHECK  By default the KDC will check the
                                    transited field of a TGT against the
                                    policy of the local realm before it
                                    will issue derivative tickets based



Neuman, et al.              Standards Track                    [Page 77]

RFC 4120                      Kerberos V5                      July 2005


                                    on the TGT.  If this flag is set in
                                    the request, checking of the
                                    transited field is disabled.
                                    Tickets issued without the
                                    performance of this check will be
                                    noted by the reset (0) value of the
                                    TRANSITED-POLICY-CHECKED flag,
                                    indicating to the application server
                                    that the transited field must be
                                    checked locally.  KDCs are
                                    encouraged but not required to honor
                                    the DISABLE-TRANSITED-CHECK option.

                                    This flag is new since RFC 1510.

   27      RENEWABLE-OK             The RENEWABLE-OK option indicates
                                    that a renewable ticket will be
                                    acceptable if a ticket with the
                                    requested life cannot otherwise be
                                    provided, in which case a renewable
                                    ticket may be issued with a renew-
                                    till equal to the requested endtime.
                                    The value of the renew-till field
                                    may still be limited by local
                                    limits, or limits selected by the
                                    individual principal or server.

   28      ENC-TKT-IN-SKEY          This option is used only by the
                                    ticket-granting service.  The ENC-
                                    TKT-IN-SKEY option indicates that
                                    the ticket for the end server is to
                                    be encrypted in the session key from
                                    the additional TGT provided.

   29      RESERVED                 Reserved for future use.

   30      RENEW                    This option is used only by the
                                    ticket-granting service.  The RENEW
                                    option indicates that the present
                                    request is for a renewal.  The
                                    ticket provided is encrypted in the
                                    secret key for the server on which
                                    it is valid.  This option will only
                                    be honored if the ticket to be
                                    renewed has its RENEWABLE flag set
                                    and if the time in its renew-till
                                    field has not passed.  The ticket to
                                    be renewed is passed in the padata



Neuman, et al.              Standards Track                    [Page 78]

RFC 4120                      Kerberos V5                      July 2005


                                    field as part of the authentication
                                    header.

   31      VALIDATE                 This option is used only by the
                                    ticket-granting service.  The
                                    VALIDATE option indicates that the
                                    request is to validate a postdated
                                    ticket.  It will only be honored if
                                    the ticket presented is postdated,
                                    presently has its INVALID flag set,
                                    and would otherwise be usable at
                                    this time.  A ticket cannot be
                                    validated before its starttime.  The
                                    ticket presented for validation is
                                    encrypted in the key of the server
                                    for which it is valid and is passed
                                    in the padata field as part of the
                                    authentication header.

   cname and sname
      These fields are the same as those described for the ticket in
      section 5.3.  The sname may only be absent when the ENC-TKT-IN-
      SKEY option is specified.  If the sname is absent, the name of the
      server is taken from the name of the client in the ticket passed
      as additional-tickets.

   enc-authorization-data
      The enc-authorization-data, if present (and it can only be present
      in the TGS_REQ form), is an encoding of the desired
      authorization-data encrypted under the sub-session key if present
      in the Authenticator, or alternatively from the session key in the
      TGT (both the Authenticator and TGT come from the padata field in
      the KRB_TGS_REQ).  The key usage value used when encrypting is 5
      if a sub-session key is used, or 4 if the session key is used.

   realm
      This field specifies the realm part of the server's principal
      identifier.  In the AS exchange, this is also the realm part of
      the client's principal identifier.

   from
      This field is included in the KRB_AS_REQ and KRB_TGS_REQ ticket
      requests when the requested ticket is to be postdated.  It
      specifies the desired starttime for the requested ticket.  If this
      field is omitted, then the KDC SHOULD use the current time
      instead.





Neuman, et al.              Standards Track                    [Page 79]

RFC 4120                      Kerberos V5                      July 2005


   till
      This field contains the expiration date requested by the client in
      a ticket request.  It is not optional, but if the requested
      endtime is ""19700101000000Z"", the requested ticket is to have the
      maximum endtime permitted according to KDC policy.  Implementation
      note: This special timestamp corresponds to a UNIX time_t value of
      zero on most systems.

   rtime
      This field is the requested renew-till time sent from a client to
      the KDC in a ticket request.  It is optional.

   nonce
      This field is part of the KDC request and response.  It is
      intended to hold a random number generated by the client.  If the
      same number is included in the encrypted response from the KDC, it
      provides evidence that the response is fresh and has not been
      replayed by an attacker.  Nonces MUST NEVER be reused.

   etype
      This field specifies the desired encryption algorithm to be used
      in the response.

   addresses
      This field is included in the initial request for tickets, and it
      is optionally included in requests for additional tickets from the
      ticket-granting server.  It specifies the addresses from which the
      requested ticket is to be valid.  Normally it includes the
      addresses for the client's host.  If a proxy is requested, this
      field will contain other addresses.  The contents of this field
      are usually copied by the KDC into the caddr field of the
      resulting ticket.

   additional-tickets
      Additional tickets MAY be optionally included in a request to the
      ticket-granting server.  If the ENC-TKT-IN-SKEY option has been
      specified, then the session key from the additional ticket will be
      used in place of the server's key to encrypt the new ticket.  When
      the ENC-TKT-IN-SKEY option is used for user-to-user
      authentication, this additional ticket MAY be a TGT issued by the
      local realm or an inter-realm TGT issued for the current KDC's
      realm by a remote KDC.  If more than one option that requires
      additional tickets has been specified, then the additional tickets
      are used in the order specified by the ordering of the options
      bits (see kdc-options, above).






Neuman, et al.              Standards Track                    [Page 80]

RFC 4120                      Kerberos V5                      July 2005


   The application tag number will be either ten (10) or twelve (12)
   depending on whether the request is for an initial ticket (AS-REQ) or
   for an additional ticket (TGS-REQ).

   The optional fields (addresses, authorization-data, and additional-
   tickets) are only included if necessary to perform the operation
   specified in the kdc-options field.

   Note that in KRB_TGS_REQ, the protocol version number appears twice
   and two different message types appear: the KRB_TGS_REQ message
   contains these fields as does the authentication header (KRB_AP_REQ)
   that is passed in the padata field.

5.4.2.  KRB_KDC_REP Definition

   The KRB_KDC_REP message format is used for the reply from the KDC for
   either an initial (AS) request or a subsequent (TGS) request.  There
   is no message type for KRB_KDC_REP.  Instead, the type will be either
   KRB_AS_REP or KRB_TGS_REP.  The key used to encrypt the ciphertext
   part of the reply depends on the message type.  For KRB_AS_REP, the
   ciphertext is encrypted in the client's secret key, and the client's
   key version number is included in the key version number for the
   encrypted data.  For KRB_TGS_REP, the ciphertext is encrypted in the
   sub-session key from the Authenticator; if it is absent, the
   ciphertext is encrypted in the session key from the TGT used in the
   request.  In that case, no version number will be present in the
   EncryptedData sequence.

   The KRB_KDC_REP message contains the following fields:

   AS-REP          ::= [APPLICATION 11] KDC-REP

   TGS-REP         ::= [APPLICATION 13] KDC-REP

   KDC-REP         ::= SEQUENCE {
           pvno            [0] INTEGER (5),
           msg-type        [1] INTEGER (11 -- AS -- | 13 -- TGS --),
           padata          [2] SEQUENCE OF PA-DATA OPTIONAL
                                   -- NOTE: not empty --,
           crealm          [3] Realm,
           cname           [4] PrincipalName,
           ticket          [5] Ticket,
           enc-part        [6] EncryptedData
                                   -- EncASRepPart or EncTGSRepPart,
                                   -- as appropriate
   }

   EncASRepPart    ::= [APPLICATION 25] EncKDCRepPart



Neuman, et al.              Standards Track                    [Page 81]

RFC 4120                      Kerberos V5                      July 2005


   EncTGSRepPart   ::= [APPLICATION 26] EncKDCRepPart

   EncKDCRepPart   ::= SEQUENCE {
           key             [0] EncryptionKey,
           last-req        [1] LastReq,
           nonce           [2] UInt32,
           key-expiration  [3] KerberosTime OPTIONAL,
           flags           [4] TicketFlags,
           authtime        [5] KerberosTime,
           starttime       [6] KerberosTime OPTIONAL,
           endtime         [7] KerberosTime,
           renew-till      [8] KerberosTime OPTIONAL,
           srealm          [9] Realm,
           sname           [10] PrincipalName,
           caddr           [11] HostAddresses OPTIONAL
   }

   LastReq         ::=     SEQUENCE OF SEQUENCE {
           lr-type         [0] Int32,
           lr-value        [1] KerberosTime
   }

   pvno and msg-type
      These fields are described above in Section 5.4.1.  msg-type is
      either KRB_AS_REP or KRB_TGS_REP.

   padata
      This field is described in detail in Section 5.4.1.  One possible
      use for it is to encode an alternate ""salt"" string to be used with
      a string-to-key algorithm.  This ability is useful for easing
      transitions if a realm name needs to change (e.g., when a company
      is acquired); in such a case all existing password-derived entries
      in the KDC database would be flagged as needing a special salt
      string until the next password change.

   crealm, cname, srealm, and sname
      These fields are the same as those described for the ticket in
      section 5.3.

   ticket
      The newly-issued ticket, from Section 5.3.

   enc-part
      This field is a place holder for the ciphertext and related
      information that forms the encrypted part of a message.  The
      description of the encrypted part of the message follows each
      appearance of this field.




Neuman, et al.              Standards Track                    [Page 82]

RFC 4120                      Kerberos V5                      July 2005


      The key usage value for encrypting this field is 3 in an AS-REP
      message, using the client's long-term key or another key selected
      via pre-authentication mechanisms.  In a TGS-REP message, the key
      usage value is 8 if the TGS session key is used, or 9 if a TGS
      authenticator subkey is used.

      Compatibility note: Some implementations unconditionally send an
      encrypted EncTGSRepPart (application tag number 26) in this field
      regardless of whether the reply is a AS-REP or a TGS-REP.  In the
      interest of compatibility, implementors MAY relax the check on the
      tag number of the decrypted ENC-PART.

   key
      This field is the same as described for the ticket in Section 5.3.

   last-req
      This field is returned by the KDC and specifies the time(s) of the
      last request by a principal.  Depending on what information is
      available, this might be the last time that a request for a TGT
      was made, or the last time that a request based on a TGT was
      successful.  It also might cover all servers for a realm, or just
      the particular server.  Some implementations MAY display this
      information to the user to aid in discovering unauthorized use of
      one's identity.  It is similar in spirit to the last login time
      displayed when logging in to timesharing systems.

   lr-type
      This field indicates how the following lr-value field is to be
      interpreted.  Negative values indicate that the information
      pertains only to the responding server.  Non-negative values
      pertain to all servers for the realm.

      If the lr-type field is zero (0), then no information is conveyed
      by the lr-value subfield.  If the absolute value of the lr-type
      field is one (1), then the lr-value subfield is the time of last
      initial request for a TGT.  If it is two (2), then the lr-value
      subfield is the time of last initial request.  If it is three (3),
      then the lr-value subfield is the time of issue for the newest TGT
      used.  If it is four (4), then the lr-value subfield is the time
      of the last renewal.  If it is five (5), then the lr-value
      subfield is the time of last request (of any type).  If it is (6),
      then the lr-value subfield is the time when the password will
      expire.  If it is (7), then the lr-value subfield is the time when
      the account will expire.







Neuman, et al.              Standards Track                    [Page 83]

RFC 4120                      Kerberos V5                      July 2005


   lr-value
      This field contains the time of the last request.  The time MUST
      be interpreted according to the contents of the accompanying lr-
      type subfield.

   nonce
      This field is described above in Section 5.4.1.

   key-expiration
      The key-expiration field is part of the response from the KDC and
      specifies the time that the client's secret key is due to expire.
      The expiration might be the result of password aging or an account
      expiration.  If present, it SHOULD be set to the earlier of the
      user's key expiration and account expiration.  The use of this
      field is deprecated, and the last-req field SHOULD be used to
      convey this information instead.  This field will usually be left
      out of the TGS reply since the response to the TGS request is
      encrypted in a session key and no client information has to be
      retrieved from the KDC database.  It is up to the application
      client (usually the login program) to take appropriate action
      (such as notifying the user) if the expiration time is imminent.

   flags, authtime, starttime, endtime, renew-till and caddr
      These fields are duplicates of those found in the encrypted
      portion of the attached ticket (see Section 5.3), provided so the
      client MAY verify that they match the intended request and in
      order to assist in proper ticket caching.  If the message is of
      type KRB_TGS_REP, the caddr field will only be filled in if the
      request was for a proxy or forwarded ticket, or if the user is
      substituting a subset of the addresses from the TGT.  If the
      client-requested addresses are not present or not used, then the
      addresses contained in the ticket will be the same as those
      included in the TGT.

5.5.  Client/Server (CS) Message Specifications

   This section specifies the format of the messages used for the
   authentication of the client to the application server.

5.5.1.  KRB_AP_REQ Definition

   The KRB_AP_REQ message contains the Kerberos protocol version number,
   the message type KRB_AP_REQ, an options field to indicate any options
   in use, and the ticket and authenticator themselves.  The KRB_AP_REQ
   message is often referred to as the ""authentication header"".






Neuman, et al.              Standards Track                    [Page 84]

RFC 4120                      Kerberos V5                      July 2005


   AP-REQ          ::= [APPLICATION 14] SEQUENCE {
           pvno            [0] INTEGER (5),
           msg-type        [1] INTEGER (14),
           ap-options      [2] APOptions,
           ticket          [3] Ticket,
           authenticator   [4] EncryptedData -- Authenticator
   }

   APOptions       ::= KerberosFlags
           -- reserved(0),
           -- use-session-key(1),
           -- mutual-required(2)

   pvno and msg-type
      These fields are described above in Section 5.4.1. msg-type is
      KRB_AP_REQ.

   ap-options
      This field appears in the application request (KRB_AP_REQ) and
      affects the way the request is processed.  It is a bit-field,
      where the selected options are indicated by the bit being set (1),
      and the unselected options and reserved fields by being reset (0).
      The encoding of the bits is specified in Section 5.2.  The
      meanings of the options are as follows:

   Bit(s)  Name             Description

   0       reserved         Reserved for future expansion of this field.

   1       use-session-key  The USE-SESSION-KEY option indicates that
                            the ticket the client is presenting to a
                            server is encrypted in the session key from
                            the server's TGT.  When this option is not
                            specified, the ticket is encrypted in the
                            server's secret key.

   2       mutual-required  The MUTUAL-REQUIRED option tells the server
                            that the client requires mutual
                            authentication, and that it must respond
                            with a KRB_AP_REP message.

   3-31    reserved         Reserved for future use.

   ticket
      This field is a ticket authenticating the client to the server.






Neuman, et al.              Standards Track                    [Page 85]

RFC 4120                      Kerberos V5                      July 2005


   authenticator
      This contains the encrypted authenticator, which includes the
      client's choice of a subkey.

   The encrypted authenticator is included in the AP-REQ; it certifies
   to a server that the sender has recent knowledge of the encryption
   key in the accompanying ticket, to help the server detect replays.
   It also assists in the selection of a ""true session key"" to use with
   the particular session.  The DER encoding of the following is
   encrypted in the ticket's session key, with a key usage value of 11
   in normal application exchanges, or 7 when used as the PA-TGS-REQ
   PA-DATA field of a TGS-REQ exchange (see Section 5.4.1):

   -- Unencrypted authenticator
   Authenticator   ::= [APPLICATION 2] SEQUENCE  {
           authenticator-vno       [0] INTEGER (5),
           crealm                  [1] Realm,
           cname                   [2] PrincipalName,
           cksum                   [3] Checksum OPTIONAL,
           cusec                   [4] Microseconds,
           ctime                   [5] KerberosTime,
           subkey                  [6] EncryptionKey OPTIONAL,
           seq-number              [7] UInt32 OPTIONAL,
           authorization-data      [8] AuthorizationData OPTIONAL
   }

   authenticator-vno
      This field specifies the version number for the format of the
      authenticator.  This document specifies version 5.

   crealm and cname
      These fields are the same as those described for the ticket in
      section 5.3.

   cksum
      This field contains a checksum of the application data that
      accompanies the KRB_AP_REQ, computed using a key usage value of 10
      in normal application exchanges, or 6 when used in the TGS-REQ
      PA-TGS-REQ AP-DATA field.

   cusec
      This field contains the microsecond part of the client's
      timestamp.  Its value (before encryption) ranges from 0 to 999999.
      It often appears along with ctime.  The two fields are used
      together to specify a reasonably accurate timestamp.

   ctime
      This field contains the current time on the client's host.



Neuman, et al.              Standards Track                    [Page 86]

RFC 4120                      Kerberos V5                      July 2005


   subkey
      This field contains the client's choice for an encryption key to
      be used to protect this specific application session.  Unless an
      application specifies otherwise, if this field is left out, the
      session key from the ticket will be used.

   seq-number
      This optional field includes the initial sequence number to be
      used by the KRB_PRIV or KRB_SAFE messages when sequence numbers
      are used to detect replays.  (It may also be used by application
      specific messages.)  When included in the authenticator, this
      field specifies the initial sequence number for messages from the
      client to the server.  When included in the AP-REP message, the
      initial sequence number is that for messages from the server to
      the client.  When used in KRB_PRIV or KRB_SAFE messages, it is
      incremented by one after each message is sent.  Sequence numbers
      fall in the range 0 through 2^32 - 1 and wrap to zero following
      the value 2^32 - 1.

      For sequence numbers to support the detection of replays
      adequately, they SHOULD be non-repeating, even across connection
      boundaries.  The initial sequence number SHOULD be random and
      uniformly distributed across the full space of possible sequence
      numbers, so that it cannot be guessed by an attacker and so that
      it and the successive sequence numbers do not repeat other
      sequences.  In the event that more than 2^32 messages are to be
      generated in a series of KRB_PRIV or KRB_SAFE messages, rekeying
      SHOULD be performed before sequence numbers are reused with the
      same encryption key.

      Implmentation note: Historically, some implementations transmit
      signed twos-complement numbers for sequence numbers.  In the
      interests of compatibility, implementations MAY accept the
      equivalent negative number where a positive number greater than
      2^31 - 1 is expected.

      Implementation note: As noted before, some implementations omit
      the optional sequence number when its value would be zero.
      Implementations MAY accept an omitted sequence number when
      expecting a value of zero, and SHOULD NOT transmit an
      Authenticator with a initial sequence number of zero.

   authorization-data
      This field is the same as described for the ticket in Section 5.3.
      It is optional and will only appear when additional restrictions
      are to be placed on the use of a ticket, beyond those carried in
      the ticket itself.




Neuman, et al.              Standards Track                    [Page 87]

RFC 4120                      Kerberos V5                      July 2005


5.5.2.  KRB_AP_REP Definition

   The KRB_AP_REP message contains the Kerberos protocol version number,
   the message type, and an encrypted time-stamp.  The message is sent
   in response to an application request (KRB_AP_REQ) for which the
   mutual authentication option has been selected in the ap-options
   field.

   AP-REP          ::= [APPLICATION 15] SEQUENCE {
           pvno            [0] INTEGER (5),
           msg-type        [1] INTEGER (15),
           enc-part        [2] EncryptedData -- EncAPRepPart
   }

   EncAPRepPart    ::= [APPLICATION 27] SEQUENCE {
           ctime           [0] KerberosTime,
           cusec           [1] Microseconds,
           subkey          [2] EncryptionKey OPTIONAL,
           seq-number      [3] UInt32 OPTIONAL
   }

   The encoded EncAPRepPart is encrypted in the shared session key of
   the ticket.  The optional subkey field can be used in an
   application-arranged negotiation to choose a per association session
   key.

   pvno and msg-type
      These fields are described above in Section 5.4.1.  msg-type is
      KRB_AP_REP.

   enc-part
      This field is described above in Section 5.4.2.  It is computed
      with a key usage value of 12.

   ctime
      This field contains the current time on the client's host.

   cusec
      This field contains the microsecond part of the client's
      timestamp.

   subkey
      This field contains an encryption key that is to be used to
      protect this specific application session.  See Section 3.2.6 for
      specifics on how this field is used to negotiate a key.  Unless an
      application specifies otherwise, if this field is left out, the
      sub-session key from the authenticator or if the latter is also
      left out, the session key from the ticket will be used.



Neuman, et al.              Standards Track                    [Page 88]

RFC 4120                      Kerberos V5                      July 2005


   seq-number
      This field is described above in Section 5.3.2.

5.5.3.  Error Message Reply

   If an error occurs while processing the application request, the
   KRB_ERROR message will be sent in response.  See Section 5.9.1 for
   the format of the error message.  The cname and crealm fields MAY be
   left out if the server cannot determine their appropriate values from
   the corresponding KRB_AP_REQ message.  If the authenticator was
   decipherable, the ctime and cusec fields will contain the values from
   it.

5.6.  KRB_SAFE Message Specification

   This section specifies the format of a message that can be used by
   either side (client or server) of an application to send a tamper-
   proof message to its peer.  It presumes that a session key has
   previously been exchanged (for example, by using the
   KRB_AP_REQ/KRB_AP_REP messages).

5.6.1.  KRB_SAFE definition

   The KRB_SAFE message contains user data along with a collision-proof
   checksum keyed with the last encryption key negotiated via subkeys,
   or with the session key if no negotiation has occurred.  The message
   fields are as follows:

   KRB-SAFE        ::= [APPLICATION 20] SEQUENCE {
           pvno            [0] INTEGER (5),
           msg-type        [1] INTEGER (20),
           safe-body       [2] KRB-SAFE-BODY,
           cksum           [3] Checksum
   }

   KRB-SAFE-BODY   ::= SEQUENCE {
           user-data       [0] OCTET STRING,
           timestamp       [1] KerberosTime OPTIONAL,
           usec            [2] Microseconds OPTIONAL,
           seq-number      [3] UInt32 OPTIONAL,
           s-address       [4] HostAddress,
           r-address       [5] HostAddress OPTIONAL
   }

   pvno and msg-type
      These fields are described above in Section 5.4.1.  msg-type is
      KRB_SAFE.




Neuman, et al.              Standards Track                    [Page 89]

RFC 4120                      Kerberos V5                      July 2005


   safe-body
      This field is a placeholder for the body of the KRB-SAFE message.

   cksum
      This field contains the checksum of the application data, computed
      with a key usage value of 15.

      The checksum is computed over the encoding of the KRB-SAFE
      sequence.  First, the cksum is set to a type zero, zero-length
      value, and the checksum is computed over the encoding of the KRB-
      SAFE sequence.  Then the checksum is set to the result of that
      computation.  Finally, the KRB-SAFE sequence is encoded again.
      This method, although different than the one specified in RFC
      1510, corresponds to existing practice.

   user-data
      This field is part of the KRB_SAFE and KRB_PRIV messages, and
      contains the application-specific data that is being passed from
      the sender to the recipient.

   timestamp
      This field is part of the KRB_SAFE and KRB_PRIV messages.  Its
      contents are the current time as known by the sender of the
      message.  By checking the timestamp, the recipient of the message
      is able to make sure that it was recently generated, and is not a
      replay.

   usec
      This field is part of the KRB_SAFE and KRB_PRIV headers.  It
      contains the microsecond part of the timestamp.

   seq-number
      This field is described above in Section 5.3.2.

   s-address
      Sender's address.

      This field specifies the address in use by the sender of the
      message.

   r-address
      This field specifies the address in use by the recipient of the
      message.  It MAY be omitted for some uses (such as broadcast
      protocols), but the recipient MAY arbitrarily reject such
      messages.  This field, along with s-address, can be used to help
      detect messages that have been incorrectly or maliciously
      delivered to the wrong recipient.




Neuman, et al.              Standards Track                    [Page 90]

RFC 4120                      Kerberos V5                      July 2005


5.7.  KRB_PRIV Message Specification

   This section specifies the format of a message that can be used by
   either side (client or server) of an application to send a message to
   its peer securely and privately.  It presumes that a session key has
   previously been exchanged (for example, by using the
   KRB_AP_REQ/KRB_AP_REP messages).

5.7.1.  KRB_PRIV Definition

   The KRB_PRIV message contains user data encrypted in the Session Key.
   The message fields are as follows:

   KRB-PRIV        ::= [APPLICATION 21] SEQUENCE {
           pvno            [0] INTEGER (5),
           msg-type        [1] INTEGER (21),
                           -- NOTE: there is no [2] tag
           enc-part        [3] EncryptedData -- EncKrbPrivPart
   }

   EncKrbPrivPart  ::= [APPLICATION 28] SEQUENCE {
           user-data       [0] OCTET STRING,
           timestamp       [1] KerberosTime OPTIONAL,
           usec            [2] Microseconds OPTIONAL,
           seq-number      [3] UInt32 OPTIONAL,
           s-address       [4] HostAddress -- sender's addr --,
           r-address       [5] HostAddress OPTIONAL -- recip's addr
   }

   pvno and msg-type
      These fields are described above in Section 5.4.1.  msg-type is
      KRB_PRIV.

   enc-part
      This field holds an encoding of the EncKrbPrivPart sequence
      encrypted under the session key, with a key usage value of 13.
      This encrypted encoding is used for the enc-part field of the
      KRB-PRIV message.

   user-data, timestamp, usec, s-address, and r-address
      These fields are described above in Section 5.6.1.

   seq-number
      This field is described above in Section 5.3.2.







Neuman, et al.              Standards Track                    [Page 91]

RFC 4120                      Kerberos V5                      July 2005


5.8.  KRB_CRED Message Specification

   This section specifies the format of a message that can be used to
   send Kerberos credentials from one principal to another.  It is
   presented here to encourage a common mechanism to be used by
   applications when forwarding tickets or providing proxies to
   subordinate servers.  It presumes that a session key has already been
   exchanged, perhaps by using the KRB_AP_REQ/KRB_AP_REP messages.

5.8.1.  KRB_CRED Definition

   The KRB_CRED message contains a sequence of tickets to be sent and
   information needed to use the tickets, including the session key from
   each.  The information needed to use the tickets is encrypted under
   an encryption key previously exchanged or transferred alongside the
   KRB_CRED message.  The message fields are as follows:

   KRB-CRED        ::= [APPLICATION 22] SEQUENCE {
           pvno            [0] INTEGER (5),
           msg-type        [1] INTEGER (22),
           tickets         [2] SEQUENCE OF Ticket,
           enc-part        [3] EncryptedData -- EncKrbCredPart
   }

   EncKrbCredPart  ::= [APPLICATION 29] SEQUENCE {
           ticket-info     [0] SEQUENCE OF KrbCredInfo,
           nonce           [1] UInt32 OPTIONAL,
           timestamp       [2] KerberosTime OPTIONAL,
           usec            [3] Microseconds OPTIONAL,
           s-address       [4] HostAddress OPTIONAL,
           r-address       [5] HostAddress OPTIONAL
   }

   KrbCredInfo     ::= SEQUENCE {
           key             [0] EncryptionKey,
           prealm          [1] Realm OPTIONAL,
           pname           [2] PrincipalName OPTIONAL,
           flags           [3] TicketFlags OPTIONAL,
           authtime        [4] KerberosTime OPTIONAL,
           starttime       [5] KerberosTime OPTIONAL,
           endtime         [6] KerberosTime OPTIONAL,
           renew-till      [7] KerberosTime OPTIONAL,
           srealm          [8] Realm OPTIONAL,
           sname           [9] PrincipalName OPTIONAL,
           caddr           [10] HostAddresses OPTIONAL
   }





Neuman, et al.              Standards Track                    [Page 92]

RFC 4120                      Kerberos V5                      July 2005


   pvno and msg-type
      These fields are described above in Section 5.4.1.  msg-type is
      KRB_CRED.

   tickets
      These are the tickets obtained from the KDC specifically for use
      by the intended recipient.  Successive tickets are paired with the
      corresponding KrbCredInfo sequence from the enc-part of the KRB-
      CRED message.

   enc-part
      This field holds an encoding of the EncKrbCredPart sequence
      encrypted under the session key shared by the sender and the
      intended recipient, with a key usage value of 14.  This encrypted
      encoding is used for the enc-part field of the KRB-CRED message.

      Implementation note: Implementations of certain applications, most
      notably certain implementations of the Kerberos GSS-API mechanism,
      do not separately encrypt the contents of the EncKrbCredPart of
      the KRB-CRED message when sending it.  In the case of those GSS-
      API mechanisms, this is not a security vulnerability, as the
      entire KRB-CRED message is itself embedded in an encrypted
      message.

   nonce
      If practical, an application MAY require the inclusion of a nonce
      generated by the recipient of the message.  If the same value is
      included as the nonce in the message, it provides evidence that
      the message is fresh and has not been replayed by an attacker.  A
      nonce MUST NEVER be reused.

   timestamp and usec
      These fields specify the time that the KRB-CRED message was
      generated.  The time is used to provide assurance that the message
      is fresh.

   s-address and r-address
      These fields are described above in Section 5.6.1.  They are used
      optionally to provide additional assurance of the integrity of the
      KRB-CRED message.

   key
      This field exists in the corresponding ticket passed by the KRB-
      CRED message and is used to pass the session key from the sender
      to the intended recipient.  The field's encoding is described in
      Section 5.2.9.





Neuman, et al.              Standards Track                    [Page 93]

RFC 4120                      Kerberos V5                      July 2005


   The following fields are optional.  If present, they can be
   associated with the credentials in the remote ticket file.  If left
   out, then it is assumed that the recipient of the credentials already
   knows their values.

   prealm and pname
      The name and realm of the delegated principal identity.

   flags, authtime, starttime, endtime, renew-till, srealm, sname,
   and caddr
      These fields contain the values of the corresponding fields from
      the ticket found in the ticket field.  Descriptions of the fields
      are identical to the descriptions in the KDC-REP message.

5.9.  Error Message Specification

   This section specifies the format for the KRB_ERROR message.  The
   fields included in the message are intended to return as much
   information as possible about an error.  It is not expected that all
   the information required by the fields will be available for all
   types of errors.  If the appropriate information is not available
   when the message is composed, the corresponding field will be left
   out of the message.

   Note that because the KRB_ERROR message is not integrity protected,
   it is quite possible for an intruder to synthesize or modify it.  In
   particular, this means that the client SHOULD NOT use any fields in
   this message for security-critical purposes, such as setting a system
   clock or generating a fresh authenticator.  The message can be
   useful, however, for advising a user on the reason for some failure.

5.9.1.  KRB_ERROR Definition

   The KRB_ERROR message consists of the following fields:

   KRB-ERROR       ::= [APPLICATION 30] SEQUENCE {
           pvno            [0] INTEGER (5),
           msg-type        [1] INTEGER (30),
           ctime           [2] KerberosTime OPTIONAL,
           cusec           [3] Microseconds OPTIONAL,
           stime           [4] KerberosTime,
           susec           [5] Microseconds,
           error-code      [6] Int32,
           crealm          [7] Realm OPTIONAL,
           cname           [8] PrincipalName OPTIONAL,
           realm           [9] Realm -- service realm --,
           sname           [10] PrincipalName -- service name --,
           e-text          [11] KerberosString OPTIONAL,



Neuman, et al.              Standards Track                    [Page 94]

RFC 4120                      Kerberos V5                      July 2005


           e-data          [12] OCTET STRING OPTIONAL
   }

   pvno and msg-type
      These fields are described above in Section 5.4.1.  msg-type is
      KRB_ERROR.

   ctime and cusec
      These fields are described above in Section 5.5.2.  If the values
      for these fields are known to the entity generating the error (as
      they would be if the KRB-ERROR is generated in reply to, e.g., a
      failed authentication service request), they should be populated
      in the KRB-ERROR.  If the values are not available, these fields
      can be omitted.

   stime
      This field contains the current time on the server.  It is of type
      KerberosTime.

   susec
      This field contains the microsecond part of the server's
      timestamp.  Its value ranges from 0 to 999999.  It appears along
      with stime.  The two fields are used in conjunction to specify a
      reasonably accurate timestamp.

   error-code
      This field contains the error code returned by Kerberos or the
      server when a request fails.  To interpret the value of this field
      see the list of error codes in Section 7.5.9.  Implementations are
      encouraged to provide for national language support in the display
      of error messages.

   crealm, and cname
      These fields are described above in Section 5.3.  When the entity
      generating the error knows these values, they should be populated
      in the KRB-ERROR.  If the values are not known, the crealm and
      cname fields SHOULD be omitted.

   realm and sname
      These fields are described above in Section 5.3.

   e-text
      This field contains additional text to help explain the error code
      associated with the failed request (for example, it might include
      a principal name which was unknown).






Neuman, et al.              Standards Track                    [Page 95]

RFC 4120                      Kerberos V5                      July 2005


   e-data
      This field contains additional data about the error for use by the
      application to help it recover from or handle the error.  If the
      errorcode is KDC_ERR_PREAUTH_REQUIRED, then the e-data field will
      contain an encoding of a sequence of padata fields, each
      corresponding to an acceptable pre-authentication method and
      optionally containing data for the method:

      METHOD-DATA     ::= SEQUENCE OF PA-DATA

   For error codes defined in this document other than
   KDC_ERR_PREAUTH_REQUIRED, the format and contents of the e-data field
   are implementation-defined.  Similarly, for future error codes, the
   format and contents of the e-data field are implementation-defined
   unless specified otherwise.  Whether defined by the implementation or
   in a future document, the e-data field MAY take the form of TYPED-
   DATA:

   TYPED-DATA      ::= SEQUENCE SIZE (1..MAX) OF SEQUENCE {
           data-type       [0] Int32,
           data-value      [1] OCTET STRING OPTIONAL
   }

5.10.  Application Tag Numbers

   The following table lists the application class tag numbers used by
   various data types defined in this section.

   Tag Number(s)  Type Name      Comments

   0                             unused

   1              Ticket         PDU

   2              Authenticator  non-PDU

   3              EncTicketPart  non-PDU

   4-9                           unused

   10             AS-REQ         PDU

   11             AS-REP         PDU

   12             TGS-REQ        PDU

   13             TGS-REP        PDU




Neuman, et al.              Standards Track                    [Page 96]

RFC 4120                      Kerberos V5                      July 2005


   14             AP-REQ         PDU

   15             AP-REP         PDU

   16             RESERVED16     TGT-REQ (for user-to-user)

   17             RESERVED17     TGT-REP (for user-to-user)

   18-19                         unused

   20             KRB-SAFE       PDU

   21             KRB-PRIV       PDU

   22             KRB-CRED       PDU

   23-24                         unused

   25             EncASRepPart   non-PDU

   26             EncTGSRepPart  non-PDU

   27             EncApRepPart   non-PDU

   28             EncKrbPrivPart non-PDU

   29             EncKrbCredPart non-PDU

   30             KRB-ERROR      PDU

   The ASN.1 types marked above as ""PDU"" (Protocol Data Unit) are the
   only ASN.1 types intended as top-level types of the Kerberos
   protocol, and are the only types that may be used as elements in
   another protocol that makes use of Kerberos.

6.  Naming Constraints

6.1.  Realm Names

   Although realm names are encoded as GeneralStrings and technically a
   realm can select any name it chooses, interoperability across realm
   boundaries requires agreement on how realm names are to be assigned,
   and what information they imply.

   To enforce these conventions, each realm MUST conform to the
   conventions itself, and it MUST require that any realms with which
   inter-realm keys are shared also conform to the conventions and
   require the same from its neighbors.



Neuman, et al.              Standards Track                    [Page 97]

RFC 4120                      Kerberos V5                      July 2005


   Kerberos realm names are case sensitive.  Realm names that differ
   only in the case of the characters are not equivalent.  There are
   presently three styles of realm names: domain, X500, and other.
   Examples of each style follow:

        domain:   ATHENA.MIT.EDU
          X500:   C=US/O=OSF
         other:   NAMETYPE:rest/of.name=without-restrictions

   Domain style realm names MUST look like domain names: they consist of
   components separated by periods (.) and they contain neither colons
   (:) nor slashes (/).  Though domain names themselves are case
   insensitive, in order for realms to match, the case must match as
   well.  When establishing a new realm name based on an internet domain
   name it is recommended by convention that the characters be converted
   to uppercase.

   X.500 names contain an equals sign (=) and cannot contain a colon (:)
   before the equals sign.  The realm names for X.500 names will be
   string representations of the names with components separated by
   slashes.  Leading and trailing slashes will not be included.  Note
   that the slash separator is consistent with Kerberos implementations
   based on RFC 1510, but it is different from the separator recommended
   in RFC 2253.

   Names that fall into the other category MUST begin with a prefix that
   contains no equals sign (=) or period (.), and the prefix MUST be
   followed by a colon (:) and the rest of the name.  All prefixes
   expect those beginning with used.  Presently none are assigned.

   The reserved category includes strings that do not fall into the
   first three categories.  All names in this category are reserved.  It
   is unlikely that names will be assigned to this category unless there
   is a very strong argument for not using the 'other' category.

   These rules guarantee that there will be no conflicts between the
   various name styles.  The following additional constraints apply to
   the assignment of realm names in the domain and X.500 categories:
   either the name of a realm for the domain or X.500 formats must be
   used by the organization owning (to whom it was assigned) an Internet
   domain name or X.500 name, or, in the case that no such names are
   registered, authority to use a realm name MAY be derived from the
   authority of the parent realm.  For example, if there is no domain
   name for E40.MIT.EDU, then the administrator of the MIT.EDU realm can
   authorize the creation of a realm with that name.

   This is acceptable because the organization to which the parent is
   assigned is presumably the organization authorized to assign names to



Neuman, et al.              Standards Track                    [Page 98]

RFC 4120                      Kerberos V5                      July 2005


   its children in the X.500 and domain name systems as well.  If the
   parent assigns a realm name without also registering it in the domain
   name or X.500 hierarchy, it is the parent's responsibility to make
   sure that in the future there will not exist a name identical to the
   realm name of the child unless it is assigned to the same entity as
   the realm name.

6.2.  Principal Names

   As was the case for realm names, conventions are needed to ensure
   that all agree on what information is implied by a principal name.
   The name-type field that is part of the principal name indicates the
   kind of information implied by the name.  The name-type SHOULD be
   treated only as a hint to interpreting the meaning of a name.  It is
   not significant when checking for equivalence.  Principal names that
   differ only in the name-type identify the same principal.  The name
   type does not partition the name space.  Ignoring the name type, no
   two names can be the same (i.e., at least one of the components, or
   the realm, MUST be different).  The following name types are defined:

   Name Type       Value  Meaning

   NT-UNKNOWN        0    Name type not known
   NT-PRINCIPAL      1    Just the name of the principal as in DCE,
                            or for users
   NT-SRV-INST       2    Service and other unique instance (krbtgt)
   NT-SRV-HST        3    Service with host name as instance
                            (telnet, rcommands)
   NT-SRV-XHST       4    Service with host as remaining components
   NT-UID            5    Unique ID
   NT-X500-PRINCIPAL 6    Encoded X.509 Distinguished name [RFC2253]
   NT-SMTP-NAME      7    Name in form of SMTP email name
                            (e.g., user@example.com)
   NT-ENTERPRISE    10    Enterprise name - may be mapped to principal
                            name

   When a name implies no information other than its uniqueness at a
   particular time, the name type PRINCIPAL SHOULD be used.  The
   principal name type SHOULD be used for users, and it might also be
   used for a unique server.  If the name is a unique machine-generated
   ID that is guaranteed never to be reassigned, then the name type of
   UID SHOULD be used.  (Note that it is generally a bad idea to
   reassign names of any type since stale entries might remain in access
   control lists.)

   If the first component of a name identifies a service and the
   remaining components identify an instance of the service in a
   server-specified manner, then the name type of SRV-INST SHOULD be



Neuman, et al.              Standards Track                    [Page 99]

RFC 4120                      Kerberos V5                      July 2005


   used.  An example of this name type is the Kerberos ticket-granting
   service whose name has a first component of krbtgt and a second
   component identifying the realm for which the ticket is valid.

   If the first component of a name identifies a service and there is a
   single component following the service name identifying the instance
   as the host on which the server is running, then the name type
   SRV-HST SHOULD be used.  This type is typically used for Internet
   services such as telnet and the Berkeley R commands.  If the separate
   components of the host name appear as successive components following
   the name of the service, then the name type SRV-XHST SHOULD be used.
   This type might be used to identify servers on hosts with X.500
   names, where the slash (/) might otherwise be ambiguous.

   A name type of NT-X500-PRINCIPAL SHOULD be used when a name from an
   X.509 certificate is translated into a Kerberos name.  The encoding
   of the X.509 name as a Kerberos principal shall conform to the
   encoding rules specified in RFC 2253.

   A name type of SMTP allows a name to be of a form that resembles an
   SMTP email name.  This name, including an ""@"" and a domain name, is
   used as the one component of the principal name.

   A name type of UNKNOWN SHOULD be used when the form of the name is
   not known.  When comparing names, a name of type UNKNOWN will match
   principals authenticated with names of any type.  A principal
   authenticated with a name of type UNKNOWN, however, will only match
   other names of type UNKNOWN.

   Names of any type with an initial component of 'krbtgt' are reserved
   for the Kerberos ticket-granting service.  See Section 7.3 for the
   form of such names.

6.2.1.  Name of Server Principals

   The principal identifier for a server on a host will generally be
   composed of two parts: (1) the realm of the KDC with which the server
   is registered, and (2) a two-component name of type NT-SRV-HST, if
   the host name is an Internet domain name, or a multi-component name
   of type NT-SRV-XHST, if the name of the host is of a form (such as
   X.500) that allows slash (/) separators.  The first component of the
   two- or multi-component name will identify the service, and the
   latter components will identify the host.  Where the name of the host
   is not case sensitive (for example, with Internet domain names) the
   name of the host MUST be lowercase.  If specified by the application
   protocol for services such as telnet and the Berkeley R commands that
   run with system privileges, the first component MAY be the string
   'host' instead of a service-specific identifier.



Neuman, et al.              Standards Track                   [Page 100]

RFC 4120                      Kerberos V5                      July 2005


7.  Constants and Other Defined Values

7.1.  Host Address Types

   All negative values for the host address type are reserved for local
   use.  All non-negative values are reserved for officially assigned
   type fields and interpretations.

   Internet (IPv4) Addresses

      Internet (IPv4) addresses are 32-bit (4-octet) quantities, encoded
      in MSB order (most significant byte first).  The IPv4 loopback
      address SHOULD NOT appear in a Kerberos PDU.  The type of IPv4
      addresses is two (2).

   Internet (IPv6) Addresses

      IPv6 addresses [RFC3513] are 128-bit (16-octet) quantities,
      encoded in MSB order (most significant byte first).  The type of
      IPv6 addresses is twenty-four (24).  The following addresses MUST
      NOT appear in any Kerberos PDU:

         *  the Unspecified Address
         *  the Loopback Address
         *  Link-Local addresses

      This restriction applies to the inclusion in the address fields of
      Kerberos PDUs, but not to the address fields of packets that might
      carry such PDUs.  The restriction is necessary because the use of
      an address with non-global scope could allow the acceptance of a
      message sent from a node that may have the same address, but which
      is not the host intended by the entity that added the restriction.
      If the link-local address type needs to be used for communication,
      then the address restriction in tickets must not be used (i.e.,
      addressless tickets must be used).

      IPv4-mapped IPv6 addresses MUST be represented as addresses of
      type 2.

   DECnet Phase IV Addresses

      DECnet Phase IV addresses are 16-bit addresses, encoded in LSB
      order.  The type of DECnet Phase IV addresses is twelve (12).








Neuman, et al.              Standards Track                   [Page 101]

RFC 4120                      Kerberos V5                      July 2005


   Netbios Addresses

      Netbios addresses are 16-octet addresses typically composed of 1
      to 15 alphanumeric characters and padded with the US-ASCII SPC
      character (code 32).  The 16th octet MUST be the US-ASCII NUL
      character (code 0).  The type of Netbios addresses is twenty (20).

   Directional Addresses

      Including the sender address in KRB_SAFE and KRB_PRIV messages is
      undesirable in many environments because the addresses may be
      changed in transport by network address translators.  However, if
      these addresses are removed, the messages may be subject to a
      reflection attack in which a message is reflected back to its
      originator.  The directional address type provides a way to avoid
      transport addresses and reflection attacks.  Directional addresses
      are encoded as four-byte unsigned integers in network byte order.
      If the message is originated by the party sending the original
      KRB_AP_REQ message, then an address of 0 SHOULD be used.  If the
      message is originated by the party to whom that KRB_AP_REQ was
      sent, then the address 1 SHOULD be used.  Applications involving
      multiple parties can specify the use of other addresses.

      Directional addresses MUST only be used for the sender address
      field in the KRB_SAFE or KRB_PRIV messages.  They MUST NOT be used
      as a ticket address or in a KRB_AP_REQ message.  This address type
      SHOULD only be used in situations where the sending party knows
      that the receiving party supports the address type.  This
      generally means that directional addresses may only be used when
      the application protocol requires their support.  Directional
      addresses are type (3).

7.2.  KDC Messaging: IP Transports

   Kerberos defines two IP transport mechanisms for communication
   between clients and servers: UDP/IP and TCP/IP.

7.2.1.  UDP/IP transport

   Kerberos servers (KDCs) supporting IP transports MUST accept UDP
   requests and SHOULD listen for them on port 88 (decimal) unless
   specifically configured to listen on an alternative UDP port.
   Alternate ports MAY be used when running multiple KDCs for multiple
   realms on the same host.







Neuman, et al.              Standards Track                   [Page 102]

RFC 4120                      Kerberos V5                      July 2005


   Kerberos clients supporting IP transports SHOULD support the sending
   of UDP requests.  Clients SHOULD use KDC discovery [7.2.3] to
   identify the IP address and port to which they will send their
   request.

   When contacting a KDC for a KRB_KDC_REQ request using UDP/IP
   transport, the client shall send a UDP datagram containing only an
   encoding of the request to the KDC.  The KDC will respond with a
   reply datagram containing only an encoding of the reply message
   (either a KRB_ERROR or a KRB_KDC_REP) to the sending port at the
   sender's IP address.  The response to a request made through UDP/IP
   transport MUST also use UDP/IP transport.  If the response cannot be
   handled using UDP (for example, because it is too large), the KDC
   MUST return KRB_ERR_RESPONSE_TOO_BIG, forcing the client to retry the
   request using the TCP transport.

7.2.2.  TCP/IP Transport

   Kerberos servers (KDCs) supporting IP transports MUST accept TCP
   requests and SHOULD listen for them on port 88 (decimal) unless
   specifically configured to listen on an alternate TCP port.
   Alternate ports MAY be used when running multiple KDCs for multiple
   realms on the same host.

   Clients MUST support the sending of TCP requests, but MAY choose to
   try a request initially using the UDP transport.  Clients SHOULD use
   KDC discovery [7.2.3] to identify the IP address and port to which
   they will send their request.

   Implementation note: Some extensions to the Kerberos protocol will
   not succeed if any client or KDC not supporting the TCP transport is
   involved.  Implementations of RFC 1510 were not required to support
   TCP/IP transports.

   When the KRB_KDC_REQ message is sent to the KDC over a TCP stream,
   the response (KRB_KDC_REP or KRB_ERROR message) MUST be returned to
   the client on the same TCP stream that was established for the
   request.  The KDC MAY close the TCP stream after sending a response,
   but MAY leave the stream open for a reasonable period of time if it
   expects a follow-up.  Care must be taken in managing TCP/IP
   connections on the KDC to prevent denial of service attacks based on
   the number of open TCP/IP connections.

   The client MUST be prepared to have the stream closed by the KDC at
   any time after the receipt of a response.  A stream closure SHOULD
   NOT be treated as a fatal error.  Instead, if multiple exchanges are
   required (e.g., certain forms of pre-authentication), the client may
   need to establish a new connection when it is ready to send



Neuman, et al.              Standards Track                   [Page 103]

RFC 4120                      Kerberos V5                      July 2005


   subsequent messages.  A client MAY close the stream after receiving a
   response, and SHOULD close the stream if it does not expect to send
   follow-up messages.

   A client MAY send multiple requests before receiving responses,
   though it must be prepared to handle the connection being closed
   after the first response.

   Each request (KRB_KDC_REQ) and response (KRB_KDC_REP or KRB_ERROR)
   sent over the TCP stream is preceded by the length of the request as
   4 octets in network byte order.  The high bit of the length is
   reserved for future expansion and MUST currently be set to zero.  If
   a KDC that does not understand how to interpret a set high bit of the
   length encoding receives a request with the high order bit of the
   length set, it MUST return a KRB-ERROR message with the error
   KRB_ERR_FIELD_TOOLONG and MUST close the TCP stream.

   If multiple requests are sent over a single TCP connection and the
   KDC sends multiple responses, the KDC is not required to send the
   responses in the order of the corresponding requests.  This may
   permit some implementations to send each response as soon as it is
   ready, even if earlier requests are still being processed (for
   example, waiting for a response from an external device or database).

7.2.3.  KDC Discovery on IP Networks

   Kerberos client implementations MUST provide a means for the client
   to determine the location of the Kerberos Key Distribution Centers
   (KDCs).  Traditionally, Kerberos implementations have stored such
   configuration information in a file on each client machine.
   Experience has shown that this method of storing configuration
   information presents problems with out-of-date information and
   scaling, especially when using cross-realm authentication.  This
   section describes a method for using the Domain Name System [RFC1035]
   for storing KDC location information.

7.2.3.1.  DNS vs. Kerberos: Case Sensitivity of Realm Names

   In Kerberos, realm names are case sensitive.  Although it is strongly
   encouraged that all realm names be all uppercase, this recommendation
   has not been adopted by all sites.  Some sites use all lowercase
   names and other use mixed case.  DNS, on the other hand, is case
   insensitive for queries.  Because the realm names ""MYREALM"",
   ""myrealm"", and ""MyRealm"" are all different, but resolve the same in
   the domain name system, it is necessary that only one of the possible
   combinations of upper- and lowercase characters be used in realm
   names.




Neuman, et al.              Standards Track                   [Page 104]

RFC 4120                      Kerberos V5                      July 2005


7.2.3.2.  Specifying KDC Location Information with DNS SRV records

   KDC location information is to be stored using the DNS SRV RR
   [RFC2782].  The format of this RR is as follows:

      _Service._Proto.Realm TTL Class SRV Priority Weight Port Target

   The Service name for Kerberos is always ""kerberos"".

   The Proto can be either ""udp"" or ""tcp"".  If these SRV records are to
   be used, both ""udp"" and ""tcp"" records MUST be specified for all KDC
   deployments.

   The Realm is the Kerberos realm that this record corresponds to.  The
   realm MUST be a domain-style realm name.

   TTL, Class, SRV, Priority, Weight, and Target have the standard
   meaning as defined in RFC 2782.

   As per RFC 2782, the Port number used for ""_udp"" and ""_tcp"" SRV
   records SHOULD be the value assigned to ""kerberos"" by the Internet
   Assigned Number Authority: 88 (decimal), unless the KDC is configured
   to listen on an alternate TCP port.

   Implementation note: Many existing client implementations do not
   support KDC Discovery and are configured to send requests to the IANA
   assigned port (88 decimal), so it is strongly recommended that KDCs
   be configured to listen on that port.

7.2.3.3.  KDC Discovery for Domain Style Realm Names on IP Networks

   These are DNS records for a Kerberos realm EXAMPLE.COM.  It has two
   Kerberos servers, kdc1.example.com and kdc2.example.com.  Queries
   should be directed to kdc1.example.com first as per the specified
   priority.  Weights are not used in these sample records.

     _kerberos._udp.EXAMPLE.COM.     IN   SRV   0 0 88 kdc1.example.com.
     _kerberos._udp.EXAMPLE.COM.     IN   SRV   1 0 88 kdc2.example.com.
     _kerberos._tcp.EXAMPLE.COM.     IN   SRV   0 0 88 kdc1.example.com.
     _kerberos._tcp.EXAMPLE.COM.     IN   SRV   1 0 88 kdc2.example.com.

7.3.  Name of the TGS

   The principal identifier of the ticket-granting service shall be
   composed of three parts: the realm of the KDC issuing the TGS ticket,
   and a two-part name of type NT-SRV-INST, with the first part ""krbtgt""
   and the second part the name of the realm that will accept the TGT.
   For example, a TGT issued by the ATHENA.MIT.EDU realm to be used to



Neuman, et al.              Standards Track                   [Page 105]

RFC 4120                      Kerberos V5                      July 2005


   get tickets from the ATHENA.MIT.EDU KDC has a principal identifier of
   ""ATHENA.MIT.EDU"" (realm), (""krbtgt"", ""ATHENA.MIT.EDU"") (name).  A TGT
   issued by the ATHENA.MIT.EDU realm to be used to get tickets from the
   MIT.EDU realm has a principal identifier of ""ATHENA.MIT.EDU"" (realm),
   (""krbtgt"", ""MIT.EDU"") (name).

7.4.  OID Arc for KerberosV5

   This OID MAY be used to identify Kerberos protocol messages
   encapsulated in other protocols.  It also designates the OID arc for
   KerberosV5-related OIDs assigned by future IETF action.
   Implementation note: RFC 1510 had an incorrect value (5) for ""dod"" in
   its OID.

   id-krb5         OBJECT IDENTIFIER ::= {
           iso(1) identified-organization(3) dod(6) internet(1)
           security(5) kerberosV5(2)
   }

   Assignment of OIDs beneath the id-krb5 arc must be obtained by
   contacting the registrar for the id-krb5 arc, or its designee.  At
   the time of the issuance of this RFC, such registrations can be
   obtained by contacting krb5-oid-registrar@mit.edu.

7.5.  Protocol Constants and Associated Values

   The following tables list constants used in the protocol and define
   their meanings.  In the ""specification"" section, ranges are specified
   that limit the values of constants for which values are defined here.
   This allows implementations to make assumptions about the maximum
   values that will be received for these constants.  Implementations
   receiving values outside the range specified in the ""specification""
   section MAY reject the request, but they MUST recover cleanly.

7.5.1.  Key Usage Numbers

   The encryption and checksum specifications in [RFC3961] require as
   input a ""key usage number"", to alter the encryption key used in any
   specific message in order to make certain types of cryptographic
   attack more difficult.  These are the key usage values assigned in
   this document:

           1.  AS-REQ PA-ENC-TIMESTAMP padata timestamp, encrypted with
               the client key (Section 5.2.7.2)







Neuman, et al.              Standards Track                   [Page 106]

RFC 4120                      Kerberos V5                      July 2005


           2.  AS-REP Ticket and TGS-REP Ticket (includes TGS session
               key or application session key), encrypted with the
               service key (Section 5.3)
           3.  AS-REP encrypted part (includes TGS session key or
               application session key), encrypted with the client key
               (Section 5.4.2)
           4.  TGS-REQ KDC-REQ-BODY AuthorizationData, encrypted with
               the TGS session key (Section 5.4.1)
           5.  TGS-REQ KDC-REQ-BODY AuthorizationData, encrypted with
               the TGS authenticator subkey (Section 5.4.1)
           6.  TGS-REQ PA-TGS-REQ padata AP-REQ Authenticator cksum,
               keyed with the TGS session key (Section 5.5.1)
           7.  TGS-REQ PA-TGS-REQ padata AP-REQ Authenticator (includes
               TGS authenticator subkey), encrypted with the TGS session
               key (Section 5.5.1)
           8.  TGS-REP encrypted part (includes application session
               key), encrypted with the TGS session key (Section 5.4.2)
           9.  TGS-REP encrypted part (includes application session
               key), encrypted with the TGS authenticator subkey
               (Section 5.4.2)
          10.  AP-REQ Authenticator cksum, keyed with the application
               session key (Section 5.5.1)
          11.  AP-REQ Authenticator (includes application authenticator
               subkey), encrypted with the application session key
               (Section 5.5.1)
          12.  AP-REP encrypted part (includes application session
               subkey), encrypted with the application session key
               (Section 5.5.2)
          13.  KRB-PRIV encrypted part, encrypted with a key chosen by
               the application (Section 5.7.1)
          14.  KRB-CRED encrypted part, encrypted with a key chosen by
               the application (Section 5.8.1)
          15.  KRB-SAFE cksum, keyed with a key chosen by the
               application (Section 5.6.1)
       16-18.  Reserved for future use in Kerberos and related
               protocols.
          19.  AD-KDC-ISSUED checksum (ad-checksum in 5.2.6.4)
       20-21.  Reserved for future use in Kerberos and related
               protocols.
       22-25.  Reserved for use in the Kerberos Version 5 GSS-API
               mechanisms [RFC4121].
      26-511.  Reserved for future use in Kerberos and related
               protocols.
    512-1023.  Reserved for uses internal to a Kerberos implementation.
        1024.  Encryption for application use in protocols that do not
               specify key usage values





Neuman, et al.              Standards Track                   [Page 107]

RFC 4120                      Kerberos V5                      July 2005


        1025.  Checksums for application use in protocols that do not
               specify key usage values
   1026-2047.  Reserved for application use.

7.5.2.  PreAuthentication Data Types

   Padata and Data Type    Padata-type   Comment
                            Value

   PA-TGS-REQ                  1
   PA-ENC-TIMESTAMP            2
   PA-PW-SALT                  3
   [reserved]                  4
   PA-ENC-UNIX-TIME            5        (deprecated)
   PA-SANDIA-SECUREID          6
   PA-SESAME                   7
   PA-OSF-DCE                  8
   PA-CYBERSAFE-SECUREID       9
   PA-AFS3-SALT                10
   PA-ETYPE-INFO               11
   PA-SAM-CHALLENGE            12       (sam/otp)
   PA-SAM-RESPONSE             13       (sam/otp)
   PA-PK-AS-REQ_OLD            14       (pkinit)
   PA-PK-AS-REP_OLD            15       (pkinit)
   PA-PK-AS-REQ                16       (pkinit)
   PA-PK-AS-REP                17       (pkinit)
   PA-ETYPE-INFO2              19       (replaces pa-etype-info)
   PA-USE-SPECIFIED-KVNO       20
   PA-SAM-REDIRECT             21       (sam/otp)
   PA-GET-FROM-TYPED-DATA      22       (embedded in typed data)
   TD-PADATA                   22       (embeds padata)
   PA-SAM-ETYPE-INFO           23       (sam/otp)
   PA-ALT-PRINC                24       (crawdad@fnal.gov)
   PA-SAM-CHALLENGE2           30       (kenh@pobox.com)
   PA-SAM-RESPONSE2            31       (kenh@pobox.com)
   PA-EXTRA-TGT                41       Reserved extra TGT
   TD-PKINIT-CMS-CERTIFICATES  101      CertificateSet from CMS
   TD-KRB-PRINCIPAL            102      PrincipalName
   TD-KRB-REALM                103      Realm
   TD-TRUSTED-CERTIFIERS       104      from PKINIT
   TD-CERTIFICATE-INDEX        105      from PKINIT
   TD-APP-DEFINED-ERROR        106      application specific
   TD-REQ-NONCE                107      INTEGER
   TD-REQ-SEQ                  108      INTEGER
   PA-PAC-REQUEST              128      (jbrezak@exchange.microsoft.com)






Neuman, et al.              Standards Track                   [Page 108]

RFC 4120                      Kerberos V5                      July 2005


7.5.3.  Address Types

   Address Type                   Value

   IPv4                             2
   Directional                      3
   ChaosNet                         5
   XNS                              6
   ISO                              7
   DECNET Phase IV                 12
   AppleTalk DDP                   16
   NetBios                         20
   IPv6                            24

7.5.4.  Authorization Data Types

   Authorization Data Type          Ad-type Value

   AD-IF-RELEVANT                     1
   AD-INTENDED-FOR-SERVER             2
   AD-INTENDED-FOR-APPLICATION-CLASS  3
   AD-KDC-ISSUED                      4
   AD-AND-OR                          5
   AD-MANDATORY-TICKET-EXTENSIONS     6
   AD-IN-TICKET-EXTENSIONS            7
   AD-MANDATORY-FOR-KDC               8
   Reserved values                 9-63
   OSF-DCE                           64
   SESAME                            65
   AD-OSF-DCE-PKI-CERTID             66 (hemsath@us.ibm.com)
   AD-WIN2K-PAC                     128 (jbrezak@exchange.microsoft.com)
   AD-ETYPE-NEGOTIATION             129  (lzhu@windows.microsoft.com)

7.5.5.  Transited Encoding Types

   Transited Encoding Type         Tr-type Value

   DOMAIN-X500-COMPRESS            1
   Reserved values                 All others

7.5.6.  Protocol Version Number

   Label               Value   Meaning or MIT Code

   pvno                  5     Current Kerberos protocol version number






Neuman, et al.              Standards Track                   [Page 109]

RFC 4120                      Kerberos V5                      July 2005


7.5.7.  Kerberos Message Types

   Message Type   Value  Meaning

   KRB_AS_REQ      10    Request for initial authentication
   KRB_AS_REP      11    Response to KRB_AS_REQ request
   KRB_TGS_REQ     12    Request for authentication based on TGT
   KRB_TGS_REP     13    Response to KRB_TGS_REQ request
   KRB_AP_REQ      14    Application request to server
   KRB_AP_REP      15    Response to KRB_AP_REQ_MUTUAL
   KRB_RESERVED16  16    Reserved for user-to-user krb_tgt_request
   KRB_RESERVED17  17    Reserved for user-to-user krb_tgt_reply
   KRB_SAFE        20    Safe (checksummed) application message
   KRB_PRIV        21    Private (encrypted) application message
   KRB_CRED        22    Private (encrypted) message to forward
                           credentials
   KRB_ERROR       30    Error response

7.5.8.  Name Types

   Name Type           Value  Meaning

   KRB_NT_UNKNOWN        0    Name type not known
   KRB_NT_PRINCIPAL      1    Just the name of the principal as in DCE,
                                or for users
   KRB_NT_SRV_INST       2    Service and other unique instance (krbtgt)
   KRB_NT_SRV_HST        3    Service with host name as instance
                                (telnet, rcommands)
   KRB_NT_SRV_XHST       4    Service with host as remaining components
   KRB_NT_UID            5    Unique ID
   KRB_NT_X500_PRINCIPAL 6    Encoded X.509 Distinguished name [RFC2253]
   KRB_NT_SMTP_NAME      7    Name in form of SMTP email name
                                (e.g., user@example.com)
   KRB_NT_ENTERPRISE    10    Enterprise name; may be mapped to
                                principal name

7.5.9.  Error Codes

   Error Code                         Value  Meaning

   KDC_ERR_NONE                           0  No error
   KDC_ERR_NAME_EXP                       1  Client's entry in database
                                               has expired
   KDC_ERR_SERVICE_EXP                    2  Server's entry in database
                                               has expired
   KDC_ERR_BAD_PVNO                       3  Requested protocol version
                                               number not supported




Neuman, et al.              Standards Track                   [Page 110]

RFC 4120                      Kerberos V5                      July 2005


   KDC_ERR_C_OLD_MAST_KVNO                4  Client's key encrypted in
                                               old master key
   KDC_ERR_S_OLD_MAST_KVNO                5  Server's key encrypted in
                                               old master key
   KDC_ERR_C_PRINCIPAL_UNKNOWN            6  Client not found in
                                               Kerberos database
   KDC_ERR_S_PRINCIPAL_UNKNOWN            7  Server not found in
                                               Kerberos database
   KDC_ERR_PRINCIPAL_NOT_UNIQUE           8  Multiple principal entries
                                               in database
   KDC_ERR_NULL_KEY                       9  The client or server has a
                                               null key
   KDC_ERR_CANNOT_POSTDATE               10  Ticket not eligible for
                                               postdating
   KDC_ERR_NEVER_VALID                   11  Requested starttime is
                                               later than end time
   KDC_ERR_POLICY                        12  KDC policy rejects request
   KDC_ERR_BADOPTION                     13  KDC cannot accommodate
                                               requested option
   KDC_ERR_ETYPE_NOSUPP                  14  KDC has no support for
                                               encryption type
   KDC_ERR_SUMTYPE_NOSUPP                15  KDC has no support for
                                               checksum type
   KDC_ERR_PADATA_TYPE_NOSUPP            16  KDC has no support for
                                               padata type
   KDC_ERR_TRTYPE_NOSUPP                 17  KDC has no support for
                                               transited type
   KDC_ERR_CLIENT_REVOKED                18  Clients credentials have
                                               been revoked
   KDC_ERR_SERVICE_REVOKED               19  Credentials for server have
                                               been revoked
   KDC_ERR_TGT_REVOKED                   20  TGT has been revoked
   KDC_ERR_CLIENT_NOTYET                 21  Client not yet valid; try
                                               again later
   KDC_ERR_SERVICE_NOTYET                22  Server not yet valid; try
                                               again later
   KDC_ERR_KEY_EXPIRED                   23  Password has expired;
                                               change password to reset
   KDC_ERR_PREAUTH_FAILED                24  Pre-authentication
                                               information was invalid
   KDC_ERR_PREAUTH_REQUIRED              25  Additional pre-
                                               authentication required
   KDC_ERR_SERVER_NOMATCH                26  Requested server and ticket
                                               don't match
   KDC_ERR_MUST_USE_USER2USER            27  Server principal valid for
                                               user2user only
   KDC_ERR_PATH_NOT_ACCEPTED             28  KDC Policy rejects
                                               transited path



Neuman, et al.              Standards Track                   [Page 111]

RFC 4120                      Kerberos V5                      July 2005


   KDC_ERR_SVC_UNAVAILABLE               29  A service is not available
   KRB_AP_ERR_BAD_INTEGRITY              31  Integrity check on
                                               decrypted field failed
   KRB_AP_ERR_TKT_EXPIRED                32  Ticket expired
   KRB_AP_ERR_TKT_NYV                    33  Ticket not yet valid
   KRB_AP_ERR_REPEAT                     34  Request is a replay
   KRB_AP_ERR_NOT_US                     35  The ticket isn't for us
   KRB_AP_ERR_BADMATCH                   36  Ticket and authenticator
                                               don't match
   KRB_AP_ERR_SKEW                       37  Clock skew too great
   KRB_AP_ERR_BADADDR                    38  Incorrect net address
   KRB_AP_ERR_BADVERSION                 39  Protocol version mismatch
   KRB_AP_ERR_MSG_TYPE                   40  Invalid msg type
   KRB_AP_ERR_MODIFIED                   41  Message stream modified
   KRB_AP_ERR_BADORDER                   42  Message out of order
   KRB_AP_ERR_BADKEYVER                  44  Specified version of key is
                                               not available
   KRB_AP_ERR_NOKEY                      45  Service key not available
   KRB_AP_ERR_MUT_FAIL                   46  Mutual authentication
                                               failed
   KRB_AP_ERR_BADDIRECTION               47  Incorrect message direction
   KRB_AP_ERR_METHOD                     48  Alternative authentication
                                               method required
   KRB_AP_ERR_BADSEQ                     49  Incorrect sequence number
                                               in message
   KRB_AP_ERR_INAPP_CKSUM                50  Inappropriate type of
                                               checksum in message
   KRB_AP_PATH_NOT_ACCEPTED              51  Policy rejects transited
                                               path
   KRB_ERR_RESPONSE_TOO_BIG              52  Response too big for UDP;
                                               retry with TCP
   KRB_ERR_GENERIC                       60  Generic error (description
                                               in e-text)
   KRB_ERR_FIELD_TOOLONG                 61  Field is too long for this
                                               implementation
   KDC_ERROR_CLIENT_NOT_TRUSTED          62  Reserved for PKINIT
   KDC_ERROR_KDC_NOT_TRUSTED             63  Reserved for PKINIT
   KDC_ERROR_INVALID_SIG                 64  Reserved for PKINIT
   KDC_ERR_KEY_TOO_WEAK                  65  Reserved for PKINIT
   KDC_ERR_CERTIFICATE_MISMATCH          66  Reserved for PKINIT
   KRB_AP_ERR_NO_TGT                     67  No TGT available to
                                               validate USER-TO-USER
   KDC_ERR_WRONG_REALM                   68  Reserved for future use
   KRB_AP_ERR_USER_TO_USER_REQUIRED      69  Ticket must be for
                                               USER-TO-USER
   KDC_ERR_CANT_VERIFY_CERTIFICATE       70  Reserved for PKINIT
   KDC_ERR_INVALID_CERTIFICATE           71  Reserved for PKINIT
   KDC_ERR_REVOKED_CERTIFICATE           72  Reserved for PKINIT



Neuman, et al.              Standards Track                   [Page 112]

RFC 4120                      Kerberos V5                      July 2005


   KDC_ERR_REVOCATION_STATUS_UNKNOWN     73  Reserved for PKINIT
   KDC_ERR_REVOCATION_STATUS_UNAVAILABLE 74  Reserved for PKINIT
   KDC_ERR_CLIENT_NAME_MISMATCH          75  Reserved for PKINIT
   KDC_ERR_KDC_NAME_MISMATCH             76  Reserved for PKINIT

8.  Interoperability Requirements

   Version 5 of the Kerberos protocol supports a myriad of options.
   Among these are multiple encryption and checksum types; alternative
   encoding schemes for the transited field; optional mechanisms for
   pre-authentication; the handling of tickets with no addresses;
   options for mutual authentication; user-to-user authentication;
   support for proxies; the format of realm names; the handling of
   authorization data; and forwarding, postdating, and renewing tickets.

   In order to ensure the interoperability of realms, it is necessary to
   define a minimal configuration that must be supported by all
   implementations.  This minimal configuration is subject to change as
   technology does.  For example, if at some later date it is discovered
   that one of the required encryption or checksum algorithms is not
   secure, it will be replaced.

8.1.  Specification 2

   This section defines the second specification of these options.
   Implementations which are configured in this way can be said to
   support Kerberos Version 5 Specification 2 (5.2).  Specification 1
   (deprecated) may be found in RFC 1510.

   Transport

      TCP/IP and UDP/IP transport MUST be supported by clients and KDCs
      claiming conformance to specification 2.

   Encryption and Checksum Methods

      The following encryption and checksum mechanisms MUST be
      supported:

      Encryption: AES256-CTS-HMAC-SHA1-96 [RFC3962]
      Checksums: HMAC-SHA1-96-AES256 [RFC3962]

      Implementations SHOULD support other mechanisms as well, but the
      additional mechanisms may only be used when communicating with
      principals known to also support them.  The following mechanisms
      from [RFC3961] and [RFC3962] SHOULD be supported:





Neuman, et al.              Standards Track                   [Page 113]

RFC 4120                      Kerberos V5                      July 2005


      Encryption: AES128-CTS-HMAC-SHA1-96, DES-CBC-MD5, DES3-CBC-SHA1-KD
      Checksums: DES-MD5, HMAC-SHA1-DES3-KD, HMAC-SHA1-96-AES128

      Implementations MAY support other mechanisms as well, but the
      additional mechanisms may only be used when communicating with
      principals known to support them also.

      Implementation note: Earlier implementations of Kerberos generate
      messages using the CRC-32 and RSA-MD5 checksum methods.  For
      interoperability with these earlier releases, implementors MAY
      consider supporting these checksum methods but should carefully
      analyze the security implications to limit the situations within
      which these methods are accepted.

   Realm Names

      All implementations MUST understand hierarchical realms in both
      the Internet Domain and the X.500 style.  When a TGT for an
      unknown realm is requested, the KDC MUST be able to determine the
      names of the intermediate realms between the KDCs realm and the
      requested realm.

   Transited Field Encoding

      DOMAIN-X500-COMPRESS (described in Section 3.3.3.2) MUST be
      supported.  Alternative encodings MAY be supported, but they may
      only be used when that encoding is supported by ALL intermediate
      realms.

   Pre-authentication Methods

      The TGS-REQ method MUST be supported.  It is not used on the
      initial request.  The PA-ENC-TIMESTAMP method MUST be supported by
      clients, but whether it is enabled by default MAY be determined on
      a realm-by-realm basis.  If the method is not used in the initial
      request and the error KDC_ERR_PREAUTH_REQUIRED is returned
      specifying PA-ENC-TIMESTAMP as an acceptable method, the client
      SHOULD retry the initial request using the PA-ENC-TIMESTAMP pre-
      authentication method.  Servers need not support the PA-ENC-
      TIMESTAMP method, but if it is not supported the server SHOULD
      ignore the presence of PA-ENC-TIMESTAMP pre-authentication in a
      request.

      The ETYPE-INFO2 method MUST be supported; this method is used to
      communicate the set of supported encryption types, and
      corresponding salt and string to key parameters.  The ETYPE-INFO
      method SHOULD be supported for interoperability with older
      implementation.



Neuman, et al.              Standards Track                   [Page 114]

RFC 4120                      Kerberos V5                      July 2005


   Mutual Authentication

      Mutual authentication (via the KRB_AP_REP message) MUST be
      supported.

   Ticket Addresses and Flags

      All KDCs MUST pass through tickets that carry no addresses (i.e.,
      if a TGT contains no addresses, the KDC will return derivative
      tickets).  Implementations SHOULD default to requesting
      addressless tickets, as this significantly increases
      interoperability with network address translation.  In some cases,
      realms or application servers MAY require that tickets have an
      address.

      Implementations SHOULD accept directional address type for the
      KRB_SAFE and KRB_PRIV message and SHOULD include directional
      addresses in these messages when other address types are not
      available.

      Proxies and forwarded tickets MUST be supported.  Individual
      realms and application servers can set their own policy on when
      such tickets will be accepted.

      All implementations MUST recognize renewable and postdated
      tickets, but they need not actually implement them.  If these
      options are not supported, the starttime and endtime in the ticket
      SHALL specify a ticket's entire useful life.  When a postdated
      ticket is decoded by a server, all implementations SHALL make the
      presence of the postdated flag visible to the calling server.

   User-to-User Authentication

      Support for user-to-user authentication (via the ENC-TKT-IN-SKEY
      KDC option) MUST be provided by implementations, but individual
      realms MAY decide as a matter of policy to reject such requests on
      a per-principal or realm-wide basis.

   Authorization Data

      Implementations MUST pass all authorization data subfields from
      TGTs to any derivative tickets unless they are directed to
      suppress a subfield as part of the definition of that registered
      subfield type.  (It is never incorrect to pass on a subfield, and
      no registered subfield types presently specify suppression at the
      KDC.)





Neuman, et al.              Standards Track                   [Page 115]

RFC 4120                      Kerberos V5                      July 2005


      Implementations MUST make the contents of any authorization data
      subfields available to the server when a ticket is used.
      Implementations are not required to allow clients to specify the
      contents of the authorization data fields.

   Constant Ranges

      All protocol constants are constrained to 32-bit (signed) values
      unless further constrained by the protocol definition.  This limit
      is provided to allow implementations to make assumptions about the
      maximum values that will be received for these constants.
      Implementations receiving values outside this range MAY reject the
      request, but they MUST recover cleanly.

8.2.  Recommended KDC Values

   Following is a list of recommended values for a KDC configuration.

      Minimum lifetime              5 minutes
      Maximum renewable lifetime    1 week
      Maximum ticket lifetime       1 day
      Acceptable clock skew         5 minutes
      Empty addresses               Allowed
      Proxiable, etc.               Allowed

9.  IANA Considerations

   Section 7 of this document specifies protocol constants and other
   defined values required for the interoperability of multiple
   implementations.  Until a subsequent RFC specifies otherwise, or the
   Kerberos working group is shut down, allocations of additional
   protocol constants and other defined values required for extensions
   to the Kerberos protocol will be administered by the Kerberos working
   group.  Following the recommendations outlined in [RFC2434], guidance
   is provided to the IANA as follows:

   ""reserved"" realm name types in Section 6.1 and ""other"" realm types
   except those beginning with ""X-"" or ""x-"" will not be registered
   without IETF standards action, at which point guidelines for further
   assignment will be specified.  Realm name types beginning with ""X-""
   or ""x-"" are for private use.

   For host address types described in Section 7.1, negative values are
   for private use.  Assignment of additional positive numbers is
   subject to review by the Kerberos working group or other expert
   review.





Neuman, et al.              Standards Track                   [Page 116]

RFC 4120                      Kerberos V5                      July 2005


   Additional key usage numbers, as defined in Section 7.5.1, will be
   assigned subject to review by the Kerberos working group or other
   expert review.

   Additional preauthentication data type values, as defined in section
   7.5.2, will be assigned subject to review by the Kerberos working
   group or other expert review.

   Additional authorization data types as defined in Section 7.5.4, will
   be assigned subject to review by the Kerberos working group or other
   expert review.  Although it is anticipated that there may be
   significant demand for private use types, provision is intentionally
   not made for a private use portion of the namespace because conflicts
   between privately assigned values could have detrimental security
   implications.

   Additional transited encoding types, as defined in Section 7.5.5,
   present special concerns for interoperability with existing
   implementations.  As such, such assignments will only be made by
   standards action, except that the Kerberos working group or another
   other working group with competent jurisdiction may make preliminary
   assignments for documents that are moving through the standards
   process.

   Additional Kerberos message types, as described in Section 7.5.7,
   will be assigned subject to review by the Kerberos working group or
   other expert review.

   Additional name types, as described in Section 7.5.8, will be
   assigned subject to review by the Kerberos working group or other
   expert review.

   Additional error codes described in Section 7.5.9 will be assigned
   subject to review by the Kerberos working group or other expert
   review.

10.  Security Considerations

   As an authentication service, Kerberos provides a means of verifying
   the identity of principals on a network.  By itself, Kerberos does
   not provide authorization.  Applications should not accept the
   issuance of a service ticket by the Kerberos server as granting
   authority to use the service, since such applications may become
   vulnerable to the bypass of this authorization check in an
   environment where they inter-operate with other KDCs or where other
   options for application authentication are provided.





Neuman, et al.              Standards Track                   [Page 117]

RFC 4120                      Kerberos V5                      July 2005


   Denial of service attacks are not solved with Kerberos.  There are
   places in the protocols where an intruder can prevent an application
   from participating in the proper authentication steps.  Because
   authentication is a required step for the use of many services,
   successful denial of service attacks on a Kerberos server might
   result in the denial of other network services that rely on Kerberos
   for authentication.  Kerberos is vulnerable to many kinds of denial
   of service attacks: those on the network, which would prevent clients
   from contacting the KDC; those on the domain name system, which could
   prevent a client from finding the IP address of the Kerberos server;
   and those by overloading the Kerberos KDC itself with repeated
   requests.

   Interoperability conflicts caused by incompatible character-set usage
   (see 5.2.1) can result in denial of service for clients that utilize
   character-sets in Kerberos strings other than those stored in the KDC
   database.

   Authentication servers maintain a database of principals (i.e., users
   and servers) and their secret keys.  The security of the
   authentication server machines is critical.  The breach of security
   of an authentication server will compromise the security of all
   servers that rely upon the compromised KDC, and will compromise the
   authentication of any principals registered in the realm of the
   compromised KDC.

   Principals must keep their secret keys secret.  If an intruder
   somehow steals a principal's key, it will be able to masquerade as
   that principal or impersonate any server to the legitimate principal.

   Password-guessing attacks are not solved by Kerberos.  If a user
   chooses a poor password, it is possible for an attacker to
   successfully mount an off-line dictionary attack by repeatedly
   attempting to decrypt, with successive entries from a dictionary,
   messages obtained that are encrypted under a key derived from the
   user's password.

   Unless pre-authentication options are required by the policy of a
   realm, the KDC will not know whether a request for authentication
   succeeds.  An attacker can request a reply with credentials for any
   principal.  These credentials will likely not be of much use to the
   attacker unless it knows the client's secret key, but the
   availability of the response encrypted in the client's secret key
   provides the attacker with ciphertext that may be used to mount brute
   force or dictionary attacks to decrypt the credentials, by guessing
   the user's password.  For this reason it is strongly encouraged that
   Kerberos realms require the use of pre-authentication.  Even with




Neuman, et al.              Standards Track                   [Page 118]

RFC 4120                      Kerberos V5                      July 2005


   pre-authentication, attackers may try brute force or dictionary
   attacks against credentials that are observed by eavesdropping on the
   network.

   Because a client can request a ticket for any server principal and
   can attempt a brute force or dictionary attack against the server
   principal's key using that ticket, it is strongly encouraged that
   keys be randomly generated (rather than generated from passwords) for
   any principals that are usable as the target principal for a
   KRB_TGS_REQ or KRB_AS_REQ messages.  [RFC4086]

   Although the DES-CBC-MD5 encryption method and DES-MD5 checksum
   methods are listed as SHOULD be implemented for backward
   compatibility, the single DES encryption algorithm on which these are
   based is weak, and stronger algorithms should be used whenever
   possible.

   Each host on the network must have a clock that is loosely
   synchronized to the time of the other hosts; this synchronization is
   used to reduce the bookkeeping needs of application servers when they
   do replay detection.  The degree of ""looseness"" can be configured on
   a per-server basis, but it is typically on the order of 5 minutes.
   If the clocks are synchronized over the network, the clock
   synchronization protocol MUST itself be secured from network
   attackers.

   Principal identifiers must not recycled on a short-term basis.  A
   typical mode of access control will use access control lists (ACLs)
   to grant permissions to particular principals.  If a stale ACL entry
   remains for a deleted principal and the principal identifier is
   reused, the new principal will inherit rights specified in the stale
   ACL entry.  By not reusing principal identifiers, the danger of
   inadvertent access is removed.

   Proper decryption of an KRB_AS_REP message from the KDC is not
   sufficient for the host to verify the identity of the user; the user
   and an attacker could cooperate to generate a KRB_AS_REP format
   message that decrypts properly but is not from the proper KDC.  To
   authenticate a user logging on to a local system, the credentials
   obtained in the AS exchange may first be used in a TGS exchange to
   obtain credentials for a local server.  Those credentials must then
   be verified by a local server through successful completion of the
   Client/Server exchange.

   Many RFC 1510-compliant implementations ignore unknown authorization
   data elements.  Depending on these implementations to honor
   authorization data restrictions may create a security weakness.




Neuman, et al.              Standards Track                   [Page 119]

RFC 4120                      Kerberos V5                      July 2005


   Kerberos credentials contain clear-text information identifying the
   principals to which they apply.  If privacy of this information is
   needed, this exchange should itself be encapsulated in a protocol
   providing for confidentiality on the exchange of these credentials.

   Applications must take care to protect communications subsequent to
   authentication, either by using the KRB_PRIV or KRB_SAFE messages as
   appropriate, or by applying their own confidentiality or integrity
   mechanisms on such communications.  Completion of the KRB_AP_REQ and
   KRB_AP_REP exchange without subsequent use of confidentiality and
   integrity mechanisms provides only for authentication of the parties
   to the communication and not confidentiality and integrity of the
   subsequent communication.  Applications applying confidentiality and
   integrity protection mechanisms other than KRB_PRIV and KRB_SAFE must
   make sure that the authentication step is appropriately linked with
   the protected communication channel that is established by the
   application.

   Unless the application server provides its own suitable means to
   protect against replay (for example, a challenge-response sequence
   initiated by the server after authentication, or use of a server-
   generated encryption subkey), the server must utilize a replay cache
   to remember any authenticator presented within the allowable clock
   skew.  All services sharing a key need to use the same replay cache.
   If separate replay caches are used, then an authenticator used with
   one such service could later be replayed to a different service with
   the same service principal.

   If a server loses track of authenticators presented within the
   allowable clock skew, it must reject all requests until the clock
   skew interval has passed, providing assurance that any lost or
   replayed authenticators will fall outside the allowable clock skew
   and can no longer be successfully replayed.

   Implementations of Kerberos should not use untrusted directory
   servers to determine the realm of a host.  To allow this would allow
   the compromise of the directory server to enable an attacker to
   direct the client to accept authentication with the wrong principal
   (i.e., one with a similar name, but in a realm with which the
   legitimate host was not registered).

   Implementations of Kerberos must not use DNS to map one name to
   another (canonicalize) in order to determine the host part of the
   principal name with which one is to communicate.  To allow this
   canonicalization would allow a compromise of the DNS to result in a
   client obtaining credentials and correctly authenticating to the





Neuman, et al.              Standards Track                   [Page 120]

RFC 4120                      Kerberos V5                      July 2005


   wrong principal.  Though the client will know who it is communicating
   with, it will not be the principal with which it intended to
   communicate.

   If the Kerberos server returns a TGT for a realm 'closer' than the
   desired realm, the client may use local policy configuration to
   verify that the authentication path used is an acceptable one.
   Alternatively, a client may choose its own authentication path rather
   than rely on the Kerberos server to select one.  In either case, any
   policy or configuration information used to choose or validate
   authentication paths, whether by the Kerberos server or client, must
   be obtained from a trusted source.

   The Kerberos protocol in its basic form does not provide perfect
   forward secrecy for communications.  If traffic has been recorded by
   an eavesdropper, then messages encrypted using the KRB_PRIV message,
   or messages encrypted using application-specific encryption under
   keys exchanged using Kerberos can be decrypted if the user's,
   application server's, or KDC's key is subsequently discovered.  This
   is because the session key used to encrypt such messages, when
   transmitted over the network, is encrypted in the key of the
   application server.  It is also encrypted under the session key from
   the user's TGT when it is returned to the user in the KRB_TGS_REP
   message.  The session key from the TGT is sent to the user in the
   KRB_AS_REP message encrypted in the user's secret key and embedded in
   the TGT, which was encrypted in the key of the KDC.  Applications
   requiring perfect forward secrecy must exchange keys through
   mechanisms that provide such assurance, but may use Kerberos for
   authentication of the encrypted channel established through such
   other means.

11.  Acknowledgements

   This document is a revision to RFC 1510 which was co-authored with
   John Kohl.  The specification of the Kerberos protocol described in
   this document is the result of many years of effort.  Over this
   period, many individuals have contributed to the definition of the
   protocol and to the writing of the specification.  Unfortunately, it
   is not possible to list all contributors as authors of this document,
   though there are many not listed who are authors in spirit, including
   those who contributed text for parts of some sections, who
   contributed to the design of parts of the protocol, and who
   contributed significantly to the discussion of the protocol in the
   IETF common authentication technology (CAT) and Kerberos working
   groups.






Neuman, et al.              Standards Track                   [Page 121]

RFC 4120                      Kerberos V5                      July 2005


   Among those contributing to the development and specification of
   Kerberos were Jeffrey Altman, John Brezak, Marc Colan, Johan
   Danielsson, Don Davis, Doug Engert, Dan Geer, Paul Hill, John Kohl,
   Marc Horowitz, Matt Hur, Jeffrey Hutzelman, Paul Leach, John Linn,
   Ari Medvinsky, Sasha Medvinsky, Steve Miller, Jon Rochlis, Jerome
   Saltzer, Jeffrey Schiller, Jennifer Steiner, Ralph Swick, Mike Swift,
   Jonathan Trostle, Theodore Ts'o, Brian Tung, Jacques Vidrine, Assar
   Westerlund, and Nicolas Williams.  Many other members of MIT Project
   Athena, the MIT networking group, and the Kerberos and CAT working
   groups of the IETF contributed but are not listed.









































Neuman, et al.              Standards Track                   [Page 122]

RFC 4120                      Kerberos V5                      July 2005


A.  ASN.1 module

KerberosV5Spec2 {
        iso(1) identified-organization(3) dod(6) internet(1)
        security(5) kerberosV5(2) modules(4) krb5spec2(2)
} DEFINITIONS EXPLICIT TAGS ::= BEGIN

-- OID arc for KerberosV5
--
-- This OID may be used to identify Kerberos protocol messages
-- encapsulated in other protocols.
--
-- This OID also designates the OID arc for KerberosV5-related OIDs.
--
-- NOTE: RFC 1510 had an incorrect value (5) for ""dod"" in its OID.
id-krb5         OBJECT IDENTIFIER ::= {
        iso(1) identified-organization(3) dod(6) internet(1)
        security(5) kerberosV5(2)
}

Int32           ::= INTEGER (-2147483648..2147483647)
                    -- signed values representable in 32 bits

UInt32          ::= INTEGER (0..4294967295)
                    -- unsigned 32 bit values

Microseconds    ::= INTEGER (0..999999)
                    -- microseconds

KerberosString  ::= GeneralString (IA5String)

Realm           ::= KerberosString

PrincipalName   ::= SEQUENCE {
        name-type       [0] Int32,
        name-string     [1] SEQUENCE OF KerberosString
}

KerberosTime    ::= GeneralizedTime -- with no fractional seconds

HostAddress     ::= SEQUENCE  {
        addr-type       [0] Int32,
        address         [1] OCTET STRING
}

-- NOTE: HostAddresses is always used as an OPTIONAL field and
-- should not be empty.
HostAddresses   -- NOTE: subtly different from rfc1510,



Neuman, et al.              Standards Track                   [Page 123]

RFC 4120                      Kerberos V5                      July 2005


                -- but has a value mapping and encodes the same
        ::= SEQUENCE OF HostAddress

-- NOTE: AuthorizationData is always used as an OPTIONAL field and
-- should not be empty.
AuthorizationData       ::= SEQUENCE OF SEQUENCE {
        ad-type         [0] Int32,
        ad-data         [1] OCTET STRING
}

PA-DATA         ::= SEQUENCE {
        -- NOTE: first tag is [1], not [0]
        padata-type     [1] Int32,
        padata-value    [2] OCTET STRING -- might be encoded AP-REQ
}

KerberosFlags   ::= BIT STRING (SIZE (32..MAX))
                    -- minimum number of bits shall be sent,
                    -- but no fewer than 32

EncryptedData   ::= SEQUENCE {
        etype   [0] Int32 -- EncryptionType --,
        kvno    [1] UInt32 OPTIONAL,
        cipher  [2] OCTET STRING -- ciphertext
}

EncryptionKey   ::= SEQUENCE {
        keytype         [0] Int32 -- actually encryption type --,
        keyvalue        [1] OCTET STRING
}

Checksum        ::= SEQUENCE {
        cksumtype       [0] Int32,
        checksum        [1] OCTET STRING
}

Ticket          ::= [APPLICATION 1] SEQUENCE {
        tkt-vno         [0] INTEGER (5),
        realm           [1] Realm,
        sname           [2] PrincipalName,
        enc-part        [3] EncryptedData -- EncTicketPart
}

-- Encrypted part of ticket
EncTicketPart   ::= [APPLICATION 3] SEQUENCE {
        flags                   [0] TicketFlags,
        key                     [1] EncryptionKey,
        crealm                  [2] Realm,



Neuman, et al.              Standards Track                   [Page 124]

RFC 4120                      Kerberos V5                      July 2005


        cname                   [3] PrincipalName,
        transited               [4] TransitedEncoding,
        authtime                [5] KerberosTime,
        starttime               [6] KerberosTime OPTIONAL,
        endtime                 [7] KerberosTime,
        renew-till              [8] KerberosTime OPTIONAL,
        caddr                   [9] HostAddresses OPTIONAL,
        authorization-data      [10] AuthorizationData OPTIONAL
}

-- encoded Transited field
TransitedEncoding       ::= SEQUENCE {
        tr-type         [0] Int32 -- must be registered --,
        contents        [1] OCTET STRING
}

TicketFlags     ::= KerberosFlags
        -- reserved(0),
        -- forwardable(1),
        -- forwarded(2),
        -- proxiable(3),
        -- proxy(4),
        -- may-postdate(5),
        -- postdated(6),
        -- invalid(7),
        -- renewable(8),
        -- initial(9),
        -- pre-authent(10),
        -- hw-authent(11),
-- the following are new since 1510
        -- transited-policy-checked(12),
        -- ok-as-delegate(13)

AS-REQ          ::= [APPLICATION 10] KDC-REQ

TGS-REQ         ::= [APPLICATION 12] KDC-REQ

KDC-REQ         ::= SEQUENCE {
        -- NOTE: first tag is [1], not [0]
        pvno            [1] INTEGER (5) ,
        msg-type        [2] INTEGER (10 -- AS -- | 12 -- TGS --),
        padata          [3] SEQUENCE OF PA-DATA OPTIONAL
                            -- NOTE: not empty --,
        req-body        [4] KDC-REQ-BODY
}

KDC-REQ-BODY    ::= SEQUENCE {
        kdc-options             [0] KDCOptions,



Neuman, et al.              Standards Track                   [Page 125]

RFC 4120                      Kerberos V5                      July 2005


        cname                   [1] PrincipalName OPTIONAL
                                    -- Used only in AS-REQ --,
        realm                   [2] Realm
                                    -- Server's realm
                                    -- Also client's in AS-REQ --,
        sname                   [3] PrincipalName OPTIONAL,
        from                    [4] KerberosTime OPTIONAL,
        till                    [5] KerberosTime,
        rtime                   [6] KerberosTime OPTIONAL,
        nonce                   [7] UInt32,
        etype                   [8] SEQUENCE OF Int32 -- EncryptionType
                                    -- in preference order --,
        addresses               [9] HostAddresses OPTIONAL,
        enc-authorization-data  [10] EncryptedData OPTIONAL
                                    -- AuthorizationData --,
        additional-tickets      [11] SEQUENCE OF Ticket OPTIONAL
                                        -- NOTE: not empty
}

KDCOptions      ::= KerberosFlags
        -- reserved(0),
        -- forwardable(1),
        -- forwarded(2),
        -- proxiable(3),
        -- proxy(4),
        -- allow-postdate(5),
        -- postdated(6),
        -- unused7(7),
        -- renewable(8),
        -- unused9(9),
        -- unused10(10),
        -- opt-hardware-auth(11),
        -- unused12(12),
        -- unused13(13),
-- 15 is reserved for canonicalize
        -- unused15(15),
-- 26 was unused in 1510
        -- disable-transited-check(26),
--
        -- renewable-ok(27),
        -- enc-tkt-in-skey(28),
        -- renew(30),
        -- validate(31)

AS-REP          ::= [APPLICATION 11] KDC-REP

TGS-REP         ::= [APPLICATION 13] KDC-REP




Neuman, et al.              Standards Track                   [Page 126]

RFC 4120                      Kerberos V5                      July 2005


KDC-REP         ::= SEQUENCE {
        pvno            [0] INTEGER (5),
        msg-type        [1] INTEGER (11 -- AS -- | 13 -- TGS --),
        padata          [2] SEQUENCE OF PA-DATA OPTIONAL
                                -- NOTE: not empty --,
        crealm          [3] Realm,
        cname           [4] PrincipalName,
        ticket          [5] Ticket,
        enc-part        [6] EncryptedData
                                -- EncASRepPart or EncTGSRepPart,
                                -- as appropriate
}

EncASRepPart    ::= [APPLICATION 25] EncKDCRepPart

EncTGSRepPart   ::= [APPLICATION 26] EncKDCRepPart

EncKDCRepPart   ::= SEQUENCE {
        key             [0] EncryptionKey,
        last-req        [1] LastReq,
        nonce           [2] UInt32,
        key-expiration  [3] KerberosTime OPTIONAL,
        flags           [4] TicketFlags,
        authtime        [5] KerberosTime,
        starttime       [6] KerberosTime OPTIONAL,
        endtime         [7] KerberosTime,
        renew-till      [8] KerberosTime OPTIONAL,
        srealm          [9] Realm,
        sname           [10] PrincipalName,
        caddr           [11] HostAddresses OPTIONAL
}

LastReq         ::=     SEQUENCE OF SEQUENCE {
        lr-type         [0] Int32,
        lr-value        [1] KerberosTime
}

AP-REQ          ::= [APPLICATION 14] SEQUENCE {
        pvno            [0] INTEGER (5),
        msg-type        [1] INTEGER (14),
        ap-options      [2] APOptions,
        ticket          [3] Ticket,
        authenticator   [4] EncryptedData -- Authenticator
}

APOptions       ::= KerberosFlags
        -- reserved(0),
        -- use-session-key(1),



Neuman, et al.              Standards Track                   [Page 127]

RFC 4120                      Kerberos V5                      July 2005


        -- mutual-required(2)

-- Unencrypted authenticator
Authenticator   ::= [APPLICATION 2] SEQUENCE  {
        authenticator-vno       [0] INTEGER (5),
        crealm                  [1] Realm,
        cname                   [2] PrincipalName,
        cksum                   [3] Checksum OPTIONAL,
        cusec                   [4] Microseconds,
        ctime                   [5] KerberosTime,
        subkey                  [6] EncryptionKey OPTIONAL,
        seq-number              [7] UInt32 OPTIONAL,
        authorization-data      [8] AuthorizationData OPTIONAL
}

AP-REP          ::= [APPLICATION 15] SEQUENCE {
        pvno            [0] INTEGER (5),
        msg-type        [1] INTEGER (15),
        enc-part        [2] EncryptedData -- EncAPRepPart
}

EncAPRepPart    ::= [APPLICATION 27] SEQUENCE {
        ctime           [0] KerberosTime,
        cusec           [1] Microseconds,
        subkey          [2] EncryptionKey OPTIONAL,
        seq-number      [3] UInt32 OPTIONAL
}

KRB-SAFE        ::= [APPLICATION 20] SEQUENCE {
        pvno            [0] INTEGER (5),
        msg-type        [1] INTEGER (20),
        safe-body       [2] KRB-SAFE-BODY,
        cksum           [3] Checksum
}

KRB-SAFE-BODY   ::= SEQUENCE {
        user-data       [0] OCTET STRING,
        timestamp       [1] KerberosTime OPTIONAL,
        usec            [2] Microseconds OPTIONAL,
        seq-number      [3] UInt32 OPTIONAL,
        s-address       [4] HostAddress,
        r-address       [5] HostAddress OPTIONAL
}

KRB-PRIV        ::= [APPLICATION 21] SEQUENCE {
        pvno            [0] INTEGER (5),
        msg-type        [1] INTEGER (21),
                        -- NOTE: there is no [2] tag



Neuman, et al.              Standards Track                   [Page 128]

RFC 4120                      Kerberos V5                      July 2005


        enc-part        [3] EncryptedData -- EncKrbPrivPart
}

EncKrbPrivPart  ::= [APPLICATION 28] SEQUENCE {
        user-data       [0] OCTET STRING,
        timestamp       [1] KerberosTime OPTIONAL,
        usec            [2] Microseconds OPTIONAL,
        seq-number      [3] UInt32 OPTIONAL,
        s-address       [4] HostAddress -- sender's addr --,
        r-address       [5] HostAddress OPTIONAL -- recip's addr
}

KRB-CRED        ::= [APPLICATION 22] SEQUENCE {
        pvno            [0] INTEGER (5),
        msg-type        [1] INTEGER (22),
        tickets         [2] SEQUENCE OF Ticket,
        enc-part        [3] EncryptedData -- EncKrbCredPart
}

EncKrbCredPart  ::= [APPLICATION 29] SEQUENCE {
        ticket-info     [0] SEQUENCE OF KrbCredInfo,
        nonce           [1] UInt32 OPTIONAL,
        timestamp       [2] KerberosTime OPTIONAL,
        usec            [3] Microseconds OPTIONAL,
        s-address       [4] HostAddress OPTIONAL,
        r-address       [5] HostAddress OPTIONAL
}

KrbCredInfo     ::= SEQUENCE {
        key             [0] EncryptionKey,
        prealm          [1] Realm OPTIONAL,
        pname           [2] PrincipalName OPTIONAL,
        flags           [3] TicketFlags OPTIONAL,
        authtime        [4] KerberosTime OPTIONAL,
        starttime       [5] KerberosTime OPTIONAL,
        endtime         [6] KerberosTime OPTIONAL,
        renew-till      [7] KerberosTime OPTIONAL,
        srealm          [8] Realm OPTIONAL,
        sname           [9] PrincipalName OPTIONAL,
        caddr           [10] HostAddresses OPTIONAL
}

KRB-ERROR       ::= [APPLICATION 30] SEQUENCE {
        pvno            [0] INTEGER (5),
        msg-type        [1] INTEGER (30),
        ctime           [2] KerberosTime OPTIONAL,
        cusec           [3] Microseconds OPTIONAL,
        stime           [4] KerberosTime,



Neuman, et al.              Standards Track                   [Page 129]

RFC 4120                      Kerberos V5                      July 2005


        susec           [5] Microseconds,
        error-code      [6] Int32,
        crealm          [7] Realm OPTIONAL,
        cname           [8] PrincipalName OPTIONAL,
        realm           [9] Realm -- service realm --,
        sname           [10] PrincipalName -- service name --,
        e-text          [11] KerberosString OPTIONAL,
        e-data          [12] OCTET STRING OPTIONAL
}

METHOD-DATA     ::= SEQUENCE OF PA-DATA

TYPED-DATA      ::= SEQUENCE SIZE (1..MAX) OF SEQUENCE {
        data-type       [0] Int32,
        data-value      [1] OCTET STRING OPTIONAL
}

-- preauth stuff follows

PA-ENC-TIMESTAMP        ::= EncryptedData -- PA-ENC-TS-ENC

PA-ENC-TS-ENC           ::= SEQUENCE {
        patimestamp     [0] KerberosTime -- client's time --,
        pausec          [1] Microseconds OPTIONAL
}

ETYPE-INFO-ENTRY        ::= SEQUENCE {
        etype           [0] Int32,
        salt            [1] OCTET STRING OPTIONAL
}

ETYPE-INFO              ::= SEQUENCE OF ETYPE-INFO-ENTRY

ETYPE-INFO2-ENTRY       ::= SEQUENCE {
        etype           [0] Int32,
        salt            [1] KerberosString OPTIONAL,
        s2kparams       [2] OCTET STRING OPTIONAL
}

ETYPE-INFO2             ::= SEQUENCE SIZE (1..MAX) OF ETYPE-INFO2-ENTRY

AD-IF-RELEVANT          ::= AuthorizationData

AD-KDCIssued            ::= SEQUENCE {
        ad-checksum     [0] Checksum,
        i-realm         [1] Realm OPTIONAL,
        i-sname         [2] PrincipalName OPTIONAL,
        elements        [3] AuthorizationData



Neuman, et al.              Standards Track                   [Page 130]

RFC 4120                      Kerberos V5                      July 2005


}

AD-AND-OR               ::= SEQUENCE {
        condition-count [0] Int32,
        elements        [1] AuthorizationData
}

AD-MANDATORY-FOR-KDC    ::= AuthorizationData

END

B.  Changes since RFC 1510

   This document replaces RFC 1510 and clarifies specification of items
   that were not completely specified.  Where changes to recommended
   implementation choices were made, or where new options were added,
   those changes are described within the document and listed in this
   section.  More significantly, ""Specification 2"" in Section 8 changes
   the required encryption and checksum methods to bring them in line
   with the best current practices and to deprecate methods that are no
   longer considered sufficiently strong.

   Discussion was added to Section 1 regarding the ability to rely on
   the KDC to check the transited field, and on the inclusion of a flag
   in a ticket indicating that this check has occurred.  This is a new
   capability not present in RFC 1510.  Pre-existing implementations may
   ignore or not set this flag without negative security implications.

   The definition of the secret key says that in the case of a user the
   key may be derived from a password.  In RFC 1510, it said that the
   key was derived from the password.  This change was made to
   accommodate situations where the user key might be stored on a
   smart-card, or otherwise obtained independently of a password.

   The introduction mentions the use of public key cryptography for
   initial authentication in Kerberos by reference.  RFC 1510 did not
   include such a reference.

   Section 1.3 was added to explain that while Kerberos provides
   authentication of a named principal, it is still the responsibility
   of the application to ensure that the authenticated name is the
   entity with which the application wishes to communicate.

   Discussion of extensibility has been added to the introduction.

   Discussion of how extensibility affects ticket flags and KDC options
   was added to the introduction of Section 2.  No changes were made to
   existing options and flags specified in RFC 1510, though some of the



Neuman, et al.              Standards Track                   [Page 131]

RFC 4120                      Kerberos V5                      July 2005


   sections in the specification were renumbered, and text was revised
   to make the description and intent of existing options clearer,
   especially with respect to the ENC-TKT-IN-SKEY option (now section
   2.9.2) which is used for user-to-user authentication.  The new option
   and ticket flag transited policy checking (Section 2.7) was added.

   A warning regarding generation of session keys for application use
   was added to Section 3, urging the inclusion of key entropy from the
   KDC generated session key in the ticket.  An example regarding use of
   the sub-session key was added to Section 3.2.6.  Descriptions of the
   pa-etype-info, pa-etype-info2, and pa-pw-salt pre-authentication data
   items were added.  The recommendation for use of pre-authentication
   was changed from ""MAY"" to ""SHOULD"" and a note was added regarding
   known plaintext attacks.

   In RFC 1510, Section 4 described the database in the KDC.  This
   discussion was not necessary for interoperability and unnecessarily
   constrained implementation.  The old Section 4 was removed.

   The current Section 4 was formerly Section 6 on encryption and
   checksum specifications.  The major part of this section was brought
   up to date to support new encryption methods, and moved to a separate
   document.  Those few remaining aspects of the encryption and checksum
   specification specific to Kerberos are now specified in Section 4.

   Significant changes were made to the layout of Section 5 to clarify
   the correct behavior for optional fields.  Many of these changes were
   made necessary because of improper ASN.1 description in the original
   Kerberos specification which left the correct behavior
   underspecified.  Additionally, the wording in this section was
   tightened wherever possible to ensure that implementations conforming
   to this specification will be extensible with the addition of new
   fields in future specifications.

   Text was added describing time_t=0 issues in the ASN.1.  Text was
   also added, clarifying issues with implementations treating omitted
   optional integers as zero.  Text was added clarifying behavior for
   optional SEQUENCE or SEQUENCE OF that may be empty.  Discussion was
   added regarding sequence numbers and behavior of some
   implementations, including ""zero"" behavior and negative numbers.  A
   compatibility note was added regarding the unconditional sending of
   EncTGSRepPart regardless of the enclosing reply type.  Minor changes
   were made to the description of the HostAddresses type.  Integer
   types were constrained.  KerberosString was defined as a
   (significantly) constrained GeneralString.  KerberosFlags was defined
   to reflect existing implementation behavior that departs from the





Neuman, et al.              Standards Track                   [Page 132]

RFC 4120                      Kerberos V5                      July 2005


   definition in RFC 1510.  The transited-policy-checked(12) and the
   ok-as-delegate(13) ticket flags were added.  The disable-transited-
   check(26) KDC option was added.

   Descriptions of commonly implemented PA-DATA were added to Section 5.
   The description of KRB-SAFE has been updated to note the existing
   implementation behavior of double-encoding.

   There were two definitions of METHOD-DATA in RFC 1510.  The second
   one, intended for use with KRB_AP_ERR_METHOD was removed leaving the
   SEQUENCE OF PA-DATA definition.

   Section 7, naming constraints, from RFC 1510 was moved to Section 6.

   Words were added describing the convention that domain-based realm
   names for newly-created realms should be specified as uppercase.
   This recommendation does not make lowercase realm names illegal.
   Words were added highlighting that the slash-separated components in
   the X.500 style of realm names is consistent with existing RFC 1510
   based implementations, but that it conflicts with the general
   recommendation of X.500 name representation specified in RFC 2253.

   Section 8, network transport, constants and defined values, from RFC
   1510 was moved to Section 7.  Since RFC 1510, the definition of the
   TCP transport for Kerberos messages was added, and the encryption and
   checksum number assignments have been moved into a separate document.

   ""Specification 2"" in Section 8 of the current document changes the
   required encryption and checksum methods to bring them in line with
   the best current practices and to deprecate methods that are no
   longer considered sufficiently strong.

   Two new sections, on IANA considerations and security considerations
   were added.

   The pseudo-code has been removed from the appendix.  The pseudo-code
   was sometimes misinterpreted to limit implementation choices and in
   RFC 1510, it was not always consistent with the words in the
   specification.  Effort was made to clear up any ambiguities in the
   specification, rather than to rely on the pseudo-code.

   An appendix was added containing the complete ASN.1 module drawn from
   the discussion in Section 5 of the current document.

END NOTES

   (*TM) Project Athena, Athena, and Kerberos are trademarks of the
   Massachusetts Institute of Technology (MIT).



Neuman, et al.              Standards Track                   [Page 133]

RFC 4120                      Kerberos V5                      July 2005


Normative References

   [RFC3961]          Raeburn, K., ""Encryption and Checksum
                      Specifications for Kerberos 5"", RFC 3961, February
                      2005.

   [RFC3962]          Raeburn, K., ""Advanced Encryption Standard (AES)
                      Encryption for Kerberos 5"", RFC 3962, February
                      2005.

   [ISO-646/ECMA-6]   International Organization for Standardization,
                      ""7-bit Coded Character Set for Information
                      Interchange"", ISO/IEC 646:1991.

   [ISO-2022/ECMA-35] International Organization for Standardization,
                      ""Character code structure and extension
                      techniques"", ISO/IEC 2022:1994.

   [RFC1035]          Mockapetris, P., ""Domain names - implementation
                      and specification"", STD 13, RFC 1035, November
                      1987.

   [RFC2119]          Bradner, S., ""Key words for use in RFCs to
                      Indicate Requirement Levels"", BCP 14, RFC 2119,
                      March 1997.

   [RFC2434]          Narten, T. and H. Alvestrand, ""Guidelines for
                      Writing an IANA Considerations Section in RFCs"",
                      BCP 26, RFC 2434, October 1998.

   [RFC2782]          Gulbrandsen, A., Vixie, P., and L. Esibov, ""A DNS
                      RR for specifying the location of services (DNS
                      SRV)"", RFC 2782, February 2000.

   [RFC2253]          Wahl, M., Kille, S., and T. Howes, ""Lightweight
                      Directory Access Protocol (v3): UTF-8 String
                      Representation of Distinguished Names"", RFC 2253,
                      December 1997.

   [RFC3513]          Hinden, R. and S. Deering, ""Internet Protocol
                      Version 6 (IPv6) Addressing Architecture"", RFC
                      3513, April 2003.

   [X680]             Abstract Syntax Notation One (ASN.1):
                      Specification of Basic Notation, ITU-T
                      Recommendation X.680 (1997) | ISO/IEC
                      International Standard 8824-1:1998.




Neuman, et al.              Standards Track                   [Page 134]

RFC 4120                      Kerberos V5                      July 2005


   [X690]             ASN.1 encoding rules: Specification of Basic
                      Encoding Rules (BER), Canonical Encoding Rules
                      (CER) and Distinguished Encoding Rules (DER),
                      ITU-T Recommendation X.690 (1997)| ISO/IEC
                      International Standard 8825-1:1998.

Informative References

   [ISO-8859]         International Organization for Standardization,
                      ""8-bit Single-byte Coded Graphic Character Sets --
                      Latin Alphabet"", ISO/IEC 8859.

   [RFC1964]          Linn, J., ""The Kerberos Version 5 GSS-API
                      Mechanism"", RFC 1964, June 1996.

   [DGT96]            Don Davis, Daniel Geer, and Theodore Ts'o,
                      ""Kerberos With Clocks Adrift: History, Protocols,
                      and Implementation"", USENIX Computing Systems 9:1,
                      January 1996.

   [DS81]             Dorothy E. Denning and Giovanni Maria Sacco,
                      ""Time-stamps in Key Distribution Protocols,""
                      Communications of the ACM, Vol. 24 (8), p. 533-
                      536, August 1981.

   [KNT94]            John T. Kohl, B. Clifford Neuman, and Theodore Y.
                      Ts'o, ""The Evolution of the Kerberos
                      Authentication System"". In Distributed Open
                      Systems, pages 78-94. IEEE Computer Society Press,
                      1994.

   [MNSS87]           S. P. Miller, B. C. Neuman, J. I. Schiller, and J.
                      H. Saltzer, Section E.2.1: Kerberos Authentication
                      and Authorization System, M.I.T. Project Athena,
                      Cambridge, Massachusetts, December 21, 1987.

   [NS78]             Roger M. Needham and Michael D. Schroeder, ""Using
                      Encryption for Authentication in Large Networks of
                      Computers,"" Communications of the ACM, Vol. 21
                      (12), pp. 993-999, December 1978.

   [Neu93]            B. Clifford Neuman, ""Proxy-Based Authorization and
                      Accounting for Distributed Systems,"" in
                      Proceedings of the 13th International Conference
                      on Distributed Computing Systems, Pittsburgh, PA,
                      May 1993.





Neuman, et al.              Standards Track                   [Page 135]

RFC 4120                      Kerberos V5                      July 2005


   [NT94]             B. Clifford Neuman and Theodore Y. Ts'o, ""An
                      Authentication Service for Computer Networks,""
                      IEEE Communications Magazine, Vol. 32 (9), p. 33-
                      38, September 1994.

   [Pat92]            J. Pato, Using Pre-Authentication to Avoid
                      Password Guessing Attacks, Open Software
                      Foundation DCE Request for Comments 26 (December
                      1992.

   [RFC1510]          Kohl, J. and C. Neuman, ""The Kerberos Network
                      Authentication Service (V5)"", RFC 1510, September
                      1993.

   [RFC4086]          Eastlake, D., 3rd, Schiller, J., and S. Crocker,
                      ""Randomness Requirements for Security"", BCP 106,
                      RFC 4086, June 2005.

   [SNS88]            J. G. Steiner, B. C. Neuman, and J. I. Schiller,
                      ""Kerberos: An Authentication Service for Open
                      Network Systems,"" p. 191-202, Usenix Conference
                      Proceedings, Dallas, Texas, February 1988.

   [RFC4121]          Zhu, L., Jaganathan, K., and S. Hartman, ""The
                      Kerberos Version 5 Generic Security Service
                      Application Program Interface (GSS-API) Mechanism:
                      Version 2"", RFC 4121, July 2005.
























Neuman, et al.              Standards Track                   [Page 136]

RFC 4120                      Kerberos V5                      July 2005


Authors' Addresses

   Clifford Neuman
   Information Sciences Institute
   University of Southern California
   4676 Admiralty Way
   Marina del Rey, CA 90292, USA

   EMail: bcn@isi.edu


   Tom Yu
   Massachusetts Institute of Technology
   77 Massachusetts Avenue
   Cambridge, MA 02139, USA

   EMail: tlyu@mit.edu


   Sam Hartman
   Massachusetts Institute of Technology
   77 Massachusetts Avenue
   Cambridge, MA 02139, USA

   EMail: hartmans-ietf@mit.edu


   Kenneth Raeburn
   Massachusetts Institute of Technology
   77 Massachusetts Avenue
   Cambridge, MA 02139, USA

   EMail: raeburn@mit.edu


















Neuman, et al.              Standards Track                   [Page 137]

RFC 4120                      Kerberos V5                      July 2005


Full Copyright Statement

   Copyright (C) The Internet Society (2005).

   This document is subject to the rights, licenses and restrictions
   contained in BCP 78, and except as set forth therein, the authors
   retain all their rights.

   This document and the information contained herein are provided on an
   ""AS IS"" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET
   ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,
   INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
   INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

Intellectual Property

   The IETF takes no position regarding the validity or scope of any
   Intellectual Property Rights or other rights that might be claimed to
   pertain to the implementation or use of the technology described in
   this document or the extent to which any license under such rights
   might or might not be available; nor does it represent that it has
   made any independent effort to identify any such rights.  Information
   on the procedures with respect to rights in RFC documents can be
   found in BCP 78 and BCP 79.

   Copies of IPR disclosures made to the IETF Secretariat and any
   assurances of licenses to be made available, or the result of an
   attempt made to obtain a general license or permission for the use of
   such proprietary rights by implementers or users of this
   specification can be obtained from the IETF on-line IPR repository at
   http://www.ietf.org/ipr.

   The IETF invites any interested party to bring to its attention any
   copyrights, patents or patent applications, or other proprietary
   rights that may cover technology that may be required to implement
   this standard.  Please address the information to the IETF at ietf-
   ipr@ietf.org.

Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.







Neuman, et al.              Standards Track                   [Page 138]

"
